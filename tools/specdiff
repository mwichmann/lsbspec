#!/bin/sh
#
# Generate a document marked for errata generation, or just to 
# highlight/check changes.
#
# There's not a great way to do this.  generated html is messy and
# produces no interesing diff, so the "best" (most readable) approach is to
# compares two versions of the txtspec (e.g. LSB-Core-generic.txt).
# This falls down badly in two areas:
# - because of the way entries are sorted, an insertion/deletion or other
#   change to tables will often show as lots more changes than expected
# - if section is inserted/deleted, following numbering at the same level
#   will change, and we can't tell diff to "ignore all but the first
#   section number change"
#
# We have tried using diffmarking tools which purport to work with Docbook
# with little profit, though that is really a separare problem anyway
#
# Workflow expected:
#
# 1. update all external matters - specdb, build_env/headers .defs file
# 2. in lsbspec, do "make gensrc" then "make"
#    Note: it may help to do just the "make gensrc" first, then run "bzr diff"
#    to make sure you're getting the changes you expect, before proceeding.
# 3. identify the book that is affected, and build in it (or rebuild them all)
#    remember production books that are /combinations/ of modules/submodules
#    are built in booksets/, while single-source ones are in books/
#    all production volumes begin with lsb-
# 4. run 'specdiff'.  If you're in LSB-foo, this will diff LSB-foo.txt
#    and leave a file LSB-foo.DIFF, marked with #ifdef ERRATA
#    these changes should be sufficient to examine changes without
#    getting too confused; and together with the appropriate bug
#    can help toto generate an errata document
#
# Variants: in the basic mode, depends on being in a working bzr tree
# for either books or booksets, and compares the current file in the
# working tree with the one in version control.  With the -l flag,
# compares the current file with one two revisions old - that is, it
# expects to compare a revision that was already checked in with the
# previous one - so just like the default (also available as -c), just
# difference between pre-checkin and post-checkin.  The third way, -e,
# tries to compare with a released ("refspecs") version.  The problem
# here is not having a canonical path to that version, so fiddle with
# Tunables just below, or use the -r flag to specify another path

# Tunables:
# if comparing to a refspec, either set this or override with cmdline option
REFPATH=/home/mats/bzr/refspec
REFVER=LSB_4.1.0
# end tunables

# diff options in use:
# -d try to find a minimal set of changes
# -b ignore changes in amount of white space
# -w ignore all white space
# -B ignore changes whose lines are all blank
DOPT="-dbwB"
# (the three previous together are overkill, but have seen some odd behavior)
# --ifdef ERRATA output merged file marked "#ifdef ERRATA"
DTYPE="--ifdef ERRATA"


function usage() {
    echo >&2
    echo >&2 "Usage: specdiff [arguments]"
    echo >&2
    echo >&2 "arguments:"
    echo >&2 "  -l     compare current with next-last commit"
    echo >&2 "         - usually used to diff last two committed versions"
    echo >&2 "  -c     compare current with last commit (default)"
    echo >&2 "         - usually used to diff uncommitted version"
    echo >&2 "  -e     errata - compare with released spec (refspecs)"
    echo >&2 "  -d     produce regular diff, not merged/ifdefd one"
    echo >&2 "  -v LSBVERSION   specify version for -e (default 4.1.0)"
    echo >&2 "  -r REFPATH      specify base path for released specs for -e"
    echo >&2 "  -h     help (this message)"
    echo >&2
    echo >&2 " must be run in a bzr branch, in an individual spec directory"
    echo >&2
}

# check for a moderately valid bzr branch:
bzr status -q > /dev/null 2>&1
if [ $? -ne 0 ]
then
    echo >&2 "Error: does not appear to be a bzr branch"
    usage
    exit 1
fi

# check we are in a spec book directory:
tree=`bzr root`
spec=`basename $PWD`
base=`dirname $PWD`
name=`basename $base`
if [ $name != 'books' -a $name != 'booksets' ]
then
    echo >&2 "Error: need to be in a spec book (one level below books/booksets)"
    usage
    exit 1
fi

mode='c'

TEMP=`getopt -o helcdv:r: -- "$@"`
if [ $? != 0 ] ; then usage ; exit 1 ; fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
    case "$1" in
	-h) usage ; exit 0 ;;
	-e) mode='e'		# errata to released spec
	    shift ;;
	-l) mode='l'		# diff current with bzr
	    shift ;;
	-c) mode='c'		# diff top two bzr versions
	    shift ;;
	-d) DTYPE=		# produce regular diff, not merged #ifdef
	    shift ;;
	-v) REFVER=LSB_$2	# change base version for -e
	    shift 2 ;;
	-r) REFPATH=$2		# change path to refspecs for -e
	    shift 2 ;;
	--) shift ; break ;;
	*) echo "Internal error!" ; exit 1 ;;
    esac
done

case "$mode" in
    'c')
	bzr diff --diff-options="$DOPT $DTYPE" $spec.txt > $spec.DIFF 
	;;
    'l')
        bzr diff --diff-options="$DOPT $DTYPE" -r -2..-1 $spec.txt > $spec.DIFF
	;;
    'e')
	if [ ! -d $REFPATH ]
	then
	    echo 2>&1 "Error: cannot find base path to refspecs: $REFPATH"
	    exit 1
	fi
	if [ ! -d $REFPATH/$REFVER ]
	then
	    echo 2>&1 "Error: cannot find versioned refspec dir: $REFPATH/$REFVER"
	    exit 1
	fi
	if [ ! -d $REFPATH/$REFVER/$spec ]
	then
	    echo 2>&1 "Error: cannot find versioned refspec dir: $REFPATH/$REFVER"
	    exit 1
	fi
        diff $DOPT $DTYPE $REFPATH/$REFVER/$spec/$spec.txt . > $spec.DIFF
	;;
esac

if [ ! -s $spec.DIFF ]
then
    echo "no differences in $spec"
    rm $spec.DIFF
else
    echo "changes are in $spec.DIFF"
fi
