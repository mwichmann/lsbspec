#!/usr/bin/perl

use Getopt::Long;
use Mysql;
use IPC::Open2;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

sub usage()
{
	print STDERR "mklibspec -l <libname> -a <archname> [-c cols] [-d]\n";
	die;
}

sub unmangle($)
{
	local($int) = @_;

	if (!defined($cxxfilt)) {
		$cxxfilt = open2(\*CXXRDR, \*CXXWRT, "c++filt") or
			die "Could not open c++filt: $!";
	}
	print CXXWRT "$int\n";
	$int = <CXXRDR>;
	chomp($int);
	$int =~ s/</\&lt;/g;
	$int =~ s/>/\&gt;/g;
	return $int;
}

sub makeid($) 
{
	my ($name) = @_;
	$name =~ s/\s+/./g;
	$name =~ s/[^A-Za-z0-9.]+/./g;
	# finally, remove any repeated . (e.g. "RPC...XDR" which arose from "RPC & XDR")
	$name =~ s/\.\.+/./g;
	return $name;
}

sub output_table($$$$$$$)
{
local ($i,$name,*int,*symver,*stdnum,*stdname,$title) = @_;
local *ref;

print "<TABLE id=\"$name\">\n";
print "<TITLE>$title</TITLE>\n";
print "<TGROUP COLS=$numcols>\n";
print "<TBODY>\n";
$inc=int(($i+($numcols-1))/$numcols);
for $row (1..$inc) {
	print "<ROW>\n";
	for $col (0..$numcols-1) {
		printf "<ENTRY>";
		my $intnum = $row+($col*$inc);
		if( $int[$intnum] ) {
			# figure out a reference
			# each table is followed by a list of references
			#
			# this is a little complex:
			# %refname is a hash, using keys of the form "std-%d-%d"
			#   with values being the names of the standards
			# @ref is an array; each element is a key in %ref
			# $refno is the current index into that array
			my $refstr = sprintf "std-%d-%d-%s", 
				$Lid, $stdnum[$intnum], $name;
			$refname{$refstr} = $stdname[$intnum];
			$refno = 0;
			for $r (0..$#ref) {
				$refno = $r;
				last if ($ref[$r] eq $refstr);
			}
			if ($ref[$refno] ne $refstr) {
				push(@ref, $refstr) ;
				$refno = $#ref;
				}
			my $interface = $int[$intnum];
			$interface = unmangle($interface) if ($demangle);
			printf "<indexterm><primary>%s</primary></indexterm>%s", $interface, $interface;
			if( $symver[$intnum] ) {
				printf "(%s)", $symver[$intnum];
				}
			if( $stdnum[$intnum] ) {
				printf "<LINK LINKEND=\"%s\"> [%d]</LINK>",
					$refstr, $refno+1;
				}
			}
		printf "</ENTRY>\n";
	}
	print "</ROW>\n";
	}
print "</TBODY>\n";
print "</TGROUP>\n";
print "</TABLE>\n";
# and dump the reference list
if ($#ref >= 0) {
	print "<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>\n";
	for $r (0..$#ref) {
		$refstr = $ref[$r];
		$refname{$refstr} = "This specification" if ($refname{$refstr} eq "Linux Standard Base" && $archname eq "All");
		printf "<FORMALPARA><TITLE id=\"%s\">[%d]</TITLE><para><XREF LINKEND=std.%s></para></FORMALPARA>\n",
			$refstr, $r+1, makeid($refname{$refstr});
		}
	}
}

sub getinterfacename($)
{
local($Iid)=@_;
my($select,%entry);

if( $Iid eq "" ) {return "";}

#print STDERR "Looking for Iname for $Iid\n";

$select = "SELECT Iname FROM Interface ";
$select.= "WHERE Iid=$Iid";
#print $select;
$isth = $Dbh->query($select) || die $Dbh->errmsg();
%entry=$isth->fetchhash;
return $entry{'Iname'};
}


sub output_classinfo($)
{
	local ($class) = @_;

	#print STDERR $$class{'CIname'}."\n";
	local $classname = unmangle($$class{'CIname'});

	print "<SECT3>\n";
	print "<TITLE>";
	print "Class data for ".$classname;
	print "</TITLE>\n";
	print "<PARA>\n";
	print "</PARA>\n";

	#
	# Display Vtable info
	#
	if( $$class{'CIvtable'} ) {
		#
		# we are in a class ... always unmangle (ignore -d)
		#
		local $tblref = sprintf "cls-%s", nmhash($$class{'CIvtable'});
		print "<PARA>\n";
		print "The virtual table for the $classname class\n";
		print "is described by <XREF LINKEND=\"$tblref\">\n";
		print "</PARA>\n";
		print "<!--classdata-->\n";
		print "<TABLE id=\"$tblref\">\n";
		print "<TITLE>";
		print unmangle(getinterfacename($$class{'CIvtable'}));
		print "</TITLE>\n";
		print "<TGROUP COLS=2>\n";
		print "<TBODY>\n";
		print "<ROW>\n";
		print "<ENTRY>Base Offset</ENTRY>\n";
		print "<ENTRY>";
		print $$class{'CIbaseoffset'};
		print "</ENTRY>\n";
		print "</ROW>\n";
		print "<ROW>\n";
		print "<ENTRY>RTTI</ENTRY>\n";
		print "<ENTRY>";
		$func=unmangle(getinterfacename($$class{'CIrtti'}));
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		$select = "SELECT * FROM Vtable ";
		$select.= "LEFT JOIN ClassInfo ON VTCid=CIid ";
		$select.= "WHERE CIid=".$$class{'CIid'}." ";
		$select.= "ORDER BY VTpos";
		$vsth = $Dbh->query($select) || die $Dbh->errmsg();
		for(1..$$class{'CInumvfunc'}) {
			%entry=$vsth->fetchhash;
			print "<ROW>\n";
			print "<ENTRY>vfunc:</ENTRY>\n";
			print "<ENTRY>";
			$func=unmangle(getinterfacename($$class{'VTviid'}));
			printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
			print "</ENTRY>\n";
			print "</ROW>\n";
			}

		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
		}

	#
	# Display RTTI info
	#
	if( $$class{'CIrtti'} ) {
		local $tblref = sprintf "rtti-%s", nmhash($$class{'CIrtti'});
		print "<PARA>\n";
		print "The Run Time Type Information for the $classname  class\n";
		print "is described by <XREF LINKEND=\"$tblref\">\n";
		print "</PARA>\n";
		print "<!--classdata-->\n";
		print "<TABLE ID=\"$tblref\">\n";
		print "<TITLE>".unmangle(getinterfacename($$class{'CIrtti'}))."</TITLE>\n";
		print "<TGROUP COLS=2>\n";
		print "<TBODY>\n";
		print "<ROW>\n";
		print "<ENTRY>Base Vtable</ENTRY>\n";
		print "<ENTRY>";
		$func=unmangle(getinterfacename($$class{'CIbasevtable'}));
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		print "<ROW>\n";
		print "<ENTRY>Name</ENTRY>\n";
		print "<ENTRY>";
		$func="_ZTS".substr($$class{'CIname'},2,256);
		$func = unmangle($func);
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		if( $$class{'CInumbasetype'} ) {
			$select = "SELECT * FROM BaseTypes ";
			$select.= "LEFT JOIN ClassInfo ON BTcid=CIid ";
			$select.= "WHERE CIid=".$$class{'CIid'}." ";
			$select.= "ORDER BY BTpos";
			$vsth = $Dbh->query($select) || die $Dbh->errmsg();
			for(1..$$class{'CInumbasetype'}) {
				%entry=$vsth->fetchhash;
				print "<ROW>\n";
				print "<ENTRY>basetype:</ENTRY>\n";
				print "<ENTRY>";
				$func=unmangle(getinterfacename($$class{'BTrttiid'}));
				printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
				print "</ENTRY>\n";
				print "</ROW>\n";
				}
			}
		if( $$class{'CInumvmitypes'} ) {
			print "<ROW>\n";
			print "<ENTRY>flags:</ENTRY>\n";
			print "<ENTRY>".$$class{'CIflags'}."</ENTRY>\n";
			print "</ROW>\n";
			$select = "SELECT * FROM VMIBaseTypes ";
			$select.= "LEFT JOIN ClassInfo ON VBTcid=CIid ";
			$select.= "WHERE CIid=".$$class{'CIid'}." ";
			$select.= "ORDER BY VBTpos";
			$vsth = $Dbh->query($select) || die $Dbh->errmsg();
			for(1..$$class{'CInumvmitypes'}) {
				%entry=$vsth->fetchhash;
				print "<ROW>\n";
				print "<ENTRY>basetype:</ENTRY>\n";
				print "<ENTRY>";
				$func=unmangle(getinterfacename($$class{'VBTbasetype'}));
				printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
				print "</ENTRY>\n";
				print "<ENTRY>".$entry{'VBTflags'}."</ENTRY>\n";
				print "</ROW>\n";
				}
			}

		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
		}
	print "</SECT3>\n";
}

sub getinterfaces($$$$)
{
	local ($Lname, $LGname, $type, $needpara) = @_;
	local(*entry);
	local(*symver);
	local(*stdnum);
	local(*stdname);
	local($table_title);
	local($name);
	local($where);
	local($safeLname)=$Lname;
	$safeLname =~ s/_/-/g;

	if ($type eq "functions" || $type eq "methods") {
		$where = "WHERE LGIlibg=$LGid AND Itype='Function' ";
		# $where.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
		$where.= "AND ( Istatus='Included' ) ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "ints";
		$table_title = "$Lname - $LGname Function Interfaces";
		}
	elsif ($type eq "deprecated functions") {
		$where = "WHERE LGIlibg=$LGid AND Itype='Function' ";
		$where.= "AND Istatus='Deprecated' ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "depints";
		$table_title = "$Lname - $LGname Deprecated Function Interfaces";
		}
	elsif ($type eq "data interfaces") {
		$where = "WHERE LGIlibg=$LGid AND Itype != 'Function' ";
		# $where.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
		$where.= "AND ( Istatus='Included' ) ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "data";
		$table_title = "$Lname - $LGname Data Interfaces";
		}
	elsif ($type eq "deprecated data interfaces") {
		$where = "WHERE LGIlibg=$LGid AND Itype != 'Function' ";
		$where.= "AND Istatus='Deprecated' ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "ddata";
		$table_title = "$Lname - $LGname Deprecated Data Interfaces";
		}
	else {
		die "Unknown type $type";
		}
	$select = "SELECT DISTINCT Iname, AIarch, Vname, Istandard, Sname FROM Interface ";
	$select.= "LEFT JOIN LGInt ON Iid=LGIint ";
	$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
	$select.= "LEFT JOIN Version ON Vid=AIversion ";
	$select.= "LEFT JOIN Standard ON Sid=Istandard ";
	$select.= "$where ";
	$select.= "ORDER BY Iname";
	print STDERR $select,"\n" if $trace;
	$inh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
	$i=0;
	for(1..$inh->numrows) {
		%entry=$inh->fetchhash;
		if( $entry[$i] ne $entry{'Iname'} ) {
			$i++;
		}
		$entry[$i]=$entry{'Iname'};
		if( $entry{'AIarch'} == $Aid ) { 
			$symver[$i]=$entry{'Vname'};
		}
		$stdnum[$i]=$entry{'Istandard'};
		$stdname[$i]=$entry{'Sname'};
	}
	if( $i > 0 ) {
		$arch_type = ($archname eq "All") ? "generic" : "architecture specific";
		$tblname = sprintf "tbl-%s-%s-%s", $safeLname, nmhash($LGname), $name;
		$tblname =~ s/\s/-/g;
		$tblname =~ s/\+/x/g;		# change the C++ names into Cxx
		print "<PARA>\n";
		print "An LSB conforming implementation shall provide the $arch_type $type\n";
		print "for $LGname specified in <XREF linkend=\"$tblname\">,\n";
		print "with the full functionality as described in the referenced\n";
		print "underlying specification.\n";
		print "</PARA>\n";
		if ($type =~ /deprecated.*/) {
			print "<NOTE><TITLE>NOTE</TITLE>";
			print "<PARA>These interfaces are deprecated, and applications\n";
			print "should avoid using them.\n";
			print "These interfaces may be withdrawn\n";
			print "in future releases of this specification.\n";
			print "</PARA></NOTE>\n";
			}
		print "<!--libgroup$name-->\n";
		output_table($i,$tblname,*entry,*symver,*stdnum,*stdname,$table_title);
		}
	elsif ($needpara) {
		print "<PARA>\n";
		print "No external $type are defined for $Lname - $LGname\n";
		print "</PARA>\n";
		}
}

sub nmhash($)
{
	local ($name) = @_;
	
	# generate a three char name from the (long) libgroup name
	local ($sname) = lc(substr($name, 0, 3));
	$namehash{$sname} = $name if (!defined ($namehash{$sname}));
	until (!defined($namehash{$sname}) || ($namehash{$sname} eq $name)) {
		$sname++;
	}
	$namehash{$sname} = $name;
	return $sname;
}

# the main program ...
# Uncomment to trace SQL statements
#$trace=1;

# A default value 

$numcols=5;

$demangle = 0;
#
# 1) process the arguments
#


GetOptions("l=s" => \$libname,
	   "c=i" => \$numcols,
	   "d"   => \$demangle,
	   "a=s" => \$archname);

if( !$libname ) { usage(); }
if( !$archname ) { usage(); }

#
# 2) Establish connection to the database
#
$Dbh = Mysql->connect($LSBDBHOST,$LSBDB,$LSBUSER, $LSBDBPASSWD) || die $Mysql::db_errstr;

#
# 3) get & print the architecture info
#
$select = "SELECT * FROM Architecture WHERE ";
$select.= "Architecture.Aname=".$Dbh->quote($archname);
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();

%entry=$sth->fetchhash;
$Aid=$entry{'Aid'};
$Aname=$entry{'Aname'};

$safelibname=$libname;
$safelibname =~ s/_/-/g;

printf("<!-- Start of text generated from database -->\n");
printf("<!-- generated from the LSB specification database -->\n");
printf("<!--    by \$Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/mklibspec,v 1.60 2004-07-13 18:49:08 nick Exp $- -->\n");
my $now_string = localtime;
printf("<!--    at %s -->\n", $now_string );

print "<SECT1 ID=", $safelibname, ">\n";
print "<TITLE>Interfaces for ", $libname, "</TITLE>\n";
print "<PARA>\n";
print "<XREF LINKEND=\"lib-$safelibname-def\"> defines the library name and shared object name\n";
print "for the $libname library\n";
print "</PARA>\n";

#
# 4) get & print the library info
#
$select = "SELECT * FROM Library ";
$select.= "LEFT JOIN ArchLib ON Lid=ALlid ";
$select.= "WHERE Library.Lname=".$Dbh->quote($libname)." ";
$select.= "AND Lstd!='No'";
$select.= "AND ALaid=$Aid";
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();

%entry=$sth->fetchhash;
$Lid=$entry{'Lid'};
$Lname=$entry{'Lname'};
$Larch=$entry{'ALaid'};

if( $Larch == $Aid ) {
	print "<TABLE id=\"lib-$safelibname-def\">\n";
	print "<TITLE>$Lname Definition</TITLE>\n";
	print "<TGROUP COLS=2>\n";
	print "<TBODY>\n";
	print "<ROW>\n";
	print "<ENTRY>Library:</ENTRY>\n";
	print "<ENTRY>", $entry{'Lname'}, "</ENTRY>\n";
	print "</ROW>\n";
	print "<ROW>\n";
	print "<ENTRY>SONAME:</ENTRY>\n";
	if( $entry{'ALrunname'} ne "" ) {
		print "<ENTRY>", $entry{'ALrunname'}, "</ENTRY>\n";
	} else {
		print "<ENTRY>See archLSB.</ENTRY>\n";
	}
	print "</ROW>\n";
	print "</TBODY>\n";
	print "</TGROUP>\n";
	print "</TABLE>\n";
}

#
# 5) Check for additional description text for the library
#
if(open(DESC,"<$Lname.txt" )) {
	while(<DESC>) {
		print $_;
	}
}

#
# 6) Get a list of the Standards that are used by this library
#
print "<PARA>\n";
$select = "SELECT DISTINCT Sfull,Sid FROM Standard ";
$select.= "LEFT JOIN Interface ON Sid=Istandard ";
$select.= "LEFT JOIN LGInt ON LGIint=Iid ";
$select.= "LEFT JOIN LibGroup ON LGid=LGIlibg ";
$select.= "LEFT JOIN ArchInt ON AIint=Iid ";
$select.= "WHERE LGlib=$Lid ";
$select.= "AND Istatus != 'Excluded' ";
$select.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
$select.= "ORDER BY Sname";
print STDERR $select,"\n" if $trace;
$lsh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if( $lsh->numrows) {
	print "The behavior of the interfaces in this library is specified ";
	print "by the following specifications:";
	print "<SIMPLELIST COLUMNS=1>\n";
	for(1..$lsh->numrows) {
		local(*entry);
		%entry=$lsh->fetchhash;
		# Footnotes removed from here ... in line references are now used
		# should add a link or xref back to the normative refs table here ...
		print "<MEMBER>\n";
		print $entry{'Sfull'};
		print "</MEMBER>\n";
		}
	print "</SIMPLELIST>\n";
	}
print "</PARA>\n";

#
# 7) Get a list of the libgroups in the library
#
$select = "SELECT * FROM LibGroup WHERE LGlib=$Lid ORDER BY LGorder";
print STDERR $select,"\n" if $trace;
$lgh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
for(1..$lgh->numrows) {
	local(*entry);
	local(*std);
	%entry=$lgh->fetchhash;
	$LGid=$entry{'LGid'};
	$LGname=$entry{'LGname'};
	print "<!-- debug: database interface name $LGname -->\n";
	$LGname=unmangle($LGname) if ($demangle);
	
	print "<SECT2>\n";
	print "<!--libgroup-->\n";
	print "<TITLE>";
	print $LGname;
	print "</TITLE>\n";
	print "<PARA>\n";
	print "</PARA>\n";
#
# 8) For each group, make a table of the class data
#
{
	local(*entry);
	local(*inh);
	$select = "SELECT * FROM ClassInfo ";
	$select.= "LEFT JOIN LibGroup ON CIlibg=LGid ";
	$select.= "WHERE LGid=$LGid ";
	$inh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
	print STDERR $select,"\n" if $trace;
	for(1..$inh->numrows) {
		%entry=$inh->fetchhash;
		output_classinfo(\%entry);
		}
}
#
# 9) For each group, make a table of the interfaces
#
	print "<SECT3>\n";
	print "<TITLE>";
	print "Interfaces for ".$LGname;
	print "</TITLE>\n";
	getinterfaces( $Lname, $LGname, $demangle ? "methods" : "functions", 1);
#
# 10) For each group, make a table of the deprecated interfaces
#
	getinterfaces($Lname, $LGname, "deprecated functions", 0);

#
# 11) Make a table of data interfaces
#
	getinterfaces($Lname, $LGname, "data interfaces", 0);
#
# 12) Make a table of deprecated data interfaces
#
	getinterfaces($Lname, $LGname, "deprecated data interfaces", 0);
	print "</SECT3>\n";
	print "</SECT2>\n";
}

print "</SECT1>\n";

#
# List the data definitions by including the related headers here
#
#
# Now, get a list of all headers associate with this library
#
$select = "SELECT DISTINCT Hname,Hid FROM Header ";
$select.= "WHERE Hlib=$Lid ";
$select.= "ORDER BY Hname";
$hdh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if( $hdh->numrows ) {
	print "<SECT1 ID=", $safelibname, "-ddefs>\n";
	print "<TITLE>Data Definitions for $Lname</TITLE>\n";
	print "<PARA>\n";
	print "This section defines global identifiers and their values that are associated ";
	print "with interfaces contained in $Lname.\n";
	print "These definitions are organized into groups that ";
	print "correspond to system headers. This convention is used as a ";
	print "convenience for the reader, and does not imply the existence ";
	print "of these headers, or their content.";
	print "</PARA>\n";
	print "<PARA>\n";
	print "These definitions are intended to supplement those provided ";
	print "in the referenced underlying specifications.\n";
	print "</PARA>\n";
	print "<PARA>\n";
	print "This specification uses ISO/IEC 9899 C Language as the reference programming ";
	print "language, and ";
	print "data definitions are specified in ISO C format. The C language ";
	print "is used here as a convenient notation. Using a C language ";
	print "description of these data objects does not preclude their use ";
	print "by other programming languages.";
	print "</PARA>\n";
	for(1..$hdh->numrows) {
		local(*entry);
		%entry=$hdh->fetchhash;
		$Hname=$entry{'Hname'};
		$headroot="../../../build_env/headers/$archname/".$Hname;
		$headname=$headroot.".defs";
		if (!open(HEADER,"<".$headname) &&
			!open(HEADER,"<../".$headname)) {
			print "<!-- missing header file $archname/$Hname -->\n";
			next;
		}
		if( -s HEADER ) { # Make sure it's not empty
			print "<SECT2>\n";
			print "<TITLE>";
			print $entry{'Hname'};
			print "</TITLE>\n";
			print "<PARA>\n";
			$headnote=$headroot.".notes";
			if (open(HEADNOTE, "<$headnote") || 
				open(HEADNOTE,"<../$headnote")) {
				print $_ while (<HEADNOTE>);
				close(HEADNOTE);
			}
			print "</PARA>\n";
			print "<SCREEN>\n";
			while(<HEADER>) {
				s/\</&lt;/g;
				print $_;
				}
			print "</SCREEN>\n";
			print "</SECT2>\n";
		} else {
			print "<!-- empty header file $archname/$Hname -->\n";
			#
			# perhaps we should print a :
			# "No additional data interfaces are defined for $Hname" 
			# message here ??
			#
		}
	}
	print "</SECT1>\n";
}
#
# List the Interface Definitions of things specified by the LSB document.
#
$select = "SELECT Iname,Istandard FROM Interface ";
$select.= "LEFT JOIN LGInt ON Iid=LGIint ";
$select.= "LEFT JOIN LibGroup ON LGid=LGIlibg ";
$select.= "LEFT JOIN Library ON Lid=LGlib ";
$select.= "LEFT JOIN Standard ON Sid=Istandard ";
$select.= "WHERE Lid=$Lid AND Iarch=$Aid ";
$select.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
$select.= "AND Sname='LSB'";
$select.= "ORDER BY Iname";
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if($sth->numrows) {
	print "<SECT1 ID=", $safelibname, "man>\n";
	print "<TITLE>Interface Definitions for ", $libname, "</TITLE>\n";
	print "<PARA>\n";
	print "The following interfaces are included in $libname and are defined\n";
	print "by this specification.\n";
	print "Unless otherwise noted, these interfaces shall be included\n";
	print "in the source standard.\n";
	print "</PARA>\n";
	print "<PARA>\n";
	print "Other interfaces listed above for $libname shall behave as described\n";
	print "in the referenced base document.\n";
	print "</PARA>\n";

	for(1..$sth->numrows) {
		local(*entry);
		%entry=$sth->fetchhash;
		# NB: Footnotes must be unique across the entire document
		# NB: names are NOT demangled here ...
		if (-f $entry{'Iname'}.".sgml") {
			print "include(".$entry{'Iname'}.".sgml)\n";
		} else {
			$missing++;
			print "<!-- MISSING DEFINITION FOR " . $entry{'Iname'} . " -->\n";
			print "<!-- Lets just hope nobody notices -->\n";
		}
	}
	print "</SECT1>\n";
}


printf STDERR ("Skipped %d missing interfaces\n", $missing) if ($missing);
printf("<!-- End of text generated from database -->\n");
printf("<!--    by \$Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/mklibspec,v 1.60 2004-07-13 18:49:08 nick Exp $- -->\n");
