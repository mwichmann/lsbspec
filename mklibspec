#!/usr/bin/perl

use Getopt::Long;
use Mysql;
use IPC::Open2;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

my $trace = 0;

sub usage()
{
	print STDERR "mklibspec -l <libname> -a <archname> [-c cols] [-d]\n";
	die;
}

sub unmangle($)
{
	local($int) = @_;

	if (!defined($cxxfilt)) {
		$cxxfilt = open2(\*CXXRDR, \*CXXWRT, "c++filt") or
			die "Could not open c++filt: $!";
	}
	print CXXWRT "$int\n";
	$int = <CXXRDR>;
	chomp($int);
	$int =~ s/</\&lt;/g;
	$int =~ s/>/\&gt;/g;
	return $int;
}

sub makeid($) 
{
	my ($name) = @_;
	$name =~ s/\s+/./g;
	$name =~ s/[^A-Za-z0-9.]+/./g;
	# finally, remove any repeated . (e.g. "RPC...XDR" which arose from "RPC & XDR")
	$name =~ s/\.\.+/./g;
	return $name;
}

sub output_table($$$$$$$)
{
local ($i,$name,*int,*symver,*stdnum,*stdname,$title) = @_;
local *ref;

print "<TABLE id=\"$name\">\n";
print "<TITLE>$title</TITLE>\n";
print "<TGROUP COLS=$numcols>\n";
print "<TBODY>\n";
$inc=int(($i+($numcols-1))/$numcols);
for $row (1..$inc) {
	print "<ROW>\n";
	for $col (0..$numcols-1) {
		printf "<ENTRY>";
		my $intnum = $row+($col*$inc);
		if( $int[$intnum] ) {
			# the reference stuff is now somewhat simpler than
			# it used to be. Up front, we calculated a hash
			# with all of the references. LINK to that table
			# by looking up the number from the %ref_list hash.

			my $interface = $int[$intnum];
			$interface = unmangle($interface) if ($demangle);
			printf "<indexterm><primary>%s</primary></indexterm>%s", $interface, $interface;
			if( $symver[$intnum] ) {
				printf "(%s)", $symver[$intnum];
				}
			if( $stdname[$intnum] ) {
				printf " <LINK LINKEND=\"STD.%s.%d\">[%d]</LINK>",
					$Lname,
					$ref_list{$stdname[$intnum]}, 
					$ref_list{$stdname[$intnum]};
				}
			}
		printf "</ENTRY>\n";
	}
	print "</ROW>\n";
	}
print "</TBODY>\n";
print "</TGROUP>\n";
print "</TABLE>\n";
}

sub getinterfacename($)
{
local($Iid)=@_;
my($select,%entry);

if( $Iid eq "" ) {return "";}

#print STDERR "Looking for Iname for $Iid\n";

$select = "SELECT Iname FROM Interface ";
$select.= "WHERE Iid=$Iid";
#print $select;
$isth = $Dbh->query($select) || die $Dbh->errmsg();
%entry=$isth->fetchhash;
return $entry{'Iname'};
}


sub output_classinfo($)
{
	local ($class) = @_;

	#print STDERR $$class{'CIname'}."\n";
	local $classname = unmangle($$class{'CIname'});

	print "\n\n";
	print "<SECT3>\n";
	print "<TITLE>";
	print "Class data for ".$classname;
	print "</TITLE>\n";
	print "<PARA>\n";
	print "</PARA>\n";

	#
	# Display Vtable info
	#
	if( $$class{'CIvtable'} ) {
		#
		# we are in a class ... always unmangle (ignore -d)
		#
		local $tblref = sprintf "cls-%s", nmhash($$class{'CIvtable'});

		$select = "SELECT * FROM ClassVtab ";
		$select.= "LEFT JOIN ArchClass ON ACcid = CVcid ";
		$select.= "AND ACpos = CVpos ";
		$select.= "WHERE CVcid=".$$class{'CIid'}." ";
		$select.= "AND ( ACaid = $Aid or ACaid = 1 ) ";
		$select.= "ORDER BY CVpos";
		$vtsth = $Dbh->query($select) || die $Dbh->errmsg();
		if( $vtsth->numrows ) {
		   print "<PARA>\n";
		   print "The virtual table for the $classname class\n";
		   print "is described by <XREF LINKEND=\"$tblref-0\">\n";
		   print "</PARA>\n";
		} else {
		   print "<PARA>\n";
		   print "The virtual table for the $classname class\n";
		   print "is described in the architecture specific document.\n";
		   print "</PARA>\n";
		}
		for(1..$vtsth->numrows) {
		  %classvtab = $vtsth->fetchhash;
		  print "<!--classdata-->\n";
		  printf "<TABLE id=\"$tblref-%d\">\n", $classvtab{'CVpos'};
		  print "<TITLE>";
		  if( $classvtab{'CVpos'} == 0 ) {
		    print "Primary ";
		  } else {
		    print "Secondary ";
		  }
		  $intname=unmangle(getinterfacename($$class{'CIvtable'}));
		  if( $intname ne '' ) {
		  	print $intname;
		  } else {
		  	print getinterfacename($$class{'CIvtable'})." ".$$class{'CIvtable'};
			die "Can't get the vtable name";
		  }
		  print "</TITLE>\n";
		  #print "<!-- ".getinterfacename($$class{'CIvtable'})." ".$$class{'CIvtable'}."-->\n";
		  print "<TGROUP COLS=2>\n";
		  print "<TBODY>\n";

		  print "<ROW>\n";
		  print "<ENTRY>Base Offset</ENTRY>\n";
		  print "<ENTRY>";
		  print $classvtab{'ACbaseoffset'};
		  print "</ENTRY>\n";
		  print "</ROW>\n";

		  print "<ROW>\n";
		  print "<ENTRY>Virtual Base Offset</ENTRY>\n";
		  print "<ENTRY>";
		  print $classvtab{'ACvoffset'};
		  print "</ENTRY>\n";
		  print "</ROW>\n";

		  print "<ROW>\n";
		  print "<ENTRY>RTTI</ENTRY>\n";
		  print "<ENTRY>";
		  $func=unmangle(getinterfacename($classvtab{'CVrtti'}));
		  printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		  print "</ENTRY>\n";
		  print "</ROW>\n";
		  $select = "SELECT * FROM Vtable ";
		  $select.= "LEFT JOIN Architecture ON VTarch=Aid ";
		  $select.= "WHERE VTcid=".$$class{'CIid'}." ";
		  $select.= "AND VTvtpos=".$classvtab{'CVpos'}." ";
		  $select.= "AND ( Aid=$Aid OR Aid=1 ) ";
		  $select.= "ORDER BY VTpos";
		  $vsth = $Dbh->query($select) || die $Dbh->errmsg();
		  $lastpost=0;
		  for(1..$vsth->numrows) {
			%ventry=$vsth->fetchhash;
			for(($lastpos+1)..($ventry{'VTpos'}-1)) {
				print "<ROW>\n";
				print "<ENTRY>vfunc&lsqb;$_&rsqb;:</ENTRY>\n";
				print "<ENTRY>";
				printf "See The Architecture Specific Specification";
				print "</ENTRY>\n";
				print "</ROW>\n";
			}
			print "<ROW>\n";
			print "<ENTRY>vfunc&lsqb;".$ventry{'VTpos'}."&rsqb;:</ENTRY>\n";
			print "<ENTRY>";
			if( $ventry{'VTviid'} != 0 ) {
				$func=unmangle(getinterfacename($ventry{'VTviid'}));
				printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
			} else {
				printf "Unspecified";
				}
			print "</ENTRY>\n";
			print "</ROW>\n";
			$lastpos=$ventry{'VTpos'};
			}

		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
		}
		}


	#
	# Display RTTI info
	#
	if( $$class{'CIrtti'} ) {
		local $tblref = sprintf "rtti-%s", nmhash($$class{'CIrtti'});
		print "<PARA>\n";
		print "The Run Time Type Information for the $classname  class\n";
		print "is described by <XREF LINKEND=\"$tblref\">\n";
		print "</PARA>\n";
		print "<!--classdata-->\n";
		print "<TABLE ID=\"$tblref\">\n";
		print "<TITLE>".unmangle(getinterfacename($$class{'CIrtti'}))."</TITLE>\n";
		print "<TGROUP COLS=2>\n";
		print "<TBODY>\n";
		print "<ROW>\n";
		print "<ENTRY>Base Vtable</ENTRY>\n";
		print "<ENTRY>";
		$func=unmangle(getinterfacename($$class{'CIbasevtable'}));
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		print "<ROW>\n";
		print "<ENTRY>Name</ENTRY>\n";
		print "<ENTRY>";
		$func="_ZTS".substr($$class{'CIname'},2,256);
		$func = unmangle($func);
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		if( $$class{'CInumbasetype'} ) {
			$select = "SELECT * FROM BaseTypes ";
			$select.= "LEFT JOIN ClassInfo ON BTcid=CIid ";
			$select.= "WHERE CIid=".$$class{'CIid'}." ";
			$select.= "ORDER BY BTpos";
			$vsth = $Dbh->query($select) || die $Dbh->errmsg();
			for(1..$$class{'CInumbasetype'}) {
				%entry=$vsth->fetchhash;
				print "<ROW>\n";
				print "<ENTRY>basetype:</ENTRY>\n";
				print "<ENTRY>";
				$func=unmangle(getinterfacename($$class{'BTrttiid'}));
				printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
				print "</ENTRY>\n";
				print "</ROW>\n";
				}
			}
		if( $$class{'CInumvmitypes'} ) {
			print "<ROW>\n";
			print "<ENTRY>flags:</ENTRY>\n";
			print "<ENTRY>".$$class{'CIflags'}."</ENTRY>\n";
			print "</ROW>\n";
			$select = "SELECT * FROM VMIBaseTypes ";
			$select.= "LEFT JOIN ClassInfo ON VBTcid=CIid ";
			$select.= "WHERE CIid=".$$class{'CIid'}." ";
			$select.= "ORDER BY VBTpos";
			$vsth = $Dbh->query($select) || die $Dbh->errmsg();
			for(1..$$class{'CInumvmitypes'}) {
				%entry=$vsth->fetchhash;
				print "<ROW>\n";
				print "<ENTRY>basetype:</ENTRY>\n";
				print "<ENTRY>";
				$func=unmangle(getinterfacename($$class{'VBTbasetype'}));
				printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
				print "</ENTRY>\n";
				print "<ENTRY>".$entry{'VBTflags'}."</ENTRY>\n";
				print "</ROW>\n";
				}
			}

		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
		}
	#
	# Display VTT info
	#
	if( $$class{'CIvtt'} ) {
		local $tblref = sprintf "vtt-%s", nmhash($$class{'CIvtt'});
		print "<PARA>\n";
		print "The VTT for the $classname  class\n";
		print "is described by <XREF LINKEND=\"$tblref\">\n";
		print "</PARA>\n";
		print "<!--classdata-->\n";
		print "<TABLE ID=\"$tblref\">\n";
		print "<TITLE>".unmangle(getinterfacename($$class{'CIvtt'}))."</TITLE>\n";
		print "<TGROUP COLS=2>\n";
		print "<TBODY>\n";
		print "<ROW>\n";
		print "<ENTRY>VTT Name</ENTRY>\n";
		print "<ENTRY>";
		$func=getinterfacename($$class{'CIvtt'});
		printf "<indexterm><primary>%s</primary></indexterm>%s", $func, $func;
		print "</ENTRY>\n";
		print "</ROW>\n";
		print "<ROW>\n";
		print "<ENTRY>Number of Entries</ENTRY>\n";
		print "<ENTRY>";
		print $$class{'CInumvtt'};
		print "</ENTRY>\n";
		print "</ROW>\n";
		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
		}
	print "</SECT3>\n";
}

sub getinterfaces($$$$)
{
	local ($Lname, $LGname, $type, $needpara) = @_;
	local(*entry);
	local(*symver);
	local(*stdnum);
	local(*stdname);
	local($table_title);
	local($name);
	local($where);
	local($safeLname)=$Lname;
	$safeLname =~ s/_/-/g;

	if ($type eq "functions" || $type eq "methods") {
		$where = "WHERE LGIlibg=$LGid AND Itype='Function' ";
		# $where.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
		$where.= "AND ( Istatus='Included' ) ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "ints";
		$table_title = "$Lname - $LGname Function Interfaces";
		}
	elsif ($type eq "deprecated functions") {
		$where = "WHERE LGIlibg=$LGid AND Itype='Function' ";
		$where.= "AND Istatus='Deprecated' ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "depints";
		$table_title = "$Lname - $LGname Deprecated Function Interfaces";
		}
	elsif ($type eq "data interfaces") {
		$where = "WHERE LGIlibg=$LGid AND Itype != 'Function' ";
		# $where.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
		$where.= "AND ( Istatus='Included' ) ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "data";
		$table_title = "$Lname - $LGname Data Interfaces";
		}
	elsif ($type eq "deprecated data interfaces") {
		$where = "WHERE LGIlibg=$LGid AND Itype != 'Function' ";
		$where.= "AND Istatus='Deprecated' ";
		$where.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
		$name  = "ddata";
		$table_title = "$Lname - $LGname Deprecated Data Interfaces";
		}
	else {
		die "Unknown type $type";
		}
	$select = "SELECT DISTINCT Iname, AIarch, Vname, Istandard, Sname FROM Interface ";
	$select.= "LEFT JOIN LGInt ON Iid=LGIint ";
	$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
	$select.= "LEFT JOIN Version ON Vid=AIversion ";
	$select.= "LEFT JOIN Standard ON Sid=Istandard ";
	$select.= "$where ";
	$select.= "ORDER BY Iname";
	print STDERR $select,"\n" if $trace;
	$inh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
	$i=0;
	for(1..$inh->numrows) {
		%entry=$inh->fetchhash;
		if( $entry[$i] ne $entry{'Iname'} ) {
			$i++;
		}
		$entry[$i]=$entry{'Iname'};
		if( $entry{'AIarch'} == $Aid ) { 
			$symver[$i]=$entry{'Vname'};
		}
		$stdnum[$i]=$entry{'Istandard'};
		$stdname[$i]=$entry{'Sname'};
	}
	if( $i > 0 ) {
		$arch_type = ($archname eq "All") ? "generic" : "architecture specific";
		$tblname = sprintf "tbl-%s-%s-%s", $safeLname, nmhash($LGname), $name;
		$tblname =~ s/\s/-/g;
		$tblname =~ s/\+/x/g;		# change the C++ names into Cxx
		print "<PARA>\n";
		print "An LSB conforming implementation shall provide the $arch_type $type\n";
		print "for $LGname specified in <XREF linkend=\"$tblname\">,\n";
		print "with the full mandatory functionality as described in the referenced\n";
		print "underlying specification.\n";
		print "</PARA>\n";
		if ($type =~ /deprecated.*/) {
			print "<NOTE>";
			print "<PARA>These interfaces are deprecated, and applications\n";
			print "should avoid using them.\n";
			print "These interfaces may be withdrawn\n";
			print "in future releases of this specification.\n";
			print "</PARA></NOTE>\n";
			}
		print "<!--libgroup$name-->\n";
		output_table($i,$tblname,*entry,*symver,*stdnum,*stdname,$table_title);
		}
	elsif ($needpara) {
		print "<PARA>\n";
		print "No external $type are defined for $Lname - $LGname\n";
		print "</PARA>\n";
		}
}

sub nmhash($)
{
	local ($name) = @_;
	
	# generate a three char name from the (long) libgroup name
	local ($sname) = lc(substr($name, 0, 3));
	$namehash{$sname} = $name if (!defined ($namehash{$sname}));
	until (!defined($namehash{$sname}) || ($namehash{$sname} eq $name)) {
		$sname++;
	}
	$namehash{$sname} = $name;
	return $sname;
}

sub data_def_header()
{
	print "<SECT1 ID=", $safelibname, "-ddefs>\n";
	print "<TITLE>Data Definitions for $Lname</TITLE>\n";
	print "<PARA>\n";
	print "This section defines global identifiers and their values that are associated ";
	print "with interfaces contained in $Lname.\n";
	print "These definitions are organized into groups that ";
	print "correspond to system headers. This convention is used as a ";
	print "convenience for the reader, and does not imply the existence ";
	print "of these headers, or their content.";
	print "</PARA>\n";
	print "<PARA>\n";
	print "These definitions are intended to supplement those provided ";
	print "in the referenced underlying specifications.\n";
	print "</PARA>\n";
	print "<PARA>\n";
	print "This specification uses ISO/IEC 9899 C Language as the reference programming ";
	print "language, and ";
	print "data definitions are specified in ISO C format. The C language ";
	print "is used here as a convenient notation. Using a C language ";
	print "description of these data objects does not preclude their use ";
	print "by other programming languages.";
	print "</PARA>\n";
	$done_data_def_header++;
}

# the main program ...
# Uncomment to trace SQL statements
#$trace=1;

# A default value 

$numcols=5;

$demangle = 0;
#
# 1) process the arguments
#


GetOptions("l=s" => \$libname,
	   "c=i" => \$numcols,
	   "d"   => \$demangle,
	   "a=s" => \$archname);

if( !$libname ) { usage(); }
if( !$archname ) { usage(); }

#
# 2) Establish connection to the database
#
$Dbh = Mysql->connect($LSBDBHOST,$LSBDB,$LSBUSER, $LSBDBPASSWD) || die $Mysql::db_errstr;

#
# 3) get & print the architecture info
#
$select = "SELECT * FROM Architecture WHERE ";
$select.= "Architecture.Aname=".$Dbh->quote($archname);
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();

%entry=$sth->fetchhash;
$Aid=$entry{'Aid'};
$Aname=$entry{'Aname'};

$safelibname=$libname;
$safelibname =~ s/_/-/g;

printf("<!-- Start of text generated from database -->\n");
printf("<!-- generated from the LSB specification database -->\n");
printf("<!--    by \$Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/mklibspec,v 1.69 2005-08-15 23:57:47 nick Exp $- -->\n");
my $now_string = localtime;
printf("<!--    at %s -->\n", $now_string );

print "<SECT1 ID=", $safelibname, ">\n";
print "<TITLE>Interfaces for ", $libname, "</TITLE>\n";
print "<PARA>\n";
print "<XREF LINKEND=\"lib-$safelibname-def\"> defines the library name and shared object name\n";
print "for the $libname library\n";
print "</PARA>\n";

#
# 4) get & print the library info
#
$select = "SELECT * FROM Library ";
$select.= "LEFT JOIN ArchLib ON Lid=ALlid ";
$select.= "WHERE Library.Lname=".$Dbh->quote($libname)." ";
$select.= "AND Lstd!='No'";
$select.= "AND ALaid=$Aid";
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();

%entry=$sth->fetchhash;
$Lid=$entry{'Lid'};
$Lname=$entry{'Lname'};
$Larch=$entry{'ALaid'};

if( $Larch == $Aid ) {
	print "<TABLE id=\"lib-$safelibname-def\">\n";
	print "<TITLE>$Lname Definition</TITLE>\n";
	print "<TGROUP COLS=2>\n";
	print "<TBODY>\n";
	print "<ROW>\n";
	print "<ENTRY>Library:</ENTRY>\n";
	print "<ENTRY>", $entry{'Lname'}, "</ENTRY>\n";
	print "</ROW>\n";
	print "<ROW>\n";
	print "<ENTRY>SONAME:</ENTRY>\n";
	if( $entry{'ALrunname'} ne "" ) {
		print "<ENTRY>", $entry{'ALrunname'}, "</ENTRY>\n";
	} else {
		print "<ENTRY>See archLSB.</ENTRY>\n";
	}
	print "</ROW>\n";
	print "</TBODY>\n";
	print "</TGROUP>\n";
	print "</TABLE>\n";
}

#
# 5) Check for additional description text for the library
#
if(open(DESC,"<$Lname.txt" )) {
	while(<DESC>) {
		print $_;
	}
	close DESC;
}

#
# 6) Get a list of the Standards that are used by this library
#
print "<PARA>\n";
$select = "SELECT DISTINCT Sname,Sid FROM Standard ";
$select.= "LEFT JOIN Interface ON Sid=Istandard ";
$select.= "LEFT JOIN LGInt ON LGIint=Iid ";
$select.= "LEFT JOIN LibGroup ON LGid=LGIlibg ";
$select.= "LEFT JOIN ArchInt ON AIint=Iid ";
$select.= "WHERE LGlib=$Lid ";
$select.= "AND Istatus != 'Excluded' ";
$select.= "AND ( AIarch=$Aid OR Iarch=$Aid ) ";
$select.= "ORDER BY Sname";
print STDERR $select,"\n" if $trace;
#my %ref_list;
$lsh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if( $lsh->numrows) {
	print "The behavior of the interfaces in this library is specified ";
	print "by the following specifications:";
	print "<SIMPLELIST COLUMNS=1>\n";
	for(my $refno=1; $refno <= $lsh->numrows; $refno++) {
		local(*entry);
		%entry=$lsh->fetchhash;
		printf "<MEMBER ID='STD.%s.%d'>\n", $Lname, $refno;
		printf "[%d] <XREF LINKEND=\"std.%s\">\n", $refno, makeid($entry{'Sname'});
		print "</MEMBER>\n";
		$ref_list{$entry{'Sname'}} = $refno;
		}
	print "</SIMPLELIST>\n";
	}
print "</PARA>\n";

#
# 7) Get a list of the libgroups in the library
#
$select = "SELECT * FROM LibGroup WHERE LGlib=$Lid ORDER BY LGorder";
print STDERR $select,"\n" if $trace;
$lgh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if ($lgh->numrows == 0) {
	if ($archname eq "All") {
		print "<PARA>\n";
		print "There are no generic interfaces to this library\n";
		print "Please refer to the architecture specific supplements for details\n";
		print "</PARA>\n";
	} else {
		print "<PARA>\n";
		print "The $archname architecture has no architecture specific interfaces\n";
		print "to this library. Please refer to the generic specification.\n";
		print "</PARA>\n";
	}
}
for(1..$lgh->numrows) {
	local(*entry);
	local(*std);
	%entry=$lgh->fetchhash;
	$LGid=$entry{'LGid'};
	$LGname=$entry{'LGname'};
	print "<!-- debug: database interface name $LGname -->\n";
	$LGname=unmangle($LGname) if ($demangle);
	
	print "<SECT2>\n";
	print "<!--libgroup-->\n";
	print "<TITLE>";
	print $LGname;
	print "</TITLE>\n";
	print "<PARA>\n";
	print "</PARA>\n";
#
# 8) For each group, make a table of the class data
#
{
	local(*entry);
	local(*inh);
	$select = "SELECT * FROM ClassInfo ";
	$select.= "LEFT JOIN LibGroup ON CIlibg=LGid ";
	$select.= "LEFT JOIN ClassVtab ON CVcid=CIid ";
	$select.= "WHERE LGid=$LGid ";
	$select.= "AND CVpos=0 ";
	$inh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
	print STDERR $select,"\n" if $trace;
	for(1..$inh->numrows) {
		%entry=$inh->fetchhash;
		output_classinfo(\%entry);
		}
}
#
# 9) For each group, make a table of the interfaces
#
	print "\n\n";
	print "<SECT3>\n";
	print "<TITLE>";
	print "Interfaces for ".$LGname;
	print "</TITLE>\n";
	getinterfaces( $Lname, $LGname, $demangle ? "methods" : "functions", 1);
#
# 10) For each group, make a table of the deprecated interfaces
#
	getinterfaces($Lname, $LGname, "deprecated functions", 0);

#
# 11) Make a table of data interfaces
#
	getinterfaces($Lname, $LGname, "data interfaces", 0);
#
# 12) Make a table of deprecated data interfaces
#
	getinterfaces($Lname, $LGname, "deprecated data interfaces", 0);
	print "</SECT3>\n";
	print "</SECT2>\n";
}

print "</SECT1>\n";

#
# List the data definitions by including the related headers here
#
#
# Now, get a list of all headers associate with this library
#
local ($data_def_header);
$data_def_header = 0;
$select = "SELECT DISTINCT Hname,Hid FROM Header ";
$select.= "WHERE Hlib=$Lid ";
$select.= "ORDER BY Hname";
$hdh = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if( $hdh->numrows ) {
	for(1..$hdh->numrows) {
		local(*entry);
		%entry=$hdh->fetchhash;
		$Hname=$entry{'Hname'};
		$headroot="../../../build_env/headers/$archname/".$Hname;
		$headname=$headroot.".defs";
		if (!open(HEADER,"<".$headname) &&
			!open(HEADER,"<../".$headname)) {
			print "<!-- missing header file $archname/$Hname -->\n";
			next;
		}
		if( -s HEADER ) { # Make sure it's not empty
			data_def_header() if (!$done_data_def_header);
			print "<SECT2>\n";
			print "<TITLE>";
			print $entry{'Hname'};
			print "</TITLE>\n";
			print "<PARA>\n";
			$headnote=$headroot.".notes";
			if (open(HEADNOTE, "<$headnote") || 
				open(HEADNOTE,"<../$headnote")) {
				print $_ while (<HEADNOTE>);
				close(HEADNOTE);
			}
			print "</PARA>\n";
			print "<SCREEN>\n";
			while(<HEADER>) {
				s/\</&lt;/g;
				print $_;
				}
			print "</SCREEN>\n";
			print "</SECT2>\n";
		} else {
			print "<!-- empty header file $archname/$Hname -->\n";
			#
			# perhaps we should print a :
			# "No additional data interfaces are defined for $Hname" 
			# message here ??
			#
		}
	}
	print "</SECT1>\n" if ($done_data_def_header);
}
#
# List the Interface Definitions of things specified by the LSB document.
#
$select = "SELECT Iname,Istandard FROM Interface ";
$select.= "LEFT JOIN LGInt ON Iid=LGIint ";
$select.= "LEFT JOIN LibGroup ON LGid=LGIlibg ";
$select.= "LEFT JOIN Library ON Lid=LGlib ";
$select.= "LEFT JOIN Standard ON Sid=Istandard ";
$select.= "WHERE Lid=$Lid AND Iarch=$Aid ";
$select.= "AND ( Istatus='Included' OR Istatus='Deprecated' ) ";
$select.= "AND Sname='LSB'";
$select.= "ORDER BY Iname";
print STDERR $select,"\n" if $trace;
$sth = $Dbh->query($select) || die $select."\n".$Dbh->errmsg();
if($sth->numrows) {
	print "<SECT1 ID=", $safelibname, "man>\n";
	print "<TITLE>Interface Definitions for ", $libname, "</TITLE>\n";
	print "<PARA>\n";
	print "The following interfaces are included in $libname and are defined\n";
	print "by this specification.\n";
	print "Unless otherwise noted, these interfaces shall be included\n";
	print "in the source standard.\n";
	print "</PARA>\n";
	print "<PARA>\n";
	print "Other interfaces listed above for $libname shall behave as described\n";
	print "in the referenced base document.\n";
	print "</PARA>\n";

	for(1..$sth->numrows) {
		local(*entry);
		%entry=$sth->fetchhash;
		# NB: Footnotes must be unique across the entire document
		# NB: names are NOT demangled here ...
		if (-f $entry{'Iname'}.".sgml") {
			print "include(".$entry{'Iname'}.".sgml)\n";
		} else {
			$missing++;
			print "<!-- MISSING DEFINITION FOR " . $entry{'Iname'} . " -->\n";
			print "<!-- Lets just hope nobody notices -->\n";
		}
	}
	print "</SECT1>\n";
}


printf STDERR ("Skipped %d missing interfaces\n", $missing) if ($missing);
printf("<!-- End of text generated from database -->\n");
printf("<!--    by \$Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/mklibspec,v 1.69 2005-08-15 23:57:47 nick Exp $- -->\n");
