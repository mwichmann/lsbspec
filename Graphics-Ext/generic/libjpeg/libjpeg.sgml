<PART ID="toclibjpeg">
<TITLE>JPEG library</TITLE>

<CHAPTER id=libjpeg62>
<TITLE>Libraries</TITLE>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.82 2006/03/29 19:10:18 mats Exp 0 -->
<!--    at Mon Apr 24 10:58:39 2006 -->
<SECT1 ID=libjpeg>
<TITLE>Interfaces for libjpeg</TITLE>
<PARA>
<XREF LINKEND="lib-libjpeg-def"> defines the library name and shared object name
for the libjpeg library
</PARA>
<TABLE id="lib-libjpeg-def">
<TITLE>libjpeg Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libjpeg</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libjpeg.so.62</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libjpeg.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name JPEG Reference library -->
<SECT2>
<!--libgroup-->
<TITLE>JPEG Reference library</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for JPEG Reference library</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for JPEG Reference library specified in <XREF linkend="tbl-libjpeg-jpeg-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libjpeg-jpeg-ints">
<TITLE>libjpeg - JPEG Reference library Function Interfaces</TITLE>
<TGROUP COLS=3>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>jpeg_CreateCompress</primary></indexterm>jpeg_CreateCompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_CreateDecompress</primary></indexterm>jpeg_CreateDecompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_abort</primary></indexterm>jpeg_abort <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_abort_compress</primary></indexterm>jpeg_abort_compress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_abort_decompress</primary></indexterm>jpeg_abort_decompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_add_quant_table</primary></indexterm>jpeg_add_quant_table <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_alloc_huff_table</primary></indexterm>jpeg_alloc_huff_table <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_alloc_quant_table</primary></indexterm>jpeg_alloc_quant_table <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_calc_output_dimensions</primary></indexterm>jpeg_calc_output_dimensions <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_consume_input</primary></indexterm>jpeg_consume_input <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_copy_critical_parameters</primary></indexterm>jpeg_copy_critical_parameters <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_default_colorspace</primary></indexterm>jpeg_default_colorspace <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_destroy</primary></indexterm>jpeg_destroy <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_destroy_compress</primary></indexterm>jpeg_destroy_compress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_destroy_decompress</primary></indexterm>jpeg_destroy_decompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_finish_compress</primary></indexterm>jpeg_finish_compress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_finish_decompress</primary></indexterm>jpeg_finish_decompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_finish_output</primary></indexterm>jpeg_finish_output <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_has_multiple_scans</primary></indexterm>jpeg_has_multiple_scans <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_input_complete</primary></indexterm>jpeg_input_complete <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_new_colormap</primary></indexterm>jpeg_new_colormap <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_quality_scaling</primary></indexterm>jpeg_quality_scaling <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_read_coefficients</primary></indexterm>jpeg_read_coefficients <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_read_header</primary></indexterm>jpeg_read_header <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_read_raw_data</primary></indexterm>jpeg_read_raw_data <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_read_scanlines</primary></indexterm>jpeg_read_scanlines <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_resync_to_restart</primary></indexterm>jpeg_resync_to_restart <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_save_markers</primary></indexterm>jpeg_save_markers <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_set_colorspace</primary></indexterm>jpeg_set_colorspace <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_set_defaults</primary></indexterm>jpeg_set_defaults <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_set_linear_quality</primary></indexterm>jpeg_set_linear_quality <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_set_marker_processor</primary></indexterm>jpeg_set_marker_processor <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_set_quality</primary></indexterm>jpeg_set_quality <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_simple_progression</primary></indexterm>jpeg_simple_progression <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_start_compress</primary></indexterm>jpeg_start_compress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_start_decompress</primary></indexterm>jpeg_start_decompress <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_start_output</primary></indexterm>jpeg_start_output <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_std_error</primary></indexterm>jpeg_std_error <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_stdio_dest</primary></indexterm>jpeg_stdio_dest <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_stdio_src</primary></indexterm>jpeg_stdio_src <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_suppress_tables</primary></indexterm>jpeg_suppress_tables <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_write_coefficients</primary></indexterm>jpeg_write_coefficients <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_write_m_byte</primary></indexterm>jpeg_write_m_byte <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_write_m_header</primary></indexterm>jpeg_write_m_header <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_write_marker</primary></indexterm>jpeg_write_marker <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jpeg_write_raw_data</primary></indexterm>jpeg_write_raw_data <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_write_scanlines</primary></indexterm>jpeg_write_scanlines <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jpeg_write_tables</primary></indexterm>jpeg_write_tables <LINK LINKEND="REFSTD.libjpeg.1">[LSB]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libjpeg-ddefs>
<TITLE>Data Definitions for libjpeg</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libjpeg.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>jpeglib.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define FAR
#define HAVE_PROTOTYPES
#define HAVE_STDDEF_H
#define HAVE_STDLIB_H
#define HAVE_UNSIGNED_CHAR
#define HAVE_UNSIGNED_SHORT
#define jpeg_create_compress(cinfo)	 \
	jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, (size_t) sizeof(struct \
	jpeg_compress_struct))
#define jpeg_create_decompress(cinfo)	 \
	jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, (size_t) \
	sizeof(struct jpeg_decompress_struct))
#define jpeg_common_fields	 \
	struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct \
	jpeg_progress_mgr * progress; void * client_data; boolean \
	is_decompressor; int global_state
#define GETJSAMPLE(value)	((int) (value))
#define GETJOCTET(value)	(value)
#define JPEG_SUSPENDED	0
#define JPOOL_PERMANENT	0
#define JPEG_RST0	0xD0
#define JPEG_EOI	0xD9
#define JPEG_APP0	0xE0
#define JPEG_COM	0xFE
#define JPEG_HEADER_OK	1
#define JPEG_REACHED_SOS	1
#define JPOOL_IMAGE	1
#define C_MAX_BLOCKS_IN_MCU	10
#define D_MAX_BLOCKS_IN_MCU	10
#define MAX_COMPONENTS	10
#define CENTERJSAMPLE	128
#define NUM_ARITH_TBLS	16
#define JPEG_HEADER_TABLES_ONLY	2
#define JPEG_REACHED_EOI	2
#define JPOOL_NUMPOOLS	2
#define JMSG_LENGTH_MAX	200
#define MAXJSAMPLE	255
#define JPEG_ROW_COMPLETED	3
#define JPEG_SCAN_COMPLETED	4
#define MAX_COMPS_IN_SCAN	4
#define MAX_SAMP_FACTOR	4
#define NUM_HUFF_TBLS	4
#define NUM_QUANT_TBLS	4
#define JPEG_LIB_VERSION	62
#define DCTSIZE2	64
#define JPEG_MAX_DIMENSION	65500L
#define BITS_IN_JSAMPLE	8
#define DCTSIZE	8
#define JMSG_STR_PARM_MAX	80
#define JPP(arglist)	arglist
#define EXTERN(type)	extern type
#define JDCT_FASTEST	JDCT_IFAST
#define JDCT_DEFAULT	JDCT_ISLOW
#define LOCAL(type)	static type
#define METHODDEF(type)	static type
#define GLOBAL(type)	type
#define JMETHOD(type,methodname,arglist)	type (*methodname) arglist

struct jpeg_decompress_struct {
    struct jpeg_error_mgr *err;
    struct jpeg_memory_mgr *mem;
    struct jpeg_progress_mgr *progress;
    void *client_data;
    boolean is_decompressor;
    int global_state;
    struct jpeg_source_mgr *src;
    JDIMENSION image_width;
    JDIMENSION image_height;
    int num_components;
    J_COLOR_SPACE jpeg_color_space;
    J_COLOR_SPACE out_color_space;
    unsigned int scale_num;
    unsigned int scale_denom;
    double output_gamma;
    boolean buffered_image;
    boolean raw_data_out;
    J_DCT_METHOD dct_method;
    boolean do_fancy_upsampling;
    boolean do_block_smoothing;
    boolean quantize_colors;
    J_DITHER_MODE dither_mode;
    boolean two_pass_quantize;
    int desired_number_of_colors;
    boolean enable_1pass_quant;
    boolean enable_external_quant;
    boolean enable_2pass_quant;
    JDIMENSION output_width;
    JDIMENSION output_height;
    int out_color_components;
    int output_components;
    int rec_outbuf_height;
    int actual_number_of_colors;
    JSAMPARRAY colormap;
    JDIMENSION output_scanline;
    int input_scan_number;
    JDIMENSION input_iMCU_row;
    int output_scan_number;
    JDIMENSION output_iMCU_row;
    int *coef_bits;
    JQUANT_TBL *quant_tbl_ptrs[4];
    JHUFF_TBL *dc_huff_tbl_ptrs[4];
    JHUFF_TBL *ac_huff_tbl_ptrs[4];
    int data_precision;
    jpeg_component_info *comp_info;
    boolean progressive_mode;
    boolean arith_code;
    UINT8 arith_dc_L[16];
    UINT8 arith_dc_U[16];
    UINT8 arith_ac_K[16];
    unsigned int restart_interval;
    boolean saw_JFIF_marker;
    UINT8 JFIF_major_version;
    UINT8 JFIF_minor_version;
    UINT8 density_unit;
    UINT16 X_density;
    UINT16 Y_density;
    boolean saw_Adobe_marker;
    UINT8 Adobe_transform;
    boolean CCIR601_sampling;
    jpeg_saved_marker_ptr marker_list;
    int max_h_samp_factor;
    int max_v_samp_factor;
    int min_DCT_scaled_size;
    JDIMENSION total_iMCU_rows;
    JSAMPLE *sample_range_limit;
    int comps_in_scan;
    jpeg_component_info *cur_comp_info[4];
    JDIMENSION MCUs_per_row;
    JDIMENSION MCU_rows_in_scan;
    int blocks_in_MCU;
    int MCU_membership[10];
    int Ss;
    int Se;
    int Ah;
    int Al;
    int unread_marker;
    struct jpeg_decomp_master *master;
    struct jpeg_d_main_controller *main;
    struct jpeg_d_coef_controller *coef;
    struct jpeg_d_post_controller *post;
    struct jpeg_input_controller *inputctl;
    struct jpeg_marker_reader *marker;
    struct jpeg_entropy_decoder *entropy;
    struct jpeg_inverse_dct *idct;
    struct jpeg_upsampler *upsample;
    struct jpeg_color_deconverter *cconvert;
    struct jpeg_color_quantizer *cquantize;
};
struct jpeg_error_mgr {
    void (*error_exit) (j_common_ptr);
    void (*emit_message) (j_common_ptr, int);
    void (*output_message) (j_common_ptr);
    void (*format_message) (j_common_ptr, char *);
    void (*reset_error_mgr) (j_common_ptr);
    int msg_code;
    union {
	int i[8];
	char s[80];
    } msg_parm;
    int trace_level;
    long int num_warnings;
    const char *const *jpeg_message_table;
    int last_jpeg_message;
    const char *const *addon_message_table;
    int first_addon_message;
    int last_addon_message;
};
struct jpeg_common_struct {
    struct jpeg_error_mgr *err;
    struct jpeg_memory_mgr *mem;
    struct jpeg_progress_mgr *progress;
    void *client_data;
    boolean is_decompressor;
    int global_state;
};
struct jpeg_memory_mgr {
    void *(*alloc_small) (j_common_ptr, int, size_t);
    void *(*alloc_large) (j_common_ptr, int, size_t);
     JSAMPARRAY(*alloc_sarray) (j_common_ptr, int, JDIMENSION, JDIMENSION);
     JBLOCKARRAY(*alloc_barray) (j_common_ptr, int, JDIMENSION,
				 JDIMENSION);
     jvirt_sarray_ptr(*request_virt_sarray) (j_common_ptr, int, boolean,
					     JDIMENSION, JDIMENSION,
					     JDIMENSION);
     jvirt_barray_ptr(*request_virt_barray) (j_common_ptr, int, boolean,
					     JDIMENSION, JDIMENSION,
					     JDIMENSION);
    void (*realize_virt_arrays) (j_common_ptr);
     JSAMPARRAY(*access_virt_sarray) (j_common_ptr, jvirt_sarray_ptr,
				      JDIMENSION, JDIMENSION, boolean);
     JBLOCKARRAY(*access_virt_barray) (j_common_ptr, jvirt_barray_ptr,
				       JDIMENSION, JDIMENSION, boolean);
    void (*free_pool) (j_common_ptr, int);
    void (*self_destruct) (j_common_ptr);
    long int max_memory_to_use;
    long int max_alloc_chunk;
};
typedef struct jpeg_common_struct *j_common_ptr;
typedef unsigned char JSAMPLE;
typedef JSAMPLE *JSAMPROW;
typedef JSAMPROW *JSAMPARRAY;
typedef unsigned int JDIMENSION;
typedef short int JCOEF;
typedef JCOEF JBLOCK[64];
typedef JBLOCK *JBLOCKROW;
typedef JBLOCKROW *JBLOCKARRAY;
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
typedef int boolean;
typedef struct jvirt_barray_control *jvirt_barray_ptr;
struct jpeg_progress_mgr {
    void (*progress_monitor) (j_common_ptr);
    long int pass_counter;
    long int pass_limit;
    int completed_passes;
    int total_passes;
};
struct jpeg_source_mgr {
    const JOCTET *next_input_byte;
    size_t bytes_in_buffer;
    void (*init_source) (j_decompress_ptr);
     boolean(*fill_input_buffer) (j_decompress_ptr);
    void (*skip_input_data) (j_decompress_ptr, long int);
     boolean(*resync_to_restart) (j_decompress_ptr, int);
    void (*term_source) (j_decompress_ptr);
};
typedef unsigned char JOCTET;
typedef struct jpeg_decompress_struct *j_decompress_ptr;
typedef enum {
    JCS_UNKNOWN = 0,
    JCS_GRAYSCALE = 1,
    JCS_RGB = 2,
    JCS_YCbCr = 3,
    JCS_CMYK = 4,
    JCS_YCCK = 5
} J_COLOR_SPACE;
typedef enum {
    JDCT_ISLOW = 0,
    JDCT_IFAST = 1,
    JDCT_FLOAT = 2
} J_DCT_METHOD;
typedef enum {
    JDITHER_NONE = 0,
    JDITHER_ORDERED = 1,
    JDITHER_FS = 2
} J_DITHER_MODE;
typedef short unsigned int UINT16;
typedef struct {
    UINT16 quantval[64];
    boolean sent_table;
} JQUANT_TBL;
typedef unsigned char UINT8;
typedef struct {
    UINT8 bits[17];
    UINT8 huffval[256];
    boolean sent_table;
} JHUFF_TBL;
typedef struct {
    int component_id;
    int component_index;
    int h_samp_factor;
    int v_samp_factor;
    int quant_tbl_no;
    int dc_tbl_no;
    int ac_tbl_no;
    JDIMENSION width_in_blocks;
    JDIMENSION height_in_blocks;
    int DCT_scaled_size;
    JDIMENSION downsampled_width;
    JDIMENSION downsampled_height;
    boolean component_needed;
    int MCU_width;
    int MCU_height;
    int MCU_blocks;
    int MCU_sample_width;
    int last_col_width;
    int last_row_height;
    JQUANT_TBL *quant_table;
    void *dct_table;
} jpeg_component_info;
struct jpeg_marker_struct {
    jpeg_saved_marker_ptr next;
    UINT8 marker;
    unsigned int original_length;
    unsigned int data_length;
    JOCTET *data;
};
typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;
struct jpeg_compress_struct {
    struct jpeg_error_mgr *err;
    struct jpeg_memory_mgr *mem;
    struct jpeg_progress_mgr *progress;
    void *client_data;
    boolean is_decompressor;
    int global_state;
    struct jpeg_destination_mgr *dest;
    JDIMENSION image_width;
    JDIMENSION image_height;
    int input_components;
    J_COLOR_SPACE in_color_space;
    double input_gamma;
    int data_precision;
    int num_components;
    J_COLOR_SPACE jpeg_color_space;
    jpeg_component_info *comp_info;
    JQUANT_TBL *quant_tbl_ptrs[4];
    JHUFF_TBL *dc_huff_tbl_ptrs[4];
    JHUFF_TBL *ac_huff_tbl_ptrs[4];
    UINT8 arith_dc_L[16];
    UINT8 arith_dc_U[16];
    UINT8 arith_ac_K[16];
    int num_scans;
    const jpeg_scan_info *scan_info;
    boolean raw_data_in;
    boolean arith_code;
    boolean optimize_coding;
    boolean CCIR601_sampling;
    int smoothing_factor;
    J_DCT_METHOD dct_method;
    unsigned int restart_interval;
    int restart_in_rows;
    boolean write_JFIF_header;
    UINT8 JFIF_major_version;
    UINT8 JFIF_minor_version;
    UINT8 density_unit;
    UINT16 X_density;
    UINT16 Y_density;
    boolean write_Adobe_marker;
    JDIMENSION next_scanline;
    boolean progressive_mode;
    int max_h_samp_factor;
    int max_v_samp_factor;
    JDIMENSION total_iMCU_rows;
    int comps_in_scan;
    jpeg_component_info *cur_comp_info[4];
    JDIMENSION MCUs_per_row;
    JDIMENSION MCU_rows_in_scan;
    int blocks_in_MCU;
    int MCU_membership[10];
    int Ss;
    int Se;
    int Ah;
    int Al;
    struct jpeg_comp_master *master;
    struct jpeg_c_main_controller *main;
    struct jpeg_c_prep_controller *prep;
    struct jpeg_c_coef_controller *coef;
    struct jpeg_marker_writer *marker;
    struct jpeg_color_converter *cconvert;
    struct jpeg_downsampler *downsample;
    struct jpeg_forward_dct *fdct;
    struct jpeg_entropy_encoder *entropy;
    jpeg_scan_info *script_space;
    int script_space_size;
};
struct jpeg_destination_mgr {
    JOCTET *next_output_byte;
    size_t free_in_buffer;
    void (*init_destination) (j_compress_ptr);
     boolean(*empty_output_buffer) (j_compress_ptr);
    void (*term_destination) (j_compress_ptr);
};
typedef struct jpeg_compress_struct *j_compress_ptr;
typedef struct {
    int comps_in_scan;
    int component_index[4];
    int Ss;
    int Se;
    int Ah;
    int Al;
} jpeg_scan_info;
typedef JSAMPARRAY *JSAMPIMAGE;
typedef boolean(*jpeg_marker_parser_method) (j_decompress_ptr);
extern void jpeg_save_markers(j_decompress_ptr, int, unsigned int);
extern boolean jpeg_has_multiple_scans(j_decompress_ptr);
extern void jpeg_set_linear_quality(j_compress_ptr, int, boolean);
extern int jpeg_consume_input(j_decompress_ptr);
extern void jpeg_stdio_src(j_decompress_ptr, FILE *);
extern void jpeg_abort(j_common_ptr);
extern boolean jpeg_finish_output(j_decompress_ptr);
extern void jpeg_set_colorspace(j_compress_ptr, J_COLOR_SPACE);
extern void jpeg_copy_critical_parameters(j_decompress_ptr,
					  j_compress_ptr);
extern jvirt_barray_ptr *jpeg_read_coefficients(j_decompress_ptr);
extern void jpeg_destroy_decompress(j_decompress_ptr);
extern void jpeg_write_m_header(j_compress_ptr, int, unsigned int);
extern boolean jpeg_resync_to_restart(j_decompress_ptr, int);
extern JDIMENSION jpeg_read_raw_data(j_decompress_ptr, JSAMPIMAGE,
				     JDIMENSION);
extern JDIMENSION jpeg_write_raw_data(j_compress_ptr, JSAMPIMAGE,
				      JDIMENSION);
extern JQUANT_TBL *jpeg_alloc_quant_table(j_common_ptr);
extern int jpeg_read_header(j_decompress_ptr, boolean);
extern struct jpeg_error_mgr *jpeg_std_error(struct jpeg_error_mgr *);
extern void jpeg_write_tables(j_compress_ptr);
extern void jpeg_simple_progression(j_compress_ptr);
extern void jpeg_set_marker_processor(j_decompress_ptr, int,
				      jpeg_marker_parser_method);
extern void jpeg_suppress_tables(j_compress_ptr, boolean);
extern JDIMENSION jpeg_write_scanlines(j_compress_ptr, JSAMPARRAY,
				       JDIMENSION);
extern void jpeg_abort_decompress(j_decompress_ptr);
extern void jpeg_default_colorspace(j_compress_ptr);
extern JHUFF_TBL *jpeg_alloc_huff_table(j_common_ptr);
extern void jpeg_abort_compress(j_compress_ptr);
extern void jpeg_add_quant_table(j_compress_ptr, int, const unsigned int *,
				 int, boolean);
extern void jpeg_calc_output_dimensions(j_decompress_ptr);
extern void jpeg_destroy_compress(j_compress_ptr);
extern boolean jpeg_finish_decompress(j_decompress_ptr);
extern void jpeg_write_coefficients(j_compress_ptr, jvirt_barray_ptr *);
extern void jpeg_set_defaults(j_compress_ptr);
extern boolean jpeg_start_decompress(j_decompress_ptr);
extern void jpeg_CreateDecompress(j_decompress_ptr, int, size_t);
extern void jpeg_new_colormap(j_decompress_ptr);
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr, JSAMPARRAY,
				      JDIMENSION);
extern int jpeg_quality_scaling(int);
extern void jpeg_finish_compress(j_compress_ptr);
extern boolean jpeg_input_complete(j_decompress_ptr);
extern void jpeg_CreateCompress(j_compress_ptr, int, size_t);
extern void jpeg_destroy(j_common_ptr);
extern boolean jpeg_start_output(j_decompress_ptr, int);
extern void jpeg_start_compress(j_compress_ptr, boolean);
extern void jpeg_set_quality(j_compress_ptr, int, boolean);
extern void jpeg_write_marker(j_compress_ptr, int, const JOCTET *,
			      unsigned int);
extern void jpeg_write_m_byte(j_compress_ptr, int);
extern void jpeg_stdio_dest(j_compress_ptr, FILE *);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libjpegman>
<TITLE>Interface Definitions for libjpeg</TITLE>
<PARA>
The interfaces defined on the following pages are included in libjpeg and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libjpeg> shall behave as described
in the referenced base document.
</PARA>
<refentry id="libjpeg.jpeg.CreateCompress.1">
<refmeta>
<refentrytitle>jpeg_CreateCompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_CreateCompress</refname>
<refpurpose>allocate and initialize a JPEG compression object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.CreateCompress.1">	<primary>jpeg_CreateCompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_CreateCompress</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>version</parameter>
</paramdef>
<paramdef>size_t
<parameter>size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function <function>jpeg_CreateCompress</function> shall allocate and
initialize a JPEG compression object of type struct jpeg_compress_struct.
The error handler structure of type struct jpeg_error_mgr must be initialized
before making a call to <function>jpeg_CreateCompress</function>.
JPEG_LIB_VERSION and size of the structure used to hold the JPEG compression
object struct jpeg_compress_struct must be passed in arguments version and size
respectively.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
<function>jpeg_CreateCompress</function> shall exit via the error handler if 
it fails to allocate memory.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.CreateDecompress.1">
<refmeta>
<refentrytitle>jpeg_CreateDecompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_CreateDecompress</refname>
<refpurpose>allocate and initialize a JPEG decompression object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.CreateDecompress.1">	<primary>jpeg_CreateDecompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_CreateDecompress</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>version</parameter>
</paramdef>
<paramdef>size_t
<parameter>size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function <function>jpeg_CreateDecompress</function> shall allocate and
initialize a JPEG decompression object of type struct jpeg_decompress_struct.
The error handler structure of type struct jpeg_error_mgr must be initialized
before making a call to <function>jpeg_CreateDecompress</function>.
JPEG_LIB_VERSION and size of the structure used to hold the JPEG compression
object struct jpeg_decompress_struct must be passed in arguments version and size
respectively.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
<function>jpeg_CreateDecompress</function> shall exit via the error handler if 
it fails to allocate memory.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.abort.1">
<refmeta>
<refentrytitle>jpeg_abort</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_abort</refname>
<refpurpose>aborts the compression or decompression cycle</refpurpose>
<indexterm id="ix.libjpeg.jpeg.abort.1">	<primary>jpeg_abort</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_abort</function>
</funcdef>
<paramdef>j_common_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_abort() shall abort the processing of a compression or
decompression operation. The function shall return the given object to an idle
state releasing any working memory. The object may be reused after a call to
jpeg_abort().
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.abort.compress.1">
<refmeta>
<refentrytitle>jpeg_abort_compress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_abort_compress</refname>
<refpurpose>abort processing of JPEG compression operation</refpurpose>
<indexterm id="ix.libjpeg.jpeg.abort.compress.1">	<primary>jpeg_abort_compress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_abort_compress</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_abort_compress() shall abort the processing of a JPEG
compression operation. The function shall return the given compression object
to an idle state releasing any working memory. The compression object may be
reused after a call to jpeg_abort_compress().
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.abort.decompress.1">
<refmeta>
<refentrytitle>jpeg_abort_decompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_abort_decompress</refname>
<refpurpose>abort processing of JPEG decompression operation</refpurpose>
<indexterm id="ix.libjpeg.jpeg.abort.decompress.1">	<primary>jpeg_abort_decompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_abort_decompress</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_abort_decompress() shall abort the processing of a JPEG
decompression operation. The function shall return the given decompression
object to an idle state releasing any working memory. The decompression object
may be reused after a call to jpeg_abort_decompress().
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.add.quant.table.1">
<refmeta>
<refentrytitle>jpeg_add_quant_table</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_add_quant_table</refname>
<refpurpose>add a quantization table</refpurpose>
<indexterm id="ix.libjpeg.jpeg.add.quant.table.1">	<primary>jpeg_add_quant_table</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_add_quant_table</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>table_slot</parameter>
</paramdef>
<paramdef>const unsigned int *
<parameter>basic_table</parameter>
</paramdef>
<paramdef>int
<parameter>scale_factor</parameter>
</paramdef>
<paramdef>boolean
<parameter>force_baseline</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_add_quant_table() shall add a quantization table parameter at
the "table_slot" index of the quantization table array. "basic_table" points to
an array of 64 unsigned ints given in normal array order.  These values are
multiplied by "scale_factor"/100. The values are limited to the range 1..65535.
If "force_baseline" is TRUE, the computed quantization table entries are
limited to 1..255 for JPEG baseline compatibility.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_add_quant_table() shall return error and exit if "table_slot" is >=
NUM_QUANT_TBLS.
jpeg_add_quant_table() shall return error and exit if the state of the
compression object indicates that the compression cycle has started.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.alloc.huff.table.1">
<refmeta>
<refentrytitle>jpeg_alloc_huff_table</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_alloc_huff_table</refname>
<refpurpose>allocate Huffman table</refpurpose>
<indexterm id="ix.libjpeg.jpeg.alloc.huff.table.1">	<primary>jpeg_alloc_huff_table</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JHUFF_TBL *
<function>jpeg_alloc_huff_table</function>
</funcdef>
<paramdef>j_common_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_alloc_huff_table() shall allocate memory for a structure holding Huffman 
coding table.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_alloc_huff_table() shall return a pointer to allocated data structure
for the Huffman coding table.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.alloc.quant.table.1">
<refmeta>
<refentrytitle>jpeg_alloc_quant_table</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_alloc_quant_table</refname>
<refpurpose>allocate quantization table</refpurpose>
<indexterm id="ix.libjpeg.jpeg.alloc.quant.table.1">	<primary>jpeg_alloc_quant_table</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JQUANT_TBL *
<function>jpeg_alloc_quant_table</function>
</funcdef>
<paramdef>j_common_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_alloc_quant_table() shall allocate memory for a structure holding
quantization table.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_alloc_quant_table() shall return a pointer to allocated data structure
for the quantization table.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.calc.output.dimensions.1">
<refmeta>
<refentrytitle>jpeg_calc_output_dimensions</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_calc_output_dimensions</refname>
<refpurpose>compute output image dimensions</refpurpose>
<indexterm id="ix.libjpeg.jpeg.calc.output.dimensions.1">	<primary>jpeg_calc_output_dimensions</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_calc_output_dimensions</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_calc_output_dimensions() computes the output image dimensions based on the
current compression parameter settings in the compression object. The following
dimensions shall be computed:
<variablelist>
<varlistentry>
<term><parameter>output_width</parameter></term>
<listitem><para>actual width of output image</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>output_height</parameter></term>
<listitem><para>actual height of output image</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>out_color_components</parameter></term>
<listitem><para>number of color components in out_color_space</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>output_components</parameter></term>
<listitem><para>number of color components returned</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>rec_outbuf_height</parameter></term>
<listitem><para>recommended height of scanline buffer</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.consume.input.1">
<refmeta>
<refentrytitle>jpeg_consume_input</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_consume_input</refname>
<refpurpose>decode input data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.consume.input.1">	<primary>jpeg_consume_input</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>jpeg_consume_input</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_consume_input() shall decode the input data as it arrives, even if it is
not to be displayed.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_consume_input() shall return with one of the following return codes:
<variablelist>
<varlistentry>
<term><parameter>JPEG_REACHED_SOS</parameter></term>
<listitem><para>reached SOS marker</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_REACHED_EOI</parameter></term>
<listitem><para>reached EOI marker</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_ROW_COMPLETED</parameter></term>
<listitem><para>completed reading one MCU row of compressed data
</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_SCAN_COMPLETED</parameter></term>
<listitem><para>completed reading last MCU row of compressed scan
</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_SUSPENDED</parameter></term>
<listitem><para>if data source module requests suspension of the decompressor.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.copy.critical.parameters.1">
<refmeta>
<refentrytitle>jpeg_copy_critical_parameters</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_copy_critical_parameters</refname>
<refpurpose>copy critical compression parameters from source decompression
object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.copy.critical.parameters.1">	<primary>jpeg_copy_critical_parameters</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_copy_critical_parameters</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>srcinfo</parameter>
</paramdef>
<paramdef>j_compress_ptr
<parameter>dstinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_copy_critical_parameters() shall initialize the compression object with
default parameters, then copy the parameters needed for lossless transcoding
from the source decompression object. 
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.default.colorspace.1">
<refmeta>
<refentrytitle>jpeg_default_colorspace</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_default_colorspace</refname>
<refpurpose>set default colorspace based on input image's color space</refpurpose>
<indexterm id="ix.libjpeg.jpeg.default.colorspace.1">	<primary>jpeg_default_colorspace</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_default_colorspace</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_default_colorspace() shall set the JPEG color space to a default value
based on the color space of the input image.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.destroy.1">
<refmeta>
<refentrytitle>jpeg_destroy</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_destroy</refname>
<refpurpose>deallocation of a JPEG object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.destroy.1">	<primary>jpeg_destroy</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_destroy</function>
</funcdef>
<paramdef>j_common_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_destroy() shall deallocate and release all memory associated
with the JPEG object. The object itself and the error manager struct allocated
by the application should not be freed by this function.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.destroy.compress.1">
<refmeta>
<refentrytitle>jpeg_destroy_compress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_destroy_compress</refname>
<refpurpose>deallocate a JPEG compression object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.destroy.compress.1">	<primary>jpeg_destroy_compress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_destroy_compress</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_destroy_compress() shall deallocate and release all memory
associated with the compression object. The jpeg_compress_struct itself and the 
error manager struct allocated by the application should not be freed by
this function.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.destroy.decompress.1">
<refmeta>
<refentrytitle>jpeg_destroy_decompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_destroy_decompress</refname>
<refpurpose>deallocate a JPEG decompression object</refpurpose>
<indexterm id="ix.libjpeg.jpeg.destroy.decompress.1">	<primary>jpeg_destroy_decompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_destroy_decompress</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_destroy_decompress() shall deallocate and release all memory
associated with the decompression object. The jpeg_decompress_struct itself and
the error manager struct allocated by the application should not be freed by
this function.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.finish.compress.1">
<refmeta>
<refentrytitle>jpeg_finish_compress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_finish_compress</refname>
<refpurpose>complete the compression cycle</refpurpose>
<indexterm id="ix.libjpeg.jpeg.finish.compress.1">	<primary>jpeg_finish_compress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_finish_compress</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_finish_compress() shall set the compression state to
completion. Any remaining bufferload of data shall be written to the data
destination. jpeg_finish_compress() shall also release working memory
associated with the JPEG object.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_finish_compress() shall return error if the function is invoked before
writing the specified number of scanlines.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.finish.decompress.1">
<refmeta>
<refentrytitle>jpeg_finish_decompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_finish_decompress</refname>
<refpurpose>complete decompression cycle</refpurpose>
<indexterm id="ix.libjpeg.jpeg.finish.decompress.1">	<primary>jpeg_finish_decompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_finish_decompress</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_finish_decompress() shall set the decompression state to
completion. Any remaining input data shall be decoded and consumed. 
jpeg_finish_decompress() shall also release working memory associated with the
JPEG object.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_finish_decompress() shall return FALSE if data source requests suspension
of the decompressor. Otherwise, jpeg_finish_decompress() shall return TRUE.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_finish_decompress() shall return error if the function is invoked before
reading the specified number of scanlines.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.finish.output.1">
<refmeta>
<refentrytitle>jpeg_finish_output</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_finish_output</refname>
<refpurpose>complete pass in buffered-image mode</refpurpose>
<indexterm id="ix.libjpeg.jpeg.finish.output.1">	<primary>jpeg_finish_output</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_finish_output</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_start_output() shall change state for completion of an output pass in 
buffered-image mode. The scan number shall be incremented if the end-of-image
marker is not reached.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_finish_output() shall return FALSE if decompression is suspended.
Otherwise, jpeg_finish_output() shall return TRUE.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.has.multiple.scans.1">
<refmeta>
<refentrytitle>jpeg_has_multiple_scans</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_has_multiple_scans</refname>
<refpurpose>test if input image has multiple scans</refpurpose>
<indexterm id="ix.libjpeg.jpeg.has.multiple.scans.1">	<primary>jpeg_has_multiple_scans</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_has_multiple_scans</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_has_multiple_scans() shall return TRUE if the incoming image file has more
than one scan.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
TRUE for multiple scans, FALSE otherwise.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.input.complete.1">
<refmeta>
<refentrytitle>jpeg_input_complete</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_input_complete</refname>
<refpurpose>test for end-of-image</refpurpose>
<indexterm id="ix.libjpeg.jpeg.input.complete.1">	<primary>jpeg_input_complete</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_input_complete</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_input_complete() shall return TRUE if the end-of-image marker has not been
read for the input image file.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
TRUE if reached EOI, FALSE otherwise.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.new.colormap.1">
<refmeta>
<refentrytitle>jpeg_new_colormap</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_new_colormap</refname>
<refpurpose>switch to a new external colormap between output passes</refpurpose>
<indexterm id="ix.libjpeg.jpeg.new.colormap.1">	<primary>jpeg_new_colormap</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_new_colormap</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_new_colormap() shall select 2-pass quantizer for using an external colormap
and notify the quantizer of the switch to a colormap that is different from the
one used in the previous pass. The new colormap must be set using cinfo.colormap
before a call to jpeg_new_colormap().
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.quality.scaling.1">
<refmeta>
<refentrytitle>jpeg_quality_scaling</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_quality_scaling</refname>
<refpurpose>convert quality scaling to percentage scaling factor</refpurpose>
<indexterm id="ix.libjpeg.jpeg.quality.scaling.1">	<primary>jpeg_quality_scaling</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>jpeg_quality_scaling</function>
</funcdef>
<paramdef>int
<parameter>quality</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_quality_scaling() shall convert a user-specified quality
rating to a percentage scaling factor for an underlying quantization table,
using IJG-recommended scaling curve. The input "quality" factor ranges from 0 to
100.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_quality_scaling() shall return the integer value of quality as a 
percentage.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.read.coefficients.1">
<refmeta>
<refentrytitle>jpeg_read_coefficients</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_read_coefficients</refname>
<refpurpose>read the contents of JPEG file as DCT coefficients</refpurpose>
<indexterm id="ix.libjpeg.jpeg.read.coefficients.1">	<primary>jpeg_read_coefficients</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>jvirt_barray_ptr *
<function>jpeg_read_coefficients</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_read_coefficients() shall return the contents of the JPEG image file as DCT
coefficients. The entire image shall be read as a set of virtual 
coefficient-block arrays, one array per component. The return value is a pointer
to an array of virtual-array descriptors.
</para>
<para>
Each block in the block arrays shall contain quantized coefficient values in
normal array order and not JPEG zigzag order. The block arrays shall contain only
DCT blocks containing real data; any entirely-dummy blocks added to fill out
interleaved MCUs at the right or bottom edges of the image shall be discarded
during reading and shall not be stored in the block arrays. The size of each
block array can be determined from the width_in_blocks and height_in_blocks
fields of the component's comp_info entry.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_read_coefficients() shall return a pointer to an array of virtual-array
descriptors containing DCT coefficients.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.read.header.1">
<refmeta>
<refentrytitle>jpeg_read_header</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_read_header</refname>
<refpurpose>read start of JPEG datastream</refpurpose>
<indexterm id="ix.libjpeg.jpeg.read.header.1">	<primary>jpeg_read_header</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>jpeg_read_header</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>boolean
<parameter>require_image</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_read_header() shall read the JPEG datastream until the first
SOS marker is encountered. The function shall initialize all decompression
parameters to default values and save all tables and parameters in the
decompression object structure.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_read_header() shall return with one of the following return codes:
<variablelist>
<varlistentry>
<term><parameter>JPEG_HEADER_OK</parameter></term>
<listitem><para>if SOS marker is reached</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_HEADER_TABLES_ONLY</parameter></term>
<listitem><para>for an abbreviated input image, if EOI is reached
</para></listitem>
</varlistentry>
<varlistentry>
<term><parameter>JPEG_SUSPENDED</parameter></term>
<listitem><para>if data source module requests suspension of the decompressor.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_read_header() returns error if it encounters end-of-image and require_image
is TRUE.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.read.raw.data.1">
<refmeta>
<refentrytitle>jpeg_read_raw_data</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_read_raw_data</refname>
<refpurpose>read raw downsampled image data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.read.raw.data.1">	<primary>jpeg_read_raw_data</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JDIMENSION
<function>jpeg_read_raw_data</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>JSAMPIMAGE
<parameter>data</parameter>
</paramdef>
<paramdef>JDIMENSION
<parameter>max_lines</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_read_raw_data() shall return upto max_lines number of scanlines of raw downsampled
data into the JSAMPIMAGE array argument. The data buffer must be of atleast
max_v_samp_factor*DCTSIZE scanlines as jpeg_read_raw_data() shall return one MCU
row per call. 
</para>
<para>
The passed max_lines value must be atleast (cinfo->max_v_samp_factor * DCTSIZE). 
Before starting the decompression sequence, cinfo->raw_data_out must be set to
TRUE. 
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_read_raw_data() shall return the number of scanlines processed.
jpeg_read_raw_data() shall return 0 if the data source is suspended.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_read_raw_data() shall report error and exit if max_lines is less than
(cinfo->max_v_samp_factor*DCTSIZE).
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.read.scanlines.1">
<refmeta>
<refentrytitle>jpeg_read_scanlines</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_read_scanlines</refname>
<refpurpose>read scanlines of data from JPEG decompressor</refpurpose>
<indexterm id="ix.libjpeg.jpeg.read.scanlines.1">	<primary>jpeg_read_scanlines</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JDIMENSION
<function>jpeg_read_scanlines</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>JSAMPARRAY
<parameter>scanlines</parameter>
</paramdef>
<paramdef>JDIMENSION
<parameter>max_lines</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_read_scanlines() shall return upto the maximum number of scanlines of 
decompressed image data. This may be less than the number requested in 
cases such as bottom of image, data source suspension, and operating
modes that emit multiple scanlines at a time. Image data shall be returned in
top-to-bottom scanline order.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, jpeg_read_scanlines() shall return the number of lines actually
read.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_read_scanlines() shall report a non-fatal error if the requested number
of scanlines is greater than the height of the original unscaled image.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.resync.to.restart.1">
<refmeta>
<refentrytitle>jpeg_resync_to_restart</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_resync_to_restart</refname>
<refpurpose>resync if marker other than expected restart marker found</refpurpose>
<indexterm id="ix.libjpeg.jpeg.resync.to.restart.1">	<primary>jpeg_resync_to_restart</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_resync_to_restart</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>desired</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_resync_to_restart() is the default resync procedure that a data source
manager can invoke when the decompressor fails to find a restart (RSTn) marker
where one is expected. The function shall find a suitable point for resuming
decompression and position the input stream to the next data segment. The desired
restart marker number (0..7) is passed as argument "desired".
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_resync_to_restart() shall return FALSE if decompression is suspended.
Otherwise, jpeg_start_output() shall return TRUE.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.save.markers.1">
<refmeta>
<refentrytitle>jpeg_save_markers</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_save_markers</refname>
<refpurpose>save the contents of special markers</refpurpose>
<indexterm id="ix.libjpeg.jpeg.save.markers.1">	<primary>jpeg_save_markers</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_save_markers</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>marker_code</parameter>
</paramdef>
<paramdef>unsigned int
<parameter>length_limit</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_save_markers() shall obtain length_limit bytes of special markers of type
specified by marker_code. The marker_code shall take one of the following
values: JPEG_COM, JPEG_APP0 - JPEG_APP15. The marker contents shall be stored in
the marker field of cinfo. If length_limit is 0xFFFF, all marker bytes are
saved.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.set.colorspace.1">
<refmeta>
<refentrytitle>jpeg_set_colorspace</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_set_colorspace</refname>
<refpurpose>set JPEG file's colorspace</refpurpose>
<indexterm id="ix.libjpeg.jpeg.set.colorspace.1">	<primary>jpeg_set_colorspace</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_set_colorspace</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>J_COLOR_SPACE
<parameter>colorspace</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_set_colorspace() shall set the JPEG file's colorspace to the given color
space. The function may change the value of other compression parameters that
are dependent on color space.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_set_colorspace() shall return error and exit if the state of the
compression object indicates that the compression cycle has started.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.set.defaults.1">
<refmeta>
<refentrytitle>jpeg_set_defaults</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_set_defaults</refname>
<refpurpose>set compression parameters to default values</refpurpose>
<indexterm id="ix.libjpeg.jpeg.set.defaults.1">	<primary>jpeg_set_defaults</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_set_defaults</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_set_defaults() shall set all JPEG compression parameters to 
default values using the input image's color space.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_set_defaults() shall return error and exit if the state of the
compression object indicates that the compression cycle has started.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.set.linear.quality.1">
<refmeta>
<refentrytitle>jpeg_set_linear_quality</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_set_linear_quality</refname>
<refpurpose>construct JPEG quantization tables for indicated scale factor</refpurpose>
<indexterm id="ix.libjpeg.jpeg.set.linear.quality.1">	<primary>jpeg_set_linear_quality</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_set_linear_quality</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>scale_factor</parameter>
</paramdef>
<paramdef>boolean
<parameter>force_baseline</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_set_linear_quality() shall construct JPEG quantization tables
from the sample table values in JPEG specification Section K.1, multiplied by
the given percentage scale factor.
If "force_baseline" is TRUE, the computed quantization table entries are
limited to 1..255 for JPEG baseline compatibility.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.set.marker.processor.1">
<refmeta>
<refentrytitle>jpeg_set_marker_processor</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_set_marker_processor</refname>
<refpurpose>set processor method for COM or APPn markers</refpurpose>
<indexterm id="ix.libjpeg.jpeg.set.marker.processor.1">	<primary>jpeg_set_marker_processor</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_set_marker_processor</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>marker_code</parameter>
</paramdef>
<paramdef>jpeg_marker_parser_method
<parameter>routine</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_set_marker_processor() shall set a marker processor routine having
signature 
boolean <function>jpeg_marker_parser_method</function> 
j_decompress_ptr <parameter>cinfo</parameter>
The marker processor routine must return TRUE if the marker and its parameters
are processed completely. The routine must return FALSE if it is forced to
suspend before reaching the end of marker parameters.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.set.quality.1">
<refmeta>
<refentrytitle>jpeg_set_quality</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_set_quality</refname>
<refpurpose>construct JPEG quantization tables for indicated quality</refpurpose>
<indexterm id="ix.libjpeg.jpeg.set.quality.1">	<primary>jpeg_set_quality</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_set_quality</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>quality</parameter>
</paramdef>
<paramdef>boolean
<parameter>force_baseline</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_set_quality() shall construct JPEG quantization tables for the
given quality setting. The quality value ranges from 0..100.  If
"force_baseline" is TRUE, the computed quantization table entries are
limited to 1..255 for JPEG baseline compatibility.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.simple.progression.1">
<refmeta>
<refentrytitle>jpeg_simple_progression</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_simple_progression</refname>
<refpurpose>generate scan script for writing progressive JPEG file</refpurpose>
<indexterm id="ix.libjpeg.jpeg.simple.progression.1">	<primary>jpeg_simple_progression</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_simple_progression</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_simple_progression() shall generate a default scan script for
writing a progressive JPEG file.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.start.compress.1">
<refmeta>
<refentrytitle>jpeg_start_compress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_start_compress</refname>
<refpurpose>initialize a compression cycle</refpurpose>
<indexterm id="ix.libjpeg.jpeg.start.compress.1">	<primary>jpeg_start_compress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_start_compress</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>boolean
<parameter>write_all_tables</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_start_compress() shall initialize state for a JPEG 
compression cycle. The compression parameters, data destination
and source image information must be set prior to the invocation of
jpeg_start_compress(). 
Setting write_all_tables to TRUE shall indicate that a complete JPEG interchange
datastream will be written and all Huffman tables shall be emited. If
write_all_tables is set to FALSE, the default behavior shall be to emit a pure
abbreviated image with no tables. 
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.start.decompress.1">
<refmeta>
<refentrytitle>jpeg_start_decompress</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_start_decompress</refname>
<refpurpose>initialize a decompression cycle</refpurpose>
<indexterm id="ix.libjpeg.jpeg.start.decompress.1">	<primary>jpeg_start_decompress</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_start_decompress</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_start_decompress() shall initialize state for a JPEG
decompression cycle and allocate working memory. The JPEG
datastream header must be read prior to the invokation of 
jpeg_start_decompress() to obtain the parameters for decompression.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.start.output.1">
<refmeta>
<refentrytitle>jpeg_start_output</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_start_output</refname>
<refpurpose>initialize for a pass in buffered-image mode</refpurpose>
<indexterm id="ix.libjpeg.jpeg.start.output.1">	<primary>jpeg_start_output</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>boolean
<function>jpeg_start_output</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>scan_number</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_start_output() shall initialize state for an output pass in buffered-image
mode. The scan_number indicates the scan of the image to be displayed. Scan
numbers start from 1.
The buffered-image mode must be selected before starting an output pass by
setting cinfo.buffered_image = TRUE.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_start_output() shall return FALSE if decompression is suspended.
Otherwise, jpeg_start_output() shall return TRUE.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.std.error.1">
<refmeta>
<refentrytitle>jpeg_std_error</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_std_error</refname>
<refpurpose>update error manager with error handling routines</refpurpose>
<indexterm id="ix.libjpeg.jpeg.std.error.1">	<primary>jpeg_std_error</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>struct jpeg_error_mgr *
<function>jpeg_std_error</function>
</funcdef>
<paramdef>struct jpeg_error_mgr *
<parameter>error_mgr</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_std_error() shall update the given jpeg_error_mgr object with standard
error handling methods.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_std_error() shall return the updated jpeg_error_mgr object.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.stdio.dest.1">
<refmeta>
<refentrytitle>jpeg_stdio_dest</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_stdio_dest</refname>
<refpurpose>Initialize state for output to stdio stream</refpurpose>
<indexterm id="ix.libjpeg.jpeg.stdio.dest.1">	<primary>jpeg_stdio_dest</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_stdio_dest</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>FILE *
<parameter>outfile</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_stdio_dest() shall initialize state for output to the given stdio stream
outfile. The stream outfile must be in open state. 
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.stdio.src.1">
<refmeta>
<refentrytitle>jpeg_stdio_src</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_stdio_src</refname>
<refpurpose>Initialize state for input from stdio stream</refpurpose>
<indexterm id="ix.libjpeg.jpeg.stdio.src.1">	<primary>jpeg_stdio_src</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_stdio_src</function>
</funcdef>
<paramdef>j_decompress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>FILE *
<parameter>infile</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_stdio_src() shall initialize state for input from the given stdio stream
infile. The stream infile must be in open state. 
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.suppress.tables.1">
<refmeta>
<refentrytitle>jpeg_suppress_tables</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_suppress_tables</refname>
<refpurpose>control quantization and Huffman table suppression</refpurpose>
<indexterm id="ix.libjpeg.jpeg.suppress.tables.1">	<primary>jpeg_suppress_tables</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_suppress_tables</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>boolean
<parameter>suppress</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The function jpeg_suppress_tables() forcibly suppress or un-suppresses all
quantization and Huffman tables. If "suppress" is TRUE, the function shall
mark all currently defined tables as already written. Otherwise, the tables will
be marked as not written. This controls the emission of tables on subsequent
calls to jpeg_start_compress().
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.coefficients.1">
<refmeta>
<refentrytitle>jpeg_write_coefficients</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_coefficients</refname>
<refpurpose>Compression initialization for writing raw-coefficient data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.coefficients.1">	<primary>jpeg_write_coefficients</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_write_coefficients</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>jvirt_barray_ptr *
<parameter>coeff_arrays</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_coefficients() shall write the contents of the JPEG file as DCT
coefficients. The DCT coefficients shall be obtained from the array of virtual 
block array descriptors pointed to be "coeff_arrays". The number of arrays
to be written is obtained from cinfo.num_components.
Note: The virtual arrays may not be realized before jpeg_write_coefficients()
is called. The virtual arrays requested from the compression object's memory
manager may be realized by calling jpeg_write_coefficients() as a side-effect.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.m.byte.1">
<refmeta>
<refentrytitle>jpeg_write_m_byte</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_m_byte</refname>
<refpurpose>emit a byte of special marker data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.m.byte.1">	<primary>jpeg_write_m_byte</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_write_m_byte</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>val</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_m_byte() shall emit a byte of marker data equal to "val".
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.m.header.1">
<refmeta>
<refentrytitle>jpeg_write_m_header</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_m_header</refname>
<refpurpose>emit header for special marker</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.m.header.1">	<primary>jpeg_write_m_header</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_write_m_header</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>marker</parameter>
</paramdef>
<paramdef>unsigned int
<parameter>datalen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_marker_header() shall emit the marker header. The marker header
consists of the marker code derived from "marker" followed by the length of 
marker data "datalen".
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.marker.1">
<refmeta>
<refentrytitle>jpeg_write_marker</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_marker</refname>
<refpurpose>write special marker data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.marker.1">	<primary>jpeg_write_marker</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_write_marker</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>int
<parameter>marker</parameter>
</paramdef>
<paramdef>const JOCTET *
<parameter>dataptr</parameter>
</paramdef>
<paramdef>unsigned int
<parameter>datalen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_marker() shall emit the marker header and "datalen" number of marker
bytes obtained from "*dataptr". The marker header consists of the marker code
followed by the length of marker data.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.raw.data.1">
<refmeta>
<refentrytitle>jpeg_write_raw_data</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_raw_data</refname>
<refpurpose>write raw downsampled image data</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.raw.data.1">	<primary>jpeg_write_raw_data</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JDIMENSION
<function>jpeg_write_raw_data</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>JSAMPIMAGE
<parameter>data</parameter>
</paramdef>
<paramdef>JDIMENSION
<parameter>num_lines</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_raw_data() shall write the compressed image data for raw downsampled
data supplied in the JSAMPIMAGE array argument. The number of scanlines passed
in num_lines to jpeg_write_raw_data() is measured in terms of the component with the
largest v_samp_factor.
</para>
<para>
If the image dimensions are not a multiple of the MCU size, the data must be
padded to a multiple of a DCT block in each component, such that each downsampled row 
must contain a multiple of 8 valid samples, and there must be a multiple of 8 sample rows
for each component. Data must be padded so that the passed num_lines value is atleast 
(cinfo->max_v_samp_factor * DCTSIZE). jpeg_write_raw_data() shall process one MCU
row per call which is (cinfo->comp_info[0].v_samp_factor*DCTSIZE) sample rows of
each component.
</para>
<para>
Before starting the compression sequence, cinfo->raw_data_in must be set to
TRUE. cinfo->jpeg_color_space must be set to colorspace to be used
in the JPEG file. The sampling factors, cinfo->comp_info[i].h_samp_factor and
cinfo->comp_info[i].v_samp_factor must be set to the dimensions of the supplied
data.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
jpeg_write_raw_data() shall return the number of scanlines processed.
jpeg_write_raw_data() shall return 0 if the compressor is suspended.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_write_raw_data() shall report error and exit if num_lines is less than
(cinfo->max_v_samp_factor*DCTSIZE).
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.scanlines.1">
<refmeta>
<refentrytitle>jpeg_write_scanlines</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_scanlines</refname>
<refpurpose>write scanlines of data to JPEG compressor</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.scanlines.1">	<primary>jpeg_write_scanlines</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>JDIMENSION
<function>jpeg_write_scanlines</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>
<paramdef>JSAMPARRAY
<parameter>scanlines</parameter>
</paramdef>
<paramdef>JDIMENSION
<parameter>num_lines</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_scanlines() shall write the number of scanlines of image data to be
compressed from in-memory buffers. The image data shall be written in
top-to-bottom scanline order.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, jpeg_read_scanlines() shall return the number of lines actually
written.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
jpeg_write_scanlines() shall report a non-fatal error if the requested number
of scanlines is greater than the height of the original unscaled image.
</para>
</refsect1>
</refentry>

<refentry id="libjpeg.jpeg.write.tables.1">
<refmeta>
<refentrytitle>jpeg_write_tables</refentrytitle>
<refmiscinfo>libjpeg</refmiscinfo>
</refmeta>

<refnamediv>
<refname>jpeg_write_tables</refname>
<refpurpose>create a tables-only file</refpurpose>
<indexterm id="ix.libjpeg.jpeg.write.tables.1">	<primary>jpeg_write_tables</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;jpeglib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>jpeg_write_tables</function>
</funcdef>
<paramdef>j_compress_ptr
<parameter>cinfo</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
jpeg_write_tables() shall create a tables-only file by writing an abbreviated
datastream containing only SOI, DQT and/or DHT and EOI markers. All the
quantization and Huffman tables  currently defined in the compression object
shall be emitted unless their sent_table flag is set to TRUE. Once emitted,
sent_table flag shall be set for all tables written.
</para>
</refsect1>
</refentry>

</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.82 2006/03/29 19:10:18 mats Exp 0 -->


</CHAPTER>

</PART>
