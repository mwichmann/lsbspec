<PART ID="tocsysinit">
<TITLE>System Initialization</TITLE>

<CHAPTER ID=sysinit>
<TITLE>System Initialization</TITLE>

<SECT1 ID=cronjobs>
<TITLE>Cron Jobs</TITLE>
<PARA>
In addition to the individual user <filename>crontab</filename> files specified
by <xref linkend=std.susv3> stored under <filename>/var/spool/cron</filename>,
the process that executes scheduled commands shall also process the following
additional <filename>crontab</filename> files:
<SIMPLELIST type=inline>
<MEMBER><FILENAME>/etc/crontab</FILENAME></MEMBER>
<MEMBER><FILENAME>/etc/cron.d/*</FILENAME></MEMBER>
</SIMPLELIST>.
The installation of a package shall not modify
the configuration file <FILENAME>/etc/crontab</FILENAME>.
<!--nor shall it modify the files in <FILENAME>/var/spool/cron/crontabs</FILENAME>.-->
</PARA>
<PARA>
If a package wishes to install a job that has to be executed periodically,
it shall place a file in one of the
following directories:
</PARA>
<SIMPLELIST>
<MEMBER><FILENAME>/etc/cron.daily</FILENAME></MEMBER>
<MEMBER><FILENAME>/etc/cron.weekly</FILENAME></MEMBER>
<MEMBER><FILENAME>/etc/cron.monthly</FILENAME></MEMBER>
</SIMPLELIST>
<PARA>
As these directory names suggest, the files within them are executed on a
daily, weekly, or monthly basis, respectively, under the control of an
entry in one of the system <filename>crontab</filename> files.
See below for the rules concerning the names of files in these directories.
</PARA>

<PARA>
It is recommended that files installed in any of these directories be
scripts (e.g. shell scripts, Perl scripts, etc.) so that they may be
modified by the local system administrator. 
</PARA>
<PARA>
The scripts in these directories should check if all necessary
programs are installed before they try to execute them. Otherwise,
problems will arise if a package is removed (but not purged), since
the configuration files are kept on the system in this situation.
</PARA>
<PARA>
If a certain job has to be executed at a different frequency (e.g. more
frequently than daily), the
package shall install a file
<FILENAME>/etc/cron.d/<replaceable>cron-name</replaceable></FILENAME>
tagged as a configuration file. This file uses the same syntax as
<FILENAME>/etc/crontab</FILENAME> and is processed by the system automatically.
</PARA>

<PARA>
To avoid namespace conflicts in the <filename>/etc/cron.*</filename> directories, the filenames
used by LSB-compliant packages in 
<SIMPLELIST type=inline>
<MEMBER><FILENAME>/etc/cron.daily</FILENAME></MEMBER>
<MEMBER><FILENAME>/etc/cron.weekly</FILENAME></MEMBER>
<MEMBER><FILENAME>/etc/cron.monthly</FILENAME></MEMBER>
<MEMBER>or <FILENAME>/etc/cron.d</FILENAME></MEMBER>
</SIMPLELIST>
shall come from a managed namespace.
These filenames may be assigned using one of the following methods:
</PARA>

<ITEMIZEDLIST MARK="bullet">
<LISTITEM><PARA>
	Assigned namespace.  This namespace consists of names which
		only use the character set <literal>[a-z0-9]</literal>.
		In order to avoid conflicts these cron script
		names shall be reserved
		through the Linux Assigned Names and Numbers
		Authority (LANANA).
		Information about the LANANA
		may be found at
		<ULINK URL="http://www.lanana.org">www.lanana.org</ULINK>.
	</PARA>

	<PARA>
		Commonly used names shall be reserved in advance; 
		developers for projects should be encouraged reserve names
		from LANANA, so that each distribution can use the same
		name, and to avoid conflicts with other projects.
</PARA></LISTITEM>

<LISTITEM><PARA>
	Hierarchical namespace.  This namespace consists of script
		names of the form: <filename>[hier1]-[hier2]-...-[name]</>,
		where name is again taken from the character set <literal>[a-z0-9],</> 
		and where there may be one or more <filename>[hier-n]</> components.  
		<filename>[hier1]</> may either be an LSB provider name assigned
		by the LANANA, or
		it may be owners' DNS name in lower case, with at
		least one <literal>'.'</>.  
	e.g.  "<literal>debian.org</>", "<literal>staroffice.sun.com</>", etc.
		The LSB provider name assigned by LANANA 
		shall only consist of the ASCII characters <literal>[a-z0-9]</>.
</PARA></LISTITEM>

<LISTITEM><PARA>
	Reserved namespace.  This namespace consists of script names
		which begin with the character '<literal>_</>', and is reserved for
		distribution use only.  This namespace should be used
		for core packages only.
</PARA></LISTITEM>
</ITEMIZEDLIST>

</SECT1>


<SECT1 ID=iniscrptact>
<TITLE>Init Script Actions</TITLE>
<PARA>
Init files provided by LSB applications shall accept one argument,
saying what to do:
</PARA>
<SIMPLELIST type=horiz columns=2>
<MEMBER>start</MEMBER><MEMBER>start the service</MEMBER>
<MEMBER>stop</MEMBER><MEMBER>stop the service</MEMBER>
<MEMBER>restart</MEMBER><MEMBER>stop and restart the service if the service
is already running, otherwise start the service</MEMBER>
<MEMBER>try-restart</MEMBER><MEMBER>restart the service if the service
is already running</MEMBER>
<MEMBER>reload</MEMBER><MEMBER>cause the configuration of the service to be
reloaded without actually stopping and restarting the service</MEMBER>
<MEMBER>force-reload</MEMBER><MEMBER>cause the configuration to be reloaded
if the service supports this, otherwise restart the service if it is
running</MEMBER>
<MEMBER>status</MEMBER><MEMBER>print the current status of the service</MEMBER>
</SIMPLELIST>
<PARA>
The start, stop, restart, force-reload, and status commands shall be supported
by all init files; the reload and the try-restart options are optional. Other
init script actions may be defined by the init script.
</PARA>
<PARA>
Init files shall ensure that they will behave sensibly if invoked
with start when the service is already running, or with stop when it
isn't, and that they don't kill unfortunately-named user processes. 
The best way to achieve this is to use the init-script functions provided by
<FILENAME>/lib/lsb/init-functions</FILENAME>.
</PARA>
<PARA>
If a service reloads its configuration automatically (as in the case
of cron, for example), the reload option of the init file shall
behave as if the configuration has been reloaded successfully. The restart,
try-restart, reload and force-reload action may be atomic; i.e. if a service
is known not be operational after a restart or reload, the script may return
an error without any further action.
</PARA>
<PARA>
These executable files shall not fail obscurely when the configuration
files remain but the package has been removed, as the default in [the
packaging system] is to leave configuration files on the system after
the package has been removed.  Only when it is executed with the
[purge] option will [the packaging system] remove configuration files.
Therefore, you should include a test statement at the top of the file,
like this:
<SCREEN>
<USERINPUT>test -f program-executed-later-in-file || exit 5</USERINPUT>
</SCREEN>
or take the equivalent action if the init file is not a shell script.
</PARA>
<PARA>
If the status command is given, the init script will return the following 
exit status codes.  

<SIMPLELIST type=horiz columns=2>
<MEMBER>0</MEMBER><MEMBER>program is running or service is OK</MEMBER>
<MEMBER>1</MEMBER><MEMBER>program is dead and /var/run pid file exists</MEMBER>
<MEMBER>2</MEMBER><MEMBER>program is dead and /var/lock lock file exists</MEMBER>
<MEMBER>3</MEMBER><MEMBER>program is not running</MEMBER>
<MEMBER>4</MEMBER><MEMBER>program or service status is unknown</MEMBER>
<MEMBER>5-99</MEMBER><MEMBER>reserved for future LSB use</MEMBER>
<MEMBER>100-149</MEMBER><MEMBER>reserved for distribution use</MEMBER>
<MEMBER>150-199</MEMBER><MEMBER>reserved for application use</MEMBER>
<MEMBER>200-254</MEMBER><MEMBER>reserved</MEMBER>
</SIMPLELIST>
</PARA>

<PARA>
In the case of init script commands other than "status" (i.e.,
"start", "stop", "restart", "try-restart", "reload", and "force-reload"), the init
script shall return an exit status of zero if the action described by
the argument has been successful.  Otherwise, the exit status shall
be non-zero, as defined below.  In addition to straightforward
success, the following situations are also to be considered
successful:

<ITEMIZEDLIST MARK="bullet">
<LISTITEM><PARA>
restarting a service (instead of reloading it) with the "force-reload" argument
</PARA></LISTITEM>
<LISTITEM><PARA>
running "start" on a service already running
</PARA></LISTITEM>
<LISTITEM><PARA>
running "stop" on a service already stopped or not running
</PARA></LISTITEM>
<LISTITEM><PARA>
running "restart" on a service already stopped or not running
</PARA></LISTITEM>
<LISTITEM><PARA>
running "try-restart" on a service already stopped or not running
</PARA></LISTITEM>
</ITEMIZEDLIST>

</PARA>
<PARA>
In case of an error, while processing any init script action except
for "status", the init script shall print an error message and return
one of the following non-zero exit status codes.

<SIMPLELIST type=horiz columns=2>
<MEMBER>1</MEMBER><MEMBER>generic or unspecified error (current practice)</MEMBER>
<MEMBER>2</MEMBER><MEMBER>invalid or excess argument(s)</MEMBER>
<MEMBER>3</MEMBER><MEMBER>unimplemented feature (for example, "reload")</MEMBER>
<MEMBER>4</MEMBER><MEMBER>user had insufficient privilege</MEMBER>
<MEMBER>5</MEMBER><MEMBER>program is not installed</MEMBER>
<MEMBER>6</MEMBER><MEMBER>program is not configured</MEMBER>
<MEMBER>7</MEMBER><MEMBER>program is not running</MEMBER>
<MEMBER>8-99</MEMBER><MEMBER>reserved for future LSB use</MEMBER>
<MEMBER>100-149</MEMBER><MEMBER>reserved for distribution use</MEMBER>
<MEMBER>150-199</MEMBER><MEMBER>reserved for application use</MEMBER>
<MEMBER>200-254</MEMBER><MEMBER>reserved</MEMBER>
</SIMPLELIST>
</PARA>
<PARA>
Error and status messages should be printed with the logging
functions such as log_failure_msg and so on.  Scripts may write to
standard error or standard output, but implementations need not
present text written to standard error/output to the user or do
anything else with it.
</PARA>
<PARA>
Since init files may be run manually by a system administrator with
non-standard environment variable values for PATH, USER, LOGNAME,
etc. init files shall not depend on the values of these environment
variables.  They should set them to some known/default values if they
are needed.

</PARA>
</SECT1>


<SECT1 ID=initscrcomconv>
<TITLE>Comment Conventions for Init Scripts</TITLE>
<TITLEABBREV ID="initscriptsShort">Comment Conventions for Init Scripts</TITLEABBREV>

<PARA>
LSB applications which need to execute script(s) at bootup and/or
shutdown may provide one or more <filename>init.d</filename> files.  These files are
installed by the install_initd program described below, which copies
it into a standard directory and makes whatever other adjustments
(creation of symlinks, creation of entries in a database, etc.) are
necessary so that the script can be run at boot-time.
<NOTE><PARA>
This specification does not require, but is designed to allow, the
development of a system which runs boot scripts in parallel.  Hence,
enforced-serialization of scripts is avoided unless it is explicitly
necessary. 
</PARA></NOTE>
</PARA>

<PARA> 
In the <filename>init.d</filename> file, information about the shell script shall be
delimited by the lines "### BEGIN INIT INFO" and "### END INIT INFO".
These delimiter lines may containg trailing whitespace, which shall be
ignored.  Inside this block there shall be lines of the form "#
{keyword}: [arg1] [arg2] ...".  (All lines inside this block start
with a hash ('#') character in the first column, so that shell treats
them as comments.)
There shall be exactly one space character between "#" and the
keyword.<note><para>More than one space, or a tab character,
indicates the continuation line.</para></note>
The following keywords, with their arguments are
defined in this specification:
</PARA>

<SCREEN>
	# Provides: boot_facility_1 [ boot_facility_2 ...]
	# Required-Start: boot_facility_1 [ boot_facility_2 ...]
	# Required-Stop: boot_facility_1 [ boot_facility_2 ...]
	# Should-Start: boot_facility_1 [ boot_facility_2 ...]
	# Should-Stop: boot_facility_1 [ boot_facility_2 ...]
	# Default-Start: run_level_1 [ run_level_2 ...]
	# Default-Stop: run_level_1 [ run_level_2 ...]
	# Short-Description: short_description
	# Description: multiline_description
</SCREEN>

<PARA>
Additional keywords may be defined in future LSB specifications.
Distributions may define local extensions by using the prefix
"X-[distribution name]" --- for example, "X-RedHat-foobardecl", or
"X-Debian-xyzzydecl".  
</PARA>

<PARA>
An <filename>init.d</filename> shell script may declare using the "Required-Start: " header
that it shall not be run until certain boot facilities are provided.
This information is used by the installation tool or the boot-time
boot-script execution facility to assure that init scripts are run in
the correct order.   When an init script is run with a "start" argument, the 
boot facility or facilities specified in the "Provides" header shall be
considered present, and hence init scripts which require those boot facilities
would then be eligble to be run.   When an init script is run with a "stop" 
argument, the boot facilities specified in the "Provides" header are 
considered  no longer  present.  
There are naming conventions for boot facilities and system
facilities, as described in a following section.
</PARA>

<PARA>
Similarly, the "Required-Stop:" header defines which facilities shall
still be available during the shutdown of that service.  Hence, the
init script system should avoid stopping shell scripts which provide
those facilities until this shell script is stopped.
</PARA>

<PARA>
The "Should-Start:" header defines which facilities if present should
be started before this service. This allows for weak dependencies which
do not cause the service to fail if a facility is not available.
But may cause reduced functionality of the service.
Compliant applications should not rely on the existence of this feature.
</PARA>

<PARA>
The "Should-Stop:" header defines which facilities should be still
available during the shutdown of that service.
</PARA>

<PARA>
The "Default-Start" and "Default-Stop" headers define which run levels
should by default run the script with a start or stop argument,
respectively, to start or stop the services controlled by the init script.
<note>
<para>
For example, if you want a service to run in runlevels 3, 4, and 5 (only),
specify "Default-Start: 3 4 5" and "Default-Stop: 0 1 2 6".
</para>
</note>
</PARA>

<PARA>
The "Short-Description" and "Description" header fields are used to
provide text which describes the actions of the init script.  The
"short_description" shall be a relatively short, pithy description of the
init script, where as the "multiline_description" can be a much longer
piece of text that may span mulitple lines.  In a multiline description,
each continuation line shall begin with a '#' followed by tab character
or a '#' followed by at least two space characters.  The multiline
description is terminated by the first line that does not match this
criteria.
</PARA>

<PARA>
The comment conventions described in this session are only required for
use by LSB-compliant applications; system init scripts as provided by
LSB-compliant run-time environments are <emphasis>not</emphasis> 
required to use the scheme outlined here.
</PARA>

</SECT1>



<SECT1 ID=initsrcinstrm>

<TITLE>Installation and Removal of init.d Files</TITLE>

<PARA>
An init.d file is installed in 
<filename>/etc/init.d</filename> (which may
be a symlink to another location).  This can be done by the package
installer.  See <xref linkend="scrptnames" />.
During the package's postinstall script, the program
"/usr/lib/lsb/install_initd" configures the distribution's boot
script system to call the package's init.d file at the appropriate
time.
<note>
<para>For example, <command>install_initd</command> might create
symbolic links in /etc/rc2.d and other such directories which point to
the files in <filename>/etc/init.d</filename>
(or it might update a database, or some other
mechanism).  The init.d files themselves should already be in
/etc/init.d before running <command>install_initd</command>.</para>
</note>
</PARA>

<PARA>
The install_initd program takes a single argument, the pathname to the
/etc/init.d file.  For example:
</PARA>

<SCREEN>
	/usr/lib/lsb/install_initd /etc/init.d/example.com-coffeed
</SCREEN>

<PARA>
The install_initd program shall return an exit status of zero if the
init.d file has been successfully installed or if the the init.d file
was already installed. If the required boot facilities cannot be fulfilled
an exit status of one shall be returned and the init.d file shall not be
installed.
</PARA>

<PARA> 
When a software package is removed, the package's preuninstall script
shall call /usr/lib/lsb/remove_initd and pass the pathname to the
/etc/init.d file.  The package manager is still responsible for removing 
the /etc/init.d file; the remove_initd program is provided in case the
distribution needs to clean up any other modifications in the distribution's
boot script system that might have been made by the install_initd program.
For example:
</PARA>

<SCREEN>
	/usr/lib/lsb/remove_initd /etc/init.d/example.com-coffeed
</SCREEN>

<PARA>
The remove_initd program shall return an exit status of zero if the
init.d file has been successfully removed or if the the init.d file
is not installed. If another init.d file which depends on a boot facility
provided by this init.d file is installed, an exit status of one shall be
returned and the init.d file shall remained installed.
</PARA>

<PARA>
There should be a tool available to the user (e.g., RedHat's chkconfig)
which can be used by the system administrator to easily manipulate at
which init levels a particular init.d script is started or stopped.
This specification currently does not specify such an interface,
however.
</PARA>

</SECT1>


<SECT1 ID=runlevels>
<TITLE>Run Levels</TITLE>
<PARA>

The following run levels are specified for use by the "Default-Start:"
and "Default-Stop:" specifiers as defined by the section <xref
linkend="initscrcomconv" endterm="initscriptsShort"/>.  Many LSB
run-time environments commonly use these run level definitions, and in
the absence of other considerations, providers of run-time
environments are strongly encouraged to follow this convention to
provide consistency for system administrators who need to work with
multiple distributions.  However, it is not required that
LSB-compliant run-time environments use these run levels; the
distribution-provided install_initd script may map the run levels
specified below to whatever distribution-specified run levels are most
appropriate.

</PARA>
<SIMPLELIST type=horiz columns=2>
<MEMBER>0</MEMBER><MEMBER>halt</MEMBER>
<MEMBER>1</MEMBER><MEMBER>single user mode</MEMBER>
<MEMBER>2</MEMBER><MEMBER>multiuser with no network services exported</MEMBER>
<MEMBER>3</MEMBER><MEMBER>normal/full multiuser</MEMBER>
<MEMBER>4</MEMBER><MEMBER>reserved for local use, default is normal/full multiuser</MEMBER>
<MEMBER>5</MEMBER><MEMBER>multiuser with xdm or equivalent</MEMBER>
<MEMBER>6</MEMBER><MEMBER>reboot</MEMBER>
</SIMPLELIST>
</SECT1>


<SECT1 ID=facilname>

<TITLE>Facility Names</TITLE>

<PARA>
Boot facilities are used to indicate dependencies in init scripts, as
defined in a previous section.  Facility names that begin with a
dollar sign ('$') are system facility names, defined by the LSB, and
SHALL be provided by distributions.
<note><para>The dollar sign does not indicate variable expansion
as in many Linux utilities.  Starting a facility name with a dollar
sign is merely a way of dividing the namespace between the system and
applications.
</para></note>
LSB applications shall not provide facilities that begin with a dollar
sign.  This document defines the following facility names:
</PARA>

<SIMPLELIST type=horiz columns=2>
<MEMBER>$local_fs</MEMBER>	
<MEMBER>all local filesystems are mounted</MEMBER>

<MEMBER>$network</MEMBER>  	
<MEMBER>low level networking (ethernet card; may
imply PCMCIA running)</MEMBER>

<MEMBER>$named</MEMBER>  	
<MEMBER>daemons which may provide hostname resolution (if present) are
running. For example, daemons to query DNS, NIS+, or
LDAP.</MEMBER>

<MEMBER>$portmap</MEMBER>
<MEMBER>daemons providing SunRPC/ONCRPC portmapping 
service as defined in RFC 1833
(if present) are running
</MEMBER>

<MEMBER>$remote_fs</MEMBER>	
<MEMBER>all remote filesystems are mounted. In some
LSB run-time environments, filesystems such as <filename>/usr</filename>
may be remote.  Many
applications that require $local_fs will probably require
also require $remote_fs.</MEMBER>

<MEMBER>$syslog</MEMBER>
<MEMBER>system logger is operational</MEMBER>

<MEMBER>$time</MEMBER>  	
<MEMBER>the system time has been set,
for example by using a network-based time program such as 
<command>ntp</command> or 
<command>rdate</command>, or 
via the hardware Real Time Clock.
</MEMBER>

</SIMPLELIST>

<PARA>
Other (non-system) facilities may be defined by other LSB applications.
These facilities shall be named using the same conventions defined for
naming init.d script names.  Commonly, the facility provided by
an LSB application init.d script will have the same name as the name 
assigned  to the init.d script.
</PARA>

</SECT1>


<SECT1 ID="scrptnames" XRefLabel="Script Names">

<TITLE>Script Names</TITLE>

<PARA>
Since init scripts live in a single directory, they must
share a single namespace. To avoid conflicts, four means of
assigning names from this namespace are provided:
</PARA>

<ITEMIZEDLIST MARK="bullet">
<LISTITEM><PARA>
Assigned names.  Such names must be chosen from 
characters in the set <literal>[a-z0-9]</literal>. This category is
desirable for scripts which system administrators may
need to run manually: e.g., <command>/etc/init.d/named restart</command>.
In order to avoid conflicts these names shall be reserved
through the Linux Assigned Names and Numbers Authority (LANANA).  
Information about the LANANA may be found at
<ULINK URL="http://www.lanana.org">www.lanana.org</ULINK>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
Commonly used names. Such names shall be reserved in advance; 
developers for projects are encouraged to reserve names
from LANANA, so that each distribution can use the same
name for the project's init script and avoid conflicts with
other projects.
</PARA></LISTITEM>

<LISTITEM><PARA>
Hierarchical names.  Script names in this category take
the form <literal>&lt;hier1&gt;-&lt;hier2&gt;-...-&lt;name&gt;
</literal>, where name is 
chosen from characters in the set <literal>[a-z0-9]</literal>, 
and where there may be one or more <literal>&lt;hier-n&gt;</literal>
components.  
<literal>&lt;hier1&gt;</literal> may either be an LSB provider name assigned
by the LANANA, or it may be the owners' DNS name in lower case, with at
least one <literal>'.'</literal> (e.g., <literal>"debian.org"</literal>, 
or <literal>"staroffice.sun.com"</literal>).
The LSB provider name assigned by LANANA 
shall consist only of characters chosen from the set 
<literal>[a-z0-9]</literal>.
</PARA></LISTITEM>

<LISTITEM><PARA>
Reserved names.  Names in this category 
begin with the character <literal>'_'</literal>, and are reserved for
distribution use only.  This namespace should be used
for essential system packages only, and in general use of this
namespace is highly discouraged.  

</PARA></LISTITEM>
</ITEMIZEDLIST>


<NOTE>
<PARA>
In general, if a package or some system function is likely to be used
on multiple systems, the package developers or the distribution should
get a registered name through LANANA, and distributions should strive to
use the same name whenever possible.  For applications which may not
be essential or may not be commonly installed, the hierarchical namespace
may be more appropriate.  An advantage to the hierarchical namespace
is that there is no need to consult with the LANANA before obtaining an
assigned name.
</PARA>

<PARA>
Short names are highly desirable, since system
administrators may need to manually start and stop services.
Given this, they should be standardized on a per-package basis.  This
is the rationale behind having the LANANA organization assign these
names.  The LANANA may be called upon to handle other namespace issues,
such as package/prerequisites naming.
</PARA>
</NOTE>

</SECT1>


<SECT1 ID=iniscrptfunc>

<TITLE>Init Script Functions</TITLE>

<PARA>
Each LSB-compliant init.d script shall source the file
<filename>/lib/lsb/init-functions</filename>. This file shall cause the
following shell script commands to be defined in an unspecified manner.  
<note>
<para>
This can be done either by
adding a directory to the 
<envar>PATH</envar> variable which defines these commands, or by
defining shell aliases.  
</para>
<para>
Although the commands made available via this mechanism need not
be LSB conforming applications in their own right, applications that
use them should only depend on features described in the LSB.
</para>
</note>
Conforming scripts
shall not specify the "exit on error" option (i.e. 
<command>set -e</command>) when sourcing this file, or calling any of the
commands thus made available. 
</PARA>

<PARA>
The <command>start_daemon</command>, <command>killproc</command> and
<command>pidofproc</command> functions shall use 
the following algorithm for determining
the status and the process identifiers of the specified program. 
<orderedlist numeration=arabic>
<listitem><para>If the <parameter>-p pidfile</parameter> option is specified,
and the named <filename>pidfile</filename> exists,
a single line at the start of the <filename>pidfile</filename> shall be read. 
If this line contains one or more numeric values, separated by spaces,
these values shall be used.
</para></listitem>
<listitem><para>
Otherwise, 
<filename>/var/run/<replaceable>basename</replaceable>.pid</filename> 
shall be read in a similar fashion.
If this contains one or more numeric values on the first line, these values
shall be used.
</para>
</listitem>
<listitem>
<para>
Optionally, if neither of the above methods has determined the
process identifiers required, implementations may use unspecified additional
methods to locate the process identifiers required.
</para>
</listitem>
</orderedlist>
The method used
to determine the status is implementation defined, but should allow for
non-binary programs.
<note>
<para>
Commonly used methods check either for the
existence of the <filename>/proc/pid</filename> directory or use
<filename>/proc/pid/exe</filename> and <filename>/proc/pid/cmdline</filename>.
Relying only on <filename>/proc/pid/exe</filename> is discouraged since the
LSB does not specify the existence of, or semantics
for, <filename>/proc</filename>. Additionally, using
<filename>/proc/pid/exe</filename>
may result in a not-running status for daemons that are written in a script
language.
</para>
</note>
Conforming implementations may use other mechanisms besides those based on
pidfiles, unless the <parameter>-p pidfile</parameter>
option has been used. Conforming applications
should not rely on such mechanisms and should
always use a <filename>pidfile</filename>.
When a program is stopped, it should delete its
<filename>pidfile</filename>. Multiple process identifiers
shall be separated by a single space in the <filename>pidfile</filename>
and in the output of <command>pidofproc</command>.
</PARA>

<VARIABLELIST>
<varlistentry>
<term>
<cmdsynopsis>
<command>
start_daemon
</command>
<arg>-f</arg>
<arg>-n nicelevel</arg>
<arg>-p pidfile</arg>
<arg choice=plain>pathname</arg>
<arg rep=repeat>args</arg>
</cmdsynopsis></term>
<listitem>
<para>
This runs the specified program as a daemon.
The <command>start_daemon</command> function
shall check if the program is already running
using the algorithm given above. If so, it shall not
start another copy of the daemon unless the <parameter>-f</parameter>
option is given. The <parameter>-n</parameter> option specifies a nice
level. See <command>nice</command>.
<command>start_daemon</command> shall
return the LSB defined exit status codes. It
shall return 0 if the program has been successfully started or
is running and not 0 otherwise.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<cmdsynopsis>
<command>killproc</command>
<arg>-p pidfile</arg>
<arg choice=plain>pathname</arg>
<arg>signal</arg>
</cmdsynopsis>
</term>
<listitem>
<para>
The <command>killproc</command> function
shall stop the specified program. The program is 
found using the algorithm given above. If a
signal is specified, using the
<parameter>-<replaceable>signal_name</replaceable></parameter> or
<parameter>-<replaceable>signal_number</replaceable></parameter> syntaxes
as specified by the <command>kill</command> command,
the program is sent that signal.
Otherwise, a <constant>SIGTERM</constant> followed by a 
<constant>SIGKILL</constant>
after an unspecified number of seconds shall be sent.
If a program has been terminated, the <filename>pidfile</filename>
should be removed if the
terminated process has not already done so.
The <command>killproc</command> function
shall return the LSB defined exit status codes. If called
without a signal, it shall return 0 if the program has been stopped or
is not running and not 0 otherwise. If a signal is given, it shall return 0
only if the program is running. 
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<cmdsynopsis>
<command>pidofproc</command>
<arg>-p pidfile</arg>
<arg choice=plain>pathname</arg>
</cmdsynopsis>
</term>
<listitem>
<para>
The <command>pidofproc</command> function shall return
one or more process identifiers for a particular
daemon using the algorithm given above. Only process identifiers
of running processes should be returned.
Multiple process identifiers shall be separated by a single space.
<note><para>
A process may exit between <command>pidofproc</command> discovering its identity
and the caller of <command>pidofproc</command> being able to act on that identity.
As a result, no test assertion can be made that the process identifiers
returned by <command>pidofproc</command> <emphasis>shall</emphasis> be
running processes.
</para>
</note>
The <command>pidofproc</command> function
shall return the LSB defined exit status
codes for "status". It shall return 0 if the program is
running and not 0 otherwise.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<cmdsynopsis>
<command>
log_success_msg
</command>
<arg choice=plain>message
</arg>
</cmdsynopsis>
</term>
<listitem>
<para>
The <command>log_success_msg</command> function
shall cause the system to print a success
message.  
<note><para>The message should be relatively short; no
more than 60 characters is highly desirable.</para></note>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<cmdsynopsis>
<command>
log_failure_msg
</command>
<arg choice=plain>message
</arg>
</cmdsynopsis>
</term>
<listitem>
<para>
The <command>log_failure_msg</command> function
shall cause the system to print a failure
message.  
<note><para>The message should be relatively short; no
more than 60 characters is highly desirable.</para></note>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<cmdsynopsis>
<command>
log_warning_msg
</command>
<arg choice=plain>message
</arg>
</cmdsynopsis>
</term>
<listitem>
<para>
The <command>log_warning_msg</command> function
shall cause the system to print a warning
message.  
<note><para>The message should be relatively short; no
more than 60 characters is highly desirable.</para></note>
</para>
</listitem>
</varlistentry>
</variablelist>
</SECT1>



</CHAPTER>

</PART>
