<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.38 2002/05/23 03:49:56 anderson Exp 0 -->
<!--    at Thu May 30 15:19:53 2002 -->
<SECT1 ID=libpthread>
<TITLE>Interfaces for libpthread</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libpthread</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libpthread.so.0</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
LSB systems support POSIX threads with the following exceptions.
This list is intended to match the behavior of historical Linux
implementations.  Applications should be written to deal with either
POSIX threads or the thread behaviors described here.

<ITEMIZEDLIST MARK=BULLET>

<LISTITEM>
<PARA>
POSIX specifies a concept of per-process rather than per-thread
signals.  The LSB does not require this behavior; traditional Linux
implementations have had per-thread signals only.  A related issue is
that applications cannot rely on getpid() returning the same value
in different threads.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Note: one implication of per-thread signals is that a core dump (for
example) may not stop all threads in a given process.  This may be an
issue when designing ways to stop/start applications.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications which create child processes (using fork() and the like)
must then wait for them (using waitpid() family of functions) in the
same thread as they created them.  Note that coding applications this
way will work both with full POSIX threads and legacy Linux thread
implementations.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
POSIX specifies that changing the user or group id instantly affects
the behavior of all threads.  This behavior is not specified;
applications must use their own lock if they need this behavior.
Rationale: it seems unnecessary and it is a performance hit (an SMP
kernel must lock the user id).
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Although this standard doesn't have a way to list processes (/proc or
"ps" command line isn't in, right?), it is our intention to not
specify one way or the other whether multiple threads appear as
separate processes or as a single process.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on resource limits (getrusage and setrusage)
being maintained per-process rather than per-thread.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must disconnect from the controlling tty before
calling pthread_create.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
times() doesn't account for all threads, just the caller.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must not call pthread_cancel if they call any system
libraries (most notably X Window System libraries), as system libraries are
not guaranteed to be thread safe.  Likewise, for such libraries, only one
thread per process may call them.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on fcntl/lockf locks being visible
per-process rather than per-thread.  Likewise for mandatory file
locks.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Threaded applications cannot use SIGUSR1 or SIGUSR2.
</PARA>
</LISTITEM>

</ITEMIZEDLIST>
</PARA>

<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-132-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-132-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread - Posix Threads Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>pthread_attr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstackaddr<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getspecific<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_once<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcanceltype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getdetachstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstacksize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_join<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setconcurrency<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getguardsize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cancel<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getinheritsched<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_broadcast<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_delete<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_rdlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setspecific<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_kill<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_timedrdlock<FOOTNOTEREF LINKEND="std-132-10"></ENTRY><ENTRY>pthread_sigmask<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedpolicy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_timedwrlock<FOOTNOTEREF LINKEND="std-132-10"></ENTRY><ENTRY>pthread_testcancel<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getscope<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_signal<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_tryrdlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_close<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstackaddr<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_timedwait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_lock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_trywrlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstacksize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_wait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_trylock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_unlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_getvalue<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_unlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_wrlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setdetachstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_open<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setguardsize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_getpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_getpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_post<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setinheritsched<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_detach<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_gettype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_timedwait<FOOTNOTEREF LINKEND="std-132-10"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_equal<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_setpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_trywait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedpolicy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_exit<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_setpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_self<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_unlink<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setscope<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_settype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcancelstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_wait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE>Data Definitions for libpthread</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>pthread.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define PTHREAD_MUTEX_TIMED_NP	1
#define __LOCK_INITIALIZER	{ 0, 0 }
#define PTHREAD_MUTEX_INITIALIZER	{0,0,0,PTHREAD_MUTEX_TIMED_NP,__LOCK_INITIALIZER}


typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef int __atomic_lock_t;


typedef unsigned long pthread_t;
struct _pthread_fastlock
{
  long __status;
  __atomic_lock_t __spinlock;
}
 ;


typedef struct _pthread_descr_struct *_pthread_descr;


typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
}
pthread_mutex_t;
typedef struct
{
  int __mutexkind;
}
pthread_mutexattr_t;


typedef struct
{
  int __detachstate;
  int __schedpolicy;
  struct sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  unsigned long __stacksize;
}
pthread_attr_t;


typedef struct
{
  struct _pthread_fastlock lock;
  _pthread_descr wait_chain;
}
pthread_cond_t;
typedef void *pthread_condattr_t;


typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
}
pthread_rwlock_t;
typedef struct
{
  int __lockkind;
  int __pshared;
}
pthread_rwlockattr_t;



#define PTHREAD_ONCE_INIT	0
#define PTHREAD_CREATE_JOINABLE	0
#define PTHREAD_INHERIT_SCHED	0
#define PTHREAD_SCOPE_SYSTEM	0
#define PTHREAD_PROCESS_PRIVATE	0
#define PTHREAD_CREATE_DETACHED	1
#define PTHREAD_EXPLICIT_SCHED	1
#define PTHREAD_SCOPE_PROCESS	1
#define PTHREAD_PROCESS_SHARED	1



#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_ENABLE	0
#define PTHREAD_CANCEL_DEFERRED	0
#define PTHREAD_CANCEL_DISABLE	1
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
</SCREEN>
</SECT2>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef struct
{
  struct _pthread_fastlock __sem_lock;
  int __sem_value;
  _pthread_descr __sem_waiting;
}
sem_t;
#define SEM_FAILED	((sem_t*)0)



#define SEM_VALUE_MAX	((int)((~0u)>>1))
</SCREEN>
</SECT2>
<SECT2>
<TITLE>signal.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define SIGEV_SIGNAL	0
#define SIG_BLOCK	0
#define SIG_UNBLOCK	1
#define SIG_SETMASK	2
#define SIGEV_THREAD	2


typedef int sig_atomic_t;
struct sigstack
{
  void *ss_sp;
  int ss_onstack;
}
 ;
#define SIG_ERR	((__sighandler_t)-1)
#define SIG_DFL	((__sighandler_t)0)
#define SIG_IGN	((__sighandler_t)1)
#define SIGHUP	1
#define SIGUSR1	10
#define SIGSEGV	11
#define SIGUSR2	12
#define SIGPIPE	13
#define SIGALRM	14
#define SIGTERM	15
#define SIGSTKFLT	16
#define SIGCHLD	17
#define SIGCONT	18
#define SIGSTOP	19
#define SIGINT	2
#define SIGTSTP	20
#define SIGTTIN	21
#define SIGTTOU	22
#define SIGURG	23
#define SIGXCPU	24
#define SIGXFSZ	25
#define SIGVTALRM	26
#define SIGPROF	27
#define SIGWINCH	28
#define SIGIO	29
#define SIGQUIT	3
#define SIGPWR	30
#define SIGUNUSED	31
#define SIGSYS	31
#define SIGILL	4
#define SIGTRAP	5
#define SIGABRT	6
#define SIGIOT	6
#define SIGBUS	7
#define SIGFPE	8
#define SIGKILL	9
#define SIGCLD	SIGCHLD
#define SIGPOLL	SIGIO





typedef void (*__sighandler_t) (void);
#define SV_ONSTACK	(1<<0)
#define SV_INTERRUPT	(1<<1)
#define SV_RESETHAND	(1<<2)


typedef union sigval
{
  int sival_int;
  void *sival_ptr;
}
sigval_t;
#define SIGEV_NONE	1


typedef struct sigevent
{
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union
  {
    int _pad[SI_PAD_SIZE];
    struct
    {
      void (*sigev_thread_func) (void);
      void *_attribute;
    }
    _sigev_thread;
  }
  _sigev_un;
}
sigevent_t;
#define SI_QUEUE	-1
#define SI_TIMER	-2
#define SI_MESGQ	-3
#define SI_ASYNCIO	-4
#define SI_USER	0


typedef struct siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  union
  {
    int _pad[SI_PAD_SIZE];
    struct
    {
      pid_t si_pid;
      uid_t si_uid;
    }
    _kill;
    struct
    {
      unsigned int _timer1;
      unsigned int _timer2;
    }
    _timer;
    struct
    {
      pid_t _pid;
      uid_t _uid;
      sigval_t _sigval;
    }
    _rt;
    struct
    {
      pid_t _pid;
      uid_t _uid;
      int _status;
      clock_t _utime;
      clock_t _stime;
    }
    _sigchld;
    struct
    {
      void *_addr;
    }
    _sigfault;
    struct
    {
      int _band;
      int _fd;
    }
    _sigpoll;
  }
  _sifields;
}
siginfo_t;


typedef struct
{
  unsigned long sig[_SIGSET_NWORDS];
}
sigset_t;
#define SA_NOCLDSTOP	0x00000001
#define SA_NOCLDWAIT	0x00000002
#define SA_SIGINFO	0x00000004
#define SA_ONSTACK	0x08000000
#define SA_RESTART	0x10000000
#define SA_INTERRUPT	0x20000000
#define SA_NODEFER	0x40000000
#define SA_RESETHAND	0x80000000
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND


struct sigaction
{
  union
  {
    __sighandler_t _sa_handler;
    void (*_sa_sigaction) (void);
  }
  __sigaction_handler;
  unsigned long sa_flags;
  void (*sa_restorer) (void);
  sigset_t sa_mask;
}
 ;


typedef struct sigaltstack
{
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
}
stack_t;








struct sigcontext
{
  unsigned short gs;
  unsigned short __gsh;
  unsigned short fs;
  unsigned short __fsh;
  unsigned short es;
  unsigned short __esh;
  unsigned short ds;
  unsigned short __dsh;
  unsigned long edi;
  unsigned long esi;
  unsigned long ebp;
  unsigned long esp;
  unsigned long ebx;
  unsigned long edx;
  unsigned long ecx;
  unsigned long eax;
  unsigned long trapno;
  unsigned long err;
  unsigned long eip;
  unsigned short cs;
  unsigned short __csh;
  unsigned long eflags;
  unsigned long esp_at_signal;
  unsigned short ss;
  unsigned short __ssh;
  struct _fpstate fpstate;
  unsigned long oldmask;
  unsigned long cr2;
}
 ;
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libpthreadman>
<TITLE>Interfaces Definitions for libpthread</TITLE>
<PARA>
</PARA>
include(pthread_rwlock_timedrdlock.sgml)
include(pthread_rwlock_timedwrlock.sgml)
include(sem_timedwait.sgml)
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.38 2002/05/23 03:49:56 anderson Exp 0 -->
