<PART ID=tocbaselib>
<TITLE>Base Libraries</TITLE>

<CHAPTER id=baselib>
<TITLE>Libraries</TITLE>

<PARA>
An LSB-conforming implementation shall support some base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
</PARA>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->
<!--    at Tue Sep 24 20:11:27 2002 -->
<SECT1 ID=libc>
<TITLE>Interfaces for libc</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libc</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>See archLSB.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-131-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Large File Support<FOOTNOTE ID="std-131-35">
<PARA>
Large File Support</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-131-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]<FOOTNOTE ID="std-131-3">
<PARA>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, February 1997, Networking Services (XNS), Issue 5(ISBN: 1-85912-165-9, C523)<FOOTNOTE ID="std-131-15">
<PARA>
CAE Specification, February 1997, Networking Services (XNS), Issue 5(ISBN: 1-85912-165-9, C523)</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-131-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
The Single UNIX® Specification(SUS) Version 3<FOOTNOTE ID="std-131-67">
<PARA>
The Single UNIX® Specification(SUS) Version 3</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
System V Interface Definition, Issue 3 (ISBN 0201566524)<FOOTNOTE ID="std-131-21">
<PARA>
System V Interface Definition, Issue 3 (ISBN 0201566524)</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
System V Interface Definition,Fourth Edition<FOOTNOTE ID="std-131-46">
<PARA>
System V Interface Definition,Fourth Edition</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<!--libgroup-->
<TITLE>RPC</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - RPC Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>authnone_create<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>setdomainname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>xdr_array<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_int<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_u_char<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_create<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svc_getreqset<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_bool<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_long<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_u_long<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_pcreateerror<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_auth<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_bytes<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_opaque<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_u_short<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_perrno<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_decode<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_callhdr<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_opaque_auth<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_union<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_perror<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_noproc<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_callmsg<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_pointer<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_vector<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_spcreateerror<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_noprog<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_char<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_reference<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_void<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_sperrno<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_progvers<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_double<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_rejected_reply<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_wrapstring<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>clnt_sperror<FOOTNOTEREF LINKEND="std-131-46"></ENTRY>
<ENTRY>svcerr_systemerr<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_enum<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_replymsg<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdrmem_create<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>getdomainname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>svcerr_weakauth<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_float<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_short<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdrrec_create<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
<ROW>
<ENTRY>key_decryptsession<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_accepted_reply<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_free<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdr_string<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
<ENTRY>xdrrec_eof<FOOTNOTEREF LINKEND="std-131-21"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>System Calls</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - System Calls Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__fxstat<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fchown<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ioctl<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>readdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setsid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__getpgid<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fcntl<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>kill<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>readdir_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setuid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__lxstat<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fdatasync<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>killpg<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>readlink<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sleep<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__xmknod<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>flock<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>lchown<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>readv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>statfs<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__xstat<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fork<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>link<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>rename<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>statfs64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
</ROW>
<ROW>
<ENTRY>access<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fstatfs<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>lockf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>rmdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>statvfs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>acct<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fsync<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>lseek<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sbrk<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>statvfs64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>alarm<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mkdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_get_priority_max<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>stime<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>brk<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftruncate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mkfifo<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_get_priority_min<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>symlink<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>chdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getcontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mlock<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_getparam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sync<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>chmod<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getegid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mlockall<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_getscheduler<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sysconf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>chown<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>geteuid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mmap<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_rr_get_interval<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>time<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>chroot<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getgid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mprotect<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_setparam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>times<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>clock<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getgroups<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>msync<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_setscheduler<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>truncate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>close<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getitimer<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>munlock<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sched_yield<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ulimit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>closedir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getloadavg<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>munlockall<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>select<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>umask<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>creat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpagesize<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>munmap<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setcontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>uname<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>dup<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpgid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>nanosleep<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setegid<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>unlink<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>dup2<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpgrp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>nice<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>seteuid<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>utime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>execl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>open<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setgid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>utimes<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>execle<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getppid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>opendir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setitimer<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vfork<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>execlp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpriority<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pathconf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setpgid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wait<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>execv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getrlimit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pause<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setpgrp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wait3<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>execve<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getrusage<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pipe<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setpriority<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wait4<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>execvp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getsid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>poll<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setregid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>waitid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>exit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getuid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pread<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setreuid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>waitpid<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>fchdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getwd<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pwrite<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setrlimit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>write<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fchmod<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>initgroups<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>read<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setrlimit64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>writev<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Standard I/O</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard I/O Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>_IO_feof<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fgetpos<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fsetpos<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putc_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_IO_getc<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fgets<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fstatvfs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putchar<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sscanf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_IO_putc<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fgetwc_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftell<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putchar_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>telldir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_IO_puts<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fileno<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftello<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>puts<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tempnam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>asprintf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>flockfile<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fwrite<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putw<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ungetc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>clearerr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fopen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>remove<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vasprintf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>ctermid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getc_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>rewind<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vdprintf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>fclose<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fputc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getchar<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>rewinddir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vfprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fdopen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fputs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getchar_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>scanf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>feof<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fread<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getw<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>seekdir<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vsnprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>ferror<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>freopen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pclose<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setbuf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vsprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fflush<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fscanf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>popen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setbuffer<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>fflush_unlocked<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fseek<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>printf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setvbuf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>fgetc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>fseeko<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>snprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<TABLE>
<TITLE>libc - Standard I/O Deprecated Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>alphasort<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>gets<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Standard I/O Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>stderr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>stdin<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>stdout<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Signal Handling</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Signal Handling Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__libc_current_sigrtmax<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigaddset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sighold<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigpause<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigsuspend<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__libc_current_sigrtmin<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigaltstack<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigignore<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigpending<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigtimedwait<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__sigsetjmp<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigandset<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>siginterrupt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigprocmask<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigwait<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__sysv_signal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigblock<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigisemptyset<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigqueue<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigwaitinfo<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>bsd_signal<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigdelset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigismember<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigrelse<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>psignal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigemptyset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>siglongjmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigreturn<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>raise<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigfillset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>signal<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sigset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>sigaction<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>siggetmask<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigorset<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sigstack<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Signal Handling Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>_sys_siglist<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Localization Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Localization Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>bind_textdomain_codeset<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>catopen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>dngettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>iconv_open<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setlocale<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>bindtextdomain<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>dcgettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>gettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>localeconv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>textdomain<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>catclose<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>dcngettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>iconv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ngettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>catgets<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>dgettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>iconv_close<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>nl_langinfo<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<TABLE>
<TITLE>libc - Localization Functions Deprecated Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__dcgettext<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Localization Functions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>_nl_msg_cat_cntr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Socket Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Socket Interface Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__h_errno_location<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>gethostbyname_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getsockopt<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>send<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>socket<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>accept<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>gethostid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>listen<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>sendmsg<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>socketpair<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>bind<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>gethostname<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>recv<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>sendto<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>bindresvport<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getpeername<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>recvfrom<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>setsockopt<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>connect<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getsockname<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>recvmsg<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>shutdown<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Wide Characters</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Wide Characters Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__wcstod_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>mbsinit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsnlen<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcstoumax<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__wcstof_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>mbsnrtowcs<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcpcpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcsnrtombs<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcstouq<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__wcstol_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>mbsrtowcs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcpncpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcspbrk<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcswcs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__wcstold_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>mbstowcs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcrtomb<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcsrchr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcswidth<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__wcstoul_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>mbtowc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcscasecmp<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcsrtombs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcsxfrm<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>btowc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcscat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcsspn<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wctob<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fgetwc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>putwchar<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcschr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcsstr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wctomb<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fgetws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>swprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcscmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstod<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wctrans<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fputwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>swscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcscoll<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstof<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wctype<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fputws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>towctrans<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcscpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstoimax<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcwidth<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fwide<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>towlower<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcscspn<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstok<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wmemchr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fwprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>towupper<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcsdup<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcstol<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wmemcmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>fwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>ungetwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsftime<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcstold<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wmemcpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>getwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>vfwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcslen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstoll<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wmemmove<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>getwchar<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vfwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsncasecmp<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wcstombs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wmemset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>mblen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vswprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsncat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstoq<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>wprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>mbrlen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vswscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsncmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstoul<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>mbrtowc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>wcsncpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wcstoull<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>String Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - String Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__mempcpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>bzero<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcasestr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strncasecmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtoimax<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__rawmemchr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>ffs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strncat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtok<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__stpcpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>index<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strchr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strncmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtok_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strdup<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memccpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strncpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtold<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtod_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memchr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcoll<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strndup<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strtoll<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtof_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memcmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strnlen<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strtoq<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtok_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memcpy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcspn<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strpbrk<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtoull<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtol_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memmove<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strdup<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strptime<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strtoumax<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtold_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memrchr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strerror<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strrchr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtouq<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtoll_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>memset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strerror_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strsep<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strverscmp<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtoul_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>rindex<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strfmon<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strsignal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strxfrm<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__strtoull_internal<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>stpcpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strfry<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strspn<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>swab<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>bcmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>stpncpy<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strftime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strstr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>bcopy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strcasecmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strlen<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtof<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>IPC Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - IPC Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>ftok<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>msgrcv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>semget<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>shmctl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>msgctl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>msgsnd<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>semop<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>shmdt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>msgget<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>semctl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>shmat<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>shmget<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Regular Expressions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Regular Expressions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>advance<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>re_exec<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>regerror<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>regfree<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>re_comp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>regcomp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>regexec<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>step<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Regular Expressions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>loc1<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>loc2<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>locs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Character Type Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Character Type Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__ctype_get_mb_cur_max<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>isdigit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswalnum<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswlower<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>toascii<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_tolower<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isgraph<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswalpha<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswprint<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tolower<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_toupper<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>islower<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswblank<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>iswpunct<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>toupper<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>isalnum<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isprint<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswcntrl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswspace<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>isalpha<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ispunct<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswctype<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>iswupper<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>isascii<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isspace<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswdigit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswxdigit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>iscntrl<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isupper<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>iswgraph<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isxdigit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Character Type Functions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__ctype_b<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>__ctype_tolower<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>__ctype_toupper<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Time Manipulation</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Time Manipulation Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>adjtime<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>asctime_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>difftime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>localtime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tzset<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>adjtimex<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>ctime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gmtime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>localtime_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ualarm<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>asctime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ctime_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gmtime_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>mktime<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Time Manipulation Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__daylight<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>__tzname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>timezone<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>__timezone<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>daylight<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tzname<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Terminal Interface Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Terminal Interface Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>cfgetispeed<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>cfsetispeed<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcdrain<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcgetattr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcsendbreak<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cfgetospeed<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>cfsetospeed<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcflow<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcgetpgrp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcsetattr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cfmakeraw<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>cfsetspeed<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>tcflush<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcgetsid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tcsetpgrp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>System Database Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - System Database Interface Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>endgrent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getgrgid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getprotobyname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getservbyport<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>setgroups<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>endhostent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getgrgid_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getprotobynumber<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getservent<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>sethostent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>endnetent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getgrnam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getprotoent<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getutent<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>setmntent<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>endprotoent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getgrnam_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getpwent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getutent_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>setnetent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>endpwent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gethostbyaddr<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getpwnam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getutxent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setprotoent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>endservent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>gethostbyaddr_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getpwnam_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getutxid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setpwent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>endutent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gethostbyname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getpwuid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getutxline<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setservent<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
</ROW>
<ROW>
<ENTRY>endutxent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gethostent_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getpwuid_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>pututxline<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setutent<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>getgrent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getnetbyaddr<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>getservbyname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>setgrent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setutxent<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Language Support</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Language Support Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__libc_start_main<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>_obstack_begin<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>_obstack_newchunk<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>obstack_free<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Large File Support</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Large File Support Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__fxstat64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>freopen64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>ftruncate64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>mmap64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>tmpfile64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
</ROW>
<ROW>
<ENTRY>__lxstat64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fseeko64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>ftw64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>nftw64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>truncate64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
</ROW>
<ROW>
<ENTRY>__xstat64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fsetpos64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>getrlimit64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>open64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>creat64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>fstatfs64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>lockf64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>pread64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>fgetpos64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>fstatvfs64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>lseek64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>pwrite64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>fopen64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>ftello64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>mkstemp64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY>readdir64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<TABLE>
<TITLE>libc - Large File Support Deprecated Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>alphasort64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<!--libgroup-->
<TITLE>Standard Library</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard Library Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>_Exit<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>div<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>globfree<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>llabs<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>sethostname<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__assert_fail<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>drand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>globfree64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>lldiv<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>setlogmask<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__cxa_atexit<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>ecvt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>grantpt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>longjmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setstate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__errno_location<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>erand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>hcreate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>lrand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>srand<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__fpending<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>err<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>hdestroy<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>lsearch<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>srand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__getpagesize<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>error<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>hsearch<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>makecontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>srandom<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isinf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>errx<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>htonl<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>malloc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtod<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isinff<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fcvt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>htons<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>memmem<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>strtol<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isinfl<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fmtmsg<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>imaxabs<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>mkstemp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>strtoul<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isnan<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fnmatch<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>imaxdiv<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>mktemp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>swapcontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isnanf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>fpathconf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>inet_addr<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>mrand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>syslog<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>__isnanl<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>free<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>inet_aton<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>nftw<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>system<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>__sysconf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>freeaddrinfo<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>inet_ntoa<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>nrand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tfind<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_exit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftrylockfile<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>inet_ntop<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>ntohl<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>tmpfile<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_longjmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ftw<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>inet_pton<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>ntohs<FOOTNOTEREF LINKEND="std-131-15"></ENTRY>
<ENTRY>tmpnam<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>_setjmp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>funlockfile<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>initstate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>openlog<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>tsearch<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>a64l<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gai_strerror<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>insque<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>perror<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ttyname<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>abort<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gcvt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isatty<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>posix_memalign<FOOTNOTEREF LINKEND="std-131-3"></ENTRY>
<ENTRY>ttyname_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>abs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getaddrinfo<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>isblank<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>ptsname<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>twalk<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>atexit<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getcwd<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isinf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>putenv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>unlockpt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>atof<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getdate<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isinff</ENTRY>
<ENTRY>qsort<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>unsetenv<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>atoi<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getenv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isinfl<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>rand<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>usleep<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>atol<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getlogin<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>isnan<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>rand_r<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>verrx<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>basename<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getnameinfo<FOOTNOTEREF LINKEND="std-131-67"></ENTRY>
<ENTRY>isnanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>random<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>vsyslog<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>bsearch<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getopt<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>isnanl<FOOTNOTEREF LINKEND="std-131-25"></ENTRY>
<ENTRY>random_r<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>warn<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>calloc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getopt_long<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>jrand48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>realloc<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>warnx<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>closelog<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getopt_long_only<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>l64a<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>realpath<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wordexp<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>confstr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>getsubopt<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>labs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>remque<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>wordfree<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cuserid<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>gettimeofday<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>lcong48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>seed48<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>daemon<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>glob<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>ldiv<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>setenv<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY>dirname<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>glob64<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>lfind<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>sethostid<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libc - Standard Library Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>__environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>_sys_errlist<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>getdate_err<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>opterr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>optopt<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>_environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY>environ<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>optarg<FOOTNOTEREF LINKEND="std-131-5"></ENTRY>
<ENTRY>optind<FOOTNOTEREF LINKEND="std-131-10"></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libc-ddefs>
<TITLE>Data Definitions for libc</TITLE>
<PARA>
This section contains standard data definitions that describe system data. These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
ISO C serves as the LSB reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>assert.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define assert(expr)	((void)0)
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>






enum
{
  _ISupper, _ISlower, _ISalpha, _ISdigit, _ISxdigit, _ISspace, _ISprint,
    _ISgraph, _ISblank, _IScntrl, _ISpunct, _ISalnum
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>dirent.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef struct __dirstream DIR;





struct dirent
{
  long d_ino;
  off_t d_off;
  unsigned short d_reclen;
  unsigned char d_type;
  char d_name[256];
}
 ;
struct dirent64
{
  uint64_t d_ino;
  int64_t d_off;
  unsigned short d_reclen;
  unsigned char d_type;
  char d_name[256];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>errno.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define errno	(*__errno_location())



#define EPERM	1
#define ECHILD	10
#define ENETDOWN	100
#define ENETUNREACH	101
#define ENETRESET	102
#define ECONNABORTED	103
#define ECONNRESET	104
#define ENOBUFS	105
#define EISCONN	106
#define ENOTCONN	107
#define ESHUTDOWN	108
#define ETOOMANYREFS	109
#define EAGAIN	11
#define ETIMEDOUT	110
#define ECONNREFUSED	111
#define EHOSTDOWN	112
#define EHOSTUNREACH	113
#define EALREADY	114
#define EINPROGRESS	115
#define ESTALE	116
#define EUCLEAN	117
#define ENOTNAM	118
#define ENAVAIL	119
#define ENOMEM	12
#define EISNAM	120
#define EREMOTEIO	121
#define EDQUOT	122
#define ENOMEDIUM	123
#define EMEDIUMTYPE	124
#define ECANCELED	125
#define EACCES	13
#define EFAULT	14
#define ENOTBLK	15
#define EBUSY	16
#define EEXIST	17
#define EXDEV	18
#define ENODEV	19
#define ENOENT	2
#define ENOTDIR	20
#define EISDIR	21
#define EINVAL	22
#define ENFILE	23
#define EMFILE	24
#define ENOTTY	25
#define ETXTBSY	26
#define EFBIG	27
#define ENOSPC	28
#define ESPIPE	29
#define ESRCH	3
#define EROFS	30
#define EMLINK	31
#define EPIPE	32
#define EDOM	33
#define ERANGE	34
#define EINTR	4
#define EIO	5
#define ENXIO	6
#define E2BIG	7
#define ENOEXEC	8
#define EBADF	9
#define EWOULDBLOCK	EAGAIN
#define EDEADLOCK	EDEADLK
#define ENOTSUP	EOPNOTSUPP
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fcntl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define O_RDONLY	00
#define O_ACCMODE	0003
#define O_WRONLY	01
#define O_CREAT	0100
#define O_TRUNC	01000
#define O_SYNC	010000
#define O_RDWR	02
#define O_EXCL	0200
#define O_APPEND	02000
#define O_ASYNC	020000
#define O_NOCTTY	0400
#define O_NDELAY	04000
#define O_NONBLOCK	04000


struct flock
{
  short l_type;
  short l_whence;
  off_t l_start;
  off_t l_len;
  pid_t l_pid;
}
 ;
struct flock64
{
  short l_type;
  short l_whence;
  loff_t l_start;
  loff_t l_len;
  pid_t l_pid;
}
 ;






#define F_DUPFD	0
#define F_RDLCK	0
#define F_GETFD	1
#define F_WRLCK	1
#define F_SETFD	2
#define F_UNLCK	2
#define F_GETFL	3
#define F_SETFL	4
#define F_GETLK	5
#define F_SETLK	6
#define F_SETLKW	7
#define F_SETOWN	8
#define F_GETOWN	9
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fmtmsg.h</TITLE>
<PARA>
</PARA>
<SCREEN>




#define MM_HARD	1
#define MM_NRECOV	128
#define MM_UTIL	16
#define MM_SOFT	2
#define MM_OPSYS	32
#define MM_FIRM	4
#define MM_RECOVER	64
#define MM_APPL	8



#define MM_NOSEV	0
#define MM_HALT	1
#define MM_ERROR	2



#define MM_NULLLBL	((char *) 0)
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fnmatch.h</TITLE>
<PARA>
</PARA>
<SCREEN>




#define FNM_PATHNAME	(1&lt;&lt;0)
#define FNM_NOESCAPE	(1&lt;&lt;1)
#define FNM_PERIOD	(1&lt;&lt;2)
#define FNM_NOMATCH	1
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ftw.h</TITLE>
<PARA>
</PARA>
<SCREEN>




#define FTW_D	FTW_D
#define FTW_DNR	FTW_DNR
#define FTW_DP	FTW_DP
#define FTW_F	FTW_F
#define FTW_NS	FTW_NS
#define FTW_SL	FTW_SL
#define FTW_SLN	FTW_SLN


enum
{
  FTW_F, FTW_D, FTW_DNR, FTW_NS, FTW_SL, FTW_DP, FTW_SLN
}
 ;


enum
{
  FTW_PHYS, FTW_MOUNT, FTW_CHDIR, FTW_DEPTH
}
 ;


struct FTW
{
  int base;
  int level;
}
 ;


typedef int (*__ftw_func_t) (char *__filename, struct stat * __status,
			     int __flag);
typedef int (*__ftw64_func_t) (char *__filename, struct stat64 * __status,
			       int __flag);
typedef int (*__nftw_func_t) (char *__filename, struct stat * __status,
			      int __flag, struct FTW * __info);
typedef int (*__nftw64_func_t) (char *__filename, struct stat64 * __status,
				int __flag, struct FTW * __info);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>getopt.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct option
{
  char *name;
  int has_arg;
  int *flag;
  int val;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>glob.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef struct
{
  size_t gl_pathc;
  char **gl_pathv;
  size_t gl_offs;
  int gl_flags;
  void (*gl_closedir) (void);
  struct dirent *(*gl_readdir) (void);
  void *(*gl_opendir) (void);
  int (*gl_lstat) (void);
  int (*gl_stat) (void);
}
glob_t;


typedef struct
{
  size_t gl_pathc;
  char **gl_pathv;
  size_t gl_offs;
  int gl_flags;
  void (*gl_closedir) (void);
  struct dirent *(*gl_readdir) (void);
  void *(*gl_opendir) (void);
  int (*gl_lstat) (void);
  int (*gl_stat) (void);
}
glob64_t;
#define GLOB_ERR	(1&lt;&lt;0)
#define GLOB_MARK	(1&lt;&lt;1)
#define GLOB_BRACE	(1&lt;&lt;10)
#define GLOB_NOMAGIC	(1&lt;&lt;11)
#define GLOB_TILDE	(1&lt;&lt;12)
#define GLOB_ONLYDIR	(1&lt;&lt;13)
#define GLOB_TILDE_CHECK	(1&lt;&lt;14)
#define GLOB_NOSORT	(1&lt;&lt;2)
#define GLOB_DOOFFS	(1&lt;&lt;3)
#define GLOB_NOCHECK	(1&lt;&lt;4)
#define GLOB_APPEND	(1&lt;&lt;5)
#define GLOB_NOESCAPE	(1&lt;&lt;6)
#define GLOB_PERIOD	(1&lt;&lt;7)
#define GLOB_MAGCHAR	(1&lt;&lt;8)
#define GLOB_ALTDIRFUNC	(1&lt;&lt;9)



#define GLOB_NOSPACE	1
#define GLOB_ABORTED	2
#define GLOB_NOMATCH	3
#define GLOB_NOSYS	4
</SCREEN>
</SECT2>
<SECT2>
<TITLE>grp.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct group
{
  char *gr_name;
  char *gr_passwd;
  gid_t gr_gid;
  char **gr_mem;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>iconv.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef void *iconv_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>inttypes.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef lldiv_t imaxdiv_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
typedef unsigned int u_int;
typedef unsigned int uint;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned int *uintptr_t;
typedef long long uint64_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>langinfo.h</TITLE>
<PARA>
</PARA>
<SCREEN>







#define ABDAY_1	0x20000
#define ABDAY_2	0x20001
#define ABDAY_3	0x20002
#define ABDAY_4	0x20003
#define ABDAY_5	0x20004
#define ABDAY_6	0x20005
#define ABDAY_7	0x20006



#define DAY_1	0x20007
#define DAY_2	0x20008
#define DAY_3	0x20009
#define DAY_4	0x2000A
#define DAY_5	0x2000B
#define DAY_6	0x2000C
#define DAY_7	0x2000D



#define ABMON_1	0x2000E
#define ABMON_2	0x2000F
#define ABMON_3	0x20010
#define ABMON_4	0x20011
#define ABMON_5	0x20012
#define ABMON_6	0x20013
#define ABMON_7	0x20014
#define ABMON_8	0x20015
#define ABMON_9	0x20016
#define ABMON_10	0x20017
#define ABMON_11	0x20018
#define ABMON_12	0x20019



#define MON_1	0x2001A
#define MON_2	0x2001B
#define MON_3	0x2001C
#define MON_4	0x2001D
#define MON_5	0x2001E
#define MON_6	0x2001F
#define MON_7	0x20020
#define MON_8	0x20021
#define MON_9	0x20022
#define MON_10	0x20023
#define MON_11	0x20024
#define MON_12	0x20025



#define AM_STR	0x20026
#define PM_STR	0x20027



#define D_T_FMT	0x20028
#define D_FMT	0x20029
#define T_FMT	0x2002A
#define T_FMT_AMPM	0x2002B



#define ERA	0x2002C
#define ERA_D_FMT	0x2002E
#define ALT_DIGITS	0x2002F
#define ERA_D_T_FMT	0x20030
#define ERA_T_FMT	0x20031






#define CODESET	14



#define CRNCYSTR	0x4000F



#define RADIXCHAR	0x10000
#define THOUSEP	0x10001
#define YESEXPR	0x50000
#define NOEXPR	0x50001
#define YESSTR	0x50002
#define NOSTR	0x50003
</SCREEN>
</SECT2>
<SECT2>
<TITLE>limits.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define OPEN_MAX	256
#define PATH_MAX	4096



#define MB_LEN_MAX	16



#define SCHAR_MIN	(-128)
#define SCHAR_MAX	127
#define UCHAR_MAX	255
#define CHAR_BIT	8
#define CHAR_MAX	SCHAR_MAX
#define CHAR_MIN	SCHAR_MIN



#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
#define USHRT_MAX	65535



#define INT_MIN	(-INT_MAX-1)
#define INT_MAX	2147483647
#define UINT_MAX	4294967295U



#define LONG_MIN	(-LONG_MAX-1L)
</SCREEN>
</SECT2>
<SECT2>
<TITLE>locale.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define LC_CTYPE	0
#define LC_NUMERIC	1
#define LC_TELEPHONE	10
#define LC_MEASUREMENT	11
#define LC_IDENTIFICATION	12
#define LC_TIME	2
#define LC_COLLATE	3
#define LC_MONETARY	4
#define LC_MESSAGES	5
#define LC_ALL	6
#define LC_PAPER	7
#define LC_NAME	8
#define LC_ADDRESS	9





struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>net/if.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IF_NAMESIZE	16



#define IFF_UP	0x01
#define IFF_BROADCAST	0x02
#define IFF_DEBUG	0x04
#define IFF_LOOPBACK	0x08
#define IFF_POINTOPOINT	0x10
#define IFF_PROMISC	0x100
#define IFF_MULTICAST	0x1000
#define IFF_NOTRAILERS	0x20
#define IFF_RUNNING	0x40
#define IFF_NOARP	0x80





struct ifaddr
{
  struct sockaddr ifa_addr;
  union
  {
    struct sockaddr ifu_broadaddr;
    struct sockaddr ifu_dstaddr;
  }
  ifa_ifu;
  void *__pad1;
  void *__pad2;
}
 ;
#define IFNAMSIZ	IF_NAMESIZE


struct ifreq
{
  union
  {
    char ifrn_name[IFNAMSIZ];
  }
  ifr_ifrn;
  union
  {
    struct sockaddr ifru_addr;
    struct sockaddr ifru_dstaddr;
    struct sockaddr ifru_broadaddr;
    struct sockaddr ifru_netmask;
    struct sockaddr ifru_hwaddr;
    short ifru_flags;
    int ifru_ivalue;
    int ifru_mtu;
    char ifru_slave[IFNAMSIZ];
    char ifru_newname[IFNAMSIZ];
    caddr_t ifru_data;
  }
  ifr_ifru;
}
 ;


struct ifconf
{
  int ifc_len;
  union
  {
    caddr_t ifcu_buf;
    struct ifreq *ifcu_req;
  }
  ifc_ifcu;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netdb.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define h_errno	(*__h_errno_location ())
#define NETDB_INTERNAL	-1
#define NETDB_SUCCESS	0
#define HOST_NOT_FOUND	1
#define TRY_AGAIN	2
#define NO_RECOVERY	3
#define NO_DATA	4
#define h_addr	h_addr_list[0]
#define NO_ADDRESS	NO_DATA


struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
}
 ;
struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  socklen_t h_length;
  char **h_addr_list;
}
 ;
struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/in.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define INADDR_NONE	((unsigned long int) 0xffffffff)
#define INADDR_BROADCAST	(0xffffffff)
#define INADDR_ANY	0
#define IPPROTO_IP	0
#define IPPROTO_ICMP	1
#define IP_TOS	1
#define IPPROTO_UDP	17
#define IPPROTO_IGMP	2
#define IPPROTO_RAW	255
#define IPPROTO_TCP	6





struct in_addr
{
  uint32_t s_addr;
}
 ;
typedef uint32_t in_addr_t;


struct sockaddr_in
{
  sa_family_t sin_family;
  unsigned short sin_port;
  struct in_addr sin_addr;
  unsigned char __pad[8];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/tcp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define TCP_NODELAY	1
</SCREEN>
</SECT2>
<SECT2>
<TITLE>nl_types.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NL_CAT_LOCALE	1
#define NL_SETD	1





typedef void *nl_catd;


typedef int nl_item;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>pwd.h</TITLE>
<PARA>
</PARA>
<SCREEN>






struct passwd
{
  char *pw_name;
  char *pw_passwd;
  uid_t pw_uid;
  gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>regex.h</TITLE>
<PARA>
</PARA>
<SCREEN>




#define RE_SYNTAX_GNU_AWK	((RE_SYNTAX_POSIX_EXTENDED|RE_BACKSLASH_ESCAPE_IN_LISTS|RE_DEBUG)&amp  ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))
#define RE_BACKSLASH_ESCAPE_IN_LISTS	((unsigned long int)1)
#define RE_BK_PLUS_QM	(RE_BACKSLASH_ESCAPE_IN_LISTS&lt;&lt;1)
#define RE_SYNTAX_AWK	(RE_BACKSLASH_ESCAPE_IN_LISTS|RE_DOT_NOT_NULL|RE_NO_BK_PARENS| RE_NO_BK_REFS| RE_NO_BK_VBAR| RE_NO_EMPTY_RANGES| RE_DOT_NEWLINE| RE_CONTEXT_INDEP_ANCHORS| RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)
#define RE_CHAR_CLASSES	(RE_BK_PLUS_QM&lt;&lt;1)
#define RE_SYNTAX_GREP	(RE_BK_PLUS_QM|RE_CHAR_CLASSES|RE_HAT_LISTS_NOT_NEWLINE|RE_INTERVALS|RE_NEWLINE_ALT)
#define RE_CONTEXT_INDEP_ANCHORS	(RE_CHAR_CLASSES&lt;&lt;1)
#define RE_SYNTAX_EGREP	(RE_CHAR_CLASSES|RE_CONTEXT_INDEP_ANCHORS| RE_CONTEXT_INDEP_OPS|RE_HAT_LISTS_NOT_NEWLINE|RE_NEWLINE_ALT|RE_NO_BK_PARENS|RE_NO_BK_VBAR)
#define _RE_SYNTAX_POSIX_COMMON	(RE_CHAR_CLASSES|RE_DOT_NEWLINE|RE_DOT_NOT_NULL|RE_INTERVALS)
#define RE_CONTEXT_INDEP_OPS	(RE_CONTEXT_INDEP_ANCHORS&lt;&lt;1)
#define RE_CONTEXT_INVALID_OPS	(RE_CONTEXT_INDEP_OPS&lt;&lt;1)
#define RE_DOT_NEWLINE	(RE_CONTEXT_INVALID_OPS&lt;&lt;1)
#define RE_INVALID_INTERVAL_ORD	(RE_DEBUG&lt;&lt;1)
#define RE_DOT_NOT_NULL	(RE_DOT_NEWLINE&lt;&lt;1)
#define RE_HAT_LISTS_NOT_NEWLINE	(RE_DOT_NOT_NULL&lt;&lt;1)
#define RE_INTERVALS	(RE_HAT_LISTS_NOT_NEWLINE&lt;&lt;1)
#define RE_LIMITED_OPS	(RE_INTERVALS&lt;&lt;1)
#define RE_NEWLINE_ALT	(RE_LIMITED_OPS&lt;&lt;1)
#define RE_NO_BK_BRACES	(RE_NEWLINE_ALT&lt;&lt;1)
#define RE_NO_BK_PARENS	(RE_NO_BK_BRACES&lt;&lt;1)
#define RE_NO_BK_REFS	(RE_NO_BK_PARENS&lt;&lt;1)
#define RE_NO_BK_VBAR	(RE_NO_BK_REFS&lt;&lt;1)
#define RE_NO_EMPTY_RANGES	(RE_NO_BK_VBAR&lt;&lt;1)
#define RE_UNMATCHED_RIGHT_PAREN_ORD	(RE_NO_EMPTY_RANGES&lt;&lt;1)
#define RE_DEBUG	(RE_NO_GNU_OPS&lt;&lt;1)
#define RE_NO_GNU_OPS	(RE_NO_POSIX_BACKTRACKING&lt;&lt;1)
#define RE_SYNTAX_POSIX_EGREP	(RE_SYNTAX_EGREP|RE_INTERVALS|RE_NO_BK_BRACES|RE_INVALID_INTERVAL_ORD)
#define RE_SYNTAX_POSIX_AWK	(RE_SYNTAX_POSIX_EXTENDED|RE_BACKSLASH_ESCAPE_IN_LISTS|RE_INTERVALS|RE_NO_GNU_OPS)
#define RE_NO_POSIX_BACKTRACKING	(RE_UNMATCHED_RIGHT_PAREN_ORD&lt;&lt;1)
#define RE_SYNTAX_POSIX_BASIC	(_RE_SYNTAX_POSIX_COMMON|RE_BK_PLUS_QM)
#define RE_SYNTAX_POSIX_EXTENDED	(_RE_SYNTAX_POSIX_COMMON|RE_CONTEXT_INDEP_ANCHORS|RE_CONTEXT_INDEP_OPS|RE_NO_BK_BRACES|RE_NO_BK_PARENS|RE_NO_BK_VBAR|RE_CONTEXT_INVALID_OPS|RE_UNMATCHED_RIGHT_PAREN_ORD)
#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED	(_RE_SYNTAX_POSIX_COMMON|RE_CONTEXT_INDEP_ANCHORS|RE_CONTEXT_INVALID_OPS|RE_NO_BK_BRACES|RE_NO_BK_PARENS|RE_NO_BK_REFS|RE_NO_BK_VBAR|RE_UNMATCHED_RIGHT_PAREN_ORD)
#define RE_SYNTAX_POSIX_MINIMAL_BASIC	(_RE_SYNTAX_POSIX_COMMON|RE_LIMITED_OPS)
#define RE_SYNTAX_ED	RE_SYNTAX_POSIX_BASIC
#define RE_SYNTAX_SED	RE_SYNTAX_POSIX_BASIC


typedef unsigned long reg_syntax_t;





typedef struct re_pattern_buffer
{
  unsigned char *buffer;
  unsigned long allocated;
  unsigned long used;
  reg_syntax_t syntax;
  char *fastmap;
  char *translate;
  size_t re_nsub;
  unsigned int can_be_null:1;
  unsigned int regs_allocated:2;
  unsigned int fastmap_accurate:1;
  unsigned int no_sub:1;
  unsigned int not_bol:1;
  unsigned int not_eol:1;
  unsigned int newline_anchor:1;
}
regex_t;
typedef int regoff_t;
typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
}
regmatch_t;
#define REG_NOTEOL	(1&lt;&lt;1)
#define REG_ICASE	(REG_EXTENDED&lt;&lt;1)
#define REG_NEWLINE	(REG_ICASE&lt;&lt;1)
#define REG_NOSUB	(REG_NEWLINE&lt;&lt;1)
#define REG_NOMATCH	-1
#define REG_EXTENDED	1
#define REG_NOTBOL	1
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sched.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SCHED_OTHER	0
#define SCHED_FIFO	1
#define SCHED_RR	2


struct sched_param
{
  int sched_priority;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>search.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef struct entry
{
  char *key;
  void *data;
}
ENTRY;
typedef enum
{
  FIND, ENTER
}
ACTION;
typedef enum
{
  preorder, postorder, endorder, leaf
}
VISIT;


typedef void (*__action_fn_t) (void *__nodep, VISIT __value, int __level);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>setjmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define setjmp(env)	_setjmp(env)
#define sigsetjmp(a,b)	__sigsetjmp(a,b)





typedef int __jmp_buf[6];


struct __jmp_buf_tag
{
  __jmp_buf __jmpbuf;
  int __mask_was_saved;
  sigset_t __saved_mask;
}
 ;


typedef struct __jmp_buf_tag jmp_buf[1];
typedef jmp_buf sigjmp_buf;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>signal.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define SIG_BLOCK	0
#define SIG_UNBLOCK	1
#define SIG_SETMASK	2
#define NSIG	64


typedef int sig_atomic_t;
struct sigstack
{
  void *ss_sp;
  int ss_onstack;
}
 ;
#define SIG_ERR	((__sighandler_t)-1)
#define SIG_DFL	((__sighandler_t)0)
#define SIG_IGN	((__sighandler_t)1)
#define SIGHUP	1
#define SIGSEGV	11
#define SIGPIPE	13
#define SIGALRM	14
#define SIGTERM	15
#define SIGINT	2
#define SIGPROF	27
#define SIGQUIT	3
#define SIGILL	4
#define SIGTRAP	5
#define SIGABRT	6
#define SIGIOT	6
#define SIGFPE	8
#define SIGKILL	9
#define SIGCLD	SIGCHLD
#define SIGPOLL	SIGIO





typedef void (*__sighandler_t) (int);
#define SV_ONSTACK	(1&lt;&lt;0)
#define SV_INTERRUPT	(1&lt;&lt;1)
#define SV_RESETHAND	(1&lt;&lt;2)


typedef union sigval
{
  int sival_int;
  void *sival_ptr;
}
sigval_t;
#define SIGEV_SIGNAL	0
#define SIGEV_NONE	1
#define SIGEV_THREAD	2


typedef struct sigevent
{
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union
  {
    int _pad[SIGEV_PAD_SIZE];
    struct
    {
      void (*sigev_thread_func) (void);
      void *_attribute;
    }
    _sigev_thread;
  }
  _sigev_un;
}
sigevent_t;
#define SI_QUEUE	-1
#define SI_TIMER	-2
#define SI_MESGQ	-3
#define SI_ASYNCIO	-4
#define SI_USER	0
#define si_pid	_sifields._kill._pid
#define si_uid	_sifields._kill._uid
#define si_value	_sifields._rt._sigval
#define si_int	_sifields._rt._sigval.sival_int
#define si_ptr	_sifields._rt._sigval.sival_ptr
#define si_status	_sifields._sigchld._status
#define si_stime	_sifields._sigchld._stime
#define si_utime	_sifields._sigchld._utime
#define si_addr	_sifields._sigfault._addr
#define si_band	_sifields._sigpoll._band
#define si_fd	_sifields._sigpoll._fd
#define si_timer1	_sifields._timer._timer1
#define si_timer2	_sifields._timer._timer2


typedef struct siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  union
  {
    int _pad[SI_PAD_SIZE];
    struct
    {
      pid_t _pid;
      uid_t _uid;
    }
    _kill;
    struct
    {
      unsigned int _timer1;
      unsigned int _timer2;
    }
    _timer;
    struct
    {
      pid_t _pid;
      uid_t _uid;
      sigval_t _sigval;
    }
    _rt;
    struct
    {
      pid_t _pid;
      uid_t _uid;
      int _status;
      clock_t _utime;
      clock_t _stime;
    }
    _sigchld;
    struct
    {
      void *_addr;
    }
    _sigfault;
    struct
    {
      int _band;
      int _fd;
    }
    _sigpoll;
  }
  _sifields;
}
siginfo_t;


typedef struct
{
  unsigned long sig[_SIGSET_NWORDS];
}
sigset_t;
#define SA_NOCLDSTOP	0x00000001
#define SA_NOCLDWAIT	0x00000002
#define SA_SIGINFO	0x00000004
#define SA_ONSTACK	0x08000000
#define SA_RESTART	0x10000000
#define SA_INTERRUPT	0x20000000
#define SA_NODEFER	0x40000000
#define SA_RESETHAND	0x80000000
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND


struct sigaction
{
  union
  {
    __sighandler_t _sa_handler;
    void (*_sa_sigaction) (void);
  }
  __sigaction_handler;
  unsigned long sa_flags;
  void (*sa_restorer) (void);
  sigset_t sa_mask;
}
 ;


typedef struct sigaltstack
{
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
}
stack_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stddef.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define offsetof(TYPE,MEMBER)	((size_t)&amp ((TYPE*)0)->MEMBER)
#define NULL	(0)


typedef long wchar_t;
typedef unsigned int size_t;
typedef long ptrdiff_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define EOF	(-1)
#define P_tmpdir	"/tmp"
#define FOPEN_MAX	16
#define L_tmpnam	20
#define FILENAME_MAX	4096
#define BUFSIZ	8192
#define L_ctermid	9
#define L_cuserid	9


typedef struct _IO_FILE FILE;
typedef struct
{
  off_t __pos;
  mbstate_t __state;
}
fpos_t;
typedef struct
{
  off64_t __pos;
  mbstate_t __state;
}
fpos64_t;



#define _IOFBF	0
#define _IOLBF	1
#define _IONBF	2
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MB_CUR_MAX	(__ctype_get_mb_cur_max())
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
#define RAND_MAX	2147483647


typedef int (*__compar_fn_t) (const void *, const void *);


typedef struct
{
  int quot;
  int rem;
}
div_t;


typedef struct
{
  long quot;
  long rem;
}
ldiv_t;


typedef struct
{
  long long quot;
  long long rem;
}
lldiv_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/file.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define LOCK_SH	1
#define LOCK_EX	2
#define LOCK_NB	4
#define LOCK_UN	8
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/ioctl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define FIONREAD	0x541B
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/ipc.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IPC_PRIVATE	((key_t)0)
#define IPC_RMID	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000
#define IPC_SET	1
#define IPC_STAT	2


struct ipc_perm
{
  key_t __key;
  uid_t uid;
  gid_t gid;
  uid_t cuid;
  gid_t cgid;
  unsigned short mode;
  unsigned short __pad1;
  unsigned short __seq;
  unsigned short __pad2;
  unsigned long __unused1;
  unsigned long __unused2;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/mman.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MAP_FAILED	((void*)-1)
#define PROT_NONE	0x0
#define MAP_SHARED	0x01
#define MAP_PRIVATE	0x02
#define PROT_READ	0x1
#define MAP_FIXED	0x10
#define PROT_WRITE	0x2
#define MAP_ANONYMOUS	0x20
#define PROT_EXEC	0x4
#define MCL_CURRENT	1
#define MS_ASYNC	1
#define MCL_FUTURE	2
#define MS_INVALIDATE	2
#define MS_SYNC	4
#define MAP_ANON	MAP_ANONYMOUS
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/msg.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MSG_NOERROR	010000








struct msqid_ds
{
  struct ipc_perm msg_perm;
  time_t msg_stime;
  unsigned long __unused1;
  time_t msg_rtime;
  unsigned long __unused2;
  time_t msg_ctime;
  unsigned long __unused3;
  unsigned long __msg_cbytes;
  msgqnum_t msg_qnum;
  msglen_t msg_qbytes;
  pid_t msg_lspid;
  pid_t msg_lrpid;
  unsigned long __unused4;
  unsigned long __unused5;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/param.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NOFILE	256
#define MAXPATHLEN	4096
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/poll.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define POLLIN	0x0001
#define POLLPRI	0x0002
#define POLLOUT	0x0004
#define POLLERR	0x0008
#define POLLHUP	0x0010
#define POLLNVAL	0x0020


struct pollfd
{
  int fd;
  short events;
  short revents;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/resource.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define RLIM_INFINITY	(~0UL)
#define RLIM_SAVED_CUR	-1
#define RLIM_SAVED_MAX	-1
#define PRIO_PROCESS	0
#define RLIMIT_CPU	0
#define RUSAGE_SELF	0
#define PRIO_PGRP	1
#define RLIMIT_FSIZE	1
#define PRIO_USER	2
#define RLIMIT_DATA	2
#define RLIMIT_STACK	3
#define RLIMIT_CORE	4
#define RLIMIT_NOFILE	7
#define RLIMIT_AS	9





typedef unsigned long rlim_t;
typedef unsigned long long rlim64_t;


struct rlimit
{
  rlim_t rlim_cur;
  rlim_t rlim_max;
}
 ;
struct rlimit64
{
  rlim64_t rlim_cur;
  rlim64_t rlim_max;
}
 ;


struct rusage
{
  struct timeval ru_utime;
  struct timeval ru_stime;
  long ru_maxrss;
  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/sem.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SEM_UNDO	0x1000
#define GETPID	11
#define GETVAL	12
#define GETALL	13
#define GETNCNT	14
#define GETZCNT	15
#define SETVAL	16
#define SETALL	17


struct sembuf
{
  short sem_num;
  short sem_op;
  short sem_flg;
}
 ;
struct semid_ds
{
  struct ipc_perm sem_perm;
  time_t sem_otime;
  unsigned long __unused1;
  time_t sem_ctime;
  unsigned long __unused2;
  unsigned long sem_nsems;
  unsigned long __unused3;
  unsigned long __unused4;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/shm.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SHMLBA	(__getpagesize())
#define SHM_RDONLY	010000
#define SHM_W	0200
#define SHM_RND	020000
#define SHM_R	0400
#define SHM_REMAP	040000
#define SHM_LOCK	11
#define SHM_UNLOCK	12
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/socket.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SHUT_RD	0
#define MSG_WAITALL	0x100
#define MSG_TRUNC	0x20
#define MSG_EOR	0x80
#define SIOCGIFCONF	0x8912
#define SIOCGIFFLAGS	0x8913
#define SIOCGIFADDR	0x8915
#define SIOCGIFNETMASK	0x891b
#define MSG_OOB	1
#define SHUT_WR	1
#define MSG_PEEK	2
#define SHUT_RDWR	2
#define MSG_DONTROUTE	4
#define MSG_CTRUNC	8
#define PF_LOCAL	AF_LOCAL
#define PF_UNSPEC	AF_UNSPEC


struct linger
{
  int l_onoff;
  int l_linger;
}
 ;
struct cmsghdr
{
  size_t cmsg_len;
  int cmsg_level;
  int cmsg_type;
}
 ;
struct iovec
{
  void *iov_base;
  size_t iov_len;
}
 ;


typedef unsigned short sa_family_t;
typedef unsigned int socklen_t;


struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
}
 ;


struct msghdr
{
  void *msg_name;
  int msg_namelen;
  struct iovec *msg_iov;
  size_t msg_iovlen;
  void *msg_control;
  size_t msg_controllen;
  unsigned int msg_flags;
}
 ;
#define AF_UNSPEC	0
#define AF_LOCAL	1
#define AF_UNIX	1
#define AF_INET6	10
#define AF_INET	2
#define AF_AX25	3
#define AF_IPX	4
#define AF_APPLETALK	5
#define AF_NETROM	6
#define AF_BRIDGE	7
#define AF_ATMPVC	8
#define AF_X25	9



#define PF_INET	AF_INET
#define PF_INET6	AF_INET6
#define PF_UNIX	AF_UNIX



#define SOCK_STREAM	1
#define SOCK_PACKET	10
#define SOCK_DGRAM	2
#define SOCK_RAW	3
#define SOCK_RDM	4
#define SOCK_SEQPACKET	5



#define SOL_IP	0
#define SOL_SOCKET	1
#define SO_DEBUG	1
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SOL_UDP	17
#define SO_REUSEADDR	2
#define SOL_RAW	255
#define SO_TYPE	3
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SOL_TCP	6
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_KEEPALIVE	9
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/stat.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define S_ISBLK(m)	(((m)&amp S_IFMT)==S_IFBLK)
#define S_ISCHR(m)	(((m)&amp S_IFMT)==S_IFCHR)
#define S_ISDIR(m)	(((m)&amp S_IFMT)==S_IFDIR)
#define S_ISFIFO(m)	(((m)&amp S_IFMT)==S_IFIFO)
#define S_ISLNK(m)	(((m)&amp S_IFMT)==S_IFLNK)
#define S_ISREG(m)	(((m)&amp S_IFMT)==S_IFREG)
#define S_ISSOCK(m)	(((m)&amp S_IFMT)==S_IFSOCK)
#define S_TYPEISMQ(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_TYPEISSEM(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_TYPEISSHM(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_IRWXU	(S_IREAD|S_IWRITE|S_IEXEC)
#define S_IROTH	(S_IRGRP>>3)
#define S_IRGRP	(S_IRUSR>>3)
#define S_IRWXO	(S_IRWXG>>3)
#define S_IRWXG	(S_IRWXU>>3)
#define S_IWOTH	(S_IWGRP>>3)
#define S_IWGRP	(S_IWUSR>>3)
#define S_IXOTH	(S_IXGRP>>3)
#define S_IXGRP	(S_IXUSR>>3)
#define S_ISVTX	01000
#define S_IXUSR	0x0040
#define S_IWUSR	0x0080
#define S_IRUSR	0x0100
#define S_ISGID	0x0400
#define S_ISUID	0x0800
#define S_IFIFO	0x1000
#define S_IFCHR	0x2000
#define S_IFDIR	0x4000
#define S_IFBLK	0x6000
#define S_IFREG	0x8000
#define S_IFLNK	0xa000
#define S_IFSOCK	0xc000
#define S_IFMT	0xf000
#define _STAT_VER	3
#define S_IREAD	S_IRUSR
#define S_IWRITE	S_IWUSR
#define S_IEXEC	S_IXUSR


struct stat
{
  dev_t st_dev;
  unsigned short __pad1;
  unsigned long st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  pid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  unsigned short __pad2;
  off_t st_size;
  blksize_t st_blksize;
  blkcnt_t st_blocks;
  time_t st_atime;
  unsigned long __unused1;
  time_t st_mtime;
  unsigned long __unused2;
  time_t st_ctime;
  unsigned long __unused3;
  unsigned long __unused4;
  unsigned long __unused5;
}
 ;
struct stat64
{
  dev_t st_dev;
  unsigned int __pad0;
  ino_t __st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  unsigned int __pad2;
  off64_t st_size;
  blksize_t st_blksize;
  blkcnt64_t st_blocks;
  time_t st_atime;
  unsigned long __unused1;
  time_t st_mtime;
  unsigned long __unused2;
  time_t st_ctime;
  unsigned long __unused3;
  ino64_t st_ino;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/statvfs.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct statvfs
{
  unsigned long f_bsize;
  unsigned long f_frsize;
  fsblkcnt_t f_blocks;
  fsblkcnt_t f_bfree;
  fsblkcnt_t f_bavail;
  fsfilcnt_t f_files;
  fsfilcnt_t f_ffree;
  fsfilcnt_t f_favail;
  unsigned long f_fsid;
  int __f_unused;
  unsigned long f_flag;
  unsigned long f_namemax;
  int __f_spare[6];
}
 ;
struct statvfs64
{
  unsigned long f_bsize;
  unsigned long f_frsize;
  fsblkcnt64_t f_blocks;
  fsblkcnt64_t f_bfree;
  fsblkcnt64_t f_bavail;
  fsfilcnt64_t f_files;
  fsfilcnt64_t f_ffree;
  fsfilcnt64_t f_favail;
  unsigned long f_fsid;
  int __f_unused;
  unsigned long f_flag;
  unsigned long f_namemax;
  int __f_spare[6];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/time.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ITIMER_REAL	0
#define ITIMER_VIRTUAL	1
#define ITIMER_PROF	2


struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
}
 ;








struct timespec
{
  time_t tv_sec;
  long tv_nsec;
}
 ;





struct timeval
{
  time_t tv_sec;
  suseconds_t tv_usec;
}
 ;


struct itimerval
{
  struct timeval it_interval;
  struct timeval it_value;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/timeb.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct timeb
{
  time_t time;
  unsigned short millitm;
  short timezone;
  short dstflag;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/times.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct tms
{
  clock_t tms_utime;
  clock_t tms_stime;
  clock_t tms_cutime;
  clock_t tms_cstime;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/types.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define FD_ISSET(d,set)	((set)->fds_bits[0]&amp (1&lt;&lt;d))
#define FD_CLR(d,set)	((set)->fds_bits[0]&amp =~(1&lt;&lt;d))
#define FD_SET(d,set)	((set)->fds_bits[0]|=(1&lt;&lt;d))
#define FD_SETSIZE	1024
#define FD_ZERO(fdsetp)	bzero(fdsetp, sizeof(*(fdsetp)))


typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef int ssize_t;
typedef unsigned int uid_t;
typedef int pid_t;
typedef unsigned long off_t;
typedef int key_t;
typedef unsigned int id_t;
typedef long suseconds_t;
typedef struct
{
  int __val[2];
}
fsid_t;
typedef unsigned long blksize_t;
typedef long fd_mask;
typedef int timer_t;
typedef int clockid_t;





typedef unsigned long long ino64_t;
typedef long long loff_t;
typedef unsigned long blkcnt_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;
typedef unsigned long long blkcnt64_t;
typedef unsigned long long fsblkcnt64_t;
typedef unsigned long long fsfilcnt64_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned long u_long;


typedef int ino_t;
typedef unsigned int gid_t;
typedef unsigned long long dev_t;
typedef unsigned int mode_t;
typedef int nlink_t;
typedef char *caddr_t;
typedef unsigned short ushort;


typedef struct
{
  unsigned long fds_bits[__FDSET_LONGS];
}
fd_set;


typedef long clock_t;
typedef long time_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/un.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UNIX_PATH_MAX	108


struct sockaddr_un
{
  sa_family_t sun_family;
  char sun_path[UNIX_PATH_MAX];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/utsname.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct utsname
{
  char sysname[65];
  char nodename[65];
  char release[65];
  char version[65];
  char machine[65];
  char domainname[65];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/wait.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define WIFSIGNALED(status)	(!WIFSTOPPED(status) &amp & !WIFEXITED(status))
#define WIFSTOPPED(status)	(((status) &amp  0xff) == 0x7f)
#define WEXITSTATUS(status)	(((status) &amp  0xff00) >> 8)
#define WTERMSIG(status)	((status) &amp  0x7f)
#define WCOREDUMP(status)	((status) &amp  0x80)
#define WIFEXITED(status)	(WTERMSIG(status) == 0)
#define WNOHANG	0x00000001
#define WUNTRACED	0x00000002
#define WCOREFLAG	0x80
#define WSTOPSIG(status)	WEXITSTATUS(status)


typedef enum
{
  P_ALL, P_PID, P_PGID
}
idtype_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>syslog.h</TITLE>
<PARA>
</PARA>
<SCREEN>




#define LOG_EMERG	0
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR	3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7



#define LOG_KERN	(0&lt;&lt;3)
#define LOG_AUTHPRIV	(10&lt;&lt;3)
#define LOG_FTP	(11&lt;&lt;3)
#define LOG_USER	(1&lt;&lt;3)
#define LOG_MAIL	(2&lt;&lt;3)
#define LOG_DAEMON	(3&lt;&lt;3)
#define LOG_AUTH	(4&lt;&lt;3)
#define LOG_SYSLOG	(5&lt;&lt;3)
#define LOG_LPR	(6&lt;&lt;3)
#define LOG_NEWS	(7&lt;&lt;3)
#define LOG_UUCP	(8&lt;&lt;3)
#define LOG_CRON	(9&lt;&lt;3)



#define LOG_LOCAL0	(16&lt;&lt;3)
#define LOG_LOCAL1	(17&lt;&lt;3)
#define LOG_LOCAL2	(18&lt;&lt;3)
#define LOG_LOCAL3	(19&lt;&lt;3)
#define LOG_LOCAL4	(20&lt;&lt;3)
#define LOG_LOCAL5	(21&lt;&lt;3)
#define LOG_LOCAL6	(22&lt;&lt;3)
#define LOG_LOCAL7	(23&lt;&lt;3)



#define LOG_UPTO(pri)	((1 &lt;&lt; ((pri)+1)) - 1)
#define LOG_MASK(pri)	(1 &lt;&lt; (pri))



#define LOG_PID	0x01
#define LOG_CONS	0x02
#define LOG_ODELAY	0x04
#define LOG_NDELAY	0x08
#define LOG_NOWAIT	0x10
#define LOG_PERROR	0x20
</SCREEN>
</SECT2>
<SECT2>
<TITLE>termios.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define TCIFLUSH	0
#define TCOOFF	0
#define TCSANOW	0
#define BS0	0000000
#define CR0	0000000
#define FF0	0000000
#define NL0	0000000
#define TAB0	0000000
#define VT0	0000000
#define OPOST	0000001
#define OLCUC	0000002
#define ONLCR	0000004
#define XCASE	0000004
#define OCRNL	0000010
#define ONOCR	0000020
#define ONLRET	0000040
#define OFILL	0000100
#define OFDEL	0000200
#define NL1	0000400
#define NLDLY	0000400
#define CR1	0001000
#define IUCLC	0001000
#define CR2	0002000
#define CR3	0003000
#define CRDLY	0003000
#define TAB1	0004000
#define TAB2	0010000
#define TAB3	0014000
#define TABDLY	0014000
#define BS1	0020000
#define BSDLY	0020000
#define VT1	0040000
#define VTDLY	0040000
#define FF1	0100000
#define FFDLY	0100000
#define TCOFLUSH	1
#define TCOON	1
#define TCSADRAIN	1
#define TCIOFF	2
#define TCIOFLUSH	2
#define TCSAFLUSH	2
#define TCION	3


struct winsize
{
  unsigned short ws_row;
  unsigned short ws_col;
  unsigned short ws_xpixel;
  unsigned short ws_ypixel;
}
 ;


typedef unsigned int speed_t;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;
#define NCCS	32


struct termios
{
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[NCCS];
  speed_t c_ispeed;
  speed_t c_ospeed;
}
 ;
#define VINTR	0
#define VQUIT	1
#define VSUSP	10
#define VEOL	11
#define VREPRINT	12
#define VDISCARD	13
#define VWERASE	14
#define VLNEXT	15
#define VEOL2	16
#define VERASE	2
#define VKILL	3
#define VEOF	4
#define VMIN	6
#define VSWTC	7
#define VSTART	8
#define VSTOP	9



#define IGNBRK	0000001
#define BRKINT	0000002
#define IGNPAR	0000004
#define PARMRK	0000010
#define INPCK	0000020
#define ISTRIP	0000040
#define INLCR	0000100
#define IGNCR	0000200
#define ICRNL	0000400
#define IXON	0002000
#define IXANY	0004000
#define IXOFF	0010000
#define IMAXBEL	0020000






#define CS5	0000000
#define CS6	0000020
#define CS7	0000040
#define CS8	0000060
#define CSIZE	0000060
#define CSTOPB	0000100
#define CREAD	0000200
#define PARENB	0000400
#define PARODD	0001000
#define HUPCL	0002000
#define CLOCAL	0004000
#define VTIME	5



#define ISIG	0000001
#define ICANON	0000002
#define ECHO	0000010
#define ECHOE	0000020
#define ECHOK	0000040
#define ECHONL	0000100
#define NOFLSH	0000200
#define TOSTOP	0000400
#define ECHOCTL	0001000
#define ECHOPRT	0002000
#define ECHOKE	0004000
#define FLUSHO	0010000
#define PENDIN	0040000
#define IEXTEN	0100000



#define B0	0000000
#define B50	0000001
#define B75	0000002
#define B110	0000003
#define B134	0000004
#define B150	0000005
#define B200	0000006
#define B300	0000007
#define B600	0000010
#define B1200	0000011
#define B1800	0000012
#define B2400	0000013
#define B4800	0000014
#define B9600	0000015
#define B19200	0000016
#define B38400	0000017
</SCREEN>
</SECT2>
<SECT2>
<TITLE>time.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define CLOCK_REALTIME	0
#define TIMER_ABSTIME	1
#define CLOCKS_PER_SEC	1000000l


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long tm_gmtoff;
  char *tm_zone;
}
 ;
struct itimerspec
{
  struct timespec it_interval;
  struct timespec it_value;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ulimit.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UL_GETFSIZE	1
#define UL_SETFSIZE	2
</SCREEN>
</SECT2>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SEEK_SET	0
#define STDIN_FILENO	0
#define SEEK_CUR	1
#define STDOUT_FILENO	1
#define SEEK_END	2
#define STDERR_FILENO	2


typedef long long off64_t;
typedef int *intptr_t;
#define F_OK	0
#define X_OK	1
#define W_OK	2
#define R_OK	4



#define _POSIX_VDISABLE	'\0'
#define _POSIX_ASYNCHRONOUS_IO	1
#define _POSIX_CHOWN_RESTRICTED	1
#define _POSIX_FSYNC	1
#define _POSIX_MAPPED_FILES	1
#define _POSIX_MEMLOCK	1
#define _POSIX_MEMLOCK_RANGE	1
#define _POSIX_MEMORY_PROTECTION	1
#define _POSIX_MESSAGE_PASSING	1
#define _POSIX_NO_TRUNC	1
#define _POSIX_PRIORITY_SCHEDULING	1
#define _POSIX_REALTIME_SIGNALS	1
#define _POSIX_SEMAPHORES	1
#define _POSIX_SHARED_MEMORY_OBJECTS	1
#define _POSIX_SYNCHRONIZED_IO	1
#define _POSIX_TIMERS	1
#define _POSIX2_C_VERSION	199209L
#define _POSIX2_VERSION	199209L
#define _POSIX_VERSION	199506L



#define _PC_LINK_MAX	0
#define _PC_MAX_CANON	1
#define _PC_ASYNC_IO	10
#define _PC_PRIO_IO	11
#define _PC_FILESIZEBITS	13
#define _PC_MAX_INPUT	2
#define _PC_NAME_MAX	3
#define _PC_PATH_MAX	4
#define _PC_PIPE_BUF	5
#define _PC_CHOWN_RESTRICTED	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_SYNC_IO	9



#define _SC_ARG_MAX	0
#define _SC_CHILD_MAX	1
#define _SC_PRIORITY_SCHEDULING	10
#define _SC_TIMERS	11
#define _SC_ASYNCHRONOUS_IO	12
#define _SC_XBS5_ILP32_OFF32	125
#define _SC_XBS5_ILP32_OFFBIG	126
#define _SC_XBS5_LP64_OFF64	127
#define _SC_XBS5_LPBIG_OFFBIG	128
#define _SC_XOPEN_LEGACY	129
#define _SC_PRIORITIZED_IO	13
#define _SC_XOPEN_REALTIME	130
#define _SC_SYNCHRONIZED_IO	14
#define _SC_MAPPED_FILES	16
#define _SC_MEMLOCK	17
#define _SC_MEMLOCK_RANGE	18
#define _SC_MEMORY_PROTECTION	19
#define _SC_CLK_TCK	2
#define _SC_MESSAGE_PASSING	20
#define _SC_SEMAPHORES	21
#define _SC_SHARED_MEMORY_OBJECTS	22
#define _SC_AIO_LISTIO_MAX	23
#define _SC_AIO_MAX	24
#define _SC_AIO_PRIO_DELTA_MAX	25
#define _SC_DELAYTIMER_MAX	26
#define _SC_MQ_OPEN_MAX	27
#define _SC_MQ_PRIO_MAX	28
#define _SC_VERSION	29
#define _SC_NGROUPS_MAX	3
#define _SC_PAGESIZE	30
#define _SC_RTSIG_MAX	31
#define _SC_SEM_NSEMS_MAX	32
#define _SC_SEM_VALUE_MAX	33
#define _SC_SIGQUEUE_MAX	34
#define _SC_TIMER_MAX	35
#define _SC_BC_BASE_MAX	36
#define _SC_BC_DIM_MAX	37
#define _SC_BC_SCALE_MAX	38
#define _SC_BC_STRING_MAX	39
#define _SC_OPEN_MAX	4
#define _SC_COLL_WEIGHTS_MAX	40
#define _SC_EXPR_NEST_MAX	42
#define _SC_LINE_MAX	43
#define _SC_RE_DUP_MAX	44
#define _SC_2_VERSION	46
#define _SC_2_C_BIND	47
#define _SC_2_C_DEV	48
#define _SC_2_FORT_DEV	49
#define _SC_STREAM_MAX	5
#define _SC_2_FORT_RUN	50
#define _SC_2_SW_DEV	51
#define _SC_2_LOCALEDEF	52
#define _SC_TZNAME_MAX	6
#define _SC_THREADS	67
#define _SC_THREAD_SAFE_FUNCTIONS	68
#define _SC_JOB_CONTROL	7
#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
#define _SC_THREAD_KEYS_MAX	74
#define _SC_THREAD_STACK_MIN	75
#define _SC_THREAD_THREADS_MAX	76
#define _SC_THREAD_ATTR_STACKADDR	77
#define _SC_THREAD_ATTR_STACKSIZE	78
#define _SC_THREAD_PRIORITY_SCHEDULING	79
#define _SC_SAVED_IDS	8
#define _SC_THREAD_PRIO_INHERIT	80
#define _SC_THREAD_PRIO_PROTECT	81
#define _SC_THREAD_PROCESS_SHARED	82
#define _SC_PASS_MAX	88
#define _SC_XOPEN_VERSION	89
#define _SC_REALTIME_SIGNALS	9
#define _SC_XOPEN_CRYPT	92
#define _SC_XOPEN_ENH_I18N	93
#define _SC_XOPEN_SHM	94
#define _SC_2_C_VERSION	96
#define _SC_2_UPE	97



#define _CS_PATH	0
#define _CS_XBS5_ILP32_OFF32_CFLAGS	1100
#define _CS_XBS5_ILP32_OFF32_LDFLAGS	1101
#define _CS_XBS5_ILP32_OFF32_LIBS	1102
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS	1103
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS	1104
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS	1105
#define _CS_XBS5_ILP32_OFFBIG_LIBS	1106
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS	1107
#define _CS_XBS5_LP64_OFF64_CFLAGS	1108
#define _CS_XBS5_LP64_OFF64_LDFLAGS	1109
#define _CS_XBS5_LP64_OFF64_LIBS	1110
#define _CS_XBS5_LP64_OFF64_LINTFLAGS	1111
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS	1112
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS	1113
#define _CS_XBS5_LPBIG_OFFBIG_LIBS	1114
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS	1115



#define _XOPEN_REALTIME	1
#define _XOPEN_XPG4	1
#define _XOPEN_XCU_VERSION	4
#define _XOPEN_VERSION	500
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utime.h</TITLE>
<PARA>
</PARA>
<SCREEN>



struct utimbuf
{
  time_t actime;
  time_t modtime;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UT_HOSTSIZE	256
#define UT_LINESIZE	32
#define UT_NAMESIZE	32


struct exit_status
{
  short e_termination;
  short e_exit;
}
 ;
struct lastlog
{
  timer_t ll_time;
  char ll_line[UT_LINESIZE];
  char ll_host[UT_HOSTSIZE];
}
 ;


struct utmp
{
  short ut_type;
  pid_t ut_pid;
  char ut_line[UT_LINESIZE];
  char ut_id[4];
  char ut_user[UT_NAMESIZE];
  char ut_host[UT_HOSTSIZE];
  struct exit_status ut_exit;
  long ut_session;
  struct timeval ut_tv;
  int32_t ut_addr_v6[4];
  char __unused[20];
}
 ;
#define EMPTY	0
#define RUN_LVL	1
#define BOOT_TIME	2
#define NEW_TIME	3
#define OLD_TIME	4
#define INIT_PROCESS	5
#define LOGIN_PROCESS	6
#define USER_PROCESS	7
#define DEAD_PROCESS	8
#define ACCOUNTING	9
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wchar.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define WEOF	(0xffffffffu)
#define WCHAR_MAX	0x7FFFFFFF
#define WCHAR_MIN	0x80000000
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>



typedef unsigned long wctype_t;
typedef unsigned int wint_t;
typedef int wctrans_t;
typedef struct
{
  int count;
  wint_t value;
}
mbstate_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wordexp.h</TITLE>
<PARA>
</PARA>
<SCREEN>






enum
{
  WRDE_DOOFFS, WRDE_APPEND, WRDE_NOCMD, WRDE_REUSE, WRDE_SHOWERR, WRDE_UNDEF,
    __WRDE_FLAGS
}
 ;


typedef struct
{
  int we_wordc;
  char **we_wordv;
  int we_offs;
}
wordexp_t;


enum
{
  WRDE_NOSYS, WRDE_NOSPACE, WRDE_BADCHAR, WRDE_BADVAL, WRDE_CMDSUB,
    WRDE_SYNTAX
}
 ;
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libcman>
<TITLE>Interfaces Definitions for libc</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib--IO-feof-3"> <REFMETA>
<REFENTRYTITLE>_IO_feof</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_feof
</REFNAME>
<REFPURPOSE>
alias for feof
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_feof(_IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The function _IO_feof() tests the end-of-file indicator for the stream pointed to by __fp, returning non-zero if it is set.  
</PARA>
<PARA>
_IO_feof is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-getc-3"> <REFMETA>
<REFENTRYTITLE>_IO_getc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_getc
</REFNAME>
<REFPURPOSE>
alias for getc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_getc(_IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_getc() reads the next character from __fp and returns it as an unsigned char
cast to an int, or EOF on end of file or error.
</PARA>
<PARA>
_IO_getc is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-putc-3"> <REFMETA>
<REFENTRYTITLE>_IO_putc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_putc
</REFNAME>
<REFPURPOSE>
alias for putc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_putc(int __c, _IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_putc() writes the character __c, cast to an unsigned char, to __fp.
</PARA>
<PARA>
_IO_putc is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-puts-3"> <REFMETA>
<REFENTRYTITLE>_IO_puts</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_puts
</REFNAME>
<REFPURPOSE>
alias for puts
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_puts(const char *__c);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_puts() writes the string __s and a trailing newline to stdout.
</PARA>
<PARA>
_IO_puts is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---assert-fail-1"> <REFMETA>
<REFENTRYTITLE>__assert_fail</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__assert_fail
</REFNAME>
<REFPURPOSE>abort the program after false assertion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 January 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
void
__assert_fail(const char *<REPLACEABLE CLASS="PARAMETER">assertion</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">file</REPLACEABLE>,
              unsigned int <REPLACEABLE CLASS="PARAMETER">line</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">function</REPLACEABLE>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>30 January 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function, when passed a string containing an asserted expression, a filename, and a line number, prints a message on the standard error stream such as:
<BLOCKQUOTE>
<PARA>
a.c:10: foobar: Assertion a == b failed.
</PARA>
</BLOCKQUOTE>
It then aborts program execution via a call to <FUNCTION>abort</FUNCTION>. The exact form of the message is up to the implementation.
</PARA>
<PARA>
If FUNCTION is NULL, then omit information about the function.
</PARA><PARA>
FILE, LINE, and ASSERTION must be non-NULL.
</PARA>
<PARA>
__assert_fail is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---ctype-b"> <REFMETA>
<REFENTRYTITLE>__ctype_b</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_c</REFNAME>
<REFPURPOSE>
array index for ctype functions
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

extern const unsigned short int *ctype_b;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Array index for ctype functions.
</PARA>

<PARA>
__ctype_b is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---ctype-get-mb-cur-max-1"> <REFMETA>
<REFENTRYTITLE>__ctype_get_mb_cur_max</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_get_mb_cur_max</REFNAME>
<REFPURPOSE>
maximum length of a multibyte character in the current locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
size_t __ctype_get_mb_cur_max(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__ctype_get_mb_cur_max() returns the maximum length of a multibyte character in the current locale.
</PARA>
<PARA>
__ctype_get_mb_cur_max is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---ctype-tolower-2"> <REFMETA>
<REFENTRYTITLE>__ctype_tolower</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_tolower
</REFNAME>
<REFPURPOSE>convert uppercase letter to lowercase letter
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __ctype_tolower(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __ctype_tolower() function converts an uppercase letter to the corresponding lowercase letter. If the argument is an uppercase letter, the __ctype_tolower() function returns the corresponding lowercase letter if there is one; otherwise, the argument is returned unchanged.
</PARA>
<PARA>
__ctype_tolower is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---ctype-toupper-2"> <REFMETA>
<REFENTRYTITLE>__ctype_toupper</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_toupper
</REFNAME>
<REFPURPOSE>convert lowercase letter to uppercase letter
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __ctype_toupper(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __ctype_toupper() function converts a lowercase letter to the corresponding uppercase letter. If the argument is a lowercase letter, the __ctype_toupper() function returns the corresponding uppercase letter if there is one; otherwise, the argument is returned unchanged.
</PARA>
<PARA>
__ctype_toupper is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---cxa-atexit"> <REFMETA>
<REFENTRYTITLE>__cxa_atexit</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__cxa_atexit</REFNAME>
<REFPURPOSE>
register a function to be called by exit or when a shared library is unloaded
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __cxa_atexit(void (*func) (void *), void *arg, void *d);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Register a function to be called by exit or when a shared library is unloaded. This function is only called from code generated by the C++ compiler. 
</PARA>

<PARA>
__cxa_atexit() has the same specification as atexit().
</PARA>
<PARA>
__cxa_atexit is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-daylight-1"> <REFMETA>
<REFENTRYTITLE>__daylight</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>
</REFNAME>
<REFPURPOSE>
global variable containing daylight
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __daylight;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "__daylight" is as specified in the Single UNIX
Specification, Version 2.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---dcgettext"> <REFMETA>
<REFENTRYTITLE>__dcgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__dcgettext</REFNAME>
<REFPURPOSE>
used by dcgettext in the translation to look up the MSGID in the DOMAINNAME message catalog for the current locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *__dcgettext(const char *domainname,
                         const char *msgid, int category);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used by dcgettext in the translation to look up the MSGID in the DOMAINNAME message catalog for the current locale category CATEGORY of the current locale.
</PARA>

<PARA>
__dcgettext() has the same specification as dcgettext().
</PARA>
<PARA>
__dcgettext is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---environ"> <REFMETA>
<REFENTRYTITLE>__environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char **__environ;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Alias for environ - user environment.
</PARA>

<PARA>
__environ has the same specification as environ.
</PARA>
<PARA>
__environ is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-errno-location-1"> <REFMETA>
<REFENTRYTITLE>__errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__errno_location
</REFNAME>
<REFPURPOSE>address of errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int *__errno_location(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA><PARA>
__errno_location is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---fpending"> <REFMETA>
<REFENTRYTITLE>__fpending</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__fpending</REFNAME>
<REFPURPOSE>
returns in bytes the amount of output pending on a stream
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio_ext.h>

size_t __fpending(FILE *stream);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __fpending function returns the amount of output in bytes pending on a stream.
</PARA>

<PARA>
__fpending is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<!-- content in __xstat.sgml -->

<!-- content in __xstat64.sgml -->

<REFENTRY ID="baselib---getpagesize"> <REFMETA>
<REFENTRYTITLE>__getpagesize</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpagesize</REFNAME>
<REFPURPOSE>
alias for getpagesize - get current page size 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int __getpagesize(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Alias for getpagesize - get current page size.
</PARA>

<PARA>
__getpagesize has the same specification as getpagesize.
</PARA>
<PARA>
__getpagesize is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---getpgid-1"> <REFMETA>
<REFENTRYTITLE>__getpgid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpgid</REFNAME>
<REFPURPOSE>
get the process group id
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
pid_t __getpgid(pid_t pid);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__getpgid(pid) has the same specification as getpgid(pid).
</PARA>
<PARA>
__getpgid is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-h-errno-location-1"> <REFMETA>
<REFENTRYTITLE>__h_errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__h_errno_location
</REFNAME>
<REFPURPOSE>address of h_errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int *__h_errno_location (void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Return the address of the h_errno variable, where h_errno is as
specified in the Single Unix Specification.  Only in the binary
standard, not the source standard.  Note that h_errno itself
is only in the source standard, not the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinf"> <REFMETA>
<REFENTRYTITLE>__isinf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinf</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isinf(double arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isinf function is like the isinf function as found in the Single
UNIX Specification, Version 3,
except that the argument type is known to be double.  The __isinf
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinff"> <REFMETA>
<REFENTRYTITLE>__isinff</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinff</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isinff(float arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isinff function is like the isinf function as found in the
Single UNIX Specification, Version 3,
except that the argument type is known to be float.  The __isinff
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinfl"> <REFMETA>
<REFENTRYTITLE>__isinfl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinfl</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isinfl(long double arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isinfl function is like the isinf function as found in the
Single UNIX Specification, Version 3,
except that the argument type is known to be long double.  The __isinfl
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnan"> <REFMETA>
<REFENTRYTITLE>__isnan</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnan</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isnan(double arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isnan function is like the isnan function as found in the Single
UNIX Specification, Version 3,
except that the argument type is known to be double.  The __isnan
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnanf"> <REFMETA>
<REFENTRYTITLE>__isnanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnanf</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isnanf(float arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isnanf function is like the isnan function as found in the
Single UNIX Specification, Version 3,
except that the argument type is known to be float.  The __isnanf
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnanl"> <REFMETA>
<REFENTRYTITLE>__isnanl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnanl</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __isnanl(long double arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __isnanl function is like the isnan function as found in the
Single UNIX Specification, Version 3,
except that the argument type is known to be long double.  The __isnanl
function is in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-current-sigrtmax-1"> <REFMETA>
<REFENTRYTITLE>__libc_current_sigrtmax</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_current_sigrtmax</REFNAME>
<REFPURPOSE>return number of available real-time signal with lowest priority
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __libc_current_sigrtmax(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__libc_current_sigrtmax() returns the number of an available real-time signal with the lowest priority.
</PARA>
<PARA>
__libc_current_sigrtmax is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-current-sigrtmin-1"> <REFMETA>
<REFENTRYTITLE>__libc_current_sigrtmin</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_current_sigrtmin</REFNAME>
<REFPURPOSE>
return number of available real-time signal with highest priority
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __libc_current_sigrtmin(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__libc_current_sigrtmin() returns the number of an available real-time signal with the highest priority
</PARA>
<PARA>
__libc_current_sigrtmin is not in the source standard; it is only in the binary standard
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-start-main-"> <REFMETA>
<REFENTRYTITLE>__libc_start_main</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_start_main
</REFNAME>
<REFPURPOSE>
initialization routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
BP_SYM __libc_start_main (int (*main) (int, char**, char**),
    int argc, char *__unbounded *__unbounded ubp_av,
    void (*init) (void), void (*fini) (void),
    void (*rtld_fini) (void), void (*__unbounded stack_end);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Initialize glibc.
</PARA>
<PARA>
__libc_start_main is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="libutil---lxstat-2"> <REFMETA>
<REFENTRYTITLE>__lxstat</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__lxstat
</REFNAME>
<REFPURPOSE>inline wrapper around call to lxstat
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __lxstat(int version, char *__path, struct stat *__statbuf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Inline wrapper around call to lxstat.
</PARA>
<PARA>
__lxstat is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- content in __xstat64.sgml -->

<REFENTRY ID="baselib---mempcpy"> <REFMETA>
<REFENTRYTITLE>__mempcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__mempcpy</REFNAME>
<REFPURPOSE>
copy given number of bytes of source to destination
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern ptr_t __mempcpy(ptr_t restrict dest,
                       const ptr_t restrict src, size_t n));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Copy n bytes of source to destination, returning pointer to bytes after the last written byte.
</PARA>

<PARA>
__mempcpy is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---rawmemchr"> <REFMETA>
<REFENTRYTITLE>__rawmemchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__rawmemchr</REFNAME>
<REFPURPOSE>
scan memory
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern ptr_t __rawmemchr(const ptr_t s, int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__rawmemchr searches in s for c.
</PARA><PARA>
This is a weak alias to rawmemchr. It is similar to memchr, but there is no length limit. 
</PARA>

<PARA>
__rawmemchr is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---sigsetjmp-1"> <REFMETA>
<REFENTRYTITLE>__sigsetjmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sigsetjmp</REFNAME>
<REFPURPOSE>
save stack context for non-local goto
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int __sigsetjmp(jmp_buf env, int savemask);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
__sigsetjmp(env, savemask) has the same behavior as sigsetjmp(env,
savemask) as specified by the Single UNIX Specification, Version 2.
</PARA>
<PARA>
__sigsetjmp is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---stpcpy-2"> <REFMETA>
<REFENTRYTITLE>__stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__stpcpy
</REFNAME>
<REFPURPOSE>copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char * __stpcpy(char *dest, const char *src);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __stpcpy() function copies the string pointed to by src (including the terminating /0 character) to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
__stpcpy() returns a pointer to the end of the string dest (that is, the address of the terminating null character) rather than the beginning.
</PARA>
<PARA>
__stpcpy() has the same specification as stpcpy().
</PARA>
<PARA>
__stpcpy is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strdup-1"> <REFMETA>
<REFENTRYTITLE>__strdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strdup</REFNAME>
<REFPURPOSE>
alias for strdup
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
char *__strdup(__const char *<REPLACEABLE CLASS="PARAMETER" >string</REPLACEABLE>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__strdup(string) has the same specification as strdup(string).
</PARA>
<PARA>
__strdup is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtod-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtod_internal
</REFNAME>
<REFPURPOSE>underlying function for strtod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
double __strtod_internal(const char *__nptr,
                         char **__endptr,
                         int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined. 
</PARA><PARA>
__strtod_internal(__nptr, __endptr, __group) has the same specification as strtod(__nptr, __endptr).
</PARA><PARA>
__strtod_internal is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtof-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtof_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtof_internal
</REFNAME>
<REFPURPOSE>underlying function for strtof
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
float __strtof_internal (const char *__nptr,
                         char **__endptr, int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined.
Otherwise the same as
strtof (__nptr, __endptr).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtok-r-1"> <REFMETA>
<REFENTRYTITLE>__strtok_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtok_r</REFNAME>
<REFPURPOSE>
alias for strtok_r
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
char *__strtok_r(char *__restrict s,
                __const char *__restrict delim,
                char **__restrict save_ptr);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__strtok_r(s, delim, save_ptr) has the same specification as strtok_r(s, delim, save_ptr).
</PARA>
<PARA>
__strtok_r is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtol-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtol_internal
</REFNAME>
<REFPURPOSE>alias for strtol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
long int __strtol_internal(const char *__nptr, char **__endptr,
                           int __base, int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__GROUP must be 0 or the behavior is undefined.  
</PARA><PARA>
__strtol_internal(__nptr, __endptr, __base, __group) has the same specification as strtol(__nptr, __endptr, __base).
</PARA><PARA>
__strtol_internal is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtold-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtold_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtold_internal</REFNAME>
<REFPURPOSE>underlying function for strtold
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long double __strtold_internal(const char *__nptr,
                               char **__endptr,
                               int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined.
Otherwise the same as
strtold (__nptr, __endptr).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtoll-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtoll_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoll_internal</REFNAME>
<REFPURPOSE>underlying function for strtoll
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long long __strtoll_internal(const char *__nptr,
                             char **__endptr,
                             int __base,
                             int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined.
Otherwise the same as
strtoll (__nptr, __endptr, __base).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtoul-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtoul_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoul_internal
</REFNAME>
<REFPURPOSE>underlying function for strtoul
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
unsigned long int __strtoul_internal (const char *__nptr,
                                      char **__endptr, int __base,
                                      int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined.
Otherwise the same as
strtoul (__nptr, __endptr, __base).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtoull-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtoull_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoull_internal</REFNAME>
<REFPURPOSE>underlying function for strtoull
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
unsigned long long __strtoull_internal(const char *__nptr,
                                      char **__endptr, int __base,
                                      int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The __group argument must be 0 or the behavior is undefined.
Otherwise the same as
strtoull (__nptr, __endptr, __base).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---sysconf"> <REFMETA>
<REFENTRYTITLE>__sysconf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sysconf</REFNAME>
<REFPURPOSE>
get configuration information at runtime
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

long __sysconf(int name);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Get configuration information at runtime.
</PARA><PARA>
This is weak alias to sysconf.
</PARA>

<PARA>
__sysconf(name) has the same specification as sysconf(name).
</PARA>
<PARA>
__sysconf is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---sysv-signal-1"> <REFMETA>
<REFENTRYTITLE>__sysv_signal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sysv_signal</REFNAME>
<REFPURPOSE>
signal handling
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
__sighandler_t __sysv_signal(int sig, __sighandler_t handler);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__sysv_signal(sig, handler) has the same behavior as signal(sig, handler) as specified by X/Open.
</PARA>
<PARA>
__sysv_signal is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-timezone-1"> <REFMETA>
<REFENTRYTITLE>__timezone</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>
</REFNAME>
<REFPURPOSE>
global variable containing timezone
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long int __timezone;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "__timezone" is the same as "timezone" as
specified in the Single UNIX Specification.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-tzname-1"> <REFMETA>
<REFENTRYTITLE>__tzname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>
</REFNAME>
<REFPURPOSE>
global variable containing the timezone
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
char *__tzname[2];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "__tzname" is the same as "tzname" as specified
in the Single UNIX Specification (note that the array size is two;
this is explicit in Version 3 of the Single UNIX Specification but not
Version 2).
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstod-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstod_internal</REFNAME>
<REFPURPOSE>underlying function for wcstod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
double __wcstod_internal(const wchar_t *nptr,
                         wchar_t **endptr,
                         int group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The group argument must be 0 or the behavior is undefined.  Otherwise
the same as wcstod(nptr, endptr).  Only in the binary standard, not
the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstof-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstof_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstof_internal</REFNAME>
<REFPURPOSE>underlying function for wcstof
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
float __wcstof_internal(const wchar_t *nptr,
                        wchar_t **endptr,
                        int group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The group argument must be 0 or the behavior is undefined.  Otherwise
the same as wcstof(nptr, endptr).  Only in the binary standard, not
the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstol-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstol_internal</REFNAME>
<REFPURPOSE>underlying function for wcstol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long __wcstol_internal(const wchar_t *nptr,
                       wchar_t ** endptr,
                       int base,
                       int group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The group argument must be 0 or the behavior is undefined.  Otherwise
the same as wcstol(nptr, endptr, base).  Only in the binary standard, not
the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstold-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstold_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstold_internal</REFNAME>
<REFPURPOSE>underlying function for wcstold
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long double __wcstold_internal(const wchar_t *nptr,
                               wchar_t ** endptr,
                               int group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The group argument must be 0 or the behavior is undefined.  Otherwise
the same as wcstold(nptr, endptr).  Only in the binary standard, not
the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstoul-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstoul_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstoul_internal</REFNAME>
<REFPURPOSE>underlying function for wcstoul
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
unsigned long
__wcstoul_internal(const wchar_t *restrict nptr,
                   wchar_t **restrict endptr,
                   int base, int group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The group argument must be 0 or the behavior is undefined.  Otherwise
the same as wcstoul(nptr, endptr, base).  Only in the binary standard, not
the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xmknod-1"> <REFMETA>
<REFENTRYTITLE>__xmknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xmknod</REFNAME>
<REFPURPOSE>
make block or character special file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __xmknod(int ver,
            __const char *path,
            __mode_t mode,
            __dev_t *dev);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
ver must be 1 or the behavior is undefined.
</PARA>
<PARA>
__xmknod(1, path, mode, dev) has the same specification as mknod(path, mode, dev).
</PARA>
<PARA>
Note that the format of dev_t is not the same as the argument that the kernel syscall uses.
</PARA>
<PARA>
__xmknod is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-xstat-1"> <REFMETA>
<REFENTRYTITLE>__xstat</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xstat
</REFNAME>
<REFPURPOSE>provide inode information
</REFPURPOSE>
<INDEXTERM ID="ix-baselib-xstat-1"><PRIMARY>stat</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat-2"><PRIMARY>xstat</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 1996</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/stat.h>
#include &lt;unistd.h>

int __xstat (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
             const char *<REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>,
             struct stat *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)

int __lxstat (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>,
              struct stat *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)

int __fxstat (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
              int <REPLACEABLE CLASS="PARAMETER">__filedesc</REPLACEABLE>,
              struct stat *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)
</SYNOPSIS>
<REFSECT2>
<TITLE>Inputs
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>Must be 3 or the behavior is undefined.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in POSIX.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__filedesc</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in POSIX.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in POSIX.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT2></REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>5 March 1996</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA><FUNCTION>__xstat()</FUNCTION> has the same behavior as stat
(__filename, __stat_buf) as specified by POSIX.
</PARA>
<PARA><FUNCTION>__lxstat()</FUNCTION> has the same behavior as lstat
(__filename, __stat_buf) as specified by POSIX.
</PARA>
<PARA><FUNCTION>__fxstat()</FUNCTION> has the same behavior as fstat
(__filedesc, __stat_buf) as specified by POSIX.
</PARA>
<PARA>
Note that the struct stat used by these functions is not the one
that the kernel uses.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Usage
</TITLE>
<PARA>
<FUNCTION>__xstat</FUNCTION>, <FUNCTION>__lxstat</FUNCTION>, and
<FUNCTION>__fxstat</FUNCTION> are not in the source standard;
<FUNCTION>stat</FUNCTION>, <FUNCTION>lstat</FUNCTION>, and
<FUNCTION>fstat</FUNCTION> are not in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-xstat64-1"> <REFMETA>
<REFENTRYTITLE>__xstat64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xstat64
</REFNAME>
<REFPURPOSE>provide inode information
</REFPURPOSE>
<INDEXTERM ID="ix-baselib-xstat64-1"><PRIMARY>stat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-2"><PRIMARY>lstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-3"><PRIMARY>fstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-4"><PRIMARY>__xstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-5"><PRIMARY>__lxstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-6"><PRIMARY>__fxstat64</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Mar 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _LARGEFILE_SOURCE 1
#include &lt;sys/stat.h>
#include &lt;unistd.h>

int __xstat64 (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
             const char *<REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>,
             struct stat64 *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)

int __lxstat64 (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>,
              struct stat64 *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)

int __fxstat64 (int <REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>,
              int <REPLACEABLE CLASS="PARAMETER">__filedesc</REPLACEABLE>,
              struct stat64 *<REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>)
</SYNOPSIS>
<REFSECT2>
<TITLE>Inputs
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__ver</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>Must be 3 or the behavior is undefined.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__filename</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in Large File Summit.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__filedesc</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in Large File Summit.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><REPLACEABLE CLASS="PARAMETER">__stat_buf</REPLACEABLE>
</TERM>
<LISTITEM>
<PARA>As in Large File Summit.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT2></REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA><FUNCTION>__xstat64()</FUNCTION> has the same behavior as stat64
(__filename, __stat_buf) as specified by Large File Summit.
</PARA>
<PARA><FUNCTION>__lxstat64()</FUNCTION> has the same behavior as lstat64
(__filename, __stat_buf) as specified by Large File Summit.
</PARA>
<PARA><FUNCTION>__fxstat64()</FUNCTION> has the same behavior as fstat64
(__filedesc, __stat_buf) as specified by Large File Summit.
</PARA>
<!--
FIXME: are we clear on specifying the correct struct stat64,
rather than the kernel one?
-->
</REFSECT1>
<REFSECT1>
<TITLE>Usage
</TITLE>
<PARA>
<FUNCTION>__xstat64</FUNCTION>, <FUNCTION>__lxstat64</FUNCTION>, and
<FUNCTION>__fxstat64</FUNCTION> are not in the source standard;
<FUNCTION>stat64</FUNCTION>, <FUNCTION>lstat64</FUNCTION>, and
<FUNCTION>fstat64</FUNCTION> are not in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--environ"> <REFMETA>
<REFENTRYTITLE>_environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char **_environ;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Alias for environ - user environment.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--nl-msg-cat-cntr"> <REFMETA>
<REFENTRYTITLE>_nl_msg_cat_cntr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_nl_msg_cat_cntr</REFNAME>
<REFPURPOSE>
variable defined in loadmsgcat.c which gets incremented every time a new catalog is loaded
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern int _nl_msg_cat_cntr;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used by Message catalogs for internationalization. A variable defined which gets incremented every time a new catalog is loaded.  
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--obstack-begin"> <REFMETA>
<REFENTRYTITLE>_obstack_begin</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_obstack_begin</REFNAME>
<REFPURPOSE>
initialize an obstack for use
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

extern int _obstack_begin(struct obstack *, int, int,
                          void *(*) (long), void (*) (void *));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Initialize an obstack for use.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--obstack-newchunk"> <REFMETA>
<REFENTRYTITLE>_obstack_newchunk</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_obstack_newchunk</REFNAME>
<REFPURPOSE>
allocate a new current chunk of memory for the obstack
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

extern void _obstack_newchunk(struct obstack *, int);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Allocate a new current chunk of memory for the obstack. 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--sys-errlist"> <REFMETA>
<REFENTRYTITLE>_sys_errlist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_errlist</REFNAME>
<REFPURPOSE>
array containing the "C" locale strings used by strerror()
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern const char *const _sys_errlist[];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
An array containing the "C" locale strings used by strerror(). This normally should not be used directly. The strerror function provides all the needed functionality.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--sys-siglist"> <REFMETA>
<REFENTRYTITLE>_sys_siglist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_siglist</REFNAME>
<REFPURPOSE>
array containing the names of the signal names
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

extern const char *const _sys_siglist[NSIG];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
An array containing the names of the signal names.
</PARA><PARA>
This exists only for compatibility. Use strsignal instead (see &lt;string.h>).
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-acct-3"> <REFMETA>
<REFENTRYTITLE>acct</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>acct</REFNAME>
<REFPURPOSE>
switch process accounting on or off
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

int acct(const char *filename);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When called with the name of an existing file as argument, accounting is turned on and records for each terminating process are appended to filename as it terminates. An argument of NULL causes accounting to be turned off.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
BSD process accounting has not been enabled when the operating system kernel was compiled.  The kernel configuration parameter controlling this feature is CONFIG_BSD_PROCESS_ACCT.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process has no permission to enable process accounting.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
The argument filename is not a regular file.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
Error writing to the file filename.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EUSERS 
</TERM>
<LISTITEM>
<PARA>
There are no more free file structures or we run out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-adjtime-2"> <REFMETA>
<REFENTRYTITLE>adjtime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtime
</REFNAME>
<REFPURPOSE>
correct the time to allow synchronization of the system clock
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;time.h>

int adjtime(const struct timeval *delta, struct timeval *olddelta);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The adjtime function makes small adjustments to the system time, as
returned by gettimeofday(2), advancing or retarding it by the time
specified by the timeval delta. If delta is negative, the clock is
slowed down by incrementing it more slowly than normal until the
correction is complete. If delta is positive, a larger increment than
normal is used. The skew used to perform the correction is generally a
fraction of one percent. Thus, the time is always a monotonically
increasing function. A time correction from an earlier call to
adjtime() may not be finished when adjtime() is called again. If
olddelta is non-nil, the structure pointed to will contain, upon
return, the number of microseconds still to be corrected from the
earlier call.
</PARA>
<PARA>
This call may be used by time servers that synchronize the clocks of computers in a local area network.  Such time servers would slow down the clocks of some machines and speed up the clocks of others to bring them to the average network time.
</PARA><PARA>
The call adjtime() is restricted to the super-user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
An argument points outside the process's allocated address space.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The process's effective user ID is not that of the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-adjtimex-3"> <REFMETA>
<REFENTRYTITLE>adjtimex</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtimex</REFNAME>
<REFPURPOSE>
tune kernel clock
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/timex.h>

int adjtimex(struct timex *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Linux uses David L. Mills' clock adjustment algorithm (see RFC 1305). The system call adjtimex reads and optionally sets adjustment parameters for this algorithm. It takes a pointer to a timex structure, updates kernel parameters from field values, and returns the same structure with current kernel values. This structure is declared as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct timex {
</TERM>
<LISTITEM>
<PARA>
                  int modes;           /* mode selector */
</PARA><PARA>
                  long offset;         /* time offset (usec) */
</PARA><PARA>
                  long freq;           /* frequency offset (scaled ppm) */
</PARA><PARA>
                  long maxerror;       /* maximum error (usec) */
</PARA><PARA>
                  long esterror;       /* estimated error (usec) */
</PARA><PARA>
                  int status;          /* clock command/status */
</PARA><PARA>
                  long constant;       /* pll time constant */
</PARA><PARA>
                  long precision;      /* clock precision (usec) (read only) */
</PARA><PARA>
                  long tolerance;      /* clock frequency tolerance (ppm)
                                          (read only) */
</PARA><PARA>
                  struct timeval time; /* current time (read only) */
</PARA><PARA>
                  long tick;           /* usecs between clock ticks */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
The modes field determines which parameters, if any, to set. It may contain a bitwise-or combination of zero or more of the following bits:
</PARA><PARA>
              #define ADJ_OFFSET            0x0001 /* time offset */
</PARA><PARA>
              #define ADJ_FREQUENCY         0x0002 /* frequency offset */
</PARA><PARA>
              #define ADJ_MAXERROR          0x0004 /* maximum time error */
</PARA><PARA>
              #define ADJ_ESTERROR          0x0008 /* estimated time error */
</PARA><PARA>
              #define ADJ_STATUS            0x0010 /* clock status */
</PARA><PARA>
              #define ADJ_TIMECONST         0x0020 /* pll time constant */
</PARA><PARA>
              #define ADJ_TICK              0x4000 /* tick value */
</PARA><PARA>
              #define ADJ_OFFSET_SINGLESHOT 0x8001 /* old-fashioned adjtime */
</PARA><PARA>
Ordinary users are restricted to a zero value for mode. Only the superuser may set any parameters.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, adjtimex returns the clock state:
</PARA><PARA>

              #define TIME_OK   0 /* clock synchronized */
</PARA><PARA>
              #define TIME_INS  1 /* insert leap second */
</PARA><PARA>
              #define TIME_DEL  2 /* delete leap second */
</PARA><PARA>
              #define TIME_OOP  3 /* leap second in progress */
</PARA><PARA>
              #define TIME_WAIT 4 /* leap second has occurred */
</PARA><PARA>
              #define TIME_BAD  5 /* clock not synchronized */
</PARA><PARA>

On error, -1 is returned, and errno is set appropriately.
</PARA>

</REFSECT1><REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
buf does not point to writable memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
buf.mode is non-zero and the user is not super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
An attempt is made to set buf.offset to a value outside the range -131071 to +131071, or to set buf.status to a value other than those listed above, or to set buf.tick to a value outside the range 900000/HZ to 1100000/HZ, where HZ is the system timer interrupt frequency.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-alphasort-3"> <REFMETA>
<REFENTRYTITLE>alphasort</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>alphasort</REFNAME>
<REFPURPOSE>
compare two directory entries alphabetically (LSB deprecated)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;dirent.h>

int alphasort(const struct dirent **a, const struct dirent **b);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The alphasort interface is expected to disappear from a future version
of the LSB; applications should provide their own routine to sort
filenames.<footnote><para>
The LSB never has contained scandir().
</para></footnote>
</para>
<PARA>
The alphasort() function can be used as the comparison function for the scandir() function to sort the directory entries into alphabetical order. Its parameters are the two directory entries, a and b, to compare.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The alphasort() function returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to complete the operation.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-alphasort64"> <REFMETA>
<REFENTRYTITLE>alphasort64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>alphasort64</REFNAME>
<REFPURPOSE>
compare two directory entries alphabetically (LSB deprecated)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;dirent.h>

int alphasort64(const struct dirent64 **a, const struct dirent64 **b);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The alphasort64 interface is expected to disappear from a future version
of the LSB; applications should provide their own routine to sort
filenames.<footnote><para>
The LSB never has contained scandir64(); alphasort64 is customarily
used with it.
</para></footnote>
</para>
<PARA>
Function to compare two struct dirent64s alphabetically. This
function is like alphasort but it uses the 64bit dirent structure.
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-asprintf"> <REFMETA>
<REFENTRYTITLE>asprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>asprintf</REFNAME>
<REFPURPOSE>
write formatted output to a string dynamically allocated with malloc and store the address of the string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;stdio.h>

extern int asprintf(char **restrict ptr, const char *restrict format, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
Same as sprintf, but calls malloc to dynamically allocate space for the
output, and then puts the output string in that space.
</PARA><PARA>
Stores the address of the string in *ptr.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-bind-textdomain-codeset"> <REFMETA>
<REFENTRYTITLE>bind_textdomain_codeset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bind_textdomain_codeset</REFNAME>
<REFPURPOSE>
specify encoding for message retrieval from message catalog for domain DOMAINNAME
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *bind_textdomain_codeset(const char *domainname, const char *codeset);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>bind_textdomain_codeset</emphasis> function can be used to
specify the output codeset for message catalogs for domain 
<emphasis>domainname</emphasis>.  The <emphasis>codeset</emphasis>
aregument must be a valid codeset name which can be used tor the
<emphasis>iconv_open()</emphasis> funtion, or a null pointer.
If the <emphasis>codeset</emphasis> argument is the null pointer, then 
function returns the currently selected codeset for the domain with the name
<emphasis>domainname</emphasis>.  It returns null pointer if no
codeset has yet been selected
</PARA>
<PARA>
The <emphasis>bind_textdomain_codeset</emphasis> function can be used
several times.  If used multiple times, with the same
<emphasis>domainname</emphasis> argument, the later call overrrides the
settings made by the earlier one.
</PARA>
<PARA>
The <emphasis>bind_textdomain_codeset</emphasis> function returns
a pointer to a string containing the name of the selected codeset. 
The string is allocated internally in the function and
must not be changed by the user.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currenlty 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for the duration of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
Returns the currently selected codeset name.  It returns null
pointer if no codeset has yet been selected.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function is not required to set the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-bindresvport-3"> <REFMETA>
<REFENTRYTITLE>bindresvport</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bindresvport</REFNAME>
<REFPURPOSE>
bind socket to privileged IP port
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;rpc.rpc.h>

int bindresvport(int sd, struct sockaddr_in *sin);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>The bindresvport() function is used to bind a socket to a
privileged IP port. This function can be used only by root.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On failure, -1 is returned, and errno is
set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPFNOSUPPORT
</TERM>
<LISTITEM>
<PARA>
Address of second argument provided did not match address family of
first argument.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-bindtextdomain"> <REFMETA>
<REFENTRYTITLE>bindtextdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bindtextdomain</REFNAME>
<REFPURPOSE>
specify that the DOMAINNAME message catalog will be found in the directory hierarchy under DIRNAME rather than in the system locale data base
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

extern char *bindtextdomain(const char *domainname,
                            const char *dirname);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Specify that the <emphasis>domainname</emphasis> message catalog will 
be found in <emphasis>dirname</emphasis> rather than in the system 
locale data base.
</PARA>
</REFSECT1>


<REFSECT1>
<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for hte furation of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dirname
</TERM>
<LISTITEM>
<PARA>
Can be an absolute or relative pathname.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
Returns the directory pathname currenlty bound to the domain.  If it fails,
a null pointer will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-cfmakeraw-3"> <REFMETA>
<REFENTRYTITLE>cfmakeraw</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfmakeraw</REFNAME>
<REFPURPOSE>
get and set terminal attributes
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;termios.h>

int cfmakeraw(struct termios *termios_p);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
cfmakeraw sets the terminal attributes as follows:
</TERM>
<LISTITEM>
<PARA>
 termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);
</PARA><PARA>
 termios_p->c_oflag &= ~OPOST;
</PARA><PARA>
 termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
</PARA><PARA>
 termios_p->c_cflag &= ~(CSIZE|PARENB);
</PARA><PARA>
 termios_p->c_cflag |= CS8;
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
termios_p is a pointer to a termios structure. This structure contains the following members:
</PARA><PARA>
              tcflag_t c_iflag;      /* input modes */
</PARA><PARA>
              tcflag_t c_oflag;      /* output modes */
</PARA><PARA>
              tcflag_t c_cflag;      /* control modes */
</PARA><PARA>
              tcflag_t c_lflag;      /* local modes */
</PARA><PARA>
              cc_t c_cc[NCCS];       /* control chars */
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On failure, -1 is returned, and errno is set appropriately.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-cfsetspeed-3"> <REFMETA>
<REFENTRYTITLE>cfsetspeed</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfsetspeed
</REFNAME>
<REFPURPOSE>
manipulate the termios structure
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;termios.h>

int cfsetspeed(struct termios *t, speedt speed);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The cfsetspeed function is provided for setting the baud rate values in the termios structure. The effects of the function on the terminal as described below do not become effective, nor are all errors detected, until the tcsetattr function is called.  Certain values for baud rates set in the termios structure and passed to tcsetattr have special meanings.
</PARA>

<REFSECT2>
<TITLE>Getting and Setting the Baud Rate
</TITLE>
<PARA>
The input and output baud rates are found in the termios structure. The unsigned integer speed_t is typdef'd in the include file &lt;termios.h>. The value of the integer corresponds directly to the baud rate being represented, however, the following symbolic values are defined.
</PARA><PARA>
     #define B0      0
</PARA><PARA>
     #define B50     50
</PARA><PARA>
     #define B75     75
</PARA><PARA>
     #define B110    110
</PARA><PARA>
     #define B134    134
</PARA><PARA>
     #define B150    150
</PARA><PARA>
     #define B200    200
</PARA><PARA>
     #define B300    300
</PARA><PARA>
     #define B600    600
</PARA><PARA>
     #define B1200   1200
</PARA><PARA>
     #define B1800   1800
</PARA><PARA>
     #define B2400   2400
</PARA><PARA>
     #define B4800   4800
</PARA><PARA>
     #define B9600   9600
</PARA><PARA>
     #define B19200  19200
</PARA><PARA>
     #define B38400  38400
</PARA><PARA>
     #ifndef _POSIX_SOURCE
</PARA><PARA>
     #define EXTA    19200
</PARA><PARA>
     #define EXTB    38400
</PARA><PARA>
     #endif  /*_POSIX_SOURCE */
</PARA><PARA>
The cfsetspeed function sets both the input and output baud rate in the termios structure referenced by t to speed.
</PARA>
</REFSECT2>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-daemon-3"> <REFMETA>
<REFENTRYTITLE>daemon</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>daemon</REFNAME>
<REFPURPOSE>
run in the background
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int daemon(int nochdir, int noclose);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The daemon() function is for programs wishing to detach themselves from the controlling terminal and run in the background as system daemons. Unless the argument nochdir is non-zero, daemon() changes the current working directory to the root (`/'). Unless the argument noclose is non-zero, daemon() will redirect standard input, standard output and standard error to /dev/null.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error, -1 is returned, and errno is set to any of the errors specified for the library functions fork(2) and setsid(2).
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-dcgettext"> <REFMETA>
<REFENTRYTITLE>dcgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dcgettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>
#include &lt;locale.h>

extern char *dcgettext(const char * domainname, const char *msgid, int category);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>dcgettext</emphasis> function is a domain specified version 
of <emphasis>gettext</emphasis>.
</PARA>
</REFSECT1>
<REFSECT1>

<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for the furation of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid</emphasis> is a null-terminated string to be matched 
in the catalogue with respect to a specific domain and the current locale.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
category
</TERM>
<LISTITEM>
<PARA>
The <emphasis>category</emphasis> argument is used for retrieving messages 
string for other than LC_MESSAGES category.  Available value for the
category argument are LC_CTYPE, LC_COLLATE, LC_MESSAGES, LC_MONETARY,
LC_NUMERIC, and LC_TIME.  The call of 
<emphasis>dcgettext(domainname, msgid, LC_MESSAGES)</emphasis>
is equivalent to
<emphasis>dgettext(doamainname, msgid)</emphasis>.
Note that LC_ALL must not be used.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds, the translated null-terminated
string is returned.  If the search fails, then <emphasis>msgid</emphasis>
is returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dcngettext"> <REFMETA>
<REFENTRYTITLE>dcngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dcngettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>
#include &lt;locale.h>

extern char *dcngettext(const char * domainname, const char *msgid1, const char *msgid2, unsigned long int n, int category);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>dcngettext</emphasis> function is a plural version 
of <emphasis>dcgettext</emphasis>.  See <emphasis>dcgettext</emphasis>
for more information.
</PARA>
</REFSECT1>
<REFSECT1>

<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for the furation of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid1
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid1</emphasis> is a null-terminated string to be 
matched in the catalogue with respect to a specific domain and the 
current locale.  If no message catalogs containing a translation
for <emphasis>msgid1</emphasis> are found, 
<emphasis>msgid1</emphasis> is returned if <emphasis>n == 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid2
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid2</emphasis> is a null-terminated string to be returned 
if no message catalogs are found and <emphasis>n != 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
n
</TERM>
<LISTITEM>
<PARA>
determines which plural form is returned, in a language and
message catalog dependent way.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
category
</TERM>
<LISTITEM>
<PARA>
The <emphasis>category</emphasis> argument is used for retrieving messages 
string for other than LC_MESSAGES category.  Availalbe value for the
category argument are LC_CTYPE, LC_COLLATE, LC_MESSAGES, LC_MONETARY,
LC_NUMERIC, and LC_TIME.  The call of 
<emphasis>dcngettext(doamainname, msgid1, msgid2, n, LC_MESSAGES)</emphasis>
is equivalent to
<emphasis>dngettext(doamainname, msgid1, msgid2, n)</emphasis>.
Note that LC_ALL must not be used.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds with <emphasis>msgid1</emphasis>, then a 
translated null-terminated string is returned.  If the search fails,
then the original <emphasis>msgid1</emphasis> 
or <emphasis>msgid2</emphasis> is returned according to <emphasis>n</emphasis>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dgettext"> <REFMETA>
<REFENTRYTITLE>dgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dgettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *dgettext(const char * domainname, const char *msgid);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>dgettext</emphasis> function is a domain specified version 
of <emphasis>gettext</emphasis>.
</PARA>
</REFSECT1>
<REFSECT1>

<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for the furation of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid</emphasis> is a null-terminated string to be matched 
in the catalogue with respect to a specific domain and the current locale.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds with <emphasis>msgid</emphasis>, then a 
translated null-terminated string is returned.  If the search fails,
then the original <emphasis>msgid</emphasis> is returned.
The length of the string returned is undetermined until the function is called. 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dngettext"> <REFMETA>
<REFENTRYTITLE>dngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dngettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *dngettext(const char * domainname, const char *msgid1, const char *msgid2, unsigned long int n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>dngettext</emphasis> function is a plural version 
of <emphasis>dgettext</emphasis>.  See <emphasis>dgettext</emphasis>
for more information.
</PARA>
</REFSECT1>
<REFSECT1>

<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <emphasis>domainname</emphasis> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <emphasis>domainname</emphasis> argument 
to <emphasis>textdomain()</emphasis>, except that the selection of the 
domain is valid only for the furation of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid1
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid1</emphasis> is a null-terminated string to be 
matched in the catalogue with respect to a specific domain and the 
current locale.  If no message catalogs containing a translation
for <emphasis>msgid1</emphasis> are found, 
<emphasis>msgid1</emphasis> is returned if <emphasis>n == 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid2
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid2</emphasis> is a null-terminated string to be returned 
if no message catalogs are found and <emphasis>n != 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
n
</TERM>
<LISTITEM>
<PARA>
determines which plural form is returned, in a languae and
message catalog dependent way.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds with <emphasis>msgid1</emphasis>, then a 
translated null-terminated string is returned.  If the search fails,
then the original <emphasis>msgid1</emphasis> 
or <emphasis>msgid2</emphasis> is returned according to <emphasis>n</emphasis>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-err-3"> <REFMETA>
<REFENTRYTITLE>err</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>err
</REFNAME>
<REFPURPOSE>display formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void err(int eval, const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The err() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The error message string affiliated with the current value of the global variable errno is output. The output is followed by a newline character.
</PARA><PARA>
The err() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-error-n"> <REFMETA>
<REFENTRYTITLE>error</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>error</REFNAME>
<REFPURPOSE>
print error message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
void error (int exitstatus, int errnum, const char *format, ...)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
Print a message to standard error.  First print the name of the
program.  If there is a function called error_print_progname (which
would be provided by the application), call it to print the program
name.  If not, print the contents of the global variable program_name
as the program name.
</PARA>
<PARA>
Then print a colon, a space, and the result of using the printf-style
<replaceable>format</replaceable> and the optional arguments.
</PARA>
<PARA>
Then, if errnum is nonzero, print a colon, a space, and the result of
<computeroutput>strerror(errnum)</computeroutput>.
</PARA>
<PARA>
Then print a newline.
</PARA>
<PARA>
Then, if exitstatus is nonzero, call
<computeroutput>exit(exitstatus)</computeroutput>.
</PARA>
<!-- There's an interaction with wide characters(?): this call makes
stderr narrow-oriented. Should put that in once we figure out what it
means and whether it would be bad in an Asian locale -->
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-errx-3"> <REFMETA>
<REFENTRYTITLE>errx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>errx
</REFNAME>
<REFPURPOSE>format error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void errx(int eval, const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The errx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA><PARA>
The errx() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-fcntl-3"> <REFMETA>
<REFENTRYTITLE>fcntl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fcntl
</REFNAME>
<REFPURPOSE>
file control
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "fcntl" is as specified in the Single UNIX
Specification but with the following differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Implementation may set O_LARGEFILE
</TITLE>
<PARA>
According to the Single UNIX Specification, only an application sets
fcntl flags, for example O_LARGEFILE.  However, this specification
also allows implementations to set O_LARGEFILE in a case in which the
default behavior matches the O_LARGEFILE behavior.<footnote><para>For
example, if off_t is 64 bits</para></footnote>  Or in other words,
calling fcntl with the F_GETFL command may return O_LARGEFILE as well
as flags explicitly set by the application.
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-flock-2"> <REFMETA>
<REFENTRYTITLE>flock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>flock</REFNAME>
<REFPURPOSE>
apply or remove an advisory lock on an open file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int flock(int fd, int operation);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Apply or remove an advisory lock on an open file. The file is specified by fd. Valid operations are given below:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
LOCK_SH
</TERM>
<LISTITEM>
<PARA>
Shared lock. More than one process may hold a shared lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_EX
</TERM>
<LISTITEM>
<PARA>
Exclusive lock. Only one process may hold an exclusive lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_UN
</TERM>
<LISTITEM>
<PARA>
Unlock.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_NB
</TERM>
<LISTITEM>
<PARA>
Don't block when locking. May be specified (by or'ing) along with one of the other operations.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
A single file may not simultaneously have both shared and exclusive locks.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EWOULDBLOCK
</TERM>
<LISTITEM>
<PARA>
The file is locked and the LOCK_NB flag was selected.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-fstatfs-2"> <REFMETA>
<REFENTRYTITLE>fstatfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fstatfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int fstatfs(int fd, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>
Description
</TITLE>
<PARA>
fstatfs returns information about a mounted file system. fd is the open file descriptor of any file within the mounted filesystem. buf is a pointer to a statfs structure defined as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
fd is not a valid open file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
buf points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS
</TERM>
<LISTITEM>
<PARA>
The filesystem fd is open on does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getdomainname"> <REFMETA>
<REFENTRYTITLE>getdomainname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getdomainname</REFNAME>
<REFPURPOSE>
get NIS domain name.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;unistd.h&gt;

extern int getdomainname(char *name, size_t namelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>
<para>
If NIS is in use, provide the NIS domain name.  Note that this is not
the same as the domain name which provides the domain portion of a
fully qualified domain name (for example, in DNS).  If NIS is not in
use, provide the string "(none)".
</para>
<para>
If the string which is provided is strictly less than namelen
characters in length, getdomainname places it in the array pointed to
by name followed by a terminating null character.  If not,
getdomainname may either truncate it to namelen characters and place
it in name (without a terminating null character), or may fail with
EINVAL.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
getdomainname returns 0 if successful; -1 if not (in which case errno
is set to indicate the error).
</para>
</refsect1>

</REFENTRY>



<REFENTRY ID="baselib-gethostbyname-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname</REFNAME>
<REFPURPOSE>
get network host entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

struct hostent *gethostbyname(const char *name);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The gethostbyname() function returns a structure of type hostent for the given host name. Here name is either a host name, or an IPv4 address in standard dot notation, or an IPv6 address in colon (and possibly dot) notation. (See RFC 1884 for the description of IPv6 addresses.) If name is an IPv4 or IPv6 address, no lookup is performed and gethostbyname() simply copies name into the h_name field and its struct in_addr equivalent into the h_addr_list[0] field of the returned hostent structure. If name doesn't end in a dot and the environment variable HOSTALIASES is set, the alias file pointed to by HOSTALIASES will first be searched for name (see hostname(7) for the file format). The current domain and its parents are searched unless name ends in a dot.
</PARA><PARA>
The domain name queries carried out by gethostbyname() use a combination of any or all of the name server named(8), a broken out line from /etc/hosts, and the Network Information Service (NIS or YP), depending upon the contents of the order line in /etc/host.conf. (See resolv+(8)). The default action is to query named(8), followed by /etc/hosts.
</PARA><PARA>
The hostent structure is defined in &lt;netdb.h> as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct hostent {
</TERM>
<LISTITEM>
<PARA>
       char    *h_name;        /* official name of host */
</PARA><PARA>
       char    **h_aliases;    /* alias list */
</PARA><PARA>
       int     h_addrtype;     /* host address type */
</PARA><PARA>
       int     h_length;       /* length of address */
</PARA><PARA>
       char    **h_addr_list;  /* list of addresses */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
#define h_addr  h_addr_list[0]  /* for backward compatibility */
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The gethostbyname()) functions return the hostent structure or a NULL pointer if an error occurs. On error, the h_errno variable holds an error number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to complete the operation. 
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-gethostbyname-r-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname_r
</REFNAME>
<REFPURPOSE>
find network host database entry matching host name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int gethostbyname_r(__const char *__restrict __name,
                           struct hostent *__restrict __result_buf,
                           char *__restrict __buf, size_t __buflen,
                           struct hostent **__restrict __result,
                           int *__restrict __h_errnop);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The gethostbyname_r() function is a reentrant version of the gethostbyname
function that searches the network host database for a host name match.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getloadavg-3"> <REFMETA>
<REFENTRYTITLE>getloadavg</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getloadavg
</REFNAME>
<REFPURPOSE>
get system load averages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdlib.h>

int getloadavg(double loadavg[], int nelem);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getloadavg() function returns the number of processes in the system run queue averaged over various periods of time. Up to nelem samples are retrieved and assigned to successive elements of loadavg[]. The system imposes a maximum of 3 samples, representing averages over the last 1, 5, and 15 minutes, respectively.
</PARA>
</REFSECT1>
<!--     BSDI BSD/OS                      June 4, 1993       -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="libutil-getopt-3"> <REFMETA>
<REFENTRYTITLE>getopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getopt-3"><PRIMARY>getopt</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
</SYNOPSIS>
<PARA>
GNU supports the following extensions of getopt:
</PARA>
<SYNOPSIS>
int getopt_long(int argc, char * const argv[],
               const char *optstring,
               const struct option *longopts, int *longindex);

int getopt_long_only(int argc, char * const argv[],
                    const char *optstring,
                    const struct option *longopts, int *longindex);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt() function parses command line arguments.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Option Characteristics</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
an element of argv that starts with "-" (and is not exactly "-" or "--") is an option element.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
characters of an option element, aside from the initial "-", are option characters.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
applications using getopt() must obey the following syntax guidelines:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
option name is a single alphanumeric character from the portable character set
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
option is preceded by the "-" delimiter character
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
options without option-arguments should be accepted when grouped behind one "-" delimiter
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
each option and option-argument is a separate argument
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
option-arguments are not optional
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
all options should precede operands on the command line
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the argument "--" is accepted as a delimiter indicating the end of options and the consideration of subsequent arguments, if any, as operands
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
historical implementations of getopt() support other characters as options as an allowed extension, but applications that use extensions are not maximally portable.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
support for multi-byte option characters is only possible when such characters can be represented as type int.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
applications that call any utility with a first operand starting with "-" should usually specify "--" to mark the end of the options.  Standard utilities that do not support this guideline indicate that fact in the OPTIONS section of the utility description.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Extensions</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if a character is followed by two colons, the option takes an optional arg; if there is text in the current argv-element, it is returned in optarg, otherwise optarg is set to zero.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if optstring contains W followed by a semi-colon, then -W foo is treated as the long option --foo.  (Not available with libraries before GNU libc 2.)
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long() works like getopt() except that it also accepts "long options", or, options that are preface with two dashes instead of one.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
long option names may be abbreviated if the abbreviation is unique or an exact match for some defined option.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
a long option may take a parameter, of the form  --arg=param or --arg param.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long_only() works like getopt_long(), except that both "-" and "--" indicate long option.  If an option that starts with "-" (not "--") doesn't match a long option, but does match a short option, it is parsed instead as a short option.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the -W option is reserved for implementation extensions.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Return Values</TITLE>
<PARA>
GNU specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
GNU specifies the following getopt_long() and getopt_long_only() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
when short option is recognized, the option character is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
when long option is recognized, val is returned if flag is NULL, otherwise, 0 is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
error and -1 returns are the same as for getopt().
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned for an ambiguous match or an extraneous parameter.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options and the first character of opstring is ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character not in optstring is encountered, or if getopt() detects a missing argument and the first character of optstring is not ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if the variable POSIXLY_CORRECT is set, option processing stops as soon as a non-option argument is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if POSIXLY_CORRECT is set, GNU getopt() conforms to POSIX.2.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the variable _[PID]_GNU_nonoption_argv_flags_ was used by bash 2.0 to communicate to GNU libc which arguments resulted from wildcard expansion and so should not be considered as options.  This behavior was removed in bash version 2.01, but the support remains in GNU libc.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
POSIX.2 Interpretation 150 reports a technical error in the function of getopt().  GNU implements the correct behavior of getopt().
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-getopt-long-3"> <REFMETA>
<REFENTRYTITLE>getopt_long</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt_long() function works like getopt() except that it also accepts long options, started out by two dashes. Long option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option. A long option may take a parameter, of the form --arg=param or --arg param.
</PARA><PARA>
longopts  is a pointer to the first element of an array of struct option declared in &lt;getopt.h> as
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
          struct option {
</TERM>
<LISTITEM>
<PARA>
              const char *name;
</PARA><PARA>
              int *flag;
</PARA><PARA>
              int has_arg;
</PARA><PARA>
              int val;
</PARA><PARA>
          };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The getopt_long() function returns the option character if the option was found successfully, : if there was a missing parameter for one of the options, ?  for an unknown option character, or -1 for the end of the option list.
</PARA><PARA>
getopt_long() also returns the option character when a short option is recognized. For a long option, they return val if flag is NULL, and 0 otherwise. Error and -1 returns are the same as for getopt(), plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getopt-long-only-3"> <REFMETA>
<REFENTRYTITLE>getopt_long_only</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long_only</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long_only(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getopt_long_only() is like getopt_long(), but - as well as -- can indicate a long option. If an option that starts with - (not --) doesn't match a long option, but does match a short option, it is parsed as a short option instead.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The function getopt_long_only() returns the option character if the option was found successfully, : if there was a missing parameter for one of the options, ? for an unknown option character, or -1 for the end of the option list. getopt_long_only() also returns the option character when a short option is recognized. For a long option, they return val if flag is NULL, and 0 otherwise. Error and -1 returns are the same as for getopt(), plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getprotobyname-3"> <REFMETA>
<REFENTRYTITLE>getprotobyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotobyname
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotobynumber(int proto);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getprotobyname() function returns a protoent structure for the line from /etc/protocols that matches the protocol name name.
</PARA>
<PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The getprotobyname() function returns the protoent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/protocols protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getprotoent-3"> <REFMETA>
<REFENTRYTITLE>getprotoent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotoent
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotoent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getprotoent() function reads the next line from the file /etc/protocols and returns a structure protoent containing the broken out fields from the line. The /etc/protocols file is opened if necessary.
</PARA><PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
The getprotoent() function returns the protoent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/etc/protocols protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getpwnam-r"> <REFMETA>
<REFENTRYTITLE>getpwnam_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getpwnam_r</REFNAME>
<REFPURPOSE>
reentrant version of getpwnam
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern int getpwnam_r (const char *name,
                       struct passwd *resultbuf,
                       char *buffer, 
                       size_t buflen,
                       struct passwd **result)

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>31 May 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Reentrant version of getpwnam. The additional arguments resultsbuf
and buffer are for internal storage, buflen the size of the buffer, and
result is the password structure used to return the requested information.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getservbyname-3"> <REFMETA>
<REFENTRYTITLE>getservbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservbyname
</REFNAME>
<REFPURPOSE>
get service entry by name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

struct servent *getservbyname(const char *name, const char *proto);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getservbyname() function returns a servent structure for the line from /etc/services that matches the service name using protocol proto.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getservbyname() returns the servent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/etc/services services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getservent-3"> <REFMETA>
<REFENTRYTITLE>getservent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservent
</REFNAME>
<REFPURPOSE>
get service entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

struct servent *getservent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getservent() function reads the next line from the file /etc/services and returns a structure servent containing the broken out fields from the line. The /etc/services file is opened if necessary.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getservent() returns the servent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/etc/services services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-gettext"> <REFMETA>
<REFENTRYTITLE>gettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *gettext(const char *msgid);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>gettext</emphasis> function attempts to retrieve a target 
string based on the specified key from the <emphasis>msgid</emphasis> 
argument within the context of a specific domain and the current locale.  
</PARA>
<PARA>
The LANGUAGE environment variable is examined first to determine the
message catalogs to be used.  The value of the LANGUAGE environment variable
is a list of locale names separated by colon (:) character.  If the
LANGUAGE environment variable is defined, each locale name is tried
in the specified order and if a message catalog containing the requested
message is found, the message is returned.  If the LANGUAGE environment
varialbe is defined but failed to locate a message catalog, 
the <emphasis>msgid</emphasis> string will be returned.
If the LANGUAGE environment variable is not defined, LC_ALL, LC_xxx, and
LANG environment varialbes are examined to locate the message catalog,
forllowing the convention used by the <emphasis>setlocale()</emphasis> function.
</PARA>
<PARA>
The pathname used to locate the message catalog is 
<emphasis>dirname/locale/category/domainname.mo</emphasis>, 
where <emphasis>dirname</emphasis> is the directory specified 
by <emphasis>bindtextdomain()</emphasis>, <emphasis>locale</emphasis>
is a locale name determined by the definition of environment variables, 
<emphasis>category</emphasis> is LC_MESSAGES.
</PARA>
<PARA>
If the LC_MESSAGES locale category of the current locale is the
standard "C" locale or the standard "POSIX" locale, the 
<emphasis>gettext</emphasis> function returns <emphasis>msgid</emphasis>
without looking in any message catalog.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
msgid
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid</emphasis> is a null-terminated string to be 
matched in the catalogue with respect to a specific domain and the 
current locale.  
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds with <emphasis>msgid</emphasis>, then a 
translated null-terminated string is returned.  If the search fails,
then the original <emphasis>msgid</emphasis> is returned.
The length of the string returned is undetermined until the function is called. 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-getutent-3"> <REFMETA>
<REFENTRYTITLE>getutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent
</REFNAME>
<REFPURPOSE>
access utmp file entries	
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

struct utmp *getutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getutent() reads a line from the current file position in the utmp file. It returns a pointer to a structure containing the fields of the line.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getutent() returns a pointer to a static struct utmp.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/var/run/utmp database of currently logged-in users
</PARA><PARA>
/var/log/wtmp database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getutent-r-3"> <REFMETA>
<REFENTRYTITLE>getutent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent_r
</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int getutent_r(struct utmp *__buffer,
                      struct utmp **__result);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getutent_r() function is a reentrant version of the getutent
utmp file handler.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-glob64"> <REFMETA>
<REFENTRYTITLE>glob64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>glob64</REFNAME>
<REFPURPOSE>
find pathnames matching a pattern  (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 December 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;glob.h>
int glob64((const char *pattern, int flags,
            int (*errfunc) (const char *, int),
            glob64_t *pglob));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The glob64() function searches for all the pathnames  matching 
pattern according to the rules used by the shell (see glob(7)).
No tilde expansion or parameter substitution is done; if you 
want these, use wordexp(3).

The results of a glob64() call are stored in the structure
pointed to by pglob, which is a glob64_t which is declared
in &lt;glob.h> and includes the following elements defined by
POSIX.2 (more may be present as an extension):

</PARA><PARA>
The glob64() function is a 64-bit version of glob.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On successful completion, glob64() returns zero.  Other possible 
returns are:

GLOB_NOSPACE
       for running out of memory,

GLOB_ABORTED
       for a read error, and

GLOB_NOMATCH
       for no found matches.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFSECT1>
</REFENTRY>













<REFENTRY ID="baselib-globfree64"> <REFMETA>
<REFENTRYTITLE>globfree64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>globfree64</REFNAME>
<REFPURPOSE>
free memory from glob64() (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 December 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;glob.h>

void globfree64(glob64_t *pglob);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The globfree64() function frees the dynamically allocate 
storage from an earlier call to glob64().
</PARA><PARA>
The globfree64 function is a 64-bit version of globfree.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFSECT1>
</REFENTRY>













<REFENTRY ID="baselib-initgroups-3"> <REFMETA>
<REFENTRYTITLE>initgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>initgroups
</REFNAME>
<REFPURPOSE>
initialize the supplementary group access list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;grp.h>
#include &lt;sys/types.h>

int initgroups(const char *user, gid_t group);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The initgroups() function initializes the group access list by reading
the group database and using all groups of which user is a member. The
additional group group is also added to the list.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process does not have sufficient privileges.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to allocate group information structure.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-ioctl-2"> <REFMETA>
<REFENTRYTITLE>ioctl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ioctl
</REFNAME>
<REFPURPOSE>
control device
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 August 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/ioctl.h>

int ioctl(int d, int request, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 August 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The ioctl function manipulates the underlying device parameters of special
files. The argument <replaceable>d</replaceable> must be an open file descriptor.
The type and value of the third parameter is dependent on the device and request.
</PARA>
<PARA>
An application may not call ioctl except for situations explicitely stated
in this specification.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. An ioctl may use the return value as an output
parameter and return a nonnegative value on success. On error, -1 is returned,
and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF  
</TERM>
<LISTITEM>
<PARA>
<replaceable>d</replaceable> is not a valid descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<replaceable>argp</replaceable> references an inaccessible memory area.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTTY 
</TERM>
<LISTITEM>
<PARA>
<replaceable>d</replaceable> is not associated with a character special device.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTTY 
</TERM>
<LISTITEM>
<PARA>
The specified request does not apply to the kind of object that the descriptor
<replaceable>d</replaceable> references.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
<replaceable>request</replaceable> or <replaceable>argp</replaceable> is not valid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

</REFENTRY>
<REFENTRY ID="baselib-sockio-2"> <REFMETA>
<REFENTRYTITLE>sockio</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sockio
</REFNAME>
<REFPURPOSE>
socket ioctl commands
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 August 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/socket.h>
#include &lt;net/if.h>

int ioctl(int sockfd, int request, char *argp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 August 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Socket ioctl commands are a subset of the ioctl(2) system calls which can
perform a variety of functions on sockets. The file descriptor
<replaceable>sockfd</replaceable> must contain the value of a file descriptor
which was created with the socket(2) or accept(2) system calls.
</PARA>
<PARA>
These commands apply to the underlying network interfaces, and affect the
entire system, not just the file descriptor used to issue the ioctl.
</PARA>
<PARA>
The following ioctls are provided:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
SIOCGIFCONF
</TERM>
<LISTITEM>
<PARA>
Gets the interface configuration list for the
system.<footnote><para>Similar to the if_nameindex family found in the
Single UNIX specification version 3 or the getifaddrs family found in
BSD.</para></footnote>
The parameter
<replaceable>argp</replaceable> is a pointer to a
<literal>struct ifconf</literal>.
Before calling, the caller must allocate the
<literal>ifc_ifcu.ifcu_req</literal> field to point to an array of
<literal>struct ifreq</literal> structures, and set
<literal>if_len</literal> to the size of this allocated array (in
bytes).  Upon return, <literal>if_len</literal> will contain the amount of
the array which was actually used (again in bytes).  If it is the same
as the length upon calling, the caller should assume that the array
was too small and try again with a larger array.
</PARA>
<para>
On success, this function can return any nonnegative
value.<footnote><para>Historical UNIX systems disagree on the meaning
of the return value.</para></footnote>
</para>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
SIOCGIFFLAGS  
</TERM>
<LISTITEM>
<PARA>
Gets the interface flags for the indicated interface.
The parameter <replaceable>argp</replaceable> is a pointer to a
<literal>struct ifreq</literal>.
Before calling, the caller should
fill in the ifr_name field with the interface name, and upon return
the ifr_ifru.ifru_flags field is set with the interface flags.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
SIOCGIFADDR  
</TERM>
<LISTITEM>
<PARA>
Gets the interface address list for the system. The parameter
<replaceable>argp</replaceable> is a pointer to a
<literal>struct ifreq</literal>.
Before calling, the caller should
fill in the ifr_name field with the interface name, and upon return
the ifr_ifru.ifru_addr field is set with the interface address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
SIOCGIFNETMASK  
</TERM>
<LISTITEM>
<PARA>
Gets the network mask for the indicated interface. The parameter
<replaceable>argp</replaceable> is a pointer to a
<literal>struct ifreq</literal>.
Before calling, the caller should
fill in the ifr_name field with the interface name, and upon return
the ifr_ifru.ifru_netmask field is set with the network mask.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

<para>The <literal>struct sockaddr</literal> structure is as specified
in the Single UNIX Specification.</para>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF  
</TERM>
<LISTITEM>
<PARA>
<replaceable>sockfd</replaceable> is not a valid descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<replaceable>argp</replaceable> references an inaccessible memory area.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTTY 
</TERM>
<LISTITEM>
<PARA>
<replaceable>sockfd</replaceable> is not associated with a character special device.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTTY 
</TERM>
<LISTITEM>
<PARA>
The specified request does not apply to the kind of object that the descriptor
<replaceable>sockfd</replaceable> references.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
<replaceable>request</replaceable> or <replaceable>argp</replaceable> is not valid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-isblank-3"> <REFMETA>
<REFENTRYTITLE>isblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>isblank
</REFNAME>
<REFPURPOSE>
character classification routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int isblank(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This functions checks whether c, which must have the value of an unsigned char or EOF, falls into a certain character class according to the current locale.
</PARA><PARA>
isblank() checks for a blank character; that is, a space or a tab. This function is a GNU extension.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The values returned are nonzero if the character c falls into the tested class, and a zero value if not.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The details of what characters belong into which class depend on the current locale. For example, isupper() will not recognize an A - umlaut as an uppercase letter in the default C locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-iswblank-3"> <REFMETA>
<REFENTRYTITLE>iswblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswblank
</REFNAME>
<REFPURPOSE>
test for whitespace wide character
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wctype.h>

int iswblank(wint_t wc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The iswblank function is the wide-character equivalent of the isblank function. It tests whether wc is a wide character belonging to the wide character class "blank".
</PARA><PARA>
The wide character class "blank" is a subclass of the wide character class "space".
</PARA><PARA>
Being a subclass of the wide character class "space", the wide character class "blank" is disjoint from the wide character class "graph" and therefore also disjoint from its subclasses "alnum", "alpha", "upper", "lower", "digit", "xdigit", "punct".
</PARA><PARA>
The wide character class "blank" always contains at least the space character and the control character '\t'.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The iswblank function returns non-zero if wc is a wide character belonging to the wide character class "blank". Otherwise it returns zero.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of iswblank depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-iswctype-3"> <REFMETA>
<REFENTRYTITLE>iswctype</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswctype
</REFNAME>
<REFPURPOSE>
wide character classification
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wctype.h>

int iswctype(wint_t wc, wctype_t desc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If wc is a wide character having the character property designated by desc (or in other words: belongs to the character class designated by desc), the iswctype function returns non-zero. Otherwise it returns zero. If wc is WEOF, zero is returned.
</PARA><PARA>
desc must be a character property descriptor returned by the wctype function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
iswctype returns non-zero if the wc has the designated property. Otherwise it returns 0.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of iswctype depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-kill-3"> <REFMETA>
<REFENTRYTITLE>kill</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>kill
</REFNAME>
<REFPURPOSE>
send a signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int kill(pid_t pid, int sig);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "kill" is as specified in the Single UNIX
Specification, Version 2 but with the
following differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Process ID -1 doesn't affect calling process
</TITLE>
<PARA>
If <replaceable>pid</replaceable> is specified as -1,
<replaceable>sig</replaceable> shall not be sent to the calling
process.<footnote>
<para>
This was a deliberate Linus decision after an unpopular experiment in
including the calling process in the 2.5.1 kernel.  See "What does it
mean to signal everybody?", Linux Weekly News, 20 December 2001,
<ulink url="http://lwn.net/2001/1220/kernel.php3"
>http://lwn.net/2001/1220/kernel.php3</ulink>
</para>
</footnote>
Other than this, the rules in the Single UNIX Specification, Version 2 apply.
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-mbsnrtowcs-3"> <REFMETA>
<REFENTRYTITLE>mbsnrtowcs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mbsnrtowcs
</REFNAME>
<REFPURPOSE>
convert a multibyte string to a wide character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t mbsnrtowcs(wchar_t *dest, const char **src,
                  size_t nms, size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mbsnrtowcs function is like the mbsrtowcs function, except that the number of bytes to be converted, starting at *src, is limited to nms.
</PARA><PARA>
If dest is not a NULL pointer, the mbsnrtowcs function converts at most nms bytes from the multibyte string *src to a wide-character string starting at dest. At most len wide characters are written to dest. The  state *ps is updated. The conversion is effectively performed by repeatedly calling mbrtowc(dest,*src,n,ps) where n is some positive number, as long as this call succeeds, and then incrementing dest by one and *src by the number of bytes consumed. The conversion can stop for three reasons:
</PARA><PARA>
1. An invalid multibyte sequence has been encountered. In this case *src is left pointing to the invalid multibyte sequence, (size_t)(-1) is returned, and errno is set to EILSEQ.
</PARA><PARA>
2. The nms limit forces a stop, or len non-L'\0' wide characters have been stored at dest. In this case *src is left pointing to the next multibyte sequence to be converted, and the number of wide characters written to dest is returned.
</PARA><PARA>
3. The multibyte string has been completely converted, including the terminating '\0' (which has the side effect of bringing back *ps to the initial state). In this case *src is set to NULL, and the number of wide characters written to dest, excluding the terminating L'\0' character, is returned.
</PARA><PARA>
If dest is NULL, len is ignored, and the conversion proceeds as above, except that the converted wide characters are not written out to memory, and that no destination length limit exists.
</PARA><PARA>
In both of the above cases, if ps is a NULL pointer, a static anonymous state only known to the mbsnrtowcs function is used instead.
</PARA><PARA>
The programmer must ensure that there is room for at least len wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The mbsnrtowcs function returns the number of wide characters that make up the converted part of the wide character string, not including the terminating null wide character. If an invalid multibyte sequence was encountered, (size_t)(-1) is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of mbsnrtowcs depends on the LC_CTYPE category of the current locale.
</PARA><PARA>
Passing NULL as ps is not multi-thread safe.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-memmem-3"> <REFMETA>
<REFENTRYTITLE>memmem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memmem</REFNAME>
<REFPURPOSE>
locate a substring
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

void *memmem(const void *haystack, size_t haystacklen,
             const void *needle, size_t needlelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  memmem() function finds the start of the first occurrence of the substring needle of length needlelen in the memory area haystack of length haystacklen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The memmem() function returns a pointer to the beginning of the substring, or NULL if the substring is not found.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
This function was broken in Linux libraries up to and including libc 5.0.9; there the needle and haystack arguments were interchanged, and a pointer to the end of the first occurrence of needle was returned. Since libc 5.0.9 is still widely used, this is a dangerous function to use.
</PARA>
<PARA>
Both old and new libc's have the bug that if needle is empty haystack-1 (instead of haystack) is returned. And glibc 2.0 makes it worse, and returns a pointer to the last byte of haystack. This is fixed in glibc 2.1.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-memrchr"> <REFMETA>
<REFENTRYTITLE>memrchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memrchr</REFNAME>
<REFPURPOSE>
scan memory for a character
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

void *memrchr(const void *s, int c, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
memrchr() returns a pointer to the last occurrence of the character represented by c in the first n characters of the string represented by s.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-ngettext"> <REFMETA>
<REFENTRYTITLE>ngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ngettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *ngettext(const char *msgid1, const char *msgid2, unsigned long int n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <emphasis>ngettext</emphasis> function is the plural version of 
<emphasis>gettext</emphasis>, which searches for the message string 
using the <emphasis>msgid1</emphasis> arguments as the key, using 
the argument <emphasis>n</emphasis> to determine the plural form.
If no message catalogs containing a translation for
<emphasis>msgid1</emphasis> are found, <emphasis>msgid1</emphasis> is 
returned if <emphasis>n == 1</emphasis>, otherwise, 
<emphasis>msgid2</emphasis> is returned.  See <emphasis>gettext</emphasis> 
for more details.
</PARA>
</REFSECT1>
<REFSECT1>

<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
msgid1
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid1</emphasis> is a null-terminated string to be 
matched in the catalogue with respect to a specific domain and the 
current locale.  If no message catalogs are found, 
<emphasis>msgid1</emphasis> is returned if <emphasis>n == 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
msgid2
</TERM>
<LISTITEM>
<PARA>
The <emphasis>msgid2</emphasis> is a null-terminated string to be returned 
if no message catalogs are found and <emphasis>n != 1</emphasis>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
n
</TERM>
<LISTITEM>
<PARA>
determines in which plural from is returned, in a language and
message catalog dependent way.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
If the function query above succeeds with <emphasis>msgid1</emphasis>, 
then a translated null-terminated string is returned.  If the search fails,
then the original <emphasis>msgid1</emphasis> or <emphasis>msgid2</emphasis> 
is returned according to <emphasis>n</emphasis>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The function will not modify the external <emphasis>errno</emphasis> variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<ulink url="baselib-gettext.html">gettext</ulink>, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<refentry id="baselib-nice"> <refmeta>
<refentrytitle>nice</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>nice</refname>
<refpurpose>
set nice value
</refpurpose>
</refnamediv>
<refsect1>
<title>Description</title>
<para>
The nice function is as specified in the Single UNIX Specification
with the following differences.
</para>
<para>
As deprecated behavior, the return value of a successful call to nice
may be 0 (rather than the new nice value).  A future version of the
LSB is expected to require the new nice value, as specified in the
Single UNIX Specification.  But until then, applications need to call
the getpriority function, rather than rely on the return value from
nice.
</para>
</refsect1>
</refentry>

<REFENTRY ID="baselib-obstack-free"> <REFMETA>
<REFENTRYTITLE>obstack_free</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>obstack_free</REFNAME>
<REFPURPOSE>
free an object in the obstack
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

void obstack_free(struct obstack *obstack, void *block);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Free an object in the obstack.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-opterr-3"> <REFMETA>
<REFENTRYTITLE>opterr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>opterr
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int opterr;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
opterr is used as a flag to suppress error message generated by getopt(). When opterr is set to 0; it suppresses the error message generated by getopt() when getopt() does not recognize an option character.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-optind-3"> <REFMETA>
<REFENTRYTITLE>optind</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>optind
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int optind;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
optind holds the current index of the array argr[] which contains the command line options being parsed by getopt().
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-optopt-3"> <REFMETA>
<REFENTRYTITLE>optopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>optopt
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int optopt;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
optopt holds the unknown option character when that option character is not recognized by getopt() 
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-psignal-3"> <REFMETA>
<REFENTRYTITLE>psignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>psignal</REFNAME>
<REFPURPOSE>
print signal message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

void psignal(int sig, const char *s);

extern const char *const sys_siglist[]
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The psignal() function displays a message on stderr consisting of the string s, a colon, a space, and a string describing the signal number sig. If sig is invalid, the message displayed will indicate an unknown signal.
</PARA>
<PARA>
The array sys_siglist holds the signal description strings indexed by signal number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
psignal() returns no value.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-random-r-3"> <REFMETA>
<REFENTRYTITLE>random_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>random_r
</REFNAME>
<REFPURPOSE>
generate random number
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int random_r(struct random_data *__restrict __buf,
                    int32_t *__restrict __result);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The random_r() function is a reentrant version of the random function
that generates a pseudorandom number.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-setbuffer-3"> <REFMETA>
<REFENTRYTITLE>setbuffer</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setbuffer
</REFNAME>
<REFPURPOSE>
stream buffering operation
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

void setbuffer(FILE *stream, char *buf, size_tsize);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
setbuffer is an alias for call to setvbuf. It works the same, except that the size of the buffer is up to the caller, rather than being determined by the default BUFSIZ.  
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setdomainname"> <REFMETA>
<REFENTRYTITLE>setdomainname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setdomainname</REFNAME>
<REFPURPOSE>
set NIS domain name.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;unistd.h&gt;

extern int setdomainname(char *name, size_t namelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>
<para>
If NIS is in use, set the NIS domain name.  Note that this is not
the same as the domain name which provides the domain portion of a
fully qualified domain name (for example, in DNS).  If NIS is not in
use, this function may set the domain name anyway, or it may fail.
</para>
<para>
This call shall fail unless the caller has appropriate privileges.
</para>
<para>
namelen shall be the length of the string pointed to by name.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
setdomainname returns 0 if successful; -1 if not (in which case errno
is set to indicate the error).
</para>
</refsect1>

</REFENTRY>


<REFENTRY ID="baselib-setegid-2"> <REFMETA>
<REFENTRYTITLE>setegid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setegid
</REFNAME>
<REFPURPOSE>
set effective group ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The setegid() function is as specified in the Single UNIX
Specification, Version 3.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-setenv-3"> <REFMETA>
<REFENTRYTITLE>setenv</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setenv
</REFNAME>
<REFPURPOSE>
change or add an environment variable
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;stdlib.h>

int setenv(const char *name, const char *value, int overwrite);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The setenv() function is as specified in the Single UNIX
Specification, Version 3.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-seteuid-2"> <REFMETA>
<REFENTRYTITLE>seteuid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>seteuid
</REFNAME>
<REFPURPOSE>
set effective user ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The seteuid() function is as specified in the Single UNIX
Specification, Version 3.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-setgroups-2"> <REFMETA>
<REFENTRYTITLE>setgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setgroups
</REFNAME>
<REFPURPOSE>
set list of supplementary group IDs
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define __USE_BSD
#include &lt;grp.h>

int setgroups(size_t size, const gid_t *list);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Sets the supplementary  groups  for  the process.
Only the super-user may use this function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is  returned.   On  error,  -1  is
returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
list has an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The user is not the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EINVA
</TERM>
<LISTITEM>
<PARA>
Size is greater than NGROUPS (32 for Linux 2.0.32).
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
The __USE_BSD flag probably shouldn't be required for setgroups.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>



<REFENTRY ID="baselib-sethostid-2"> <REFMETA>
<REFENTRYTITLE>sethostid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostid
</REFNAME>
<REFPURPOSE>
set the unique identifier of the current host
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int sethostid(long int hostid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Set a unique 32-bit identifier for the current machine. The 32-bit identifier is intended to be unique among all UNIX systems in existence. This normally resembles the Internet address for the local machine, as returned by gethostbyname(3), and thus usually never needs to be set.
</PARA><PARA>
The sethostid call is restricted to the superuser.
</PARA><PARA>
The hostid argument is stored in the file /etc/hostid.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
gethostid returns the 32-bit identifier for the current host as set by sethostid(2).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/hostid
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sethostname-2"> <REFMETA>
<REFENTRYTITLE>sethostname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostname
</REFNAME>
<REFPURPOSE>
set host name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;unistd.h>

int sethostname(const char *name, size_t len);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
This function is used to change the host name of the current processor.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
len is negative or len is larger than the maximum allowed size.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
the caller was not the superuser.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
name is an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The Single UNIX Specification, Version 2 guarantees that Host names
are limited to 255 bytes.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setmntent-3"> <REFMETA>
<REFENTRYTITLE>setmntent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setmntent
</REFNAME>
<REFPURPOSE>
get file system descriptor file entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>
#include &lt;mntent.h>

FILE *setmntent(const char *filename, const char *type);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This routine is used to access the file system description file /etc/fstab and the mounted file system description file /etc/mtab.
</PARA><PARA>
The setmntent() function opens the file system description file filep and returns a file pointer which can be used by getmntent(). The argument type is the type of access required and can take the same values as the mode argument of fopen(3).
</PARA><PARA>
The mntent structure is defined in &lt;mntent.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct mntent {
</TERM>
<LISTITEM>
<PARA>
                      char    *mnt_fsname;    /* name of mounted file system */
</PARA><PARA>
                      char    *mnt_dir;       /* file system path prefix */
</PARA><PARA>
                      char    *mnt_type;      /* mount type (see mntent.h) */
</PARA><PARA>
                      char    *mnt_opts;      /* mount options (see mntent.h) */
</PARA><PARA>
                      int     mnt_freq;       /* dump frequency in days */
</PARA><PARA>
                      int     mnt_passno;     /* pass number on parallel fsck */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/fstab file system description file
/etc/mtab mounted file system description file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setutent-3"> <REFMETA>
<REFENTRYTITLE>setutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setutent
</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

void setutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
setutent() rewinds the file pointer to the beginning of the utmp file. It is generally a Good Idea to call it before any of the other functions.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/var/run/utmp database of currently logged-in users
/var/log/wtmp database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigandset"> <REFMETA>
<REFENTRYTITLE>sigandset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigandset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical AND
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

extern int sigandset(sigset_t *set, const sigset_t *left,
                     const sigset_t *right);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A signal function that builds a new signal set by combining the two input sets using logical AND.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigblock-2"> <REFMETA>
<REFENTRYTITLE>sigblock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigblock
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

int sigblock(int mask);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
The sigblock system call adds the signals specified in mask to the set of signals currently being blocked from delivery.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Prototype for this function is only available if _BSD_SOURCE is defined before the inclusion of any system.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-siggetmask-2"> <REFMETA>
<REFENTRYTITLE>siggetmask</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>siggetmask
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

int siggetmask(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
siggetmask returns the current set of masked signals.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Prototype for this function is only available if _BSD_SOURCE is defined before the inclusion of any system header file.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigisemptyset"> <REFMETA>
<REFENTRYTITLE>sigisemptyset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigisemptyset</REFNAME>
<REFPURPOSE>
check for empty signal set
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;signal.h>

extern int sigisemptyset(const sigset_t *set);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
Check for empty signal set. Returns non-empty value if SET is not empty.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigorset"> <REFMETA>
<REFENTRYTITLE>sigorset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigorset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical OR
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt:signal.h>

extern int sigorset((sigset_t *set, const sigset_t *left,
                     const sigset_t *right));

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A signal function that builds a new signal set by combining the two input sets using logical OR.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigreturn-2"> <REFMETA>
<REFENTRYTITLE>sigreturn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigreturn
</REFNAME>
<REFPURPOSE>
return from signal handler and cleanup stack frame
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int sigreturn(unsigned long __unused);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When the Linux kernel creates the stack frame for a signal handler, a call to sigreturn is inserted into the stack frame so that the the signal handler will call sigreturn upon return. This inserted call to sigreturn cleans up the stack so that the process can restart from where it was interrupted by the signal.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
sigreturn never returns.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Warning
</TITLE>
<PARA>
sigreturn call is used by the kernel to implement signal handlers. It should never be called directly. Better yet, the specific use of the __unused argument varies depending on the architecture.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/usr/src/linux/arch/i386/kernel/signal.c
</PARA><PARA>
/usr/src/linux/arch/alpha/kernel/entry.s
</PARA>
</REFSECT1>

<!-- LDP GENERAL PUBLIC LICENSE  -->
<!-- Version 1a, November 1998   -->

</REFENTRY>

<REFENTRY ID="baselib-statfs-2"> <REFMETA>
<REFENTRYTITLE>statfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int statfs(const char *path, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
statfs returns information about a mounted file system. path is the path name of any file within the mounted filesystem.
</PARA><PARA>
buf is a pointer to a statfs structure defined as follow:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
ENOTDIR
</TERM>
<LISTITEM>
<PARA>
A component of the path prefix of path is not a directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENAMETOOLONG
</TERM>
<LISTITEM>
<PARA>
path is too long.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOENT 
</TERM>
<LISTITEM>
<PARA>
The file referred to by path does not exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
Search permission is denied for a component of the path prefix of path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ELOOP
</TERM>
<LISTITEM>
<PARA>
Too many symbolic links were encountered in translating path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
Buf or path points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient kernel memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
The filesystem path is on does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-statvfs64"> <REFMETA>
<REFENTRYTITLE>statvfs64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statvfs64</REFNAME>
<REFPURPOSE>
get file system statistics (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>11 June 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/statfs.h>

int statvfs64(__const char *__restrict __file,
              struct statvfs64 *__restrict __buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>11 June 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
statvfs64 returns information about a mounted file system.
</PARA><PARA>
The statvfs64() function is the 64-bit version of statvfs().
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-stime-2"> <REFMETA>
<REFENTRYTITLE>stime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stime
</REFNAME>
<REFPURPOSE>
set time
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _SVID_SOURCE /* glibc2 needs this */
#include &lt;time.h>

int stime(time_t *t);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
stime sets the system's idea of the time and date. Time, pointed to by t, is measured in seconds from 00:00:00 GMT January 1, 1970. stime() may only be executed by the super user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The caller is not the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Under glibc2, &lt;time.h> only provides a prototype when _SVID_SOURCE is defined.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-stpcpy-3"> <REFMETA>
<REFENTRYTITLE>stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpcpy</REFNAME>
<REFPURPOSE>
copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpcpy(char *dest, const char *src);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The stpcpy() function copies the string pointed to by src (including the terminating \0 character) to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
stpcpy() returns a pointer to the end of the string dest (that is, the address of the terminating null character) rather than the beginning.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Example
</TITLE>
<PARA>
For example, this program uses stpcpy to concatenate foo and bar to produce foobar, which it then prints.
</PARA><PARA>
#include &lt;string.h>
</PARA><PARA>
int
main (void)
{
  char *to = buffer;
  to = stpcpy (to, "foo");
  to = stpcpy (to, "bar");
  printf ("%s\n", buffer);
}
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-stpncpy-3"> <REFMETA>
<REFENTRYTITLE>stpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpncpy</REFNAME>
<REFPURPOSE>
copy a fixed-size string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpncpy (char *dest, const char *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The stpncpy function copies at most n characters from  the
string  pointed  to by src, including the terminating '\0'
character, to the array pointed  to  by  dest.  Exactly  n
characters  are written at dest. If the length strlen(src)
is smaller than n, the remaining characters in  the  array
pointed to by dest are filled with '\0' characters. If the
length strlen(src) is greater or equal to  n,  the  string
pointed to by dest will not be '\0' terminated.

The strings may not overlap.

The programmer must ensure that there is room for at least
n characters at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
stpncpy returns a pointer to the terminating null in dest,
or, if dest is not null-terminated, dest + n.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strcasestr"> <REFMETA>
<REFENTRYTITLE>strcasestr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strcasestr</REFNAME>
<REFPURPOSE>
locate a substring - ignores the case of both strings
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strcasestr(const char *haystack, const char *needle);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Similar to strstr but this function ignores the case of both strings.
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strerror-r"> <REFMETA>
<REFENTRYTITLE>strerror_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strerror_r</REFNAME>
<REFPURPOSE>
reentrant version of strerror
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The strerror_r function is as specified in the Single UNIX
Specification, Version 3 but with the
differences listed below.
</para>
<refsect2>
<title>Return Type</title>
<para>
The strerror_r function may return either int (as specified in the
Single UNIX Specification, Version 3), or char *.
Applications may not rely on the return type or
value.
</para>
</refsect2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strfry-3"> <REFMETA>
<REFENTRYTITLE>strfry</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strfry</REFNAME>
<REFPURPOSE>
randomize a string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strfry(char *string);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strfry() function randomizes the contents of string by using rand(3) to randomly swap characters in the string. The result is an anagram of string.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strfry() functions returns a pointer to the randomized string.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strndup"> <REFMETA>
<REFENTRYTITLE>strndup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strndup</REFNAME>
<REFPURPOSE>
return a malloc'd copy of at most the specified number of bytes of a string 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern char *strndup(const char *string, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Return a malloc'd copy of at most n bytes of string. The resultant string is terminated even if no null terminator appears before STRING[N].
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strnlen-3"> <REFMETA>
<REFENTRYTITLE>strnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

size_t strnlen(const char *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strnlen function returns the number of characters in the string pointed to by s, not including the terminating '\0' character, but at most maxlen. In doing this, strnlen looks only at the first maxlen characters at s and never beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strnlen function returns strlen(s), if that is less than maxlen, or maxlen if there is no '\0' character among the first maxlen characters pointed to by s.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strptime-3"> <REFMETA>
<REFENTRYTITLE>strptime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strptime
</REFNAME>
<REFPURPOSE>
parse a time string
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "strptime" is as specified in the Single UNIX
Specification, Version 2 but with the
following differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Number of leading zeroes limited
</TITLE>
<PARA>
For all fields for which the Single UNIX Specification, Version 2
specifies "leading zeros are
permitted but not required", applications must not expect to be able
to supply more leading zeroes than would be implied by the range of
the field.  Implementations may choose to either match an input with
excess leading zeroes, or treat this as a non-matching input.  For
example, %j has a range of 001 to 366, so 0, 00, 000, 001, or 045 are
acceptable inputs, but inputs such as 0000, 0366 and the like are not.
</PARA>
</REFSECT2>

</REFSECT1>

<REFSECT1>
<TITLE>Rationale
</TITLE>
<PARA>
Glibc developers consider forbidding excess leading zeroes
to be the correct behavior.  When trying to parse a given input
against several format strings, forbidding excess leading zeroes could
be helpful.  For example, if one matches "0011-12-26" against
"%m-%d-%Y" and then against "%Y-%m-%d", it seems useful for the first
match to fail, as it would be perverse to parse that date as November
12, year 26.  The second pattern parses it as December 26, year 11.
</PARA>
<PARA>
The Single UNIX Specification is not explicit that an unlimited number of
leading zeroes are required, although it may imply this.  The LSB
explicitly allows implementations to have either behavior.  Future
versions of this standard may require implementations to forbid excess
leading zeroes.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-strsep-3"> <REFMETA>
<REFENTRYTITLE>strsep</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsep</REFNAME>
<REFPURPOSE>
extract token from string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strsep(char **stringp, const char *delim);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If *stringp is NULL, the strsep() function returns NULL and does nothing else. Otherwise, this function finds the first token in the string *stringp, where tokens are delimited by symbols in the string delim. This token is terminated with a \0 character (by overwriting the delimiter) and *stringp is updated to point past the token. In case no delimiter was found, the token is taken to be the entire string *stringp, and *stringp is made NULL.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strsep() function returns a pointer to the token, that is, it returns the original value of *stringp.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The strsep() function was introduced as a replacement for strtok(), since the latter cannot handle empty fields. However, strtok() conforms to ANSI-C and hence is more portable.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
This function suffers from the same problems as strtok(). In particular, it modifies the original string. Avoid it.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strsignal-3"> <REFMETA>
<REFENTRYTITLE>strsignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsignal</REFNAME>
<REFPURPOSE>
return string describing signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

char *strsignal(int sig);

extern const char * const sys_siglist[];
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strsignal() function returns a string describing the signal number passed in the argument sig. The string can only be used until the next call to strsignal().
</PARA><PARA>
The array sys_siglist holds the signal description strings indexed by signal number. The strsignal() function should be used if possible instead of this array.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strsignal() function returns the appropriate description string, or an unknown signal message if the signal number is invalid. On some systems (but not on Linux), a NULL pointer may be returned instead for an invalid signal number.
</PARA>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strtok-r-3"> <REFMETA>
<REFENTRYTITLE>strtok_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtok_r
</REFNAME>
<REFPURPOSE>
extract tokens from strings
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strtok_r(char *s, const char *delim, char **ptrptr);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A token is a nonempty string of characters not occurring in the string delim, followed by \0 or by a character occurring in delim.
</PARA><PARA>
The strtok_r() function can be used to parse the string s into tokens. The first call to strtok_r() should have s as its first argument. Subsequent calls should have the first argument set to NULL. Each call returns a pointer to the next token, or NULL when no more tokens are found.
</PARA><PARA>
If a token ends with a delimiter, this delimiting character is overwritten with a \0 and a pointer to the next character is saved for the next call to strtok_r(). The delimiter string delim may be different for each call.
</PARA><PARA>
ptrptr is a user allocated char* pointer. It must be the same while parsing the same string.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
Never use this function. Note that:
<ITEMIZEDLIST>
<LISTITEM>
<PARA>
It modifies its first argument.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The identity of the delimiting character is lost.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
This function cannot be used on constant strings.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strtok_r() function returns a pointer to the next token, or NULL if there are no more tokens.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-strtoq-3"> <REFMETA>
<REFENTRYTITLE>strtoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtoq
</REFNAME>
<REFPURPOSE>
convert string value to a long or quad_t integer
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;stdlib.h>
#include &lt;limits.h>

quadt strtoq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strtoq() function converts the string in nptr to a quadt value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.
</PARA><PARA>
The string may begin with an arbitrary amount of white space (as determine by isspace(3)) followed by a single optional + or - sign. If base is zero or 16, the string may then include a 0x prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is 0, in which case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to a long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter A in either upper or lower case represents 10, B represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
strtoq() function returns the result of the conversion, unless the value would underflow or overflow. If an underflow occurs, strtoq() returns QUAD_MIN. If an overflow occurs, strtoq() returns QUAD_MAX. In both cases, errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strtouq-3"> <REFMETA>
<REFENTRYTITLE>strtouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtouq
</REFNAME>
<REFPURPOSE>
convert a string to an uquad_t
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;stdlib.h>
#include &lt;limits.h>

uquadt strtouq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strtouq() function converts the string in nptr to a uquadt value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.
</PARA><PARA>
The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional + or - sign. If base is zero or 16, the string may then include a 0x prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is 0, in which case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to an unsigned long value in the obvious manner, stopping at the end of the string or at the first character that does not produce a valid digit in the given base. (In bases above 10, the letter A in either upper or lower case represents 10, B represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
Upon success the strtouq() function returns either the result of the conversion or, if there was a leading minus sign, the negation of the result of the conversion, unless the original (non-negated) value would overflow. In the case of an overflow the function returns UQUAD_MAX and the global variable errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strverscmp"> <REFMETA>
<REFENTRYTITLE>strverscmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strverscmp</REFNAME>
<REFPURPOSE>
compare strings holding name and indices/version numbers
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern int strverscmp(const char *s1, const char *s2);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Compare s1 and s2 as strings holding name and indices/version numbers.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-system-3"> <REFMETA>
<REFENTRYTITLE>system</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>system
</REFNAME>
<REFPURPOSE>
execute a shell command
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdlib.h>

int system (const char * string);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
system() executes a command specified in string by calling /bin/sh -c string, and returns after the command has been completed. During execution of the command, SIGCHLD will be blocked, and SIGINT and SIGQUIT will be ignored.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The value returned is 127 if the execve() call for /bin/sh fails, -1 if there was another error and the return code of the command otherwise.
</PARA><PARA>
If the value of string is NULL, system() returns nonzero if the shell is available, and zero if not.
</PARA><PARA>
system() does not affect the wait status of any other children.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The fact that system() ignores interrupts is often not what a program
wants. The Single UNIX Specification describes some of the consequences
- one additional one is that a program which calls system() from a loop
cannot reliably be interrupted.  Many programs will want to use the
exec(3) family of functions instead.
</PARA><PARA>
Do not use system() from a program with suid or sgid privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with suid or sgid privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)
</PARA><PARA>
The check for the availability of /bin/sh is not actually performed; it is always assumed to be available. ISO C specifies the check, but POSIX.2 specifies that the return shall always be non-zero, since a system without the shell is not conforming, and it is this that is implemented.
</PARA><PARA>
It is possible for the shell command to return 127, so that code is not a sure indication that the execve() call failed; check errno to make sure.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-textdomain"> <REFMETA>
<REFENTRYTITLE>textdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>textdomain</REFNAME>
<REFPURPOSE>
set the current default message catalog to <emphasis>domainname</emphasis>
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2002</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *textdomain(const char *domainname);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Set the current default message catalog to <emphasis>domainname</emphasis>
which remains valid across subsequent calls to 
<emphasis>setlocale()</emphasis>, and <emphasis>gettext()</emphasis>.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
Upon success, returns the currently selected domain.  If failed, then a
null ponter will be returned.
</PARA>
<PARA>
If <emphasis>domainname</emphasis> is null, return the current default.
</PARA>
<PARA>
If <emphasis>domainname</emphasis> is "", reset to the default of "messages". 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
The function may have failed if there was "insufficent memory available."
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-unlink-3"> <REFMETA>
<REFENTRYTITLE>unlink</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>unlink
</REFNAME>
<REFPURPOSE>
remove a directory entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int unlink(const char *path);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The specification for "unlink" is as specified in the Single UNIX
Specification, Version 2 but with the
following differences as listed below.
</PARA>

<para>
See also <xref linkend="exec-link-unlink" />.
</para>

<REFSECT2>
<TITLE>May return EISDIR on directories
</TITLE>
<PARA>
If <replaceable>path</replaceable> specifies a directory, the
implementation may return EISDIR instead of EPERM as specified by
Single UNIX Specification, Version 2.
<footnote>
<PARA>
The Linux kernel has deliberately chosen EISDIR for this
case and does not expect to change (Al Viro, personal communication).
</PARA>
</footnote>
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-unsetenv-3"> <REFMETA>
<REFENTRYTITLE>unsetenv</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>unsetenv
</REFNAME>
<REFPURPOSE>
delete an environment variable
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<SYNOPSIS>
#include &lt;stdlib.h>

void unsetenv(const char *name);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The unsetenv() function is as specified in the Single UNIX
Specification, Version 3.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-vasprintf"> <REFMETA>
<REFENTRYTITLE>vasprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vasprintf</REFNAME>
<REFPURPOSE>
write formatted output to a string dynamically allocated with malloc and store the address of the string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern int vasprintf(char **restrict ptr, const char *restrict f,
                     G_va_list arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Write formatted output to a string dynamically allocated with malloc.
</PARA><PARA>
Store the address of the string in *ptr.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-vdprintf"> <REFMETA>
<REFENTRYTITLE>vdprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vdprintf</REFNAME>
<REFPURPOSE>
write formatted output to a file descriptor
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern int vdprintf(int fd, const char *restrict fmt,
                    G_va_list arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Write formatted output to a file descriptor.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-verrx-3"> <REFMETA>
<REFENTRYTITLE>verrx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>verrx
</REFNAME>
<REFPURPOSE>display formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void verrx(int eval, const char *fmt, valist args);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The verrx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA><PARA>
The verrx() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-vsyslog-3"> <REFMETA>
<REFENTRYTITLE>vsyslog</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>vsyslog
</REFNAME>
<REFPURPOSE>
log to system log
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<SYNOPSIS>
void vsyslog (int priority, char *message, va_list arglist)
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
Identical to syslog as specified in the Single UNIX Specification, except that
<replaceable>arglist</replaceable> (as defined by stdarg.h) replaces
the variable number of arguments.
</PARA>
<PARA>
The caller is responsible for running va_end after calling vsyslog.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-wait4-2"> <REFMETA>
<REFENTRYTITLE>wait4</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wait4
</REFNAME>
<REFPURPOSE>
wait for process termination, BSD style
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _USE_BSD
#include &lt;sys/types.h>
#include &lt;sys/resource.h>
#include &lt;sys/wait.h>

pid_t wait4(pid_t pid, int *status, int options,
            struct rusage *rusage);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wait4 function suspends execution of the current process until a child as specified by the pid argument has exited, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function. If a child as requested by pid has already exited by the time of the call (a so-called "zombie" process), the function returns immediately. Any system resources used by the child are freed.
</PARA><PARA>
The value of pid can be one of:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
&lt; -1   
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to the absolute value of pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
-1     
</TERM>
<LISTITEM>
<PARA>
wait for any child process; this is equivalent to calling wait3.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
0      
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to that of the calling process.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
&gt; 0    
</TERM>
<LISTITEM>
<PARA>
wait for the child whose process ID is equal to the value of pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
The value of options is a bitwise OR of zero or more of the following constants:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WNOHANG
</TERM>
<LISTITEM>
<PARA>
return immediately if no child is there to be waited for.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WUNTRACED
</TERM>
<LISTITEM>
<PARA>
return for children which are stopped, and whose status has not been reported.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If status is not NULL, wait4 stores status information in the location pointed to by status.
</PARA><PARA>
This status can be evaluated with the following macros (these macros take the stat buffer (an int) as an argument -- not a pointer to the buffer!):
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WIFEXITED(status)
</TERM>
<LISTITEM>
<PARA>
is non-zero if the child exited normally.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WEXITSTATUS(status)
</TERM>
<LISTITEM>
<PARA>
evaluates to the least significant eight bits of the return code of the child which terminated, which may have been set as the argument to a call to exit() or as the argument for a return statement in the main program. This macro can only be evaluated if WIFEXITED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSIGNALED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process exited because of a signal which was not caught.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WTERMSIG(status)
</TERM>
<LISTITEM>
<PARA>
returns the number of the signal that caused the child process to terminate. This macro can only be evaluated if WIFSIGNALED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSTOPPED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process which caused the return is currently stopped; this is only possible if the call was done using WUNTRACED.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WSTOPSIG(status)
</TERM>

<LISTITEM>
<PARA>
returns the number of the signal which caused the child to stop. This macro can only be evaluated if WIFSTOPPED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If rusage is not NULL, the struct rusage as defined in &lt;sys/resource.h> it points to will be filled with accounting information. See getrusage(2) for details.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The process ID of the child which exited, -1 on error (in particular, when no unwaited-for child processes of the specified kind exist) or zero if WNOHANG was used and no child was available  yet. In the latter two cases errno will be set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ECHILD 
</TERM>
<LISTITEM>
<PARA>
No unwaited-for child process as specified does exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ERESTARTSYS
</TERM>
<LISTITEM>
<PARA>
If WNOHANG was not set and an unblocked signal or a SIGCHLD was caught. This error is returned by the system call. The library interface is not allowed to return ERESTARTSYS, but will return EINTR.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-waitpid-3"> <REFMETA>
<REFENTRYTITLE>waitpid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>waitpid
</REFNAME>
<REFPURPOSE>
wait for child process
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description</TITLE>
<PARA>
The specification for <function>waitpid</function> is as specified in
the Single UNIX Specification but with the following differences as
listed below.
</PARA>

<REFSECT2>
<TITLE>Need not support WCONTINUED</TITLE>
<PARA>
Implementations need not support the functionality of WCONTINUED or
WIFCONTINUED.
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-warn-3"> <REFMETA>
<REFENTRYTITLE>warn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warn
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void warn(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The warn() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The error message string affiliated with the current value of the global variable errno is output. The output is followed by a newline character.
</PARA>
</REFSECT1>

<!-- 4th Berkeley Distribution        June 9, 1993  -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-warnx-3"> <REFMETA>
<REFENTRYTITLE>warnx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warnx
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void warnx(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The warnx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA>
</REFSECT1>
<!--        4th Berkeley Distribution        June 9, 1993    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-wcpcpy-3"> <REFMETA>
<REFENTRYTITLE>wcpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpcpy
</REFNAME>
<REFPURPOSE>
copy a wide character string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcpcpy(wchar_t *dest, const wchar_t *src);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcpcpy function is the wide-character equivalent of the stpcpy function. It copies the wide character string pointed to by src, including the terminating L'\0' character, to the array pointed to by dest.
</PARA><PARA>
The strings may not overlap.
</PARA><PARA>
The programmer must ensure that there is room for at least wcslen(src)+1 wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
wcpcpy returns a pointer to the end of the wide-character string dest, that is, a pointer to the terminating L'\0' character.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcpncpy-3"> <REFMETA>
<REFENTRYTITLE>wcpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpncpy
</REFNAME>
<REFPURPOSE>
copy a fixed-size string of wide characters, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcpncpy(wchar_t *dest, const wchar_t *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcpncpy function is the wide-character equivalent of the stpncpy function. It copies at most n wide characters from the wide-character string pointed to by src, including the terminating L'\0' character, to the array pointed to by dest. Exactly n wide characters are written at dest. If the length wcslen(src) is smaller than n, the remaining wide characters in the array pointed to by dest are filled with L'\0' characters. If the length wcslen(src) is greater or equal to n, the string pointed to by dest will not be L'\0' terminated.
</PARA><PARA>
The strings may not overlap.
</PARA><PARA>
The programmer must ensure that there is room for at least n wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
wcpncpy returns a pointer to the last wide character written, i.e. dest + n - 1.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcscasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcscasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcscasecmp
</REFNAME>
<REFPURPOSE>
compare two wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

int wcscasecmp(const wchar_t *s1, const wchar_t *s2);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcscasecmp function is the wide-character equivalent of the strcasecmp function. It compares the wide-character string pointed to by s1 and the wide-character string pointed to by s2, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcscasecmp function returns zero if the wide-character strings at s1 and s2 are equal except for case distinctions. It returns a positive integer if s1 is greater than s2, ignoring case. It returns a negative integer if s1 is smaller than s2, ignoring case.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcscasecmp depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsdup-3"> <REFMETA>
<REFENTRYTITLE>wcsdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsdup
</REFNAME>
<REFPURPOSE>
duplicate a wide-character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcsdup(const wchar_t *s);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsdup function is the wide-character equivalent of the strdup function. It allocates and returns a new wide-character string whose initial contents is a duplicate of the wide-character string pointed to by s.
</PARA><PARA>
Memory for the new wide-character string is obtained with malloc(3), and can be freed with free(3).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsdup function returns a pointer to the new wide-character string, or NULL if sufficient memory was not available.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsncasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcsncasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsncasecmp</REFNAME>
<REFPURPOSE>
compare two fixed-size wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

int wcsncasecmp(const wchar_t *s1, const wchar_t *s2, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsncasecmp function is the wide-character equivalent of the strncasecmp function. It compares the wide-character string pointed to by s1 and the wide-character string pointed to by s2, but at most n wide characters from each string, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsncasecmp function returns zero if the wide-character strings at s1 and s2, truncated to at most length n, are equal except for case distinctions. It returns a positive integer if truncated s1 is greater than truncated s2, ignoring case. It returns a negative integer if truncated s1 is smaller than truncated s2, ignoring case.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsncasecmp depends on the LC_CTYPE category of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcsnlen-3"> <REFMETA>
<REFENTRYTITLE>wcsnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size wide-character string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnlen(const wchar_t *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnlen function is the wide-character equivalent of the strnlen function. It returns the number of wide-characters in the string pointed to by s, not including the terminating  L'\0' character, but at most maxlen. In doing this, wcsnlen looks only at the first maxlen wide-characters at s and never beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsnlen function returns wcslen(s), if that is less than maxlen, or maxlen if there is no L'\0' character among the first maxlen wide characters pointed to by s.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsncasecmp depends on the LC_CTYPE category of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcsnrtombs-3"> <REFMETA>
<REFENTRYTITLE>wcsnrtombs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnrtombs</REFNAME>
<REFPURPOSE>
convert a wide character string to a multi-byte string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnrtombs(char *dest, const wchar_t **src, size_t nwc,
                  size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnrtombs function is like the wcsrtombs function, except that the number of wide characters to be converted, starting at *src, is limited to nwc.
</PARA><PARA>
If dest is not a NULL pointer, the wcsnrtombs function converts at most nwc wide characters from the wide-character string *src to a multibyte string starting at dest. At most len bytes are written to dest. The  state *ps is updated. The conversion is effectively performed by repeatedly calling wcrtomb(dest,*src,ps), as long as this call succeeds, and then incrementing dest by the number of bytes written and *src by one. The conversion can stop for three reasons:
</PARA><PARA>
1. A wide character has been encountered that can not be represented as a multibyte sequence (according to the current locale). In this case *src is left pointing to the invalid wide character, (size_t)(-1) is returned, and errno is set to EILSEQ.
</PARA><PARA>
2. nwc wide characters have been converted without encountering a L'\0', or the length limit forces a stop. In this case *src is left pointing to the next wide character to be converted, and the number of bytes written to dest is returned.
</PARA><PARA>
3. The wide-character string has been completely converted, including the terminating L'\0' (which has the side effect of bringing back *ps to the initial state). In this case *src is set to NULL, and the number of bytes written to dest, excluding the terminating '\0' byte, is returned.
</PARA><PARA>
If dest is NULL, len is ignored, and the conversion proceeds as above, except that the converted bytes are not written out to memory, and that no destination length limit exists.
</PARA><PARA>
In both of the above cases, if ps is a NULL pointer, a static anonymous state only known to the wcsnrtombs function is used instead.
</PARA><PARA>
The programmer must ensure that there is room for at least len bytes at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsnrtombs function returns the number of bytes that make up the converted part of multibyte sequence, not including the terminating null byte. If a wide character was encountered which could not be converted, (size_t)(-1) is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsnrtombs depends on the LC_CTYPE category of the current locale.
</PARA><PARA>
Passing NULL as ps is not multi-thread safe.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstoq"> <REFMETA>
<REFENTRYTITLE>wcstoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstoq</REFNAME>
<REFPURPOSE>
convert initial portion of wide string NPTR to long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

extern long long int wcstoq(const wchar_t *restrict nptr,
                            wchar_t **restrict endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Convert initial portion of wide string NPTR to long int representation.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstouq"> <REFMETA>
<REFENTRYTITLE>wcstouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstouq</REFNAME>
<REFPURPOSE>
convert initial portion of wide string NPTR to unsigned long long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

extern unsigned long long int wcstouq(const wchar_t *restrict nptr,
                           wchar_t **restrict endptr,int base);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Convert initial portion of wide string NPTR to unsigned long long int representation.
</PARA>

</REFSECT1>
</REFENTRY>


</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->
<!--    at Tue Sep 24 20:12:36 2002 -->
<SECT1 ID=libm>
<TITLE>Interfaces for libm</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libm Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libm</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>See archLSB.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-13-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-13-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<!--libgroup-->
<TITLE>Math</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libm - Math Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>acos<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>ceilf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>erfcl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>j1<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>remainderl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>acosf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ceill<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>erff<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>j1f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>remquo<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>acosh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>cexp<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>erfl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>j1l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>remquof<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>acoshf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cexpf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>exp<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>jn<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>remquol<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>acoshl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cexpl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>expm1<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>jnf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>rint<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>acosl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cimag<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fabs<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>jnl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>rintf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>asin<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>cimagf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fabsf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ldexp<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>rintl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>asinf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cimagl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fabsl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ldexpf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>round<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>asinh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>clog<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fdim<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ldexpl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>roundf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>asinhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>clog10<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fdimf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgamma<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>roundl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>asinhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>clog10f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fdiml<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgamma_r<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalb<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>asinl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>clog10l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>feclearexcept<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgammaf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atan<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>clogf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fegetenv<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgammaf_r<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atan2<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>clogl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fegetexceptflag<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgammal<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbln<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atan2f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>conj<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fegetround<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lgammal_r<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalblnf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atan2l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>conjf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>feholdexcept<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llrint<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalblnl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atanf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>conjl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>feraiseexcept<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llrintf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbn<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atanh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>copysign<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fesetenv<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llrintl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbnf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atanhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>copysignf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fesetexceptflag<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llround<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>scalbnl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atanhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>copysignl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fesetround<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llroundf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>significand<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>atanl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cos<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>fetestexcept<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>llroundl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>significandf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cabs<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>cosf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>feupdateenv<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>log<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>significandl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cabsf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cosh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>finite<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>log10<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>sin<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cabsl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>coshf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>finitef<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>log1p<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>sincos<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacos<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>coshl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>finitel<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>logb<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>sincosf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacosf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cosl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>floor<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>lrint<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sincosl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacosh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cpow<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>floorf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lrintf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sinf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacoshf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cpowf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>floorl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lrintl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sinh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacoshl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cpowl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fma<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lround<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sinhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cacosl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cproj<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmaf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lroundf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sinhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>carg<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cprojf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmal<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>lroundl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sinl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cargf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>cprojl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmax<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>matherr<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sqrt<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cargl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>creal<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmaxf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>modf<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>sqrtf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>casin<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>crealf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmaxl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>modff<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>sqrtl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>casinf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>creall<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmin<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>modfl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tan<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>casinh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csin<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fminf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nan<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tanf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>casinhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csinf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fminl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nanf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tanh<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>casinhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csinh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmod<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>nanl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tanhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>casinl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csinhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmodf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nearbyint<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tanhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catan<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csinhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>fmodl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nearbyintf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tanl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catanf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csinl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>frexp<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>nearbyintl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tgamma<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catanh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csqrt<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>frexpf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nextafter<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>tgammaf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catanhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csqrtf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>frexpl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nextafterf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>tgammal<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catanhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>csqrtl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>gamma<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>nextafterl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>trunc<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>catanl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ctan<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>gammaf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nexttoward<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>truncf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cbrt<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>ctanf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>gammal<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>nexttowardf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>truncl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>cbrtf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ctanh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>hypot<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>nexttowardl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y0<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>cbrtl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ctanhf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>hypotf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>pow<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y0f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccos<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ctanhl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>hypotl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>pow10<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y0l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccosf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ctanl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ilogb<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>pow10f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y1<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccosh<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>dremf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ilogbf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>pow10l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y1f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccoshf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>dreml<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ilogbl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>powf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>y1l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccoshl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>erf<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>j0<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>powl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>yn<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>ccosl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>erfc<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>j0f<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>remainder<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>ynf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
<ROW>
<ENTRY>ceil<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY>erfcf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>j0l<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>remainderf<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
<ENTRY>ynl<FOOTNOTEREF LINKEND="std-13-25"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<!--libgroupdata-->
<TABLE>
<TITLE>libm - Math Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>signgam<FOOTNOTEREF LINKEND="std-13-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libm-ddefs>
<TITLE>Data Definitions for libm</TITLE>
<PARA>
This section contains standard data definitions that describe system data. These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
ISO C serves as the LSB reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>float.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define DBL_MAX	1.7976931348623157e+308
</SCREEN>
</SECT2>
<SECT2>
<TITLE>math.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define HUGE_VAL	0x7FF00000UL
#define DOMAIN	1
#define SING	2


struct exception
{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
}
 ;
#define M_1_PI	0.31830988618379067154
#define M_LOG10E	0.43429448190325182765
#define M_2_PI	0.63661977236758134308
#define M_LN2	0.69314718055994530942
#define M_SQRT1_2	0.70710678118654752440
#define M_PI_4	0.78539816339744830962
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2	1.41421356237309504880
#define M_LOG2E	1.4426950408889634074
#define M_PI_2	1.57079632679489661923
#define M_LN10	2.30258509299404568402
#define M_E	2.7182818284590452354
#define M_PI	3.14159265358979323846
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->
<!--    at Tue Sep 24 20:13:04 2002 -->
<SECT1 ID=libpthread>
<TITLE>Interfaces for libpthread</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libpthread</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libpthread.so.0</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
LSB systems support POSIX threads with the following exceptions.
This list is intended to match the behavior of historical Linux
implementations.  Applications should be written to deal with either
POSIX threads or the thread behaviors described here.

<ITEMIZEDLIST MARK=BULLET>

<LISTITEM>
<PARA>
POSIX specifies a concept of per-process rather than per-thread
signals.  The LSB does not require this behavior; traditional Linux
implementations have had per-thread signals only.  A related issue is
that applications cannot rely on getpid() returning the same value
in different threads.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Note: one implication of per-thread signals is that a core dump (for
example) may not stop all threads in a given process.  This may be an
issue when designing ways to stop/start applications.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications which create child processes (using fork() and the like)
must then wait for them (using waitpid() family of functions) in the
same thread as they created them.  Note that coding applications this
way will work both with full POSIX threads and legacy Linux thread
implementations.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
POSIX specifies that changing the user or group id instantly affects
the behavior of all threads.  This behavior is not specified;
applications must use their own lock if they need this behavior.
Rationale: it seems unnecessary and it is a performance hit (an SMP
kernel must lock the user id).
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Although this standard doesn't have a way to list processes (/proc or
"ps" command line isn't in, right?), it is our intention to not
specify one way or the other whether multiple threads appear as
separate processes or as a single process.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on resource limits (getrusage and setrusage)
being maintained per-process rather than per-thread.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must disconnect from the controlling tty before
calling pthread_create.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
times() doesn't account for all threads, just the caller.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must not call pthread_cancel if they call any system
libraries (most notably X Window System libraries), as system libraries are
not guaranteed to be thread safe.  Likewise, for such libraries, only one
thread per process may call them.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on fcntl/lockf locks being visible
per-process rather than per-thread.  Likewise for mandatory file
locks.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Threaded applications cannot use SIGUSR1 or SIGUSR2.
</PARA>
</LISTITEM>

</ITEMIZEDLIST>
</PARA>

<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-132-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-132-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<!--libgroup-->
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread - Posix Threads Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>pthread_attr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_attr_setstackaddr<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_getspecific<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_once<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_setcanceltype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getdetachstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_attr_setstacksize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_join<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_setconcurrency<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getguardsize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cancel<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_key_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_setschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getinheritsched<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_broadcast<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_key_delete<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_rdlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_setspecific<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_kill<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_timedrdlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_sigmask<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getschedpolicy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutex_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_timedwrlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_testcancel<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getscope<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_signal<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutex_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_tryrdlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_close<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getstackaddr<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_timedwait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutex_lock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_trywrlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_getstacksize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_cond_wait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutex_trylock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_unlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_getvalue<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_condattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutex_unlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlock_wrlock<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setdetachstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_condattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlockattr_destroy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_open<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setguardsize<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_getpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlockattr_getpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_post<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setinheritsched<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_detach<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_gettype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlockattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_timedwait<FOOTNOTEREF LINKEND="std-132-10"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_equal<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_init<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_rwlockattr_setpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_trywait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setschedpolicy<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_exit<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_setpshared<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_self<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_unlink<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
<ROW>
<ENTRY>pthread_attr_setscope<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_getschedparam<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_mutexattr_settype<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>pthread_setcancelstate<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
<ENTRY>sem_wait<FOOTNOTEREF LINKEND="std-132-5"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE>Data Definitions for libpthread</TITLE>
<PARA>
This section contains standard data definitions that describe system data. These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
ISO C serves as the LSB reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>pthread.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define PTHREAD_MUTEX_DEFAULT	1
#define PTHREAD_MUTEX_NORMAL	1
#define PTHREAD_MUTEX_TIMED_NP	1
#define PTHREAD_MUTEX_RECURSIVE	2
#define PTHREAD_MUTEX_ERRORCHECK	3
#define __LOCK_INITIALIZER	{ 0, 0 }
#define PTHREAD_RWLOCK_INITIALIZER	{ __LOCK_INITIALIZER, 0, NULL, NULL, NULL,PTHREAD_RWLOCK_DEFAULT_NP, PTHREAD_PROCESS_PRIVATE }
#define PTHREAD_MUTEX_INITIALIZER	{0,0,0,PTHREAD_MUTEX_TIMED_NP,__LOCK_INITIALIZER}
#define PTHREAD_COND_INITIALIZER	{__LOCK_INITIALIZER,0}


typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef int __atomic_lock_t;


typedef unsigned long pthread_t;
struct _pthread_fastlock
{
  long __status;
  __atomic_lock_t __spinlock;
}
 ;


typedef struct _pthread_descr_struct *_pthread_descr;


typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
}
pthread_mutex_t;
typedef struct
{
  int __mutexkind;
}
pthread_mutexattr_t;


typedef struct
{
  int __detachstate;
  int __schedpolicy;
  struct sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  unsigned long __stacksize;
}
pthread_attr_t;


typedef struct
{
  struct _pthread_fastlock lock;
  _pthread_descr wait_chain;
}
pthread_cond_t;
typedef void *pthread_condattr_t;


typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
}
pthread_rwlock_t;
typedef struct
{
  int __lockkind;
  int __pshared;
}
pthread_rwlockattr_t;



#define PTHREAD_CREATE_JOINABLE	0
#define PTHREAD_INHERIT_SCHED	0
#define PTHREAD_ONCE_INIT	0
#define PTHREAD_PROCESS_PRIVATE	0
#define PTHREAD_SCOPE_SYSTEM	0
#define PTHREAD_CREATE_DETACHED	1
#define PTHREAD_EXPLICIT_SCHED	1
#define PTHREAD_PROCESS_SHARED	1
#define PTHREAD_SCOPE_PROCESS	1



#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_DEFERRED	0
#define PTHREAD_CANCEL_ENABLE	0
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
#define PTHREAD_CANCEL_DISABLE	1
</SCREEN>
</SECT2>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>






typedef struct
{
  struct _pthread_fastlock __sem_lock;
  int __sem_value;
  _pthread_descr __sem_waiting;
}
sem_t;
#define SEM_FAILED	((sem_t*)0)



#define SEM_VALUE_MAX	((int)((~0u)>>1))
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libpthreadman>
<TITLE>Interfaces Definitions for libpthread</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib-sem-timedwait-3"> <REFMETA>
<REFENTRYTITLE>sem_timedwait</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sem_timedwait
</REFNAME>
<REFPURPOSE>
operation on semaphore
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;semaphore.h>
int sem_timedwait(sem_t *__restrict __sem, 
		  __const struct timespec *__restrict __abstime);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
sem_timedwait() waits for semaphore object SEM being posted. It is a new function from IEEE Std. 1003.1-200x that is similar to sem_wait but waits only until ABSTIME.
</PARA>
</REFSECT1>
</REFENTRY>

</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->
<!--    at Tue Sep 24 20:13:20 2002 -->
<SECT1 ID=libdl>
<TITLE>Interfaces for libdl</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libdl Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libdl</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libdl.so.2</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-27-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-27-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<!--libgroup-->
<TITLE>Dynamic Loader</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libdl - Dynamic Loader Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>dladdr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-10"></ENTRY>
<ENTRY>dlclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY>
<ENTRY>dlerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY>
<ENTRY>dlopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY>
<ENTRY>dlsym(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libdl-ddefs>
<TITLE>Data Definitions for libdl</TITLE>
<PARA>
This section contains standard data definitions that describe system data. These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
ISO C serves as the LSB reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>dlfcn.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define RTLD_LOCAL	0
#define RTLD_LAZY	0x00001
#define RTLD_NOW	0x00002
#define RTLD_GLOBAL	0x00100


typedef struct
{
  char *dli_fname;
  void *dli_fbase;
  char *dli_sname;
  void *dli_saddr;
}
Dl_info;
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libdlman>
<TITLE>Interfaces Definitions for libdl</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib-dladdr-3"> <REFMETA>
<REFENTRYTITLE>dladdr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dladdr
</REFNAME>
<REFPURPOSE>
library routine for dynamic linking of object files
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
cc ... -ldl ...

#include &lt;dlfcn.h>

typedef struct {
             const char      *dli_fname;
             void            *dli_fbase;
             const char      *dli_sname;
             void            *dli_saddr;
} Dl_info;

int dladdr(void *address, Dlinfo *dlip);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function implements the System V dynamic linking routines.
</PARA><PARA>
The dladdr() function is the inverse of the dlsym() function. If the given address is successfully located inside a module, dladdr() returns nonzero, otherwise 0. On a successful return, the fields of dlip are filled in as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
dli_fname
</TERM>
<LISTITEM>
<PARA>
the pathname of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dli_fbase   
</TERM>
<LISTITEM>
<PARA>
the base address of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dli_sname   
</TERM>
<LISTITEM>
<PARA>
the name of the highest addressed symbol whose address precedes the given address 
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dli_saddr   
</TERM>
<LISTITEM>
<PARA>
the address of that symbol
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
Shared objects must be linked using the -shared option to the linker ld(1). The linker flag -rpath may be used to add a directory to the default search path for shared objects and shared libraries. The linker flag -E or the C compiler flag -rdynamic should be used to cause the application to export its symbols to the shared objects.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Environment
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
LD_LIBRARY_PATH
</TERM>
<LISTITEM>
<PARA>
directory search-path for object files
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--      BSDI BSD/OS                    February 9, 1998    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->
<!--    at Tue Sep 24 20:13:32 2002 -->
<SECT1 ID=libcrypt>
<TITLE>Interfaces for libcrypt</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libcrypt Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libcrypt</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libcrypt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-29-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<!--libgroup-->
<TITLE>Encryption</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libcrypt - Encryption Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY>crypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY>
<ENTRY>encrypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY>
<ENTRY>setkey(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libcrypt-ddefs>
<TITLE>Data Definitions for libcrypt</TITLE>
<PARA>
This section contains standard data definitions that describe system data. These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
ISO C serves as the LSB reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.47 2002/09/24 16:34:18 anderson Exp 0 -->


</CHAPTER>

</PART>
