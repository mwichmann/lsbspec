<PART ID=tocbaselib>
<TITLE>Base Libraries</TITLE>

<CHAPTER id=baselib xreflabel="Base Libraries">
<TITLE>Base Libraries</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
An LSB-conforming implementation shall support the following
base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
<itemizedlist>
<listitem><para>libc</para></listitem>
<listitem><para>libm</para></listitem>
<listitem><para>libgcc_s</para></listitem>
<listitem><para>libdl</para></listitem>
<listitem><para>librt</para></listitem>
<listitem><para>libcrypt</para></listitem>
<listitem><para>libpam</para></listitem>
</itemizedlist>
</PARA>
<PARA>
There are three main parts to the definition of each of these
libraries.
</PARA>
<PARA>
The "Interfaces" section defines the required library name and version,
and the required public symbols (interfaces and global data), as well
as symbol versions, if any.
</PARA>
<PARA>
The "Interface Definitions" section provides complete or partial
definitions of certain interfaces where either this specification is
the source specification, or where there are variations from the source
specification. If an interface definition requires one or more header 
files, one of those headers shall include the function 
prototype for the interface.
</PARA>
<PARA>
For source definitions of interfaces which include a reference to a
header file, the contents of such header files form a
part of the specification.  The "Data Definitions" section provides the
binary-level details for the header files from the source specifications,
such as values for macros and enumerated types, as well as structure layouts,
sizes and padding, etc.  These data definitions, although presented in the form
of header files for convenience, should not be taken a representing complete
header files, as they are a supplement to the source
specifications.  Application developers should follow the guidelines
of the source specifications when determining which header files need
to be included to completely resolve all references.
<NOTE>
<PARA>
While the Data Definitions supplement the source specifications,
this specification itself does not require conforming implementations
to supply any header files.
</PARA>
</NOTE>
</PARA>
</SECT1>

<SECT1 ID=proginterp>
<TITLE>Program Interpreter</TITLE>
<PARA>
The Program Interpreter is specified in the appropriate
architecture specific part of &ISOSTD;.
</PARA>
</SECT1>


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libc>
<TITLE>Interfaces for libc</TITLE>
<PARA>
<XREF LINKEND="lib-libc-def"> defines the library name and shared object name
for the libc library
</PARA>
<TABLE id="lib-libc-def">
<TITLE>libc Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libc</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>See archLSB.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libc.1'>
[LFS] <XREF LINKEND="std.LFS">
</MEMBER>
<MEMBER ID='REFSTD.libc.2'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
<MEMBER ID='REFSTD.libc.3'>
[RPC & XDR] <XREF LINKEND="std.RPC.XDR">
</MEMBER>
<MEMBER ID='REFSTD.libc.4'>
[SUSv2] <XREF LINKEND="std.SUSv2">
</MEMBER>
<MEMBER ID='REFSTD.libc.5'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
<MEMBER ID='REFSTD.libc.6'>
[SUSv4] <XREF LINKEND="std.SUSv4">
</MEMBER>
<MEMBER ID='REFSTD.libc.7'>
[SVID.3] <XREF LINKEND="std.SVID.3">
</MEMBER>
<MEMBER ID='REFSTD.libc.8'>
[SVID.4] <XREF LINKEND="std.SVID.4">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name RPC -->
<SECT2>
<!--libgroup-->
<TITLE>RPC</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for RPC</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for RPC specified in <XREF linkend="tbl-libc-rpc-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-rpc-ints">
<TITLE>libc - RPC Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>authnone_create</primary></indexterm>authnone_create <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>callrpc</primary></indexterm>callrpc <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnt_create</primary></indexterm>clnt_create <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnt_pcreateerror</primary></indexterm>clnt_pcreateerror <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clnt_perrno</primary></indexterm>clnt_perrno <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnt_perror</primary></indexterm>clnt_perror <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnt_spcreateerror</primary></indexterm>clnt_spcreateerror <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnt_sperrno</primary></indexterm>clnt_sperrno <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clnt_sperror</primary></indexterm>clnt_sperror <LINK LINKEND="REFSTD.libc.8">[SVID.4]</LINK></ENTRY>
<ENTRY><indexterm><primary>clntraw_create</primary></indexterm>clntraw_create <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>clnttcp_create</primary></indexterm>clnttcp_create <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>clntudp_bufcreate</primary></indexterm>clntudp_bufcreate <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clntudp_create</primary></indexterm>clntudp_create <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>key_decryptsession</primary></indexterm>key_decryptsession <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pmap_getport</primary></indexterm>pmap_getport <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pmap_set</primary></indexterm>pmap_set <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pmap_unset</primary></indexterm>pmap_unset <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>svc_getreqset</primary></indexterm>svc_getreqset <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svc_register</primary></indexterm>svc_register <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>svc_run</primary></indexterm>svc_run <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>svc_sendreply</primary></indexterm>svc_sendreply <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_auth</primary></indexterm>svcerr_auth <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_decode</primary></indexterm>svcerr_decode <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_noproc</primary></indexterm>svcerr_noproc <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>svcerr_noprog</primary></indexterm>svcerr_noprog <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_progvers</primary></indexterm>svcerr_progvers <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_systemerr</primary></indexterm>svcerr_systemerr <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcerr_weakauth</primary></indexterm>svcerr_weakauth <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>svcfd_create</primary></indexterm>svcfd_create <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcraw_create</primary></indexterm>svcraw_create <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>svctcp_create</primary></indexterm>svctcp_create <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>svcudp_create</primary></indexterm>svcudp_create <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_accepted_reply</primary></indexterm>xdr_accepted_reply <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_array</primary></indexterm>xdr_array <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_bool</primary></indexterm>xdr_bool <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_bytes</primary></indexterm>xdr_bytes <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_callhdr</primary></indexterm>xdr_callhdr <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_callmsg</primary></indexterm>xdr_callmsg <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_char</primary></indexterm>xdr_char <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_double</primary></indexterm>xdr_double <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_enum</primary></indexterm>xdr_enum <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_float</primary></indexterm>xdr_float <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_free</primary></indexterm>xdr_free <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_int</primary></indexterm>xdr_int <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_long</primary></indexterm>xdr_long <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_opaque</primary></indexterm>xdr_opaque <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_opaque_auth</primary></indexterm>xdr_opaque_auth <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_pointer</primary></indexterm>xdr_pointer <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_reference</primary></indexterm>xdr_reference <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_rejected_reply</primary></indexterm>xdr_rejected_reply <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_replymsg</primary></indexterm>xdr_replymsg <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_short</primary></indexterm>xdr_short <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_string</primary></indexterm>xdr_string <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_u_char</primary></indexterm>xdr_u_char <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_u_int</primary></indexterm>xdr_u_int <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_u_long</primary></indexterm>xdr_u_long <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_u_short</primary></indexterm>xdr_u_short <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_union</primary></indexterm>xdr_union <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_vector</primary></indexterm>xdr_vector <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdr_void</primary></indexterm>xdr_void <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdr_wrapstring</primary></indexterm>xdr_wrapstring <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdrmem_create</primary></indexterm>xdrmem_create <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdrrec_create</primary></indexterm>xdrrec_create <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdrrec_endofrecord</primary></indexterm>xdrrec_endofrecord <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>xdrrec_eof</primary></indexterm>xdrrec_eof <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdrrec_skiprecord</primary></indexterm>xdrrec_skiprecord <LINK LINKEND="REFSTD.libc.3">[RPC & XDR]</LINK></ENTRY>
<ENTRY><indexterm><primary>xdrstdio_create</primary></indexterm>xdrstdio_create <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for RPC specified in <XREF linkend="tbl-libc-rpc-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-rpc-depints">
<TITLE>libc - RPC Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>key_decryptsession</primary></indexterm>key_decryptsession <LINK LINKEND="REFSTD.libc.7">[SVID.3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Epoll -->
<SECT2>
<!--libgroup-->
<TITLE>Epoll</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Epoll</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Epoll specified in <XREF linkend="tbl-libc-epoll-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-epoll-ints">
<TITLE>libc - Epoll Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>epoll_create</primary></indexterm>epoll_create(GLIBC_2.3.2) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>epoll_ctl</primary></indexterm>epoll_ctl(GLIBC_2.3.2) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>epoll_wait</primary></indexterm>epoll_wait(GLIBC_2.3.2) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name System Calls -->
<SECT2>
<!--libgroup-->
<TITLE>System Calls</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for System Calls</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for System Calls specified in <XREF linkend="tbl-libc-syste-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-syste-ints">
<TITLE>libc - System Calls Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__chk_fail</primary></indexterm>__chk_fail(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fxstat</primary></indexterm>__fxstat <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fxstatat</primary></indexterm>__fxstatat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__getpgid</primary></indexterm>__getpgid <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__lxstat</primary></indexterm>__lxstat <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__read_chk</primary></indexterm>__read_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__readlink_chk</primary></indexterm>__readlink_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__stack_chk_fail</primary></indexterm>__stack_chk_fail(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__xmknod</primary></indexterm>__xmknod <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__xmknodat</primary></indexterm>__xmknodat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__xstat</primary></indexterm>__xstat <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>access</primary></indexterm>access <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>acct</primary></indexterm>acct <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>alarm</primary></indexterm>alarm <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>brk</primary></indexterm>brk <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
<ENTRY><indexterm><primary>chdir</primary></indexterm>chdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>chmod</primary></indexterm>chmod <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>chown</primary></indexterm>chown <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>chroot</primary></indexterm>chroot <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
<ENTRY><indexterm><primary>clock</primary></indexterm>clock <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>close</primary></indexterm>close <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>closedir</primary></indexterm>closedir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>creat</primary></indexterm>creat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>dup</primary></indexterm>dup <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>dup2</primary></indexterm>dup2 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>execl</primary></indexterm>execl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>execle</primary></indexterm>execle <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>execlp</primary></indexterm>execlp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>execv</primary></indexterm>execv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>execve</primary></indexterm>execve <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>execvp</primary></indexterm>execvp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>exit</primary></indexterm>exit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>faccessat</primary></indexterm>faccessat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>fchdir</primary></indexterm>fchdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fchmod</primary></indexterm>fchmod <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fchmodat</primary></indexterm>fchmodat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fchown</primary></indexterm>fchown <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fchownat</primary></indexterm>fchownat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>fcntl</primary></indexterm>fcntl <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fdatasync</primary></indexterm>fdatasync <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fdopendir</primary></indexterm>fdopendir(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>fexecve</primary></indexterm>fexecve <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>flock</primary></indexterm>flock <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fork</primary></indexterm>fork <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fstatfs</primary></indexterm>fstatfs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fstatvfs</primary></indexterm>fstatvfs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fsync</primary></indexterm>fsync <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ftime</primary></indexterm>ftime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ftruncate</primary></indexterm>ftruncate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>futimesat</primary></indexterm>futimesat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getcontext</primary></indexterm>getcontext <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getdtablesize</primary></indexterm>getdtablesize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getegid</primary></indexterm>getegid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>geteuid</primary></indexterm>geteuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgid</primary></indexterm>getgid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgroups</primary></indexterm>getgroups <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getitimer</primary></indexterm>getitimer <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getloadavg</primary></indexterm>getloadavg <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpagesize</primary></indexterm>getpagesize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpgid</primary></indexterm>getpgid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getpgrp</primary></indexterm>getpgrp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpid</primary></indexterm>getpid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getppid</primary></indexterm>getppid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpriority</primary></indexterm>getpriority <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getrlimit</primary></indexterm>getrlimit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getrusage</primary></indexterm>getrusage <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getsid</primary></indexterm>getsid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getuid</primary></indexterm>getuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getwd</primary></indexterm>getwd <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>initgroups</primary></indexterm>initgroups <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ioctl</primary></indexterm>ioctl <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>kill</primary></indexterm>kill <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>killpg</primary></indexterm>killpg <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lchown</primary></indexterm>lchown <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>link</primary></indexterm>link <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>linkat</primary></indexterm>linkat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lockf</primary></indexterm>lockf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lseek</primary></indexterm>lseek <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mkdir</primary></indexterm>mkdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mkdirat</primary></indexterm>mkdirat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mkfifo</primary></indexterm>mkfifo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mkfifoat</primary></indexterm>mkfifoat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>mlock</primary></indexterm>mlock <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mlockall</primary></indexterm>mlockall <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mmap</primary></indexterm>mmap <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mprotect</primary></indexterm>mprotect <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mremap</primary></indexterm>mremap <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>msync</primary></indexterm>msync <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>munlock</primary></indexterm>munlock <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>munlockall</primary></indexterm>munlockall <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>munmap</primary></indexterm>munmap <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nanosleep</primary></indexterm>nanosleep <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nice</primary></indexterm>nice <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>open</primary></indexterm>open <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>openat</primary></indexterm>openat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>opendir</primary></indexterm>opendir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pathconf</primary></indexterm>pathconf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pause</primary></indexterm>pause <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pipe</primary></indexterm>pipe <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>poll</primary></indexterm>poll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pselect</primary></indexterm>pselect <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>read</primary></indexterm>read <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>readdir</primary></indexterm>readdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>readdir_r</primary></indexterm>readdir_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>readlink</primary></indexterm>readlink <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>readlinkat</primary></indexterm>readlinkat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>readv</primary></indexterm>readv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rename</primary></indexterm>rename <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>renameat</primary></indexterm>renameat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>rmdir</primary></indexterm>rmdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sbrk</primary></indexterm>sbrk <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_get_priority_max</primary></indexterm>sched_get_priority_max <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sched_get_priority_min</primary></indexterm>sched_get_priority_min <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_getaffinity</primary></indexterm>sched_getaffinity(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_getparam</primary></indexterm>sched_getparam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_getscheduler</primary></indexterm>sched_getscheduler <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sched_rr_get_interval</primary></indexterm>sched_rr_get_interval <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_setaffinity</primary></indexterm>sched_setaffinity(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_setparam</primary></indexterm>sched_setparam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sched_setscheduler</primary></indexterm>sched_setscheduler <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sched_yield</primary></indexterm>sched_yield <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>select</primary></indexterm>select <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setcontext</primary></indexterm>setcontext <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setegid</primary></indexterm>setegid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>seteuid</primary></indexterm>seteuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setgid</primary></indexterm>setgid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setitimer</primary></indexterm>setitimer <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setpgid</primary></indexterm>setpgid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setpgrp</primary></indexterm>setpgrp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setpriority</primary></indexterm>setpriority <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setregid</primary></indexterm>setregid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setreuid</primary></indexterm>setreuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setrlimit</primary></indexterm>setrlimit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setrlimit64</primary></indexterm>setrlimit64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>setsid</primary></indexterm>setsid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setuid</primary></indexterm>setuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sleep</primary></indexterm>sleep <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>statfs</primary></indexterm>statfs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>statvfs</primary></indexterm>statvfs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>stime</primary></indexterm>stime <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>symlink</primary></indexterm>symlink <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>symlinkat</primary></indexterm>symlinkat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>sync</primary></indexterm>sync <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sysconf</primary></indexterm>sysconf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>time</primary></indexterm>time <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>times</primary></indexterm>times <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>truncate</primary></indexterm>truncate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ulimit</primary></indexterm>ulimit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>umask</primary></indexterm>umask <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>uname</primary></indexterm>uname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>unlink</primary></indexterm>unlink <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>unlinkat</primary></indexterm>unlinkat(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>utime</primary></indexterm>utime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>utimes</primary></indexterm>utimes <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vfork</primary></indexterm>vfork <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wait</primary></indexterm>wait <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wait4</primary></indexterm>wait4 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>waitid</primary></indexterm>waitid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>waitpid</primary></indexterm>waitpid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>write</primary></indexterm>write <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>writev</primary></indexterm>writev <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for System Calls specified in <XREF linkend="tbl-libc-syste-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-syste-depints">
<TITLE>libc - System Calls Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>fstatfs</primary></indexterm>fstatfs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getdtablesize</primary></indexterm>getdtablesize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpagesize</primary></indexterm>getpagesize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getwd</primary></indexterm>getwd <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>statfs</primary></indexterm>statfs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Standard I/O -->
<SECT2>
<!--libgroup-->
<TITLE>Standard I/O</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Standard I/O</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Standard I/O specified in <XREF linkend="tbl-libc-stand-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-stand-ints">
<TITLE>libc - Standard I/O Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>_IO_feof</primary></indexterm>_IO_feof <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_IO_getc</primary></indexterm>_IO_getc <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_IO_putc</primary></indexterm>_IO_putc <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_IO_puts</primary></indexterm>_IO_puts <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__fgets_chk</primary></indexterm>__fgets_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fprintf_chk</primary></indexterm>__fprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__printf_chk</primary></indexterm>__printf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__snprintf_chk</primary></indexterm>__snprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__sprintf_chk</primary></indexterm>__sprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__vfprintf_chk</primary></indexterm>__vfprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__vprintf_chk</primary></indexterm>__vprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__vsnprintf_chk</primary></indexterm>__vsnprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__vsprintf_chk</primary></indexterm>__vsprintf_chk <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>asprintf</primary></indexterm>asprintf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>clearerr</primary></indexterm>clearerr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clearerr_unlocked</primary></indexterm>clearerr_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ctermid</primary></indexterm>ctermid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>dprintf</primary></indexterm>dprintf <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>fclose</primary></indexterm>fclose <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fdopen</primary></indexterm>fdopen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>feof</primary></indexterm>feof <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>feof_unlocked</primary></indexterm>feof_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ferror</primary></indexterm>ferror <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ferror_unlocked</primary></indexterm>ferror_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fflush</primary></indexterm>fflush <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fflush_unlocked</primary></indexterm>fflush_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetc</primary></indexterm>fgetc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetc_unlocked</primary></indexterm>fgetc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fgetpos</primary></indexterm>fgetpos <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgets</primary></indexterm>fgets <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgets_unlocked</primary></indexterm>fgets_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetwc_unlocked</primary></indexterm>fgetwc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fgetws_unlocked</primary></indexterm>fgetws_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fileno</primary></indexterm>fileno <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fileno_unlocked</primary></indexterm>fileno_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>flockfile</primary></indexterm>flockfile <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fopen</primary></indexterm>fopen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fprintf</primary></indexterm>fprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputc</primary></indexterm>fputc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputc_unlocked</primary></indexterm>fputc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fputs</primary></indexterm>fputs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputs_unlocked</primary></indexterm>fputs_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputwc_unlocked</primary></indexterm>fputwc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputws_unlocked</primary></indexterm>fputws_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fread</primary></indexterm>fread <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fread_unlocked</primary></indexterm>fread_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>freopen</primary></indexterm>freopen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fscanf</primary></indexterm>fscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fseek</primary></indexterm>fseek <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fseeko</primary></indexterm>fseeko <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fsetpos</primary></indexterm>fsetpos <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ftell</primary></indexterm>ftell <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ftello</primary></indexterm>ftello <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fwrite</primary></indexterm>fwrite <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fwrite_unlocked</primary></indexterm>fwrite_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getc</primary></indexterm>getc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getc_unlocked</primary></indexterm>getc_unlocked <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getchar</primary></indexterm>getchar <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getchar_unlocked</primary></indexterm>getchar_unlocked <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getdelim</primary></indexterm>getdelim <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getline</primary></indexterm>getline <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>getw</primary></indexterm>getw <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
<ENTRY><indexterm><primary>getwchar_unlocked</primary></indexterm>getwchar_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pclose</primary></indexterm>pclose <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>popen</primary></indexterm>popen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>printf</primary></indexterm>printf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putc</primary></indexterm>putc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putc_unlocked</primary></indexterm>putc_unlocked <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>putchar</primary></indexterm>putchar <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putchar_unlocked</primary></indexterm>putchar_unlocked <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>puts</primary></indexterm>puts <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putw</primary></indexterm>putw <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>putwc_unlocked</primary></indexterm>putwc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>putwchar_unlocked</primary></indexterm>putwchar_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>remove</primary></indexterm>remove <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rewind</primary></indexterm>rewind <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>rewinddir</primary></indexterm>rewinddir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scanf</primary></indexterm>scanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>seekdir</primary></indexterm>seekdir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setbuf</primary></indexterm>setbuf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setbuffer</primary></indexterm>setbuffer <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>setvbuf</primary></indexterm>setvbuf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>snprintf</primary></indexterm>snprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sprintf</primary></indexterm>sprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sscanf</primary></indexterm>sscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>telldir</primary></indexterm>telldir <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tempnam</primary></indexterm>tempnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetc</primary></indexterm>ungetc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vasprintf</primary></indexterm>vasprintf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vdprintf</primary></indexterm>vdprintf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vfprintf</primary></indexterm>vfprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vprintf</primary></indexterm>vprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vsnprintf</primary></indexterm>vsnprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vsprintf</primary></indexterm>vsprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Standard I/O specified in <XREF linkend="tbl-libc-stand-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-stand-depints">
<TITLE>libc - Standard I/O Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>tempnam</primary></indexterm>tempnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Standard I/O specified in <XREF linkend="tbl-libc-stand-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-stand-data">
<TITLE>libc - Standard I/O Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>getwc_unlocked</primary></indexterm>getwc_unlocked <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>stderr</primary></indexterm>stderr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>stdin</primary></indexterm>stdin <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>stdout</primary></indexterm>stdout <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Signal Handling -->
<SECT2>
<!--libgroup-->
<TITLE>Signal Handling</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Signal Handling</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Signal Handling specified in <XREF linkend="tbl-libc-signa-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-signa-ints">
<TITLE>libc - Signal Handling Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__libc_current_sigrtmax</primary></indexterm>__libc_current_sigrtmax <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__libc_current_sigrtmin</primary></indexterm>__libc_current_sigrtmin <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__sigsetjmp</primary></indexterm>__sigsetjmp <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__sysv_signal</primary></indexterm>__sysv_signal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__xpg_sigpause</primary></indexterm>__xpg_sigpause <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>bsd_signal</primary></indexterm>bsd_signal <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>psignal</primary></indexterm>psignal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>raise</primary></indexterm>raise <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigaction</primary></indexterm>sigaction <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigaddset</primary></indexterm>sigaddset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigaltstack</primary></indexterm>sigaltstack <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigandset</primary></indexterm>sigandset <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigdelset</primary></indexterm>sigdelset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigemptyset</primary></indexterm>sigemptyset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigfillset</primary></indexterm>sigfillset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sighold</primary></indexterm>sighold <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigignore</primary></indexterm>sigignore <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>siginterrupt</primary></indexterm>siginterrupt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigisemptyset</primary></indexterm>sigisemptyset <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigismember</primary></indexterm>sigismember <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>siglongjmp</primary></indexterm>siglongjmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>signal</primary></indexterm>signal <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigorset</primary></indexterm>sigorset <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigpause</primary></indexterm>sigpause <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigpending</primary></indexterm>sigpending <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigprocmask</primary></indexterm>sigprocmask <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigqueue</primary></indexterm>sigqueue <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigrelse</primary></indexterm>sigrelse <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigreturn</primary></indexterm>sigreturn <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigset</primary></indexterm>sigset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigsuspend</primary></indexterm>sigsuspend <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigtimedwait</primary></indexterm>sigtimedwait <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sigwait</primary></indexterm>sigwait <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sigwaitinfo</primary></indexterm>sigwaitinfo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Signal Handling specified in <XREF linkend="tbl-libc-signa-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-signa-depints">
<TITLE>libc - Signal Handling Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>sigpause</primary></indexterm>sigpause <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Signal Handling specified in <XREF linkend="tbl-libc-signa-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-signa-data">
<TITLE>libc - Signal Handling Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>_sys_siglist</primary></indexterm>_sys_siglist <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Localization Functions -->
<SECT2>
<!--libgroup-->
<TITLE>Localization Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Localization Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Localization Functions specified in <XREF linkend="tbl-libc-local-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-local-ints">
<TITLE>libc - Localization Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>bind_textdomain_codeset</primary></indexterm>bind_textdomain_codeset <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>bindtextdomain</primary></indexterm>bindtextdomain <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>catclose</primary></indexterm>catclose <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catgets</primary></indexterm>catgets <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>catopen</primary></indexterm>catopen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>dcgettext</primary></indexterm>dcgettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dcngettext</primary></indexterm>dcngettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dgettext</primary></indexterm>dgettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>dngettext</primary></indexterm>dngettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>duplocale</primary></indexterm>duplocale(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>freelocale</primary></indexterm>freelocale(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gettext</primary></indexterm>gettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>iconv</primary></indexterm>iconv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iconv_close</primary></indexterm>iconv_close <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iconv_open</primary></indexterm>iconv_open <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>localeconv</primary></indexterm>localeconv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>newlocale</primary></indexterm>newlocale(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ngettext</primary></indexterm>ngettext <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>nl_langinfo</primary></indexterm>nl_langinfo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setlocale</primary></indexterm>setlocale <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>textdomain</primary></indexterm>textdomain <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>uselocale</primary></indexterm>uselocale(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Localization Functions specified in <XREF linkend="tbl-libc-local-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-local-data">
<TITLE>libc - Localization Functions Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>_nl_msg_cat_cntr</primary></indexterm>_nl_msg_cat_cntr <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Posix Spawn Option -->
<SECT2>
<!--libgroup-->
<TITLE>Posix Spawn Option</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Posix Spawn Option</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Posix Spawn Option specified in <XREF linkend="tbl-libc-posix-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-posix-ints">
<TITLE>libc - Posix Spawn Option Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>posix_spawn</primary></indexterm>posix_spawn <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawn_file_actions_addclose</primary></indexterm>posix_spawn_file_actions_addclose <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawn_file_actions_adddup2</primary></indexterm>posix_spawn_file_actions_adddup2 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawn_file_actions_addopen</primary></indexterm>posix_spawn_file_actions_addopen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>posix_spawn_file_actions_destroy</primary></indexterm>posix_spawn_file_actions_destroy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawn_file_actions_init</primary></indexterm>posix_spawn_file_actions_init <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_destroy</primary></indexterm>posix_spawnattr_destroy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_getflags</primary></indexterm>posix_spawnattr_getflags <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>posix_spawnattr_getpgroup</primary></indexterm>posix_spawnattr_getpgroup <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_getschedparam</primary></indexterm>posix_spawnattr_getschedparam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_getschedpolicy</primary></indexterm>posix_spawnattr_getschedpolicy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_getsigdefault</primary></indexterm>posix_spawnattr_getsigdefault <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>posix_spawnattr_getsigmask</primary></indexterm>posix_spawnattr_getsigmask <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_init</primary></indexterm>posix_spawnattr_init <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_setflags</primary></indexterm>posix_spawnattr_setflags <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_setpgroup</primary></indexterm>posix_spawnattr_setpgroup <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>posix_spawnattr_setschedparam</primary></indexterm>posix_spawnattr_setschedparam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_setschedpolicy</primary></indexterm>posix_spawnattr_setschedpolicy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_setsigdefault</primary></indexterm>posix_spawnattr_setsigdefault <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_spawnattr_setsigmask</primary></indexterm>posix_spawnattr_setsigmask <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>posix_spawnp</primary></indexterm>posix_spawnp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Posix Advisory Option -->
<SECT2>
<!--libgroup-->
<TITLE>Posix Advisory Option</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Posix Advisory Option</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Posix Advisory Option specified in <XREF linkend="tbl-libc-posiy-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-posiy-ints">
<TITLE>libc - Posix Advisory Option Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>posix_fadvise</primary></indexterm>posix_fadvise <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_fallocate</primary></indexterm>posix_fallocate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_madvise</primary></indexterm>posix_madvise <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_memalign</primary></indexterm>posix_memalign <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Socket Interface -->
<SECT2>
<!--libgroup-->
<TITLE>Socket Interface</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Socket Interface</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Socket Interface specified in <XREF linkend="tbl-libc-socke-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-socke-ints">
<TITLE>libc - Socket Interface Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__h_errno_location</primary></indexterm>__h_errno_location <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__recv_chk</primary></indexterm>__recv_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__recvfrom_chk</primary></indexterm>__recvfrom_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>accept</primary></indexterm>accept <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bind</primary></indexterm>bind <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>bindresvport</primary></indexterm>bindresvport <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>connect</primary></indexterm>connect <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostid</primary></indexterm>gethostid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gethostname</primary></indexterm>gethostname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpeername</primary></indexterm>getpeername <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getsockname</primary></indexterm>getsockname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getsockopt</primary></indexterm>getsockopt <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>if_freenameindex</primary></indexterm>if_freenameindex <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>if_indextoname</primary></indexterm>if_indextoname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>if_nameindex</primary></indexterm>if_nameindex <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>if_nametoindex</primary></indexterm>if_nametoindex <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>listen</primary></indexterm>listen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>recv</primary></indexterm>recv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>recvfrom</primary></indexterm>recvfrom <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>recvmsg</primary></indexterm>recvmsg <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>send</primary></indexterm>send <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>sendmsg</primary></indexterm>sendmsg <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>sendto</primary></indexterm>sendto <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>setsockopt</primary></indexterm>setsockopt <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>shutdown</primary></indexterm>shutdown <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sockatmark</primary></indexterm>sockatmark <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>socket</primary></indexterm>socket <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>socketpair</primary></indexterm>socketpair <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Socket Interface specified in <XREF linkend="tbl-libc-socke-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-socke-data">
<TITLE>libc - Socket Interface Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>in6addr_any</primary></indexterm>in6addr_any <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>in6addr_loopback</primary></indexterm>in6addr_loopback <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Wide Characters -->
<SECT2>
<!--libgroup-->
<TITLE>Wide Characters</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Wide Characters</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Wide Characters specified in <XREF linkend="tbl-libc-wide-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-wide-ints">
<TITLE>libc - Wide Characters Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__fwprintf_chk</primary></indexterm>__fwprintf_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__swprintf_chk</primary></indexterm>__swprintf_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcscat_chk</primary></indexterm>__wcscat_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcscpy_chk</primary></indexterm>__wcscpy_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__wcsncpy_chk</primary></indexterm>__wcsncpy_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcstod_internal</primary></indexterm>__wcstod_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcstof_internal</primary></indexterm>__wcstof_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcstol_internal</primary></indexterm>__wcstol_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__wcstold_internal</primary></indexterm>__wcstold_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wcstoul_internal</primary></indexterm>__wcstoul_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wctomb_chk</primary></indexterm>__wctomb_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__wmemmove_chk</primary></indexterm>__wmemmove_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>btowc</primary></indexterm>btowc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetwc</primary></indexterm>fgetwc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetws</primary></indexterm>fgetws <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fputwc</primary></indexterm>fputwc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fputws</primary></indexterm>fputws <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fwide</primary></indexterm>fwide <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fwprintf</primary></indexterm>fwprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fwscanf</primary></indexterm>fwscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getwc</primary></indexterm>getwc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getwchar</primary></indexterm>getwchar <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mblen</primary></indexterm>mblen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mbrlen</primary></indexterm>mbrlen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mbrtowc</primary></indexterm>mbrtowc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mbsinit</primary></indexterm>mbsinit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mbsnrtowcs</primary></indexterm>mbsnrtowcs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mbsrtowcs</primary></indexterm>mbsrtowcs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mbstowcs</primary></indexterm>mbstowcs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mbtowc</primary></indexterm>mbtowc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putwc</primary></indexterm>putwc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>putwchar</primary></indexterm>putwchar <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>swprintf</primary></indexterm>swprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>swscanf</primary></indexterm>swscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>towctrans</primary></indexterm>towctrans <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>towlower</primary></indexterm>towlower <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>towupper</primary></indexterm>towupper <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetwc</primary></indexterm>ungetwc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vfwprintf</primary></indexterm>vfwprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vfwscanf</primary></indexterm>vfwscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vswprintf</primary></indexterm>vswprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vswscanf</primary></indexterm>vswscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwprintf</primary></indexterm>vwprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwscanf</primary></indexterm>vwscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcpcpy</primary></indexterm>wcpcpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcpncpy</primary></indexterm>wcpncpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcrtomb</primary></indexterm>wcrtomb <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcscasecmp</primary></indexterm>wcscasecmp <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcscat</primary></indexterm>wcscat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcschr</primary></indexterm>wcschr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcscmp</primary></indexterm>wcscmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcscoll</primary></indexterm>wcscoll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcscpy</primary></indexterm>wcscpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcscspn</primary></indexterm>wcscspn <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsdup</primary></indexterm>wcsdup <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsftime</primary></indexterm>wcsftime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcslen</primary></indexterm>wcslen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsncasecmp</primary></indexterm>wcsncasecmp <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsncat</primary></indexterm>wcsncat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsncmp</primary></indexterm>wcsncmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcsncpy</primary></indexterm>wcsncpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsnlen</primary></indexterm>wcsnlen <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsnrtombs</primary></indexterm>wcsnrtombs <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcspbrk</primary></indexterm>wcspbrk <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcsrchr</primary></indexterm>wcsrchr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsrtombs</primary></indexterm>wcsrtombs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsspn</primary></indexterm>wcsspn <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsstr</primary></indexterm>wcsstr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcstod</primary></indexterm>wcstod <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstof</primary></indexterm>wcstof <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstoimax</primary></indexterm>wcstoimax <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstok</primary></indexterm>wcstok <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcstol</primary></indexterm>wcstol <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstold</primary></indexterm>wcstold <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstoll</primary></indexterm>wcstoll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstombs</primary></indexterm>wcstombs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcstoq</primary></indexterm>wcstoq <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstoul</primary></indexterm>wcstoul <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstoull</primary></indexterm>wcstoull <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcstoumax</primary></indexterm>wcstoumax <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcstouq</primary></indexterm>wcstouq <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcswcs</primary></indexterm>wcswcs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcswidth</primary></indexterm>wcswidth <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcsxfrm</primary></indexterm>wcsxfrm <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wctob</primary></indexterm>wctob <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wctomb</primary></indexterm>wctomb <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wctrans</primary></indexterm>wctrans <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wctype</primary></indexterm>wctype <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcwidth</primary></indexterm>wcwidth <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmemchr</primary></indexterm>wmemchr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmemcmp</primary></indexterm>wmemcmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmemcpy</primary></indexterm>wmemcpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wmemmove</primary></indexterm>wmemmove <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmemset</primary></indexterm>wmemset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wprintf</primary></indexterm>wprintf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscanf</primary></indexterm>wscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name String Functions -->
<SECT2>
<!--libgroup-->
<TITLE>String Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for String Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for String Functions specified in <XREF linkend="tbl-libc-strin-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-strin-ints">
<TITLE>libc - String Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__memcpy_chk</primary></indexterm>__memcpy_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__memmove_chk</primary></indexterm>__memmove_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__mempcpy</primary></indexterm>__mempcpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__mempcpy_chk</primary></indexterm>__mempcpy_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__memset_chk</primary></indexterm>__memset_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__rawmemchr</primary></indexterm>__rawmemchr <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__stpcpy</primary></indexterm>__stpcpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__stpcpy_chk</primary></indexterm>__stpcpy_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__strcat_chk</primary></indexterm>__strcat_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strcpy_chk</primary></indexterm>__strcpy_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strdup</primary></indexterm>__strdup <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strncat_chk</primary></indexterm>__strncat_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__strncpy_chk</primary></indexterm>__strncpy_chk(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtod_internal</primary></indexterm>__strtod_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtof_internal</primary></indexterm>__strtof_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtok_r</primary></indexterm>__strtok_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__strtol_internal</primary></indexterm>__strtol_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtold_internal</primary></indexterm>__strtold_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtoll_internal</primary></indexterm>__strtoll_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__strtoul_internal</primary></indexterm>__strtoul_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__strtoull_internal</primary></indexterm>__strtoull_internal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__xpg_strerror_r</primary></indexterm>__xpg_strerror_r(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>bcmp</primary></indexterm>bcmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>bcopy</primary></indexterm>bcopy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bzero</primary></indexterm>bzero <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ffs</primary></indexterm>ffs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>index</primary></indexterm>index <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>memccpy</primary></indexterm>memccpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>memchr</primary></indexterm>memchr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>memcmp</primary></indexterm>memcmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>memcpy</primary></indexterm>memcpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>memmove</primary></indexterm>memmove <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>memrchr</primary></indexterm>memrchr <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>memset</primary></indexterm>memset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rindex</primary></indexterm>rindex <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>stpcpy</primary></indexterm>stpcpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>stpncpy</primary></indexterm>stpncpy <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcasecmp</primary></indexterm>strcasecmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcasestr</primary></indexterm>strcasestr <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcat</primary></indexterm>strcat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strchr</primary></indexterm>strchr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcmp</primary></indexterm>strcmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcoll</primary></indexterm>strcoll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strcpy</primary></indexterm>strcpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strcspn</primary></indexterm>strcspn <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strdup</primary></indexterm>strdup <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strerror</primary></indexterm>strerror <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strerror_r</primary></indexterm>strerror_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strfmon</primary></indexterm>strfmon <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strftime</primary></indexterm>strftime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strlen</primary></indexterm>strlen <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strncasecmp</primary></indexterm>strncasecmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strncat</primary></indexterm>strncat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strncmp</primary></indexterm>strncmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strncpy</primary></indexterm>strncpy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strndup</primary></indexterm>strndup <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strnlen</primary></indexterm>strnlen <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strpbrk</primary></indexterm>strpbrk <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strptime</primary></indexterm>strptime <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strrchr</primary></indexterm>strrchr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strsep</primary></indexterm>strsep <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strsignal</primary></indexterm>strsignal <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strspn</primary></indexterm>strspn <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strstr</primary></indexterm>strstr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strtof</primary></indexterm>strtof <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtoimax</primary></indexterm>strtoimax <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtok</primary></indexterm>strtok <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtok_r</primary></indexterm>strtok_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strtold</primary></indexterm>strtold <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtoll</primary></indexterm>strtoll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtoq</primary></indexterm>strtoq <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtoull</primary></indexterm>strtoull <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strtoumax</primary></indexterm>strtoumax <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtouq</primary></indexterm>strtouq <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>strxfrm</primary></indexterm>strxfrm <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>swab</primary></indexterm>swab <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for String Functions specified in <XREF linkend="tbl-libc-strin-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-strin-depints">
<TITLE>libc - String Functions Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>strerror_r</primary></indexterm>strerror_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name IPC Functions -->
<SECT2>
<!--libgroup-->
<TITLE>IPC Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for IPC Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for IPC Functions specified in <XREF linkend="tbl-libc-ipc-f-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-ipc-f-ints">
<TITLE>libc - IPC Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>ftok</primary></indexterm>ftok <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>msgctl</primary></indexterm>msgctl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>msgget</primary></indexterm>msgget <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>msgrcv</primary></indexterm>msgrcv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>msgsnd</primary></indexterm>msgsnd <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>semctl</primary></indexterm>semctl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>semget</primary></indexterm>semget <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>semop</primary></indexterm>semop <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>shmat</primary></indexterm>shmat <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>shmctl</primary></indexterm>shmctl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>shmdt</primary></indexterm>shmdt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>shmget</primary></indexterm>shmget <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Regular Expressions -->
<SECT2>
<!--libgroup-->
<TITLE>Regular Expressions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Regular Expressions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Regular Expressions specified in <XREF linkend="tbl-libc-regul-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-regul-ints">
<TITLE>libc - Regular Expressions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>regcomp</primary></indexterm>regcomp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>regerror</primary></indexterm>regerror <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>regexec</primary></indexterm>regexec <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>regfree</primary></indexterm>regfree <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Character Type Functions -->
<SECT2>
<!--libgroup-->
<TITLE>Character Type Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Character Type Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Character Type Functions specified in <XREF linkend="tbl-libc-chara-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-chara-ints">
<TITLE>libc - Character Type Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__ctype_b_loc</primary></indexterm>__ctype_b_loc(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__ctype_get_mb_cur_max</primary></indexterm>__ctype_get_mb_cur_max <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__ctype_tolower_loc</primary></indexterm>__ctype_tolower_loc(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__ctype_toupper_loc</primary></indexterm>__ctype_toupper_loc(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>_tolower</primary></indexterm>_tolower <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>_toupper</primary></indexterm>_toupper <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isalnum</primary></indexterm>isalnum <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isalpha</primary></indexterm>isalpha <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>isascii</primary></indexterm>isascii <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iscntrl</primary></indexterm>iscntrl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isdigit</primary></indexterm>isdigit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isgraph</primary></indexterm>isgraph <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>islower</primary></indexterm>islower <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isprint</primary></indexterm>isprint <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ispunct</primary></indexterm>ispunct <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isspace</primary></indexterm>isspace <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>isupper</primary></indexterm>isupper <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswalnum</primary></indexterm>iswalnum <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswalpha</primary></indexterm>iswalpha <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswblank</primary></indexterm>iswblank <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>iswcntrl</primary></indexterm>iswcntrl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswctype</primary></indexterm>iswctype <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswdigit</primary></indexterm>iswdigit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswgraph</primary></indexterm>iswgraph <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>iswlower</primary></indexterm>iswlower <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswprint</primary></indexterm>iswprint <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswpunct</primary></indexterm>iswpunct <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswspace</primary></indexterm>iswspace <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>iswupper</primary></indexterm>iswupper <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>iswxdigit</primary></indexterm>iswxdigit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isxdigit</primary></indexterm>isxdigit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>toascii</primary></indexterm>toascii <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tolower</primary></indexterm>tolower <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>toupper</primary></indexterm>toupper <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Time Manipulation -->
<SECT2>
<!--libgroup-->
<TITLE>Time Manipulation</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Time Manipulation</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Time Manipulation specified in <XREF linkend="tbl-libc-time-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-time-ints">
<TITLE>libc - Time Manipulation Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>adjtime</primary></indexterm>adjtime <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>asctime</primary></indexterm>asctime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asctime_r</primary></indexterm>asctime_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctime</primary></indexterm>ctime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ctime_r</primary></indexterm>ctime_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>difftime</primary></indexterm>difftime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gmtime</primary></indexterm>gmtime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gmtime_r</primary></indexterm>gmtime_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>localtime</primary></indexterm>localtime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>localtime_r</primary></indexterm>localtime_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mktime</primary></indexterm>mktime <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tzset</primary></indexterm>tzset <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ualarm</primary></indexterm>ualarm <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Time Manipulation specified in <XREF linkend="tbl-libc-time-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-time-data">
<TITLE>libc - Time Manipulation Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__daylight</primary></indexterm>__daylight <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__timezone</primary></indexterm>__timezone <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__tzname</primary></indexterm>__tzname <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>daylight</primary></indexterm>daylight <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>timezone</primary></indexterm>timezone <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tzname</primary></indexterm>tzname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Terminal Interface Functions -->
<SECT2>
<!--libgroup-->
<TITLE>Terminal Interface Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Terminal Interface Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Terminal Interface Functions specified in <XREF linkend="tbl-libc-termi-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-termi-ints">
<TITLE>libc - Terminal Interface Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>cfgetispeed</primary></indexterm>cfgetispeed <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cfgetospeed</primary></indexterm>cfgetospeed <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cfmakeraw</primary></indexterm>cfmakeraw <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>cfsetispeed</primary></indexterm>cfsetispeed <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cfsetospeed</primary></indexterm>cfsetospeed <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cfsetspeed</primary></indexterm>cfsetspeed <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcdrain</primary></indexterm>tcdrain <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcflow</primary></indexterm>tcflow <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tcflush</primary></indexterm>tcflush <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcgetattr</primary></indexterm>tcgetattr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcgetpgrp</primary></indexterm>tcgetpgrp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcgetsid</primary></indexterm>tcgetsid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tcsendbreak</primary></indexterm>tcsendbreak <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcsetattr</primary></indexterm>tcsetattr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tcsetpgrp</primary></indexterm>tcsetpgrp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name System Database Interface -->
<SECT2>
<!--libgroup-->
<TITLE>System Database Interface</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for System Database Interface</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for System Database Interface specified in <XREF linkend="tbl-libc-systf-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-systf-ints">
<TITLE>libc - System Database Interface Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>endgrent</primary></indexterm>endgrent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>endprotoent</primary></indexterm>endprotoent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>endpwent</primary></indexterm>endpwent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>endservent</primary></indexterm>endservent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>endutent</primary></indexterm>endutent <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>endutxent</primary></indexterm>endutxent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgrent</primary></indexterm>getgrent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgrent_r</primary></indexterm>getgrent_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getgrgid</primary></indexterm>getgrgid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgrgid_r</primary></indexterm>getgrgid_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgrnam</primary></indexterm>getgrnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getgrnam_r</primary></indexterm>getgrnam_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getgrouplist</primary></indexterm>getgrouplist <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyaddr</primary></indexterm>gethostbyaddr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyaddr_r</primary></indexterm>gethostbyaddr_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname</primary></indexterm>gethostbyname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gethostbyname2</primary></indexterm>gethostbyname2 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname2_r</primary></indexterm>gethostbyname2_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname_r</primary></indexterm>gethostbyname_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getprotobyname</primary></indexterm>getprotobyname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getprotobyname_r</primary></indexterm>getprotobyname_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getprotobynumber</primary></indexterm>getprotobynumber <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getprotobynumber_r</primary></indexterm>getprotobynumber_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getprotoent</primary></indexterm>getprotoent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getprotoent_r</primary></indexterm>getprotoent_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpwent</primary></indexterm>getpwent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpwent_r</primary></indexterm>getpwent_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpwnam</primary></indexterm>getpwnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getpwnam_r</primary></indexterm>getpwnam_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpwuid</primary></indexterm>getpwuid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getpwuid_r</primary></indexterm>getpwuid_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getservbyname</primary></indexterm>getservbyname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getservbyname_r</primary></indexterm>getservbyname_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getservbyport</primary></indexterm>getservbyport <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getservbyport_r</primary></indexterm>getservbyport_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getservent</primary></indexterm>getservent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getservent_r</primary></indexterm>getservent_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getutent</primary></indexterm>getutent <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getutent_r</primary></indexterm>getutent_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getutxent</primary></indexterm>getutxent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getutxid</primary></indexterm>getutxid <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getutxline</primary></indexterm>getutxline <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pututxline</primary></indexterm>pututxline <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setgrent</primary></indexterm>setgrent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setgroups</primary></indexterm>setgroups <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>setprotoent</primary></indexterm>setprotoent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setpwent</primary></indexterm>setpwent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setservent</primary></indexterm>setservent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setutent</primary></indexterm>setutent <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>setutxent</primary></indexterm>setutxent <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>utmpname</primary></indexterm>utmpname <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for System Database Interface specified in <XREF linkend="tbl-libc-systf-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-systf-depints">
<TITLE>libc - System Database Interface Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>gethostbyaddr</primary></indexterm>gethostbyaddr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyaddr_r</primary></indexterm>gethostbyaddr_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname</primary></indexterm>gethostbyname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname2</primary></indexterm>gethostbyname2 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gethostbyname2_r</primary></indexterm>gethostbyname2_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gethostbyname_r</primary></indexterm>gethostbyname_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Language Support -->
<SECT2>
<!--libgroup-->
<TITLE>Language Support</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Language Support</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Language Support specified in <XREF linkend="tbl-libc-langu-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-langu-ints">
<TITLE>libc - Language Support Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__libc_start_main</primary></indexterm>__libc_start_main <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__register_atfork</primary></indexterm>__register_atfork(GLIBC_2.3.2) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Large File Support -->
<SECT2>
<!--libgroup-->
<TITLE>Large File Support</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Large File Support</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Large File Support specified in <XREF linkend="tbl-libc-large-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-large-ints">
<TITLE>libc - Large File Support Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__fxstat64</primary></indexterm>__fxstat64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fxstatat64</primary></indexterm>__fxstatat64(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__lxstat64</primary></indexterm>__lxstat64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__xstat64</primary></indexterm>__xstat64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>creat64</primary></indexterm>creat64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>fgetpos64</primary></indexterm>fgetpos64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>fopen64</primary></indexterm>fopen64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>freopen64</primary></indexterm>freopen64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fseeko64</primary></indexterm>fseeko64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>fsetpos64</primary></indexterm>fsetpos64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>fstatfs64</primary></indexterm>fstatfs64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fstatvfs64</primary></indexterm>fstatvfs64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ftello64</primary></indexterm>ftello64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>ftruncate64</primary></indexterm>ftruncate64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>ftw64</primary></indexterm>ftw64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>getrlimit64</primary></indexterm>getrlimit64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lockf64</primary></indexterm>lockf64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>mkstemp64</primary></indexterm>mkstemp64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mmap64</primary></indexterm>mmap64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>nftw64</primary></indexterm>nftw64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>openat64</primary></indexterm>openat64(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_fadvise64</primary></indexterm>posix_fadvise64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_fallocate64</primary></indexterm>posix_fallocate64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>readdir64</primary></indexterm>readdir64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>readdir64_r</primary></indexterm>readdir64_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>statfs64</primary></indexterm>statfs64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>statvfs64</primary></indexterm>statvfs64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>tmpfile64</primary></indexterm>tmpfile64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>truncate64</primary></indexterm>truncate64 <LINK LINKEND="REFSTD.libc.1">[LFS]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Large File Support specified in <XREF linkend="tbl-libc-large-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-large-depints">
<TITLE>libc - Large File Support Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>fstatfs64</primary></indexterm>fstatfs64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>statfs64</primary></indexterm>statfs64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Inotify -->
<SECT2>
<!--libgroup-->
<TITLE>Inotify</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Inotify</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Inotify specified in <XREF linkend="tbl-libc-inoti-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-inoti-ints">
<TITLE>libc - Inotify Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>inotify_add_watch</primary></indexterm>inotify_add_watch(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inotify_init</primary></indexterm>inotify_init(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inotify_rm_watch</primary></indexterm>inotify_rm_watch(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Standard Library -->
<SECT2>
<!--libgroup-->
<TITLE>Standard Library</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Standard Library</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Standard Library specified in <XREF linkend="tbl-libc-stane-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libc-stane-ints">
<TITLE>libc - Standard Library Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>_Exit</primary></indexterm>_Exit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>__assert_fail</primary></indexterm>__assert_fail <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__cxa_atexit</primary></indexterm>__cxa_atexit <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__cxa_finalize</primary></indexterm>__cxa_finalize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__errno_location</primary></indexterm>__errno_location <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fpending</primary></indexterm>__fpending <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__getcwd_chk</primary></indexterm>__getcwd_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__getpagesize</primary></indexterm>__getpagesize <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__isinf</primary></indexterm>__isinf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__isinff</primary></indexterm>__isinff <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__isinfl</primary></indexterm>__isinfl <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__isnan</primary></indexterm>__isnan <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__isnanf</primary></indexterm>__isnanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__isnanl</primary></indexterm>__isnanl <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__realpath_chk</primary></indexterm>__realpath_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__sysconf</primary></indexterm>__sysconf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__syslog_chk</primary></indexterm>__syslog_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__vsyslog_chk</primary></indexterm>__vsyslog_chk(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__xpg_basename</primary></indexterm>__xpg_basename <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_exit</primary></indexterm>_exit <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>_longjmp</primary></indexterm>_longjmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>_setjmp</primary></indexterm>_setjmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>a64l</primary></indexterm>a64l <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>abort</primary></indexterm>abort <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>abs</primary></indexterm>abs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>alphasort</primary></indexterm>alphasort <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>alphasort64</primary></indexterm>alphasort64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>atof</primary></indexterm>atof <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>atoi</primary></indexterm>atoi <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atol</primary></indexterm>atol <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atoll</primary></indexterm>atoll <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>basename</primary></indexterm>basename <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bsearch</primary></indexterm>bsearch <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>calloc</primary></indexterm>calloc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>closelog</primary></indexterm>closelog <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>confstr</primary></indexterm>confstr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cuserid</primary></indexterm>cuserid <LINK LINKEND="REFSTD.libc.4">[SUSv2]</LINK></ENTRY>
<ENTRY><indexterm><primary>daemon</primary></indexterm>daemon <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dirfd</primary></indexterm>dirfd <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>dirname</primary></indexterm>dirname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>div</primary></indexterm>div <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>drand48</primary></indexterm>drand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>drand48_r</primary></indexterm>drand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ecvt</primary></indexterm>ecvt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erand48</primary></indexterm>erand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>erand48_r</primary></indexterm>erand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>err</primary></indexterm>err <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>error</primary></indexterm>error <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>errx</primary></indexterm>errx <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fcvt</primary></indexterm>fcvt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmemopen</primary></indexterm>fmemopen <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmtmsg</primary></indexterm>fmtmsg <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fnmatch</primary></indexterm>fnmatch <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fpathconf</primary></indexterm>fpathconf <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>free</primary></indexterm>free <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>freeaddrinfo</primary></indexterm>freeaddrinfo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ftrylockfile</primary></indexterm>ftrylockfile <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ftw</primary></indexterm>ftw <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>funlockfile</primary></indexterm>funlockfile <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gai_strerror</primary></indexterm>gai_strerror <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gcvt</primary></indexterm>gcvt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getaddrinfo</primary></indexterm>getaddrinfo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getcwd</primary></indexterm>getcwd <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getdate</primary></indexterm>getdate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getdomainname</primary></indexterm>getdomainname <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getenv</primary></indexterm>getenv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getlogin</primary></indexterm>getlogin <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getlogin_r</primary></indexterm>getlogin_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getnameinfo</primary></indexterm>getnameinfo <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>getopt</primary></indexterm>getopt <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getopt_long</primary></indexterm>getopt_long <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getopt_long_only</primary></indexterm>getopt_long_only <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getsubopt</primary></indexterm>getsubopt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gettimeofday</primary></indexterm>gettimeofday <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>glob</primary></indexterm>glob <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>glob64</primary></indexterm>glob64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>globfree</primary></indexterm>globfree <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>globfree64</primary></indexterm>globfree64 <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>grantpt</primary></indexterm>grantpt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>hcreate</primary></indexterm>hcreate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>hcreate_r</primary></indexterm>hcreate_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>hdestroy</primary></indexterm>hdestroy <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>hdestroy_r</primary></indexterm>hdestroy_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>hsearch</primary></indexterm>hsearch <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>hsearch_r</primary></indexterm>hsearch_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>htonl</primary></indexterm>htonl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>htons</primary></indexterm>htons <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>imaxabs</primary></indexterm>imaxabs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>imaxdiv</primary></indexterm>imaxdiv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>inet_addr</primary></indexterm>inet_addr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>inet_aton</primary></indexterm>inet_aton <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inet_ntoa</primary></indexterm>inet_ntoa <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>inet_ntop</primary></indexterm>inet_ntop <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>inet_pton</primary></indexterm>inet_pton <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>initstate</primary></indexterm>initstate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>initstate_r</primary></indexterm>initstate_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>insque</primary></indexterm>insque <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isatty</primary></indexterm>isatty <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>isblank</primary></indexterm>isblank <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>jrand48</primary></indexterm>jrand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jrand48_r</primary></indexterm>jrand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>l64a</primary></indexterm>l64a <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>labs</primary></indexterm>labs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lcong48</primary></indexterm>lcong48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lcong48_r</primary></indexterm>lcong48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ldiv</primary></indexterm>ldiv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lfind</primary></indexterm>lfind <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>llabs</primary></indexterm>llabs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lldiv</primary></indexterm>lldiv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>longjmp</primary></indexterm>longjmp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lrand48</primary></indexterm>lrand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lrand48_r</primary></indexterm>lrand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lsearch</primary></indexterm>lsearch <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>makecontext</primary></indexterm>makecontext <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>malloc</primary></indexterm>malloc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>memmem</primary></indexterm>memmem <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mkdtemp</primary></indexterm>mkdtemp <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>mkstemp</primary></indexterm>mkstemp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mktemp</primary></indexterm>mktemp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mrand48</primary></indexterm>mrand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mrand48_r</primary></indexterm>mrand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>nftw</primary></indexterm>nftw <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nrand48</primary></indexterm>nrand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nrand48_r</primary></indexterm>nrand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ntohl</primary></indexterm>ntohl <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ntohs</primary></indexterm>ntohs <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>open_memstream</primary></indexterm>open_memstream <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>open_wmemstream</primary></indexterm>open_wmemstream(GLIBC_2.4) <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>openlog</primary></indexterm>openlog <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>perror</primary></indexterm>perror <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>posix_openpt</primary></indexterm>posix_openpt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ptsname</primary></indexterm>ptsname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>putenv</primary></indexterm>putenv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>qsort</primary></indexterm>qsort <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rand</primary></indexterm>rand <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rand_r</primary></indexterm>rand_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>random</primary></indexterm>random <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>random_r</primary></indexterm>random_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>realloc</primary></indexterm>realloc <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>realpath</primary></indexterm>realpath <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>remque</primary></indexterm>remque <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scandir</primary></indexterm>scandir <LINK LINKEND="REFSTD.libc.6">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>seed48</primary></indexterm>seed48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>seed48_r</primary></indexterm>seed48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sendfile</primary></indexterm>sendfile <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sendfile64</primary></indexterm>sendfile64(GLIBC_2.3) <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>setenv</primary></indexterm>setenv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sethostname</primary></indexterm>sethostname <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setlogmask</primary></indexterm>setlogmask <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setstate</primary></indexterm>setstate <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setstate_r</primary></indexterm>setstate_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>srand</primary></indexterm>srand <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>srand48</primary></indexterm>srand48 <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>srand48_r</primary></indexterm>srand48_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>srandom</primary></indexterm>srandom <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>srandom_r</primary></indexterm>srandom_r <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>strtod</primary></indexterm>strtod <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtol</primary></indexterm>strtol <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>strtoul</primary></indexterm>strtoul <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>swapcontext</primary></indexterm>swapcontext <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>syslog</primary></indexterm>syslog <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>system</primary></indexterm>system <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>tdelete</primary></indexterm>tdelete <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tfind</primary></indexterm>tfind <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tmpfile</primary></indexterm>tmpfile <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tmpnam</primary></indexterm>tmpnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tsearch</primary></indexterm>tsearch <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ttyname</primary></indexterm>ttyname <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ttyname_r</primary></indexterm>ttyname_r <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>twalk</primary></indexterm>twalk <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>unlockpt</primary></indexterm>unlockpt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>unsetenv</primary></indexterm>unsetenv <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>usleep</primary></indexterm>usleep <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>verrx</primary></indexterm>verrx <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vfscanf</primary></indexterm>vfscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vscanf</primary></indexterm>vscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vsscanf</primary></indexterm>vsscanf <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vsyslog</primary></indexterm>vsyslog <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>warn</primary></indexterm>warn <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>warnx</primary></indexterm>warnx <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wordexp</primary></indexterm>wordexp <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>wordfree</primary></indexterm>wordfree <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Standard Library specified in <XREF linkend="tbl-libc-stane-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libc-stane-depints">
<TITLE>libc - Standard Library Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>basename</primary></indexterm>basename <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>getdomainname</primary></indexterm>getdomainname <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inet_aton</primary></indexterm>inet_aton <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>tmpnam</primary></indexterm>tmpnam <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Standard Library specified in <XREF linkend="tbl-libc-stane-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libc-stane-data">
<TITLE>libc - Standard Library Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__environ</primary></indexterm>__environ <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_environ</primary></indexterm>_environ <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_sys_errlist</primary></indexterm>_sys_errlist <LINK LINKEND="REFSTD.libc.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>environ</primary></indexterm>environ <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getdate_err</primary></indexterm>getdate_err <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>optarg</primary></indexterm>optarg <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>opterr</primary></indexterm>opterr <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>optind</primary></indexterm>optind <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>optopt</primary></indexterm>optopt <LINK LINKEND="REFSTD.libc.5">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libc-ddefs>
<TITLE>Data Definitions for libc</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libc.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>arpa/inet.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern uint32_t htonl(uint32_t);
extern uint16_t htons(uint16_t);
extern in_addr_t inet_addr(const char *);
extern int inet_aton(const char *, struct in_addr *);
extern char *inet_ntoa(struct in_addr);
extern const char *inet_ntop(int, const void *, char *, socklen_t);
extern int inet_pton(int, const char *, void *);
extern uint32_t ntohl(uint32_t);
extern uint16_t ntohs(uint16_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>assert.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#ifdef NDEBUG
#define assert(expr) ((void)0)
#else
#define assert(expr)	((void) ((expr) ? 0 : (__assert_fail (#expr, __FILE__, __LINE__, __PRETTY_FUNCTION__), 0)))
#endif

extern void __assert_fail(const char *, const char *, unsigned int,
			  const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>cpio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define C_IXOTH	000001
#define C_IWOTH	000002
#define C_IROTH	000004
#define C_IXGRP	000010
#define C_IWGRP	000020
#define C_IRGRP	000040
#define C_IXUSR	000100
#define C_IWUSR	000200
#define C_IRUSR	000400
#define C_ISVTX	001000
#define C_ISGID	002000
#define C_ISUID	004000
#define C_ISFIFO	010000
#define C_ISREG	0100000
#define C_ISCTG	0110000
#define C_ISLNK	0120000
#define C_ISSOCK	0140000
#define C_ISCHR	020000
#define C_ISDIR	040000
#define C_ISBLK	060000
#define MAGIC	"070707"
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int _tolower(int);
extern int _toupper(int);
extern int isalnum(int);
extern int isalpha(int);
extern int isascii(int);
extern int iscntrl(int);
extern int isdigit(int);
extern int isgraph(int);
extern int islower(int);
extern int isprint(int);
extern int ispunct(int);
extern int isspace(int);
extern int isupper(int);
extern int isxdigit(int);
extern int toascii(int);
extern int tolower(int);
extern int toupper(int);
extern int isblank(int);
extern const unsigned short **__ctype_b_loc(void);
extern const int32_t **__ctype_toupper_loc(void);
extern const int32_t **__ctype_tolower_loc(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>dirent.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef struct __dirstream DIR;

struct dirent {
    long int d_ino;
    off_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
struct dirent64 {
    uint64_t d_ino;
    int64_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};
extern int readdir64_r(DIR *, struct dirent64 *, struct dirent64 **);
extern int alphasort(const struct dirent **, const struct dirent **);
extern int alphasort64(const struct dirent64 **, const struct dirent64 **);
extern int dirfd(DIR *);
extern void rewinddir(DIR *);
extern int scandir(const char *, struct dirent ***,
		   int (*)(const struct dirent *)
		   , int (*)(const struct dirent *, const struct dirent *)
    );
extern void seekdir(DIR *, long int);
extern long int telldir(DIR *);
extern int closedir(DIR *);
extern DIR *opendir(const char *);
extern struct dirent *readdir(DIR *);
extern struct dirent64 *readdir64(DIR *);
extern int readdir_r(DIR *, struct dirent *, struct dirent **);
extern int scandir64(const char *, struct dirent64 ***,
		     int (*)(const struct dirent64 *)
		     , int (*)(const struct dirent64 *,
			       const struct dirent64 *)
    );
extern DIR *fdopendir(int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>endian.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define __LITTLE_ENDIAN	1234
#define __BIG_ENDIAN	4321
#define BIG_ENDIAN	__BIG_ENDIAN
#define BYTE_ORDER	__BYTE_ORDER
#define LITTLE_ENDIAN	__LITTLE_ENDIAN
</SCREEN>
</SECT2>
<SECT2>
<TITLE>err.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern void err(int, const char *, ...);
extern void errx(int, const char *, ...);
extern void warn(const char *, ...);
extern void warnx(const char *, ...);
extern void error(int, int, const char *, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>errno.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define errno	(*__errno_location())

#define EPERM	1		/* Operation not permitted */
#define ECHILD	10		/* No child processes */
#define ENETDOWN	100	/* Network is down */
#define ENETUNREACH	101	/* Network is unreachable */
#define ENETRESET	102	/* Network dropped connection because of reset */
#define ECONNABORTED	103	/* Software caused connection abort */
#define ECONNRESET	104	/* Connection reset by peer */
#define ENOBUFS	105		/* No buffer space available */
#define EISCONN	106		/* Transport endpoint is already connected */
#define ENOTCONN	107	/* Transport endpoint is not connected */
#define ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
#define ETOOMANYREFS	109	/* Too many references: cannot splice */
#define EAGAIN	11		/* Try again */
#define ETIMEDOUT	110	/* Connection timed out */
#define ECONNREFUSED	111	/* Connection refused */
#define EHOSTDOWN	112	/* Host is down */
#define EHOSTUNREACH	113	/* No route to host */
#define EALREADY	114	/* Operation already in progress */
#define EINPROGRESS	115	/* Operation now in progress */
#define ESTALE	116		/* Stale NFS file handle */
#define EUCLEAN	117		/* Structure needs cleaning */
#define ENOTNAM	118		/* Not a XENIX named type file */
#define ENAVAIL	119		/* No XENIX semaphores available */
#define ENOMEM	12		/* Out of memory */
#define EISNAM	120		/* Is a named type file */
#define EREMOTEIO	121	/* Remote I/O error */
#define EDQUOT	122		/* Quota exceeded */
#define ENOMEDIUM	123	/* No medium found */
#define EMEDIUMTYPE	124	/* Wrong medium type */
#define ECANCELED	125	/* Operation Canceled */
#define EACCES	13		/* Permission denied */
#define EFAULT	14		/* Bad address */
#define ENOTBLK	15		/* Block device required */
#define EBUSY	16		/* Device or resource busy */
#define EEXIST	17		/* File exists */
#define EXDEV	18		/* Cross-device link */
#define ENODEV	19		/* No such device */
#define ENOENT	2		/* No such file or directory */
#define ENOTDIR	20		/* Not a directory */
#define EISDIR	21		/* Is a directory */
#define EINVAL	22		/* Invalid argument */
#define ENFILE	23		/* File table overflow */
#define EMFILE	24		/* Too many open files */
#define ENOTTY	25		/* Not a typewriter */
#define ETXTBSY	26		/* Text file busy */
#define EFBIG	27		/* File too large */
#define ENOSPC	28		/* No space left on device */
#define ESPIPE	29		/* Illegal seek */
#define ESRCH	3		/* No such process */
#define EROFS	30		/* Read-only file system */
#define EMLINK	31		/* Too many links */
#define EPIPE	32		/* Broken pipe */
#define EDOM	33		/* Math argument out of domain of func */
#define ERANGE	34		/* Math result not representable */
#define EDEADLK	35		/* Resource deadlock would occur */
#define ENAMETOOLONG	36	/* File name too long */
#define ENOLCK	37		/* No record locks available */
#define ENOSYS	38		/* Function not implemented */
#define ENOTEMPTY	39	/* Directory not empty */
#define EINTR	4		/* Interrupted system call */
#define ELOOP	40		/* Too many symbolic links encountered */
#define ENOMSG	42		/* No message of desired type */
#define EIDRM	43		/* Identifier removed */
#define ECHRNG	44		/* Channel number out of range */
#define EL2NSYNC	45	/* Level 2 not synchronized */
#define EL3HLT	46		/* Level 3 halted */
#define EL3RST	47		/* Level 3 reset */
#define ELNRNG	48		/* Link number out of range */
#define EUNATCH	49		/* Protocol driver not attached */
#define EIO	5		/* I/O error */
#define ENOANO	55		/* No anode */
#define EBADRQC	56		/* Invalid request code */
#define EBADSLT	57		/* Invalid slot */
#define EBFONT	59		/* Bad font file format */
#define ENXIO	6		/* No such device or address */
#define ENOSTR	60		/* Device not a stream */
#define ENODATA	61		/* No data available */
#define ETIME	62		/* Timer expired */
#define ENOSR	63		/* Out of streams resources */
#define ENONET	64		/* Machine is not on the network */
#define ENOPKG	65		/* Package not installed */
#define EREMOTE	66		/* Object is remote */
#define ENOLINK	67		/* Link has been severed */
#define EADV	68		/* Advertise error */
#define ESRMNT	69		/* Srmount error */
#define E2BIG	7		/* Argument list too long */
#define ECOMM	70		/* Communication error on send */
#define EPROTO	71		/* Protocol error */
#define EMULTIHOP	72	/* Multihop attempted */
#define EDOTDOT	73		/* RFS specific error */
#define EBADMSG	74		/* Not a data message */
#define EOVERFLOW	75	/* Value too large for defined data type */
#define ENOTUNIQ	76	/* Name not unique on network */
#define EBADFD	77		/* File descriptor in bad state */
#define EREMCHG	78		/* Remote address changed */
#define ELIBACC	79		/* Can not access a needed shared library */
#define ENOEXEC	8		/* Exec format error */
#define ELIBBAD	80		/* Accessing a corrupted shared library */
#define ELIBSCN	81		/* .lib section in a.out corrupted */
#define ELIBMAX	82		/* Attempting to link in too many shared libraries */
#define ELIBEXEC	83	/* Cannot exec a shared library directly */
#define EILSEQ	84		/* Illegal byte sequence */
#define ERESTART	85	/* Interrupted system call should be restarted */
#define ESTRPIPE	86	/* Streams pipe error */
#define EUSERS	87		/* Too many users */
#define ENOTSOCK	88	/* Socket operation on non-socket */
#define EDESTADDRREQ	89	/* Destination address required */
#define EBADF	9		/* Bad file number */
#define EMSGSIZE	90	/* Message too long */
#define EPROTOTYPE	91	/* Protocol wrong type for socket */
#define ENOPROTOOPT	92	/* Protocol not available */
#define EPROTONOSUPPORT	93	/* Protocol not supported */
#define ESOCKTNOSUPPORT	94	/* Socket type not supported */
#define EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
#define EPFNOSUPPORT	96	/* Protocol family not supported */
#define EAFNOSUPPORT	97	/* Address family not supported by protocol */
#define EADDRINUSE	98	/* Address already in use */
#define EADDRNOTAVAIL	99	/* Cannot assign requested address */
#define EWOULDBLOCK	EAGAIN	/* Operation would block */
#define ENOTSUP	EOPNOTSUPP

extern int *__errno_location(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fcntl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define POSIX_FADV_NORMAL	0
#define O_RDONLY	00
#define O_ACCMODE	0003
#define O_WRONLY	01
#define O_CREAT	0100
#define O_TRUNC	01000
#define O_DSYNC	010000
#define O_RSYNC	010000
#define O_SYNC	010000
#define O_RDWR	02
#define O_EXCL	0200
#define O_APPEND	02000
#define O_ASYNC	020000
#define O_NOCTTY	0400
#define O_NDELAY	04000
#define O_NONBLOCK	04000
#define FD_CLOEXEC	1
#define POSIX_FADV_RANDOM	1
#define POSIX_FADV_SEQUENTIAL	2
#define POSIX_FADV_WILLNEED	3

struct flock {
    short l_type;
    short l_whence;
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
};
struct flock64 {
    short l_type;
    short l_whence;
    loff_t l_start;
    loff_t l_len;
    pid_t l_pid;
};

#define AT_FDCWD	-100
#define AT_SYMLINK_NOFOLLOW	0x100
#define AT_EACCESS	0x200
#define AT_REMOVEDIR	0x200
#define AT_SYMLINK_FOLLOW	0x400

#define F_DUPFD	0
#define F_RDLCK	0
#define F_GETFD	1
#define F_WRLCK	1
#define F_SETSIG	10
#define F_GETSIG	11
#define F_SETFD	2
#define F_UNLCK	2
#define F_GETFL	3
#define F_SETFL	4
#define F_GETLK	5
#define F_SETLK	6
#define F_SETLKW	7
#define F_SETOWN	8
#define F_GETOWN	9

extern int posix_fadvise(int, off_t, off_t, int);
extern int posix_fallocate(int, off_t, off_t);
extern int posix_fadvise64(int, off64_t, off64_t, int);
extern int posix_fallocate64(int, off64_t, off64_t);
extern int creat(const char *, mode_t);
extern int creat64(const char *, mode_t);
extern int fcntl(int, int, ...);
extern int open(const char *, int, ...);
extern int open64(const char *, int, ...);
extern int openat(int, const char *, int, ...);
extern int openat64(int, const char *, int, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fmtmsg.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MM_HARD	1		/* Source of the condition is hardware. */
#define MM_NRECOV	128	/* Non-recoverable error. */
#define MM_UTIL	16		/* Condition detected by utility. */
#define MM_SOFT	2		/* Source of the condition is software. */
#define MM_PRINT	256	/* Display message in standard error. */
#define MM_OPSYS	32	/* Condition detected by operating system. */
#define MM_FIRM	4		/* Source of the condition is firmware. */
#define MM_CONSOLE	512	/* Display message on system console. */
#define MM_RECOVER	64	/* Recoverable error. */
#define MM_APPL	8		/* Condition detected by application. */

#define MM_NOSEV	0	/* No severity level provided for the message. */
#define MM_HALT	1		/* Error causing application to halt. */
#define MM_ERROR	2	/* Application has encountered a non-fatal fault. */
#define MM_WARNING	3	/* Application has detected unusual non-error condition. */
#define MM_INFO	4		/* Informative message. */

#define MM_NULLACT	((char *) 0)
#define MM_NULLLBL	((char *) 0)
#define MM_NULLTAG	((char *) 0)
#define MM_NULLTXT	((char *) 0)
#define MM_NULLMC	((long int) 0)
#define MM_NULLSEV	0

#define MM_NOTOK	-1	/* The function failed completely. */
#define MM_OK	0		/* The function succeeded. */
#define MM_NOMSG	1	/* The function was unable to generate a message on standard error, but otherwise succeeded. */
#define MM_NOCON	4	/* The function was unable to generate a console message, but otherwise succeeded. */

extern int fmtmsg(long int, const char *, int, const char *, const char *,
		  const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fnmatch.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define FNM_PATHNAME	(1&lt;&lt;0)
#define FNM_NOESCAPE	(1&lt;&lt;1)
#define FNM_PERIOD	(1&lt;&lt;2)
#define FNM_NOMATCH	1

extern int fnmatch(const char *, const char *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ftw.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define FTW_D	FTW_D
#define FTW_DNR	FTW_DNR
#define FTW_DP	FTW_DP
#define FTW_F	FTW_F
#define FTW_NS	FTW_NS
#define FTW_SL	FTW_SL
#define FTW_SLN	FTW_SLN

enum {
    FTW_F,
    FTW_D,
    FTW_DNR,
    FTW_NS,
    FTW_SL,
    FTW_DP,
    FTW_SLN
};

enum {
    FTW_PHYS = 1,
    FTW_MOUNT = 2,
    FTW_CHDIR = 4,
    FTW_DEPTH = 8
};

struct FTW {
    int base;
    int level;
};

typedef int (*__ftw_func_t) (const char *__filename,
			     const struct stat * __status, int __flag);
typedef int (*__ftw64_func_t) (const char *__filename,
			       const struct stat64 * __status, int __flag);
typedef int (*__nftw_func_t) (const char *__filename,
			      const struct stat * __status, int __flag,
			      struct FTW * __info);
typedef int (*__nftw64_func_t) (const char *__filename,
				const struct stat64 * __status, int __flag,
				struct FTW * __info);
extern int ftw(const char *, __ftw_func_t, int);
extern int ftw64(const char *, __ftw64_func_t, int);
extern int nftw(const char *, __nftw_func_t, int, int);
extern int nftw64(const char *, __nftw64_func_t, int, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>getopt.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define no_argument	0
#define required_argument	1
#define optional_argument	2

struct option {
    const char *name;
    int has_arg;
    int *flag;
    int val;
};
extern int getopt_long(int, char *const, const char *,
		       const struct option *, int *);
extern int getopt_long_only(int, char *const, const char *,
			    const struct option *, int *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>glob.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define GLOB_ERR	(1&lt;&lt;0)
#define GLOB_MARK	(1&lt;&lt;1)
#define GLOB_BRACE	(1&lt;&lt;10)
#define GLOB_NOMAGIC	(1&lt;&lt;11)
#define GLOB_TILDE	(1&lt;&lt;12)
#define GLOB_ONLYDIR	(1&lt;&lt;13)
#define GLOB_TILDE_CHECK	(1&lt;&lt;14)
#define GLOB_NOSORT	(1&lt;&lt;2)
#define GLOB_DOOFFS	(1&lt;&lt;3)
#define GLOB_NOCHECK	(1&lt;&lt;4)
#define GLOB_APPEND	(1&lt;&lt;5)
#define GLOB_NOESCAPE	(1&lt;&lt;6)
#define GLOB_PERIOD	(1&lt;&lt;7)
#define GLOB_MAGCHAR	(1&lt;&lt;8)
#define GLOB_ALTDIRFUNC	(1&lt;&lt;9)

#define GLOB_NOSPACE	1
#define GLOB_ABORTED	2
#define GLOB_NOMATCH	3
#define GLOB_NOSYS	4

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob_t;

typedef struct {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;
    void (*gl_closedir) (void *);
    struct dirent64 *(*gl_readdir) (void *);
    void *(*gl_opendir) (const char *);
    int (*gl_lstat) (const char *, struct stat *);
    int (*gl_stat) (const char *, struct stat *);
} glob64_t;
extern int glob(const char *, int, int (*)(const char *p1, int p2)
		, glob_t *);
extern int glob64(const char *, int, int (*)(const char *p1, int p2)
		  , glob64_t *);
extern void globfree(glob_t *);
extern void globfree64(glob64_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>grp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct group {
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;
};

extern void endgrent(void);
extern struct group *getgrent(void);
extern struct group *getgrgid(gid_t);
extern struct group *getgrnam(const char *);
extern int initgroups(const char *, gid_t);
extern void setgrent(void);
extern int setgroups(size_t, const gid_t *);
extern int getgrgid_r(gid_t, struct group *, char *, size_t,
		      struct group **);
extern int getgrnam_r(const char *, struct group *, char *, size_t,
		      struct group **);
extern int getgrent_r(struct group *, char *, size_t, struct group **);
extern int getgrouplist(const char *, gid_t, gid_t *, int *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>iconv.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef void *iconv_t;
extern size_t iconv(iconv_t, char **, size_t *, char **, size_t *);
extern int iconv_close(iconv_t);
extern iconv_t iconv_open(const char *, const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>inttypes.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef lldiv_t imaxdiv_t;

#define __PDP_ENDIAN	3412
#define PDP_ENDIAN	__PDP_ENDIAN

extern intmax_t strtoimax(const char *, char **, int);
extern uintmax_t strtoumax(const char *, char **, int);
extern intmax_t wcstoimax(const wchar_t *, wchar_t * *, int);
extern uintmax_t wcstoumax(const wchar_t *, wchar_t * *, int);
extern intmax_t imaxabs(intmax_t);
extern imaxdiv_t imaxdiv(intmax_t, intmax_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>langinfo.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ABDAY_1	0x20000		/* Sun. */
#define ABDAY_2	0x20001
#define ABDAY_3	0x20002
#define ABDAY_4	0x20003
#define ABDAY_5	0x20004
#define ABDAY_6	0x20005
#define ABDAY_7	0x20006

#define DAY_1	0x20007
#define DAY_2	0x20008
#define DAY_3	0x20009
#define DAY_4	0x2000A
#define DAY_5	0x2000B
#define DAY_6	0x2000C
#define DAY_7	0x2000D

#define ABMON_1	0x2000E
#define ABMON_2	0x2000F
#define ABMON_3	0x20010
#define ABMON_4	0x20011
#define ABMON_5	0x20012
#define ABMON_6	0x20013
#define ABMON_7	0x20014
#define ABMON_8	0x20015
#define ABMON_9	0x20016
#define ABMON_10	0x20017
#define ABMON_11	0x20018
#define ABMON_12	0x20019

#define MON_1	0x2001A
#define MON_2	0x2001B
#define MON_3	0x2001C
#define MON_4	0x2001D
#define MON_5	0x2001E
#define MON_6	0x2001F
#define MON_7	0x20020
#define MON_8	0x20021
#define MON_9	0x20022
#define MON_10	0x20023
#define MON_11	0x20024
#define MON_12	0x20025

#define AM_STR	0x20026
#define PM_STR	0x20027

#define D_T_FMT	0x20028
#define D_FMT	0x20029
#define T_FMT	0x2002A
#define T_FMT_AMPM	0x2002B

#define ERA	0x2002C
#define ERA_D_FMT	0x2002E
#define ALT_DIGITS	0x2002F
#define ERA_D_T_FMT	0x20030
#define ERA_T_FMT	0x20031

#define CODESET	14

#define CRNCYSTR	0x4000F

#define RADIXCHAR	0x10000
#define THOUSEP	0x10001
#define YESEXPR	0x50000
#define NOEXPR	0x50001
#define YESSTR	0x50002
#define NOSTR	0x50003

extern char *nl_langinfo(nl_item);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>libgen.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define basename __xpg_basename

extern char *dirname(char *);
extern char *__xpg_basename(char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>libintl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern char *bindtextdomain(const char *, const char *);
extern char *dcgettext(const char *, const char *, int);
extern char *dgettext(const char *, const char *);
extern char *gettext(const char *);
extern char *textdomain(const char *);
extern char *bind_textdomain_codeset(const char *, const char *);
extern char *dcngettext(const char *, const char *, const char *,
			unsigned long int, int);
extern char *dngettext(const char *, const char *, const char *,
		       unsigned long int);
extern char *ngettext(const char *, const char *, unsigned long int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>limits.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define LLONG_MIN	(-LLONG_MAX-1LL)
#define _POSIX_AIO_MAX	1
#define _POSIX_QLIMIT	1
#define _POSIX2_BC_STRING_MAX	1000
#define _POSIX2_CHARCLASS_NAME_MAX	14
#define _POSIX_NAME_MAX	14
#define _POSIX_UIO_MAXIOV	16
#define ULLONG_MAX	18446744073709551615ULL
#define _POSIX2_COLL_WEIGHTS_MAX	2
#define _POSIX_AIO_LISTIO_MAX	2
#define _POSIX_OPEN_MAX	20
#define _POSIX_CLOCKRES_MIN	20000000
#define CHARCLASS_NAME_MAX	2048
#define LINE_MAX	2048
#define _POSIX2_BC_DIM_MAX	2048
#define _POSIX2_LINE_MAX	2048
#define _POSIX_CHILD_MAX	25
#define COLL_WEIGHTS_MAX	255
#define _POSIX2_RE_DUP_MAX	255
#define _POSIX_HOST_NAME_MAX	255
#define _POSIX_MAX_CANON	255
#define _POSIX_MAX_INPUT	255
#define _POSIX_RE_DUP_MAX	255
#define _POSIX_SYMLINK_MAX	255
#define OPEN_MAX	256
#define _POSIX_PATH_MAX	256
#define _POSIX_SEM_NSEMS_MAX	256
#define NGROUPS_MAX	32
#define _POSIX2_EXPR_NEST_MAX	32
#define _POSIX_DELAYTIMER_MAX	32
#define _POSIX_MQ_PRIO_MAX	32
#define _POSIX_SIGQUEUE_MAX	32
#define _POSIX_TIMER_MAX	32
#define _POSIX_SEM_VALUE_MAX	32767
#define _POSIX_SSIZE_MAX	32767
#define PATH_MAX	4096
#define _POSIX_ARG_MAX	4096
#define _POSIX_PIPE_BUF	512
#define _POSIX_TZNAME_MAX	6
#define _POSIX_LINK_MAX	8
#define _POSIX_MQ_OPEN_MAX	8
#define _POSIX_NGROUPS_MAX	8
#define _POSIX_RTSIG_MAX	8
#define _POSIX_STREAM_MAX	8
#define _POSIX_SYMLOOP_MAX	8
#define _POSIX_LOGIN_NAME_MAX	9
#define _POSIX_TTY_NAME_MAX	9
#define LLONG_MAX	9223372036854775807LL
#define _POSIX2_BC_BASE_MAX	99
#define _POSIX2_BC_SCALE_MAX	99
#define SSIZE_MAX	LONG_MAX	/* Maximum value of an object of type ssize_t */
#define BC_BASE_MAX	_POSIX2_BC_BASE_MAX
#define BC_DIM_MAX	_POSIX2_BC_DIM_MAX
#define BC_SCALE_MAX	_POSIX2_BC_SCALE_MAX
#define BC_STRING_MAX	_POSIX2_BC_STRING_MAX
#define EXPR_NEST_MAX	_POSIX2_EXPR_NEST_MAX
#define _POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
#define _POSIX_HIWAT	_POSIX_PIPE_BUF

#define MB_LEN_MAX	16

#define SCHAR_MIN	(-128)
#define SCHAR_MAX	127
#define UCHAR_MAX	255
#define CHAR_BIT	8

#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
#define USHRT_MAX	65535

#define INT_MIN	(-INT_MAX-1)
#define INT_MAX	2147483647
#define UINT_MAX	4294967295U

#define LONG_MIN	(-LONG_MAX-1L)

#define PTHREAD_KEYS_MAX	1024
#define PTHREAD_THREADS_MAX	16384
#define PTHREAD_DESTRUCTOR_ITERATIONS	4
</SCREEN>
</SECT2>
<SECT2>
<TITLE>locale.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

#define LC_GLOBAL_LOCALE	((locale_t) -1L)
#define LC_CTYPE	0
#define LC_NUMERIC	1
#define LC_TELEPHONE	10
#define LC_MEASUREMENT	11
#define LC_IDENTIFICATION	12
#define LC_TIME	2
#define LC_COLLATE	3
#define LC_MONETARY	4
#define LC_MESSAGES	5
#define LC_ALL	6
#define LC_PAPER	7
#define LC_NAME	8
#define LC_ADDRESS	9

struct __locale_struct {
    struct locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;

typedef struct __locale_struct *locale_t;

#define LC_ADDRESS_MASK	(1 &lt;&lt; LC_ADDRESS)
#define LC_COLLATE_MASK	(1 &lt;&lt; LC_COLLATE)
#define LC_IDENTIFICATION_MASK	(1 &lt;&lt; LC_IDENTIFICATION)
#define LC_MEASUREMENT_MASK	(1 &lt;&lt; LC_MEASUREMENT)
#define LC_MESSAGES_MASK	(1 &lt;&lt; LC_MESSAGES)
#define LC_MONETARY_MASK	(1 &lt;&lt; LC_MONETARY)
#define LC_NAME_MASK	(1 &lt;&lt; LC_NAME)
#define LC_NUMERIC_MASK	(1 &lt;&lt; LC_NUMERIC)
#define LC_PAPER_MASK	(1 &lt;&lt; LC_PAPER)
#define LC_TELEPHONE_MASK	(1 &lt;&lt; LC_TELEPHONE)
#define LC_TIME_MASK	(1 &lt;&lt; LC_TIME)
#define LC_CTYPE_MASK	(1&lt;&lt;LC_CTYPE)
#define LC_ALL_MASK	\
        (LC_CTYPE_MASK| LC_NUMERIC_MASK| LC_TIME_MASK| LC_COLLATE_MASK| LC_MONETARY_MASK|\
         LC_MESSAGES_MASK| LC_PAPER_MASK| LC_NAME_MASK| LC_ADDRESS_MASK| LC_TELEPHONE_MASK|\
         LC_MEASUREMENT_MASK| LC_IDENTIFICATION_MASK)

extern struct lconv *localeconv(void);
extern char *setlocale(int, const char *);
extern locale_t uselocale(locale_t);
extern void freelocale(locale_t);
extern locale_t duplocale(locale_t);
extern locale_t newlocale(int, const char *, locale_t);
</SCREEN>
</SECT2>
<!-- empty header file All/malloc.h -->
<SECT2>
<TITLE>monetary.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern ssize_t strfmon(char *, size_t, const char *, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>net/if.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IF_NAMESIZE	16

#define IFF_UP	0x01		/* Interface is up. */
#define IFF_BROADCAST	0x02	/* Broadcast address valid. */
#define IFF_DEBUG	0x04	/* Turn on debugging. */
#define IFF_LOOPBACK	0x08	/* Is a loopback net. */
#define IFF_POINTOPOINT	0x10	/* Interface is point-to-point link. */
#define IFF_PROMISC	0x100	/* Receive all packets. */
#define IFF_MULTICAST	0x1000	/* Supports multicast. */
#define IFF_NOTRAILERS	0x20	/* Avoid use of trailers. */
#define IFF_RUNNING	0x40	/* Resources allocated. */
#define IFF_NOARP	0x80	/* No address resolution protocol. */

struct if_nameindex {
    unsigned int if_index;
    char *if_name;
};

struct ifaddr {
    struct sockaddr ifa_addr;
    union {
	struct sockaddr ifu_broadaddr;
	struct sockaddr ifu_dstaddr;
    } ifa_ifu;
    void *ifa_ifp;
    void *ifa_next;
};

#define ifr_name	ifr_ifrn.ifrn_name	/* interface name */
#define ifr_addr	ifr_ifru.ifru_addr	/* address */
#define ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
#define ifr_data	ifr_ifru.ifru_data	/* for use by interface */
#define ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk */
#define ifr_flags	ifr_ifru.ifru_flags	/* flags */
#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* interface name */
#define ifr_bandwidth	ifr_ifru.ifru_ivalue	/* link bandwidth */
#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index */
#define ifr_metric	ifr_ifru.ifru_ivalue	/* metric */
#define ifr_qlen	ifr_ifru.ifru_ivalue	/* queue length */
#define ifr_mtu	ifr_ifru.ifru_mtu	/* mtu */
#define ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
#define ifr_slave	ifr_ifru.ifru_slave	/* slave device */
#define IFNAMSIZ	IF_NAMESIZE

struct ifreq {
    union {
	char ifrn_name[IFNAMSIZ];
    } ifr_ifrn;
    union {
	struct sockaddr ifru_addr;
	struct sockaddr ifru_dstaddr;
	struct sockaddr ifru_broadaddr;
	struct sockaddr ifru_netmask;
	struct sockaddr ifru_hwaddr;
	short ifru_flags;
	int ifru_ivalue;
	int ifru_mtu;
	char ifru_slave[IFNAMSIZ];
	char ifru_newname[IFNAMSIZ];
	caddr_t ifru_data;
	struct ifmap ifru_map;
    } ifr_ifru;
};

#define ifc_buf	ifc_ifcu.ifcu_buf	/* Buffer address. */
#define ifc_req	ifc_ifcu.ifcu_req	/* Array of structures. */

struct ifconf {
    int ifc_len;
    union {
	caddr_t ifcu_buf;
	struct ifreq *ifcu_req;
    } ifc_ifcu;
};
extern void if_freenameindex(struct if_nameindex *);
extern char *if_indextoname(unsigned int, char *);
extern struct if_nameindex *if_nameindex(void);
extern unsigned int if_nametoindex(const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netdb.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define h_errno	(*__h_errno_location ())
#define NETDB_INTERNAL	-1	/* See errno. */
#define NETDB_SUCCESS	0	/* No problem. */
#define HOST_NOT_FOUND	1	/* Authoritative Answer Host not found. */
#define IPPORT_RESERVED	1024
#define NI_MAXHOST	1025
#define TRY_AGAIN	2	/* Non-Authoritative Host not found, or SERVERFAIL. */
#define NO_RECOVERY	3	/* Non recoverable errors, FORMERR, REFUSED, NOTIMP. */
#define NI_MAXSERV	32
#define NO_DATA	4		/* Valid name, no data record of requested type. */
#define h_addr	h_addr_list[0]
#define NO_ADDRESS	NO_DATA	/* No address, look for MX record. */

struct servent {
    char *s_name;
    char **s_aliases;
    int s_port;
    char *s_proto;
};
struct hostent {
    char *h_name;
    char **h_aliases;
    int h_addrtype;
    int h_length;
    char **h_addr_list;
};
struct protoent {
    char *p_name;
    char **p_aliases;
    int p_proto;
};
struct netent {
    char *n_name;
    char **n_aliases;
    int n_addrtype;
    unsigned int n_net;
};

#define AI_PASSIVE	0x0001	/* Socket address is intended for `bind' */
#define AI_CANONNAME	0x0002	/* Request for canonical name */
#define AI_NUMERICHOST	0x0004	/* Don't use name resolution */
#define AI_V4MAPPED	0x0008	/* IPv4 mapped addresses are acceptable. */
#define AI_ALL	0x0010		/* Return IPv4 mapped and IPv6 addresses. */
#define AI_ADDRCONFIG	0x0020	/* Use configuration of this host to choose returned address type.. */
#define AI_NUMERICSERV	0x0400	/* Don't use name resolution */

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;
    struct addrinfo *ai_next;
};

#define NI_NUMERICHOST	1
#define NI_DGRAM	16
#define NI_NUMERICSERV	2
#define NI_NOFQDN	4
#define NI_NAMEREQD	8

#define EAI_BADFLAGS	-1	/* Invalid value for `ai_flags' field. */
#define EAI_MEMORY	-10	/* Memory allocation failure. */
#define EAI_SYSTEM	-11	/* System error returned in `errno'. */
#define EAI_NONAME	-2	/* NAME or SERVICE is unknown. */
#define EAI_AGAIN	-3	/* Temporary failure in name resolution. */
#define EAI_FAIL	-4	/* Non-recoverable failure in name res. */
#define EAI_NODATA	-5	/* No address associated with NAME. */
#define EAI_FAMILY	-6	/* `ai_family' not supported. */
#define EAI_SOCKTYPE	-7	/* `ai_family' not supported. */
#define EAI_SERVICE	-8	/* SERVICE not supported for `ai_socktype'. */
#define EAI_ADDRFAMILY	-9	/* Address family for NAME not supported. */

extern int gethostbyname2_r(const char *, int, struct hostent *, char *,
			    size_t, struct hostent **, int *);
extern int getprotobyname_r(const char *, struct protoent *, char *,
			    size_t, struct protoent **);
extern int getprotobynumber_r(int, struct protoent *, char *, size_t,
			      struct protoent **);
extern int getprotoent_r(struct protoent *, char *, size_t,
			 struct protoent **);
extern int getservbyname_r(const char *, const char *, struct servent *,
			   char *, size_t, struct servent **);
extern int getservbyport_r(int, const char *, struct servent *, char *,
			   size_t, struct servent **);
extern int getservent_r(struct servent *, char *, size_t,
			struct servent **);
extern void endprotoent(void);
extern void endservent(void);
extern void freeaddrinfo(struct addrinfo *);
extern const char *gai_strerror(int);
extern int getaddrinfo(const char *, const char *, const struct addrinfo *,
		       struct addrinfo **);
extern struct hostent *gethostbyaddr(const void *, socklen_t, int);
extern struct hostent *gethostbyname(const char *);
extern struct hostent *gethostbyname2(const char *, int);
extern struct protoent *getprotobyname(const char *);
extern struct protoent *getprotobynumber(int);
extern struct protoent *getprotoent(void);
extern struct servent *getservbyname(const char *, const char *);
extern struct servent *getservbyport(int, const char *);
extern struct servent *getservent(void);
extern void setprotoent(int);
extern void setservent(int);
extern int *__h_errno_location(void);
extern int gethostbyaddr_r(const void *, socklen_t, int, struct hostent *,
			   char *, size_t, struct hostent **, int *);
extern int gethostbyname_r(const char *, struct hostent *, char *, size_t,
			   struct hostent **, int *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/in.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IPPROTO_IP	0
#define IPPROTO_ICMP	1
#define IPPROTO_UDP	17
#define IPPROTO_IGMP	2
#define IPPROTO_RAW	255
#define IPPROTO_IPV6	41
#define IPPROTO_ICMPV6	58
#define IPPROTO_TCP	6

typedef uint16_t in_port_t;

struct in_addr {
    uint32_t s_addr;
};
typedef uint32_t in_addr_t;

#define INADDR_NONE	((in_addr_t) 0xffffffff)
#define INADDR_BROADCAST	(0xffffffff)
#define INADDR_ANY	0
#define INADDR_LOOPBACK	0x7f000001	/* 127.0.0.1 */

#define s6_addr16	in6_u.u6_addr16
#define s6_addr32	in6_u.u6_addr32
#define s6_addr	in6_u.u6_addr8

struct in6_addr {
    union {
	uint8_t u6_addr8[16];
	uint16_t u6_addr16[8];
	uint32_t u6_addr32[4];
    } in6_u;
};

#define IN6ADDR_ANY_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
#define IN6ADDR_LOOPBACK_INIT	{ { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

#define IN_MULTICAST(a)	((((in_addr_t)(a))&amp;0xf0000000)==0xe0000000)
#define INET_ADDRSTRLEN	16

struct sockaddr_in {
    sa_family_t sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    unsigned char sin_zero[8];
};

#define IN6_IS_ADDR_LINKLOCAL(a)	((((const uint32_t *) (a))[0] &amp; htonl (0xffc00000)) == htonl (0xfe800000))
#define IN6_IS_ADDR_SITELOCAL(a)	((((const uint32_t *) (a))[0] &amp; htonl (0xffc00000)) == htonl (0xfec00000))
#define IN6_ARE_ADDR_EQUAL(a,b)	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0]) &amp;&amp; (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1]) &amp;&amp; (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2]) &amp;&amp; (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
#define IN6_IS_ADDR_V4COMPAT(a)	((((const uint32_t *) (a))[0] == 0) &amp;&amp; (((const uint32_t *) (a))[1] == 0) &amp;&amp; (((const uint32_t *) (a))[2] == 0) &amp;&amp; (ntohl (((const uint32_t *) (a))[3]) > 1))
#define IN6_IS_ADDR_V4MAPPED(a)	((((const uint32_t *) (a))[0] == 0) &amp;&amp; (((const uint32_t *) (a))[1] == 0) &amp;&amp; (((const uint32_t *) (a))[2] == htonl (0xffff)))
#define IN6_IS_ADDR_UNSPECIFIED(a)	(((const uint32_t *) (a))[0] == 0 &amp;&amp; ((const uint32_t *) (a))[1] == 0 &amp;&amp; ((const uint32_t *) (a))[2] == 0 &amp;&amp; ((const uint32_t *) (a))[3] == 0)
#define IN6_IS_ADDR_LOOPBACK(a)	(((const uint32_t *) (a))[0] == 0 &amp;&amp; ((const uint32_t *) (a))[1] == 0 &amp;&amp; ((const uint32_t *) (a))[2] == 0 &amp;&amp; ((const uint32_t *) (a))[3] == htonl (1))
#define IN6_IS_ADDR_MULTICAST(a)	(((const uint8_t *) (a))[0] == 0xff)
#define IN6_IS_ADDR_MC_NODELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &amp;&amp; ((((const uint8_t *) (a))[1] &amp; 0xf) == 0x1))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &amp;&amp; ((((const uint8_t *) (a))[1] &amp; 0xf) == 0x2))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &amp;&amp; ((((const uint8_t *) (a))[1] &amp; 0xf) == 0x5))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	(IN6_IS_ADDR_MULTICAST(a) &amp;&amp; ((((const uint8_t *) (a))[1] &amp; 0xf) == 0x8))
#define IN6_IS_ADDR_MC_GLOBAL(a)	(IN6_IS_ADDR_MULTICAST(a) &amp;&amp; ((((const uint8_t *) (a))[1] &amp; 0xf) == 0xe))
#define INET6_ADDRSTRLEN	46

struct sockaddr_in6 {
    unsigned short sin6_family;
    uint16_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

#define SOL_IP	0
#define IP_TOS	1		/* IP type of service and precedence */
#define IPV6_UNICAST_HOPS	16
#define IPV6_MULTICAST_IF	17
#define IPV6_MULTICAST_HOPS	18
#define IPV6_MULTICAST_LOOP	19
#define IP_TTL	2		/* IP time to live */
#define IPV6_JOIN_GROUP	20
#define IPV6_LEAVE_GROUP	21
#define IPV6_V6ONLY	26
#define IP_MULTICAST_IF	32	/* set/get IP multicast i/f */
#define IP_MULTICAST_TTL	33	/* set/get IP multicast ttl */
#define IP_MULTICAST_LOOP	34	/* set/get IP multicast loopback */
#define IP_ADD_MEMBERSHIP	35	/* add an IP group membership */
#define IP_DROP_MEMBERSHIP	36	/* drop an IP group membership */
#define IP_OPTIONS	4	/* IP per-packet options */
#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP

struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;
    int ipv6mr_interface;
};
struct ip_mreq {
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
};
extern int bindresvport(int, struct sockaddr_in *);
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/ip.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IPOPT_EOL
#define IPOPT_OPTVAL
#define IPOPT_TS_TSONLY
#define IPOPT_CLASS(o)	((o) &amp; IPOPT_CLASS_MASK)
#define IPOPT_COPIED(o)	((o) &amp; IPOPT_COPY)
#define IPOPT_NUMBER(o)	((o) &amp; IPOPT_NUMBER_MASK)
#define IPOPT_CONTROL	0x00
#define IPOPT_SECUR_UNCLASS	0x0000
#define IPOPT_NUMBER_MASK	0x1f
#define IP_OFFMASK	0x1fff
#define IPOPT_RESERVED1	0x20
#define IP_MF	0x2000
#define IPOPT_DEBMEAS	0x40
#define IP_DF	0x4000
#define IPOPT_CLASS_MASK	0x60
#define IPOPT_RESERVED2	0x60
#define IPOPT_SECUR_TOPSECRET	0x6bc5
#define IPOPT_SECUR_EFTO	0x789a
#define IPOPT_COPY	0x80
#define IP_RF	0x8000
#define IPOPT_SECUR_RESTR	0xaf13
#define IPOPT_SECUR_MMMM	0xbc4d
#define IPOPT_SECUR_SECRET	0xd788
#define IPOPT_SECUR_CONFID	0xf135
#define IPOPT_NOP	1
#define IPOPT_OLEN	1
#define IPOPT_TS_TSANDADDR	1
#define IPTTLDEC	1
#define IPOPT_SECURITY	130
#define IPOPT_LSRR	131
#define IPOPT_SATID	136
#define IPOPT_SSRR	137
#define IPOPT_RA	148
#define IPOPT_OFFSET	2
#define MAXTTL	255
#define IPOPT_TS_PRESPEC	3
#define IPOPT_MINOFF	4
#define IPVERSION	4
#define MAX_IPOPTLEN	40
#define IP_MSS	576
#define IPFRAGTTL	60
#define IPDEFTTL	64
#define IP_MAXPACKET	65535
#define IPOPT_TS	68
#define IPOPT_RR	7
#define IPOPT_MEASUREMENT	IPOPT_DEBMEAS
#define IPOPT_END	IPOPT_EOL
#define IPOPT_NOOP	IPOPT_NOP
#define IPOPT_SID	IPOPT_SATID
#define IPOPT_SEC	IPOPT_SECURITY
#define IPOPT_TIMESTAMP	IPOPT_TS

#define IPTOS_TOS(tos)	((tos) &amp; IPTOS_TOS_MASK)
#define IPTOS_LOWCOST	0x02
#define IPTOS_RELIABILITY	0x04
#define IPTOS_THROUGHPUT	0x08
#define IPTOS_LOWDELAY	0x10
#define IPTOS_TOS_MASK	0x1e
#define IPTOS_MINCOST	IPTOS_LOWCOST

#define IPTOS_PREC(tos)	((tos) &amp; IPTOS_PREC_MASK)
#define IPTOS_PREC_MASK	0xe0
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/ip6.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IP6OPT_PAD1
#define IP6OPT_TYPE(o)	((o) &amp; 0xc0)
#define IP6OPT_TYPE_SKIP	0x00
#define IP6OPT_TUNNEL_LIMIT	0x04
#define IP6OPT_ROUTER_ALERT	0x05
#define IP6OPT_TYPE_MUTABLE	0x20
#define IP6OPT_TYPE_DISCARD	0x40
#define IP6OPT_TYPE_FORCEICMP	0x80
#define IP6OPT_TYPE_ICMP	0xc0
#define IP6OPT_JUMBO	0xc2
#define IP6OPT_NSAP_ADDR	0xc3
#define IP6OPT_PADN	1
#define IP6OPT_JUMBO_LEN	6
#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_nxt	ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_vfc	ip6_ctlun.ip6_un2_vfc

struct ip6_hdrctl {
    uint32_t ip6_un1_flow;
    uint16_t ip6_un1_plen;
    uint8_t ip6_un1_nxt;
    uint8_t ip6_un1_hlim;
};
struct ip6_hdr {
    struct in6_addr ip6_src;
    struct in6_addr ip6_dst;
};
struct ip6_ext {
    uint8_t ip6e_nxt;
    uint8_t ip6e_len;
};
struct ip6_hbh {
    uint8_t ip6h_nxt;
    uint8_t ip6h_len;
};
struct ip6_dest {
    uint8_t ip6d_nxt;
    uint8_t ip6d_len;
};
struct ip6_rthdr {
    uint8_t ip6r_nxt;
    uint8_t ip6r_len;
    uint8_t ip6r_type;
    uint8_t ip6r_segleft;
};
struct ip6_frag {
    uint8_t ip6f_nxt;
    uint8_t ip6f_reserved;
    uint16_t ip6f_offlg;
    uint32_t ip6f_ident;
};
struct ip6_opt {
    uint8_t ip6o_type;
    uint8_t ip6o_len;
};
struct ip6_opt_jumbo {
    uint8_t ip6oj_type;
    uint8_t ip6oj_len;
    uint8_t ip6oj_jumbo_len[4];
};
struct ip6_opt_nsap {
    uint8_t ip6on_type;
    uint8_t ip6on_len;
    uint8_t ip6on_src_nsap_len;
    uint8_t ip6on_dst_nsap_len;
};
struct ip6_opt_tunnel {
    uint8_t ip6ot_type;
    uint8_t ip6ot_len;
    uint8_t ip6ot_encap_limit;
};
struct ip6_opt_router {
    uint8_t ip6or_type;
    uint8_t ip6or_len;
    uint8_t ip6or_value[2];
};
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/tcp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2)
#define TCPOPT_TSTAMP_HDR	(TCPOPT_NOP&lt;&lt;24|TCPOPT_NOP&lt;&lt;16|TCPOPT_TIMESTAMP&lt;&lt;8|TCPOLEN_TIMESTAMP)
#define TCPOPT_EOL	0
#define TCPI_OPT_TIMESTAMPS	1
#define TCPOPT_NOP	1
#define TCP_NODELAY	1
#define TCPOLEN_TIMESTAMP	10
#define TCP_WINDOW_CLAMP	10
#define TCP_INFO	11
#define TCP_QUICKACK	12
#define TCP_CONGESTION	13
#define TCP_MAX_WINSHIFT	14
#define TCP_MD5SIG	14
#define TCPI_OPT_SACK	2
#define TCPOLEN_SACK_PERMITTED	2
#define TCPOPT_MAXSEG	2
#define TCP_MAXSEG	2
#define TCPOLEN_WINDOW	3
#define TCPOPT_WINDOW	3
#define TCP_CORK	3
#define TCPI_OPT_WSCALE	4
#define TCPOLEN_MAXSEG	4
#define TCPOPT_SACK_PERMITTED	4
#define TCP_KEEPIDLE	4
#define TCPOPT_SACK	5
#define TCP_KEEPINTVL	5
#define TCP_MSS	512
#define SOL_TCP	6
#define TCP_KEEPCNT	6
#define TCP_MAXWIN	65535
#define TCP_SYNCNT	7
#define TCPI_OPT_ECN	8
#define TCPOPT_TIMESTAMP	8
#define TCP_LINGER2	8
#define TCP_MD5SIG_MAXKEYLEN	80
#define TCP_DEFER_ACCEPT	9

enum tcp_ca_state {
    TCP_CA_Open,
    TCP_CA_Disorder,
    TCP_CA_CWR,
    TCP_CA_Recovery,
    TCP_CA_Loss
};
struct tcp_info {
    uint8_t tcpi_state;
    uint8_t tcpi_ca_state;
    uint8_t tcpi_retransmits;
    uint8_t tcpi_probes;
    uint8_t tcpi_backoff;
    uint8_t tcpi_options;
    uint8_t tcpi_snd_wscale:4;
    uint8_t tcpi_rcv_wscale:4;
    uint32_t tcpi_rto;
    uint32_t tcpi_ato;
    uint32_t tcpi_snd_mss;
    uint32_t tcpi_rcv_mss;
    uint32_t tcpi_unacked;
    uint32_t tcpi_sacked;
    uint32_t tcpi_lost;
    uint32_t tcpi_retrans;
    uint32_t tcpi_fackets;
    uint32_t tcpi_last_data_sent;
    uint32_t tcpi_last_ack_sent;
    uint32_t tcpi_last_data_recv;
    uint32_t tcpi_last_ack_recv;
    uint32_t tcpi_pmtu;
    uint32_t tcpi_rcv_ssthresh;
    uint32_t tcpi_rtt;
    uint32_t tcpi_rttvar;
    uint32_t tcpi_snd_ssthresh;
    uint32_t tcpi_snd_cwnd;
    uint32_t tcpi_advmss;
    uint32_t tcpi_reordering;
};
enum {
    TCP_ESTABLISHED = 1,
    TCP_SYN_SENT = 2,
    TCP_SYN_RECV = 3,
    TCP_FIN_WAIT1 = 4,
    TCP_FIN_WAIT2 = 5,
    TCP_TIME_WAIT = 6,
    TCP_CLOSE = 7,
    TCP_CLOSE_WAIT = 8,
    TCP_LAST_ACK = 9,
    TCP_LISTEN = 10,
    TCP_CLOSING = 11
};
struct tcp_md5sig {
    struct sockaddr_storage tcpm_addr;
    u_int16_t __tcpm_pad1;
    u_int16_t tcpm_keylen;
    u_int32_t __tcpm_pad2;
    u_int8_t tcpm_key[TCP_MD5SIG_MAXKEYLEN];
};
</SCREEN>
</SECT2>
<SECT2>
<TITLE>netinet/udp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SOL_UDP	17

struct udphdr {
    u_int16_t source;
    u_int16_t dest;
    u_int16_t len;
    u_int16_t check;
};
</SCREEN>
</SECT2>
<SECT2>
<TITLE>nl_types.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NL_CAT_LOCALE	1
#define NL_SETD	1

typedef void *nl_catd;

typedef int nl_item;
extern int catclose(nl_catd);
extern char *catgets(nl_catd, int, int, const char *);
extern nl_catd catopen(const char *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>poll.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int poll(struct pollfd *, nfds_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>pty.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int openpty(int *, int *, char *, struct termios *,
		   struct winsize *);
extern int forkpty(int *, char *, struct termios *, struct winsize *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>pwd.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct passwd {
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gecos;
    char *pw_dir;
    char *pw_shell;
};
extern int getpwent_r(struct passwd *, char *, size_t, struct passwd **);
extern void endpwent(void);
extern struct passwd *getpwent(void);
extern struct passwd *getpwnam(const char *);
extern struct passwd *getpwuid(uid_t);
extern void setpwent(void);
extern int getpwnam_r(const char *, struct passwd *, char *, size_t,
		      struct passwd **);
extern int getpwuid_r(uid_t, struct passwd *, char *, size_t,
		      struct passwd **);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>regex.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define RE_DUP_MAX	(0x7fff)

typedef unsigned long int reg_syntax_t;

typedef struct re_pattern_buffer {
    unsigned char *buffer;
    unsigned long int allocated;
    unsigned long int used;
    reg_syntax_t syntax;
    char *fastmap;
    char *translate;
    size_t re_nsub;
    unsigned int can_be_null:1;
    unsigned int regs_allocated:2;
    unsigned int fastmap_accurate:1;
    unsigned int no_sub:1;
    unsigned int not_bol:1;
    unsigned int not_eol:1;
    unsigned int newline_anchor:1;
} regex_t;
typedef int regoff_t;
typedef struct {
    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;

#define REG_ICASE	(REG_EXTENDED&lt;&lt;1)
#define REG_NEWLINE	(REG_ICASE&lt;&lt;1)
#define REG_NOSUB	(REG_NEWLINE&lt;&lt;1)
#define REG_EXTENDED	1

#define REG_NOTEOL	(1&lt;&lt;1)
#define REG_NOTBOL	1

typedef enum {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} reg_errcode_t;
extern int regcomp(regex_t *, const char *, int);
extern size_t regerror(int, const regex_t *, char *, size_t);
extern int regexec(const regex_t *, const char *, size_t, regmatch_t, int);
extern void regfree(regex_t *);
</SCREEN>
</SECT2>
<!-- empty header file All/regexp.h -->
<SECT2>
<TITLE>rpc/auth.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define auth_destroy(auth)	((*((auth)->ah_ops->ah_destroy))(auth))

enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,
    AUTH_REJECTEDCRED = 2,
    AUTH_BADVERF = 3,
    AUTH_REJECTEDVERF = 4,
    AUTH_TOOWEAK = 5,
    AUTH_INVALIDRESP = 6,
    AUTH_FAILED = 7
};

union des_block {
    struct {
	u_int32_t high;
	u_int32_t low;
    } key;
    char c[8];
};

struct opaque_auth {
    enum_t oa_flavor;
    caddr_t oa_base;
    u_int oa_length;
};

typedef struct AUTH {
    struct opaque_auth ah_cred;
    struct opaque_auth ah_verf;
    union des_block ah_key;
    struct auth_ops *ah_ops;
    caddr_t ah_private;
} AUTH;

struct auth_ops {
    void (*ah_nextverf) (struct AUTH *);
    int (*ah_marshal) (struct AUTH *, XDR *);
    int (*ah_validate) (struct AUTH *, struct opaque_auth *);
    int (*ah_refresh) (struct AUTH *);
    void (*ah_destroy) (struct AUTH *);
};
extern struct AUTH *authnone_create(void);
extern int key_decryptsession(char *, union des_block *);
extern bool_t xdr_opaque_auth(XDR *, struct opaque_auth *);
</SCREEN>
</SECT2>
<!-- empty header file All/rpc/auth_des.h -->
<!-- empty header file All/rpc/auth_unix.h -->
<SECT2>
<TITLE>rpc/clnt.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define clnt_control(cl,rq,in)	((*(cl)->cl_ops->cl_control)(cl,rq,in))
#define clnt_abort(rh)	((*(rh)->cl_ops->cl_abort)(rh))
#define clnt_destroy(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
#define clnt_freeres(rh,xres,resp)	((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
#define clnt_geterr(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
#define NULLPROC	((u_long)0)	/* By convention, procedure 0 takes null arguments and returns */
#define CLSET_TIMEOUT	1	/* set timeout (timeval) */
#define CLGET_XID	10	/* Get xid */
#define CLSET_XID	11	/* Set xid */
#define CLGET_VERS	12	/* Get version number */
#define CLSET_VERS	13	/* Set version number */
#define CLGET_PROG	14	/* Get program number */
#define CLSET_PROG	15	/* Set program number */
#define CLGET_TIMEOUT	2	/* get timeout (timeval) */
#define CLGET_SERVER_ADDR	3	/* get server's address (sockaddr) */
#define CLSET_RETRY_TIMEOUT	4	/* set retry timeout (timeval) */
#define CLGET_RETRY_TIMEOUT	5	/* get retry timeout (timeval) */
#define CLGET_FD	6	/* get connections file descriptor */
#define CLGET_SVC_ADDR	7	/* get server's address (netbuf) */
#define CLSET_FD_CLOSE	8	/* close fd while clnt_destroy */
#define CLSET_FD_NCLOSE	9	/* Do not close fd while clnt_destroy */
#define clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

enum clnt_stat {
    RPC_SUCCESS = 0,
    RPC_CANTENCODEARGS = 1,
    RPC_CANTDECODERES = 2,
    RPC_CANTSEND = 3,
    RPC_CANTRECV = 4,
    RPC_TIMEDOUT = 5,
    RPC_VERSMISMATCH = 6,
    RPC_AUTHERROR = 7,
    RPC_PROGUNAVAIL = 8,
    RPC_PROGVERSMISMATCH = 9,
    RPC_PROCUNAVAIL = 10,
    RPC_CANTDECODEARGS = 11,
    RPC_SYSTEMERROR = 12,
    RPC_NOBROADCAST = 21,
    RPC_UNKNOWNHOST = 13,
    RPC_UNKNOWNPROTO = 17,
    RPC_UNKNOWNADDR = 19,
    RPC_RPCBFAILURE = 14,
    RPC_PROGNOTREGISTERED = 15,
    RPC_N2AXLATEFAILURE = 22,
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
};
struct rpc_err {
    enum clnt_stat re_status;
    union {
	int RE_errno;
	enum auth_stat RE_why;
	struct {
	    u_long low;
	    u_long high;
	} RE_vers;
	struct {
	    long int s1;
	    long int s2;
	} RE_lb;
    } ru;
};

typedef struct CLIENT {
    struct AUTH *cl_auth;
    struct clnt_ops *cl_ops;
    caddr_t cl_private;
} CLIENT;

struct clnt_ops {
    enum clnt_stat (*cl_call) (struct CLIENT *, u_long, xdrproc_t, caddr_t,
			       xdrproc_t, caddr_t, struct timeval);
    void (*cl_abort) (void);
    void (*cl_geterr) (struct CLIENT *, struct rpc_err *);
     bool_t(*cl_freeres) (struct CLIENT *, xdrproc_t, caddr_t);
    void (*cl_destroy) (struct CLIENT *);
     bool_t(*cl_control) (struct CLIENT *, int, char *);
};
extern struct CLIENT *clntraw_create(u_long, u_long);
extern struct CLIENT *clnttcp_create(struct sockaddr_in *, u_long, u_long,
				     int *, u_int, u_int);
extern struct CLIENT *clntudp_bufcreate(struct sockaddr_in *, u_long,
					u_long, struct timeval, int *,
					u_int, u_int);
extern struct CLIENT *clntudp_create(struct sockaddr_in *, u_long, u_long,
				     struct timeval, int *);
extern int callrpc(const char *, const u_long, const u_long, const u_long,
		   const xdrproc_t, const char *, const xdrproc_t, char *);
extern struct CLIENT *clnt_create(const char *, const u_long, const u_long,
				  const char *);
extern void clnt_pcreateerror(const char *);
extern void clnt_perrno(enum clnt_stat);
extern void clnt_perror(struct CLIENT *, const char *);
extern char *clnt_spcreateerror(const char *);
extern char *clnt_sperrno(enum clnt_stat);
extern char *clnt_sperror(struct CLIENT *, const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>rpc/pmap_clnt.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern u_short pmap_getport(struct sockaddr_in *, const u_long,
			    const u_long, u_int);
extern bool_t pmap_set(const u_long, const u_long, int, u_short);
extern bool_t pmap_unset(u_long, u_long);
</SCREEN>
</SECT2>
<!-- empty header file All/rpc/rpc.h -->
<SECT2>
<TITLE>rpc/rpc_msg.h</TITLE>
<PARA>
</PARA>
<SCREEN>

enum msg_type {
    CALL = 0,
    REPLY = 1
};
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
};
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
};
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
};

#define ar_results	ru.AR_results
#define ar_vers	ru.AR_versions

struct accepted_reply {
    struct opaque_auth ar_verf;
    enum accept_stat ar_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} AR_versions;
	struct {
	    caddr_t where;
	    xdrproc_t proc;
	} AR_results;
    } ru;
};

#define rj_vers	ru.RJ_versions
#define rj_why	ru.RJ_why

struct rejected_reply {
    enum reject_stat rj_stat;
    union {
	struct {
	    unsigned long int low;
	    unsigned long int high;
	} RJ_versions;
	enum auth_stat RJ_why;
    } ru;
};

#define rp_acpt	ru.RP_ar
#define rp_rjct	ru.RP_dr

struct reply_body {
    enum reply_stat rp_stat;
    union {
	struct accepted_reply RP_ar;
	struct rejected_reply RP_dr;
    } ru;
};

struct call_body {
    unsigned long int cb_rpcvers;
    unsigned long int cb_prog;
    unsigned long int cb_vers;
    unsigned long int cb_proc;
    struct opaque_auth cb_cred;
    struct opaque_auth cb_verf;
};

#define rm_call	ru.RM_cmb
#define rm_reply	ru.RM_rmb
#define acpted_rply	ru.RM_rmb.ru.RP_ar
#define rjcted_rply	ru.RM_rmb.ru.RP_dr

struct rpc_msg {
    unsigned long int rm_xid;
    enum msg_type rm_direction;
    union {
	struct call_body RM_cmb;
	struct reply_body RM_rmb;
    } ru;
};
extern bool_t xdr_accepted_reply(XDR *, struct accepted_reply *);
extern bool_t xdr_callhdr(XDR *, struct rpc_msg *);
extern bool_t xdr_callmsg(XDR *, struct rpc_msg *);
extern bool_t xdr_rejected_reply(XDR *, struct rejected_reply *);
extern bool_t xdr_replymsg(XDR *, struct rpc_msg *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>rpc/svc.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define svc_getcaller(x)	(&amp;(x)->xp_raddr)
#define svc_destroy(xprt)	(*(xprt)->xp_ops->xp_destroy)(xprt)
#define svc_recv(xprt,msg)	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
#define svc_reply(xprt,msg)	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
#define svc_stat(xprt)	(*(xprt)->xp_ops->xp_stat)(xprt)
#define RPC_ANYSOCK	-1
#define svc_freeargs(xprt,xargs, argsp)	\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt,xargs, argsp)	\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))

enum xprt_stat {
    XPRT_DIED,
    XPRT_MOREREQS,
    XPRT_IDLE
};

typedef struct SVCXPRT {
    int xp_sock;
    u_short xp_port;
    struct xp_ops *xp_ops;
    int xp_addrlen;
    struct sockaddr_in xp_raddr;
    struct opaque_auth xp_verf;
    caddr_t xp_p1;
    caddr_t xp_p2;
    char xp_pad[256];
} SVCXPRT;

struct svc_req {
    rpcprog_t rq_prog;
    rpcvers_t rq_vers;
    rpcproc_t rq_proc;
    struct opaque_auth rq_cred;
    caddr_t rq_clntcred;
    SVCXPRT *rq_xprt;
};

typedef void (*__dispatch_fn_t) (struct svc_req *, SVCXPRT *);

struct xp_ops {
    bool_t(*xp_recv) (SVCXPRT * __xprt, struct rpc_msg * __msg);
    enum xprt_stat (*xp_stat) (SVCXPRT * __xprt);
     bool_t(*xp_getargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			  caddr_t args_ptr);
     bool_t(*xp_reply) (SVCXPRT * __xprt, struct rpc_msg * __msg);
     bool_t(*xp_freeargs) (SVCXPRT * __xprt, xdrproc_t __xdr_args,
			   caddr_t args_ptr);
    void (*xp_destroy) (SVCXPRT * __xprt);
};
extern SVCXPRT *svcraw_create(void);
extern void svc_getreqset(fd_set *);
extern bool_t svc_register(SVCXPRT *, rpcprog_t, rpcvers_t,
			   __dispatch_fn_t, rpcprot_t);
extern void svc_run(void);
extern bool_t svc_sendreply(SVCXPRT *, xdrproc_t, caddr_t);
extern void svcerr_auth(SVCXPRT *, enum auth_stat);
extern void svcerr_decode(SVCXPRT *);
extern void svcerr_noproc(SVCXPRT *);
extern void svcerr_noprog(SVCXPRT *);
extern void svcerr_progvers(SVCXPRT *, rpcvers_t, rpcvers_t);
extern void svcerr_systemerr(SVCXPRT *);
extern void svcerr_weakauth(SVCXPRT *);
extern SVCXPRT *svctcp_create(int, u_int, u_int);
extern SVCXPRT *svcudp_create(int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>rpc/types.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef int bool_t;
typedef int enum_t;
typedef unsigned long int rpcprog_t;
typedef unsigned long int rpcvers_t;
typedef unsigned long int rpcproc_t;
typedef unsigned long int rpcprot_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>rpc/xdr.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define XDR_DESTROY(xdrs)	 \
   do { if ((xdrs)->x_ops->x_destroy) (*(xdrs)->x_ops->x_destroy)(xdrs); \
      } while (0)
#define xdr_destroy(xdrs)	 \
   do { if ((xdrs)->x_ops->x_destroy) (*(xdrs)->x_ops->x_destroy)(xdrs); \
      } while (0)
#define XDR_GETBYTES(xdrs,addr,len)	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs,addr,len)	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define XDR_GETINT32(xdrs,int32p)	(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
#define xdr_getint32(xdrs,int32p)	(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
#define XDR_GETLONG(xdrs,longp)	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs,longp)	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define XDR_GETPOS(xdrs)	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_getpos(xdrs)	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define XDR_INLINE(xdrs,len)	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define xdr_inline(xdrs,len)	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define XDR_PUTBYTES(xdrs,addr,len)	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs,addr,len)	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define XDR_PUTINT32(xdrs,int32p)	(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
#define xdr_putint32(xdrs,int32p)	(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
#define XDR_PUTLONG(xdrs,longp)	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs,longp)	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define XDR_SETPOS(xdrs,pos)	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs,pos)	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)

enum xdr_op {
    XDR_ENCODE,
    XDR_DECODE,
    XDR_FREE
};
typedef struct XDR {
    enum xdr_op x_op;
    struct xdr_ops *x_ops;
    caddr_t x_public;
    caddr_t x_private;
    caddr_t x_base;
    int x_handy;
} XDR;

struct xdr_ops {
    bool_t(*x_getlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_putlong) (XDR * __xdrs, long int *__lp);
    bool_t(*x_getbytes) (XDR * __xdrs, caddr_t __addr, u_int __len);
    bool_t(*x_putbytes) (XDR * __xdrs, char *__addr, u_int __len);
    u_int(*x_getpostn) (XDR * __xdrs);
    bool_t(*x_setpostn) (XDR * __xdrs, u_int __pos);
    int32_t *(*x_inline) (XDR * __xdrs, int __len);
    void (*x_destroy) (XDR * __xdrs);
     bool_t(*x_getint32) (XDR * __xdrs, int32_t * __ip);
     bool_t(*x_putint32) (XDR * __xdrs, int32_t * __ip);
};

typedef bool_t(*xdrproc_t) (XDR *, void *, ...);

struct xdr_discrim {
    int value;
    xdrproc_t proc;
};
extern bool_t xdrrec_endofrecord(XDR *, bool_t);
extern bool_t xdrrec_skiprecord(XDR *);
extern void xdrstdio_create(XDR *, FILE *, enum xdr_op);
extern bool_t xdr_array(XDR *, caddr_t *, u_int *, u_int, u_int,
			xdrproc_t);
extern bool_t xdr_bool(XDR *, bool_t *);
extern bool_t xdr_bytes(XDR *, char **, u_int *, u_int);
extern bool_t xdr_char(XDR *, char *);
extern bool_t xdr_double(XDR *, double *);
extern bool_t xdr_enum(XDR *, enum_t *);
extern bool_t xdr_float(XDR *, float *);
extern void xdr_free(xdrproc_t, char *);
extern bool_t xdr_int(XDR *, int *);
extern bool_t xdr_long(XDR *, long int *);
extern bool_t xdr_opaque(XDR *, caddr_t, u_int);
extern bool_t xdr_pointer(XDR *, char **, u_int, xdrproc_t);
extern bool_t xdr_reference(XDR *, caddr_t *, u_int, xdrproc_t);
extern bool_t xdr_short(XDR *, short *);
extern bool_t xdr_string(XDR *, char **, u_int);
extern bool_t xdr_u_char(XDR *, u_char *);
extern bool_t xdr_u_int(XDR *, u_int *);
extern bool_t xdr_u_long(XDR *, u_long *);
extern bool_t xdr_u_short(XDR *, u_short *);
extern bool_t xdr_union(XDR *, enum_t *, char *,
			const struct xdr_discrim *, xdrproc_t);
extern bool_t xdr_vector(XDR *, char *, u_int, u_int, xdrproc_t);
extern bool_t xdr_void(void);
extern bool_t xdr_wrapstring(XDR *, char **);
extern void xdrmem_create(XDR *, caddr_t, u_int, enum xdr_op);
extern void xdrrec_create(XDR *, u_int, u_int, caddr_t,
			  int (*)(char *p1, char *p2, int p3)
			  , int (*)(char *p1, char *p2, int p3)
    );
extern bool_t xdrrec_eof(XDR *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sched.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define __CPUELT(cpu)	((cpu) / __NCPUBITS)
#define __CPUMASK(cpu)	((__cpu_mask) 1 &lt;&lt; ((cpu) % __NCPUBITS))
#define __NCPUBITS	(8 * sizeof (__cpu_mask))
#define SCHED_OTHER	0
#define SCHED_FIFO	1
#define __CPU_SETSIZE	1024
#define SCHED_RR	2
#define CPU_ALLOC(count)	__CPU_ALLOC (count)
#define CPU_ALLOC_SIZE(count)	__CPU_ALLOC_SIZE (count)
#define CPU_COUNT(cpusetp)	__CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)
#define CPU_FREE(cpuset)	__CPU_FREE (cpuset)
#define CPU_SETSIZE	__CPU_SETSIZE
#define CPU_ZERO(cpusetp)	__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)

struct sched_param {
    int sched_priority;
};
typedef unsigned long int __cpu_mask;
typedef struct {
    __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
} cpu_set_t;
extern int sched_get_priority_max(int);
extern int sched_get_priority_min(int);
extern int sched_getparam(pid_t, struct sched_param *);
extern int sched_getscheduler(pid_t);
extern int sched_rr_get_interval(pid_t, struct timespec *);
extern int sched_setparam(pid_t, const struct sched_param *);
extern int sched_setscheduler(pid_t, int, const struct sched_param *);
extern int sched_yield(void);
extern int sched_getaffinity(pid_t, size_t, cpu_set_t *);
extern int sched_setaffinity(pid_t, size_t, const cpu_set_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>search.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef struct entry {
    char *key;
    void *data;
} ENTRY;
typedef enum {
    FIND,
    ENTER
} ACTION;
struct _ENTRY;
typedef enum {
    preorder,
    postorder,
    endorder,
    leaf
} VISIT;
struct hsearch_data {
    struct _ENTRY *table;
    unsigned int size;
    unsigned int filled;
};

typedef void (*__action_fn_t) (const void *__nodep, VISIT __value,
			       int __level);
extern int hcreate_r(size_t, struct hsearch_data *);
extern void hdestroy_r(struct hsearch_data *);
extern int hsearch_r(ENTRY, ACTION, ENTRY * *, struct hsearch_data *);
extern int hcreate(size_t);
extern ENTRY *hsearch(ENTRY, ACTION);
extern void insque(void *, void *);
extern void *lfind(const void *, const void *, size_t *, size_t,
		   __compar_fn_t);
extern void *lsearch(const void *, void *, size_t *, size_t,
		     __compar_fn_t);
extern void remque(void *);
extern void hdestroy(void);
extern void *tdelete(const void *, void **, __compar_fn_t);
extern void *tfind(const void *, void *const *, __compar_fn_t);
extern void *tsearch(const void *, void **, __compar_fn_t);
extern void twalk(const void *, __action_fn_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>setjmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define setjmp(env)	_setjmp(env)
#define sigsetjmp(a,b)	__sigsetjmp(a,b)

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    sigset_t __saved_mask;
};

typedef struct __jmp_buf_tag jmp_buf[1];
typedef jmp_buf sigjmp_buf;
extern int __sigsetjmp(jmp_buf, int);
extern void longjmp(jmp_buf, int);
extern void siglongjmp(sigjmp_buf, int);
extern void _longjmp(jmp_buf, int);
extern int _setjmp(jmp_buf);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>signal.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define sigpause __xpg_sigpause

#define _SIGSET_NWORDS	(1024/(8*sizeof(unsigned long)))
#define SIGRTMAX	(__libc_current_sigrtmax ())
#define SIGRTMIN	(__libc_current_sigrtmin ())
#define NSIG	65
#define SIG_BLOCK	0	/* Block signals. */
#define SIG_UNBLOCK	1	/* Unblock signals. */
#define SIG_SETMASK	2	/* Set the set of blocked signals. */

typedef int sig_atomic_t;

typedef void (*sighandler_t) (int);

#define SIG_HOLD	((sighandler_t) 2)	/* Request that signal be held. */
#define SIG_DFL	((sighandler_t)0)	/* Request for default signal handling. */
#define SIG_IGN	((sighandler_t)1)	/* Request that signal be ignored. */
#define SIG_ERR	((sighandler_t)-1)	/* Return value from signal() in case of error. */

#define SIGHUP	1		/* Hangup. */
#define SIGINT	2		/* Terminal interrupt signal. */
#define SIGQUIT	3		/* Terminal quit signal. */
#define SIGILL	4		/* Illegal instruction. */
#define SIGTRAP	5		/* Trace/breakpoint trap. */
#define SIGABRT	6		/* Process abort signal. */
#define SIGIOT	6		/* IOT trap */
#define SIGBUS	7		/* Access to an undefined portion of a memory object. */
#define SIGFPE	8		/* Erroneous arithmetic operation. */
#define SIGKILL	9		/* Kill (cannot be caught or ignored). */
#define SIGUSR1	10		/* User-defined signal 1. */
#define SIGSEGV	11		/* Invalid memory reference. */
#define SIGUSR2	12		/* User-defined signal 2. */
#define SIGPIPE	13		/* Write  on a pipe with no one to read it. */
#define SIGALRM	14		/* Alarm clock. */
#define SIGTERM	15		/* Termination signal. */
#define SIGSTKFLT	16	/* Stack fault. */
#define SIGCHLD	17		/* Child process terminated, stopped, or continued. */
#define SIGCLD	SIGCHLD		/* Same as SIGCHLD */
#define SIGCONT	18		/* Continue executing, if stopped. */
#define SIGSTOP	19		/* Stop executing (cannot be caught or ignored). */
#define SIGTSTP	20		/* Terminal stop signal. */
#define SIGTTIN	21		/* Background process attempting read. */
#define SIGTTOU	22		/* Background process attempting write. */
#define SIGURG	23		/* High bandwidth data is available at a socket. */
#define SIGXCPU	24		/* CPU time limit exceeded. */
#define SIGXFSZ	25		/* File size limit exceeded. */
#define SIGVTALRM	26	/* Virtual timer expired. */
#define SIGPROF	27		/* Profiling timer expired. */
#define SIGWINCH	28	/* Window size change. */
#define SIGIO	29		/* I/O now possible. */
#define SIGPOLL	SIGIO		/* Pollable event. */
#define SIGPWR	30		/* Power failure restart */
#define SIGSYS	31		/* Bad system call. */
#define SIGUNUSED	31

#define SV_ONSTACK	(1&lt;&lt;0)	/* Take the signal on the signal stack. */
#define SV_INTERRUPT	(1&lt;&lt;1)	/* Do not restart system calls. */
#define SV_RESETHAND	(1&lt;&lt;2)	/* Reset handler to SIG_DFL on receipt. */

typedef union sigval {
    int sival_int;
    void *sival_ptr;
} sigval_t;

#define SIGEV_SIGNAL	0	/* Notify via signal. */
#define SIGEV_NONE	1	/* Other notification: meaningless. */
#define SIGEV_THREAD	2	/* Deliver via thread creation. */
#define SIGEV_MAX_SIZE	64

typedef struct sigevent {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;
    union {
	int _pad[SIGEV_PAD_SIZE];
	struct {
	    void (*_function) (sigval_t);
	    void *_attribute;
	} _sigev_thread;
    } _sigev_un;
} sigevent_t;

#define SI_MAX_SIZE	128
#define si_pid	_sifields._kill._pid
#define si_uid	_sifields._kill._uid
#define si_value	_sifields._rt._sigval
#define si_int	_sifields._rt._sigval.sival_int
#define si_ptr	_sifields._rt._sigval.sival_ptr
#define si_status	_sifields._sigchld._status
#define si_stime	_sifields._sigchld._stime
#define si_utime	_sifields._sigchld._utime
#define si_addr	_sifields._sigfault._addr
#define si_band	_sifields._sigpoll._band
#define si_fd	_sifields._sigpoll._fd
#define si_timer1	_sifields._timer._timer1
#define si_timer2	_sifields._timer._timer2

typedef struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union {
	int _pad[SI_PAD_SIZE];
	struct {
	    pid_t _pid;
	    uid_t _uid;
	} _kill;
	struct {
	    unsigned int _timer1;
	    unsigned int _timer2;
	} _timer;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    sigval_t _sigval;
	} _rt;
	struct {
	    pid_t _pid;
	    uid_t _uid;
	    int _status;
	    clock_t _utime;
	    clock_t _stime;
	} _sigchld;
	struct {
	    void *_addr;
	} _sigfault;
	struct {
	    int _band;
	    int _fd;
	} _sigpoll;
    } _sifields;
} siginfo_t;

#define SI_QUEUE	-1	/* Sent by sigqueue. */
#define SI_TIMER	-2	/* Sent by timer expiration. */
#define SI_MESGQ	-3	/* Sent by real time mesq state change. */
#define SI_ASYNCIO	-4	/* Sent by AIO completion. */
#define SI_SIGIO	-5	/* Sent by queued SIGIO. */
#define SI_TKILL	-6	/* Sent by tkill. */
#define SI_ASYNCNL	-60	/* Sent by asynch name lookup completion. */
#define SI_USER	0		/* Sent by kill, sigsend, raise. */
#define SI_KERNEL	0x80	/* Sent by kernel. */

#define ILL_ILLOPC	1	/* Illegal opcode. */
#define ILL_ILLOPN	2	/* Illegal operand. */
#define ILL_ILLADR	3	/* Illegal addressing mode. */
#define ILL_ILLTRP	4	/* Illegal trap. */
#define ILL_PRVOPC	5	/* Privileged opcode. */
#define ILL_PRVREG	6	/* Privileged register. */
#define ILL_COPROC	7	/* Coprocessor error. */
#define ILL_BADSTK	8	/* Internal stack error. */

#define FPE_INTDIV	1	/* Integer divide by zero. */
#define FPE_INTOVF	2	/* Integer overflow. */
#define FPE_FLTDIV	3	/*  Floating-point divide by zero. */
#define FPE_FLTOVF	4	/* Floating-point overflow. */
#define FPE_FLTUND	5	/*  Floating-point underflow. */
#define FPE_FLTRES	6	/*  Floating-point inexact result. */
#define FPE_FLTINV	7	/* Invalid floating-point operation. */
#define FPE_FLTSUB	8	/* Subscript out of range. */

#define SEGV_MAPERR	1	/* Address not mapped to object. */
#define SEGV_ACCERR	2	/*  Invalid permissions for mapped object. */

#define BUS_ADRALN	1	/*  Invalid address alignment. */
#define BUS_ADRERR	2	/*  Nonexistent physical address. */
#define BUS_OBJERR	3	/*  Object-specific hardware error. */

#define TRAP_BRKPT	1	/*  Process breakpoint. */
#define TRAP_TRACE	2	/*  Process trace trap. */

#define CLD_EXITED	1	/* Child has exited. */
#define CLD_KILLED	2	/* Child has terminated abnormally and did not create a core fi */
#define CLD_DUMPED	3	/* Child has terminated abnormally and created a core file. */
#define CLD_TRAPPED	4	/*  Traced child has trapped. */
#define CLD_STOPPED	5	/* Child has stopped. */
#define CLD_CONTINUED	6	/* Stopped child has continued. */

#define POLL_IN	1		/*  Data input available. */
#define POLL_OUT	2	/*  Output buffers available. */
#define POLL_MSG	3	/*  Input message available. */
#define POLL_ERR	4	/*  I/O error. */
#define POLL_PRI	5	/* High priority input available. */
#define POLL_HUP	6	/*  Device disconnected. */

typedef struct {
    unsigned long int sig[_SIGSET_NWORDS];
} sigset_t;

#define SA_INTERRUPT	0x20000000
#define sa_handler	__sigaction_handler._sa_handler
#define sa_sigaction	__sigaction_handler._sa_sigaction
#define SA_ONSTACK	0x08000000	/* Use signal stack by using `sa_restorer`. */
#define SA_RESETHAND	0x80000000	/* Reset to SIG_DFL on entry to handler. */
#define SA_NOCLDSTOP	0x00000001	/* Don't send SIGCHLD when children stop. */
#define SA_SIGINFO	0x00000004	/* Invoke signal-catching function with three arguments instead of one. */
#define SA_NODEFER	0x40000000	/* Don't automatically block the signal when its handler is being executed. */
#define SA_RESTART	0x10000000	/* Restart syscall on signal return. */
#define SA_NOCLDWAIT	0x00000002	/* Don't create zombie on child death. */
#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND

typedef struct sigaltstack {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
} stack_t;

#define SS_ONSTACK	1
#define SS_DISABLE	2

extern int __libc_current_sigrtmax(void);
extern int __libc_current_sigrtmin(void);
extern sighandler_t __sysv_signal(int, sighandler_t);
extern char *const _sys_siglist[];
extern int killpg(pid_t, int);
extern void psignal(int, const char *);
extern int raise(int);
extern int sigaddset(sigset_t *, int);
extern int sigandset(sigset_t *, const sigset_t *, const sigset_t *);
extern int sigdelset(sigset_t *, int);
extern int sigemptyset(sigset_t *);
extern int sigfillset(sigset_t *);
extern int sighold(int);
extern int sigignore(int);
extern int siginterrupt(int, int);
extern int sigisemptyset(const sigset_t *);
extern int sigismember(const sigset_t *, int);
extern int sigorset(sigset_t *, const sigset_t *, const sigset_t *);
extern int sigpending(sigset_t *);
extern int sigrelse(int);
extern sighandler_t sigset(int, sighandler_t);
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, const sigset_t *, sigset_t *);
extern int sigaction(int, const struct sigaction *, struct sigaction *);
extern int sigwait(const sigset_t *, int *);
extern int kill(pid_t, int);
extern int sigaltstack(const struct sigaltstack *, struct sigaltstack *);
extern sighandler_t signal(int, sighandler_t);
extern int sigprocmask(int, const sigset_t *, sigset_t *);
extern int sigreturn(struct sigcontext *);
extern int sigsuspend(const sigset_t *);
extern int sigqueue(pid_t, int, const union sigval);
extern int sigwaitinfo(const sigset_t *, siginfo_t *);
extern int sigtimedwait(const sigset_t *, siginfo_t *,
			const struct timespec *);
extern sighandler_t bsd_signal(int, sighandler_t);
extern int __xpg_sigpause(int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>spawn.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define POSIX_SPAWN_RESETIDS	0x01
#define POSIX_SPAWN_SETPGROUP	0x02
#define POSIX_SPAWN_SETSIGDEF	0x04
#define POSIX_SPAWN_SETSIGMASK	0x08
#define POSIX_SPAWN_SETSCHEDPARAM	0x10
#define POSIX_SPAWN_SETSCHEDULER	0x20

typedef struct {
    int __allocated;
    int __used;
    struct __spawn_action *__actions;
    int __pad[16];
} posix_spawn_file_actions_t;
typedef struct {
    short __flags;
    pid_t __pgrp;
    sigset_t __sd;
    sigset_t __ss;
    struct sched_param __sp;
    int __policy;
    int __pad[16];
} posix_spawnattr_t;
extern int posix_spawn(pid_t *, const char *,
		       const posix_spawn_file_actions_t *,
		       const posix_spawnattr_t *, char *const,
		       char *const);
extern int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *,
					     int);
extern int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *,
					    int, int);
extern int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *,
					    int, const char *, int,
					    mode_t);
extern int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *);
extern int posix_spawn_file_actions_init(posix_spawn_file_actions_t *);
extern int posix_spawnattr_destroy(posix_spawnattr_t *);
extern int posix_spawnattr_getflags(const posix_spawnattr_t *,
				    short int *);
extern int posix_spawnattr_getpgroup(const posix_spawnattr_t *, pid_t *);
extern int posix_spawnattr_getschedparam(const posix_spawnattr_t *,
					 struct sched_param *);
extern int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *,
					  int *);
extern int posix_spawnattr_getsigdefault(const posix_spawnattr_t *,
					 sigset_t *);
extern int posix_spawnattr_getsigmask(const posix_spawnattr_t *,
				      sigset_t *);
extern int posix_spawnattr_init(posix_spawnattr_t *);
extern int posix_spawnattr_setflags(posix_spawnattr_t *, short int);
extern int posix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t);
extern int posix_spawnattr_setschedparam(posix_spawnattr_t *,
					 const struct sched_param *);
extern int posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int);
extern int posix_spawnattr_setsigdefault(posix_spawnattr_t *,
					 const sigset_t *);
extern int posix_spawnattr_setsigmask(posix_spawnattr_t *,
				      const sigset_t *);
extern int posix_spawnp(pid_t *, const char *,
			const posix_spawn_file_actions_t *,
			const posix_spawnattr_t *, char *const,
			char *const);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stddef.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define offsetof(TYPE,MEMBER)	((size_t)&amp;((TYPE*)0)->MEMBER)
#ifndef NULL
#  ifdef __cplusplus
#    define NULL        (0L)
#  else
#    define NULL        ((void*) 0)
#  endif
#endif
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdint.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define INT16_C(c)	c
#define INT32_C(c)	c
#define INT8_C(c)	c
#define UINT16_C(c)	c
#define UINT8_C(c)	c
#define UINT32_C(c)	c ## U

#define INT8_MIN	(-128)
#define INT_FAST8_MIN	(-128)
#define INT_LEAST8_MIN	(-128)
#define INT32_MIN	(-2147483647-1)
#define INT_LEAST32_MIN	(-2147483647-1)
#define SIG_ATOMIC_MIN	(-2147483647-1)
#define INT16_MIN	(-32767-1)
#define INT_LEAST16_MIN	(-32767-1)
#define INT64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INTMAX_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_FAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
#define WINT_MIN	(0u)
#define INT8_MAX	(127)
#define INT_FAST8_MAX	(127)
#define INT_LEAST8_MAX	(127)
#define INT32_MAX	(2147483647)
#define INT_LEAST32_MAX	(2147483647)
#define SIG_ATOMIC_MAX	(2147483647)
#define UINT8_MAX	(255)
#define UINT_FAST8_MAX	(255)
#define UINT_LEAST8_MAX	(255)
#define INT16_MAX	(32767)
#define INT_LEAST16_MAX	(32767)
#define UINT32_MAX	(4294967295U)
#define UINT_LEAST32_MAX	(4294967295U)
#define WINT_MAX	(4294967295u)
#define UINT16_MAX	(65535)
#define UINT_LEAST16_MAX	(65535)
#define INT64_MAX	(__INT64_C(9223372036854775807))
#define INTMAX_MAX	(__INT64_C(9223372036854775807))
#define INT_FAST64_MAX	(__INT64_C(9223372036854775807))
#define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
#define UINT64_MAX	(__UINT64_C(18446744073709551615))
#define UINTMAX_MAX	(__UINT64_C(18446744073709551615))
#define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
#define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define EOF	(-1)
#define P_tmpdir	"/tmp"
#define FOPEN_MAX	16
#define L_tmpnam	20
#define FILENAME_MAX	4096
#define BUFSIZ	8192
#define L_ctermid	9
#define L_cuserid	9

typedef struct {
    off_t __pos;
    mbstate_t __state;
} fpos_t;
typedef struct {
    off64_t __pos;
    mbstate_t __state;
} fpos64_t;

typedef struct _IO_FILE FILE;

#define _IOFBF	0
#define _IOLBF	1
#define _IONBF	2

extern void clearerr_unlocked(FILE *);
extern int feof_unlocked(FILE *);
extern int ferror_unlocked(FILE *);
extern char *fgets_unlocked(char *, int, FILE *);
extern int fputc_unlocked(int, FILE *);
extern int fputs_unlocked(const char *, FILE *);
extern size_t fread_unlocked(void *, size_t, size_t, FILE *);
extern size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
extern FILE *open_memstream(char **, size_t *);
extern int fgetc_unlocked(FILE *);
extern int fileno_unlocked(FILE *);
extern ssize_t getdelim(char **, size_t *, int, FILE *);
extern ssize_t getline(char **, size_t *, FILE *);
extern FILE *fmemopen(void *, size_t, const char *);
extern char *const _sys_errlist[];
extern void clearerr(FILE *);
extern int fclose(FILE *);
extern FILE *fdopen(int, const char *);
extern int fflush_unlocked(FILE *);
extern int fileno(FILE *);
extern FILE *fopen(const char *, const char *);
extern int fprintf(FILE *, const char *, ...);
extern int fputc(int, FILE *);
extern FILE *freopen(const char *, const char *, FILE *);
extern FILE *freopen64(const char *, const char *, FILE *);
extern int fscanf(FILE *, const char *, ...);
extern int fseek(FILE *, long int, int);
extern int fseeko(FILE *, off_t, int);
extern int fseeko64(FILE *, loff_t, int);
extern off_t ftello(FILE *);
extern loff_t ftello64(FILE *);
extern int getchar(void);
extern int getchar_unlocked(void);
extern int getw(FILE *);
extern int pclose(FILE *);
extern void perror(const char *);
extern FILE *popen(const char *, const char *);
extern int printf(const char *, ...);
extern int putc_unlocked(int, FILE *);
extern int putchar(int);
extern int putchar_unlocked(int);
extern int putw(int, FILE *);
extern int remove(const char *);
extern void rewind(FILE *);
extern int scanf(const char *, ...);
extern void setbuf(FILE *, char *);
extern int sprintf(char *, const char *, ...);
extern int sscanf(const char *, const char *, ...);
extern FILE *stderr;
extern FILE *stdin;
extern FILE *stdout;
extern char *tempnam(const char *, const char *);
extern FILE *tmpfile64(void);
extern FILE *tmpfile(void);
extern char *tmpnam(char *);
extern int vfprintf(FILE *, const char *, va_list);
extern int vprintf(const char *, va_list);
extern int feof(FILE *);
extern int ferror(FILE *);
extern int fflush(FILE *);
extern int fgetc(FILE *);
extern int fgetpos(FILE *, fpos_t *);
extern char *fgets(char *, int, FILE *);
extern int fputs(const char *, FILE *);
extern size_t fread(void *, size_t, size_t, FILE *);
extern int fsetpos(FILE *, const fpos_t *);
extern long int ftell(FILE *);
extern size_t fwrite(const void *, size_t, size_t, FILE *);
extern int getc(FILE *);
extern int putc(int, FILE *);
extern int puts(const char *);
extern int setvbuf(FILE *, char *, int, size_t);
extern int snprintf(char *, size_t, const char *, ...);
extern int ungetc(int, FILE *);
extern int vsnprintf(char *, size_t, const char *, va_list);
extern int vsprintf(char *, const char *, va_list);
extern void flockfile(FILE *);
extern int asprintf(char **, const char *, ...);
extern int fgetpos64(FILE *, fpos64_t *);
extern FILE *fopen64(const char *, const char *);
extern int fsetpos64(FILE *, const fpos64_t *);
extern int ftrylockfile(FILE *);
extern void funlockfile(FILE *);
extern int getc_unlocked(FILE *);
extern void setbuffer(FILE *, char *, size_t);
extern int vasprintf(char **, const char *, va_list);
extern int vdprintf(int, const char *, va_list);
extern int vfscanf(FILE *, const char *, va_list);
extern int vscanf(const char *, va_list);
extern int vsscanf(const char *, const char *, va_list);
extern size_t __fpending(FILE *);
extern char *__fgets_chk(char *, size_t, int, FILE *);
extern int __vsprintf_chk(char *, int, size_t, const char *, va_list);
extern int __vprintf_chk(int, const char *, va_list);
extern int __printf_chk(int, const char *, ...);
extern int __vsnprintf_chk(char *, size_t, int, size_t, const char *,
			   va_list);
extern int __snprintf_chk(char *, size_t, int, size_t, const char *, ...);
extern int __sprintf_chk(char *, int, size_t, const char *, ...);
extern int dprintf(int, const char *, ...);
extern int renameat(int, const char *, int, const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MB_CUR_MAX	(__ctype_get_mb_cur_max())
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
#define RAND_MAX	2147483647

struct drand48_data {
    unsigned short __x[3];
    unsigned short __old_x[3];
    unsigned short __c;
    unsigned short __init;
    unsigned long long int __a;
};
typedef int (*__compar_fn_t) (const void *, const void *);
struct random_data {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
};

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;
extern int initstate_r(unsigned int, char *, size_t, struct random_data *);
extern int srandom_r(unsigned int, struct random_data *);
extern double __strtod_internal(const char *, char **, int);
extern float __strtof_internal(const char *, char **, int);
extern long int __strtol_internal(const char *, char **, int, int);
extern long double __strtold_internal(const char *, char **, int);
extern long long int __strtoll_internal(const char *, char **, int, int);
extern unsigned long int __strtoul_internal(const char *, char **, int,
					    int);
extern unsigned long long int __strtoull_internal(const char *, char **,
						  int, int);
extern long int a64l(const char *);
extern void abort(void);
extern int abs(int);
extern double atof(const char *);
extern int atoi(const char *);
extern long int atol(const char *);
extern long long int atoll(const char *);
extern void *bsearch(const void *, const void *, size_t, size_t,
		     __compar_fn_t);
extern div_t div(int, int);
extern double drand48(void);
extern int drand48_r(struct drand48_data *, double *);
extern char *ecvt(double, int, int *, int *);
extern double erand48(unsigned short);
extern void exit(int);
extern char *fcvt(double, int, int *, int *);
extern char *gcvt(double, int, char *);
extern char *getenv(const char *);
extern int getsubopt(char **, char *const *, char **);
extern int grantpt(int);
extern long int jrand48(unsigned short);
extern char *l64a(long int);
extern long int labs(long int);
extern void lcong48(unsigned short);
extern ldiv_t ldiv(long int, long int);
extern long long int llabs(long long int);
extern lldiv_t lldiv(long long int, long long int);
extern long int lrand48(void);
extern int lrand48_r(struct drand48_data *, long int *);
extern int mblen(const char *, size_t);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern int mbtowc(wchar_t *, const char *, size_t);
extern char *mktemp(char *);
extern long int mrand48(void);
extern int mrand48_r(struct drand48_data *, long int *);
extern long int nrand48(unsigned short);
extern char *ptsname(int);
extern int putenv(char *);
extern void qsort(void *, size_t, size_t, const __compar_fn_t);
extern int rand(void);
extern int rand_r(unsigned int *);
extern unsigned short *seed48(unsigned short);
extern void srand48(long int);
extern int unlockpt(int);
extern size_t wcstombs(char *, const wchar_t *, size_t);
extern int wctomb(char *, wchar_t);
extern int system(const char *);
extern void *calloc(size_t, size_t);
extern void free(void *);
extern char *initstate(unsigned int, char *, size_t);
extern void *malloc(size_t);
extern long int random(void);
extern void *realloc(void *, size_t);
extern char *setstate(char *);
extern void srand(unsigned int);
extern void srandom(unsigned int);
extern double strtod(const char *, char **);
extern float strtof(const char *, char **);
extern long int strtol(const char *, char **, int);
extern long double strtold(const char *, char **);
extern long long int strtoll(const char *, char **, int);
extern long long int strtoq(const char *, char **, int);
extern unsigned long int strtoul(const char *, char **, int);
extern unsigned long long int strtoull(const char *, char **, int);
extern unsigned long long int strtouq(const char *, char **, int);
extern void _Exit(int);
extern size_t __ctype_get_mb_cur_max(void);
extern char **environ;
extern int erand48_r(unsigned short, struct drand48_data *, double *);
extern int jrand48_r(unsigned short, struct drand48_data *, long int *);
extern int nrand48_r(unsigned short, struct drand48_data *, long int *);
extern int random_r(struct random_data *, int32_t *);
extern char *realpath(const char *, char *);
extern int seed48_r(unsigned short, struct drand48_data *);
extern int setenv(const char *, const char *, int);
extern int setstate_r(char *, struct random_data *);
extern int srand48_r(long int, struct drand48_data *);
extern int unsetenv(const char *);
extern int getloadavg(double, int);
extern int mkstemp64(char *);
extern int posix_memalign(void **, size_t, size_t);
extern int posix_openpt(int);
extern char *__realpath_chk(const char *, char *, size_t);
extern int __wctomb_chk(char *, wchar_t, size_t);
extern char *mkdtemp(char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>string.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define strerror_r __xpg_strerror_r

extern void *__mempcpy(void *, const void *, size_t);
extern char *__stpcpy(char *, const char *);
extern char *__strtok_r(char *, const char *, char **);
extern void *memchr(const void *, int, size_t);
extern int memcmp(const void *, const void *, size_t);
extern void *memcpy(void *, const void *, size_t);
extern void *memmem(const void *, size_t, const void *, size_t);
extern void *memmove(void *, const void *, size_t);
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(const char *, int);
extern int strcmp(const char *, const char *);
extern int strcoll(const char *, const char *);
extern char *strcpy(char *, const char *);
extern size_t strcspn(const char *, const char *);
extern char *strerror(int);
extern size_t strlen(const char *);
extern char *strncat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t);
extern char *strncpy(char *, const char *, size_t);
extern char *strpbrk(const char *, const char *);
extern char *strrchr(const char *, int);
extern char *strsignal(int);
extern size_t strspn(const char *, const char *);
extern char *strstr(const char *, const char *);
extern char *strtok(char *, const char *);
extern size_t strxfrm(char *, const char *, size_t);
extern void *memccpy(void *, const void *, int, size_t);
extern char *strdup(const char *);
extern char *strndup(const char *, size_t);
extern size_t strnlen(const char *, size_t);
extern char *strsep(char **, const char *);
extern char *strtok_r(char *, const char *, char **);
extern char *strcasestr(const char *, const char *);
extern char *stpcpy(char *, const char *);
extern char *stpncpy(char *, const char *, size_t);
extern void *memrchr(const void *, int, size_t);
extern int __xpg_strerror_r(int, char *, size_t);
extern void *__memmove_chk(void *, const void *, size_t, size_t);
extern char *__strcat_chk(char *, const char *, size_t);
extern char *__strncat_chk(char *, const char *, size_t, size_t);
extern char *__strncpy_chk(char *, const char *, size_t, size_t);
extern char *__stpcpy_chk(char *, const char *, size_t);
extern char *__strcpy_chk(char *, const char *, size_t);
extern void *__memset_chk(void *, int, size_t, size_t);
extern void *__mempcpy_chk(void *, const void *, size_t, size_t);
extern void *__memcpy_chk(void *, const void *, size_t, size_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>strings.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern void bcopy(const void *, void *, size_t);
extern int bcmp(const void *, const void *, size_t);
extern void bzero(void *, size_t);
extern int ffs(int);
extern char *index(const char *, int);
extern char *rindex(const char *, int);
extern int strcasecmp(const char *, const char *);
extern int strncasecmp(const char *, const char *, size_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/epoll.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define EPOLLONESHOT	(1 &lt;&lt; 30)
#define EPOLLET	(1 &lt;&lt; 31)
#define EPOLLIN	1
#define EPOLL_CTL_ADD	1
#define EPOLLMSG	1024
#define EPOLLRDBAND	128
#define EPOLLHUP	16
#define EPOLLPRI	2
#define EPOLL_CTL_DEL	2
#define EPOLLWRNORM	256
#define EPOLL_CTL_MOD	3
#define EPOLLOUT	4
#define EPOLLWRBAND	512
#define EPOLLRDNORM	64
#define EPOLLERR	8

union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
};
typedef union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
struct epoll_event {
    uint32_t events;
    epoll_data_t data;
};
extern int epoll_wait(int, struct epoll_event *, int, int);
extern int epoll_ctl(int, int, int, struct epoll_event *);
extern int epoll_create(int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/file.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define LOCK_SH	1
#define LOCK_EX	2
#define LOCK_NB	4
#define LOCK_UN	8

extern int flock(int, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/inotify.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IN_ACCESS	0x00000001
#define IN_MODIFY	0x00000002
#define IN_ATTRIB	0x00000004
#define IN_CLOSE_WRITE	0x00000008
#define IN_CLOSE_NOWRITE	0x00000010
#define IN_OPEN	0x00000020
#define IN_MOVED_FROM	0x00000040
#define IN_MOVED_TO	0x00000080
#define IN_CREATE	0x00000100
#define IN_DELETE	0x00000200
#define IN_DELETE_SELF	0x00000400
#define IN_MOVE_SELF	0x00000800
#define IN_UNMOUNT	0x00002000
#define IN_Q_OVERFLOW	0x00004000
#define IN_IGNORED	0x00008000
#define IN_ISDIR	0x40000000
#define IN_ONESHOT	0x80000000
#define IN_CLOSE	(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
#define IN_MOVE	(IN_MOVED_FROM | IN_MOVED_TO)
#define IN_ALL_EVENTS	 \
   (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
  IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_CREATE | \
 IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF)

struct inotify_event {
    int wd;
    uint32_t mask;
    uint32_t cookie;
    uint32_t len;
    char name[0];
};
extern int inotify_add_watch(int, const char *, uint32_t);
extern int inotify_init(void);
extern int inotify_rm_watch(int, uint32_t);
</SCREEN>
</SECT2>
<!-- empty header file All/sys/io.h -->
<SECT2>
<TITLE>sys/ioctl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel;
    unsigned short ws_ypixel;
};
extern int ioctl(int, unsigned long int, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/ipc.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define IPC_PRIVATE	((key_t)0)
#define IPC_RMID	0
#define IPC_CREAT	00001000
#define IPC_EXCL	00002000
#define IPC_NOWAIT	00004000
#define IPC_SET	1
#define IPC_STAT	2

extern key_t ftok(const char *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/mman.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MAP_FAILED	((void*)-1)
#define POSIX_MADV_NORMAL	0
#define PROT_NONE	0x0
#define MAP_SHARED	0x01
#define MAP_PRIVATE	0x02
#define PROT_READ	0x1
#define MAP_FIXED	0x10
#define PROT_WRITE	0x2
#define MAP_ANONYMOUS	0x20
#define PROT_EXEC	0x4
#define MREMAP_MAYMOVE	1
#define MS_ASYNC	1
#define POSIX_MADV_RANDOM	1
#define MREMAP_FIXED	2
#define MS_INVALIDATE	2
#define POSIX_MADV_SEQUENTIAL	2
#define POSIX_MADV_WILLNEED	3
#define MS_SYNC	4
#define POSIX_MADV_DONTNEED	4
#define MAP_ANON	MAP_ANONYMOUS

extern void *mremap(void *, size_t, size_t, int, ...);
extern int posix_madvise(void *, size_t, int);
extern int msync(void *, size_t, int);
extern int mlock(const void *, size_t);
extern int mlockall(int);
extern void *mmap(void *, size_t, int, int, int, off_t);
extern int mprotect(void *, size_t, int);
extern int munlock(const void *, size_t);
extern int munlockall(void);
extern int munmap(void *, size_t);
extern void *mmap64(void *, size_t, int, int, int, off64_t);
extern int shm_open(const char *, int, mode_t);
extern int shm_unlink(const char *);
</SCREEN>
</SECT2>
<!-- empty header file All/sys/mmap.h -->
<SECT2>
<TITLE>sys/msg.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define MSG_NOERROR	010000

extern int msgctl(int, int, struct msqid_ds *);
extern int msgget(key_t, int);
extern ssize_t msgrcv(int, void *, size_t, long int, int);
extern int msgsnd(int, const void *, size_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/param.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NOFILE	256
#define MAXPATHLEN	4096
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/poll.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define POLLIN	0x0001		/* There is data to read */
#define POLLPRI	0x0002		/* There is urgent data to read */
#define POLLOUT	0x0004		/* Writing now will not block */
#define POLLERR	0x0008		/* Error condition */
#define POLLHUP	0x0010		/* Hung up */
#define POLLNVAL	0x0020	/* Invalid request: fd not open */
#define POLLRDNORM	0x0040	/* Normal data may be read */
#define POLLRDBAND	0x0080	/* Priority data may be read */
#define POLLWRNORM	0x0100	/* Writing now will not block */
#define POLLWRBAND	0x0200	/* Priority data may be written */

struct pollfd {
    int fd;
    short events;
    short revents;
};
typedef unsigned long int nfds_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/resource.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define RUSAGE_CHILDREN	(-1)
#define RLIM_INFINITY	(~0UL)
#define RLIM_SAVED_CUR	-1
#define RLIM_SAVED_MAX	-1
#define RLIMIT_CPU	0
#define RUSAGE_SELF	0
#define RLIMIT_FSIZE	1
#define RLIMIT_LOCKS	10
#define RLIM_NLIMITS	11
#define RLIMIT_DATA	2
#define RLIMIT_STACK	3
#define RLIMIT_CORE	4
#define RLIMIT_RSS	5
#define RLIMIT_NPROC	6
#define RLIMIT_NOFILE	7
#define RLIMIT_MEMLOCK	8
#define RLIMIT_AS	9

typedef unsigned long int rlim_t;
typedef unsigned long long int rlim64_t;
typedef int __rlimit_resource_t;

struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
struct rlimit64 {
    rlim64_t rlim_cur;
    rlim64_t rlim_max;
};

struct rusage {
    struct timeval ru_utime;
    struct timeval ru_stime;
    long int ru_maxrss;
    long int ru_ixrss;
    long int ru_idrss;
    long int ru_isrss;
    long int ru_minflt;
    long int ru_majflt;
    long int ru_nswap;
    long int ru_inblock;
    long int ru_oublock;
    long int ru_msgsnd;
    long int ru_msgrcv;
    long int ru_nsignals;
    long int ru_nvcsw;
    long int ru_nivcsw;
};

enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
};

#define PRIO_PGRP	PRIO_PGRP
#define PRIO_PROCESS	PRIO_PROCESS
#define PRIO_USER	PRIO_USER

typedef enum __priority_which __priority_which_t;
extern int getpriority(__priority_which_t, id_t);
extern int getrlimit64(id_t, struct rlimit64 *);
extern int setpriority(__priority_which_t, id_t, int);
extern int setrlimit(__rlimit_resource_t, const struct rlimit *);
extern int setrlimit64(__rlimit_resource_t, const struct rlimit64 *);
extern int getrlimit(__rlimit_resource_t, struct rlimit *);
extern int getrusage(int, struct rusage *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/select.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NFDBITS	(8 * sizeof (long))

extern int pselect(int, fd_set *, fd_set *, fd_set *,
		   const struct timespec *, const sigset_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/sem.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SEM_UNDO	0x1000
#define GETPID	11
#define GETVAL	12
#define GETALL	13
#define GETNCNT	14
#define GETZCNT	15
#define SETVAL	16
#define SETALL	17

struct sembuf {
    short sem_num;
    short sem_op;
    short sem_flg;
};
extern int semctl(int, int, int, ...);
extern int semget(key_t, int, int);
extern int semop(int, struct sembuf *, size_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/sendfile.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern ssize_t sendfile(int, int, off_t *, size_t);
extern ssize_t sendfile64(int, int, off64_t *, size_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/shm.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SHM_RDONLY	010000
#define SHM_W	0200
#define SHM_RND	020000
#define SHM_R	0400
#define SHM_REMAP	040000
#define SHM_LOCK	11
#define SHM_UNLOCK	12

extern int __getpagesize(void);
extern void *shmat(int, const void *, int);
extern int shmctl(int, int, struct shmid_ds *);
extern int shmdt(const void *);
extern int shmget(key_t, size_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/socket.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define CMSG_LEN(len)	(CMSG_ALIGN(sizeof(struct cmsghdr))+(len))
#define SCM_RIGHTS	0x01
#define SOL_SOCKET	1
#define SOMAXCONN	128
#define SOL_RAW	255
#define CMSG_ALIGN(len)	\
	(((len)+sizeof(size_t)-1)&amp;(size_t)~(sizeof(size_t)-1))
#define CMSG_DATA(cmsg)	\
	((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
#define CMSG_SPACE(len)	\
	(CMSG_ALIGN(sizeof(struct cmsghdr))+CMSG_ALIGN(len))
#define CMSG_FIRSTHDR(msg)	\
           ((msg)->msg_controllen >= sizeof(struct cmsghdr) ? \
            (struct cmsghdr *)(msg)->msg_control : \
            (struct cmsghdr *)NULL)
#define CMSG_NXTHDR(mhdr,cmsg)	\
        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \
         (((u_char *)(cmsg) + CMSG_ALIGN((cmsg)->cmsg_len) \
                            + CMSG_ALIGN(sizeof(struct cmsghdr)) > \
           (u_char *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
          (struct cmsghdr *)NULL : \
          (struct cmsghdr *)((u_char *)(cmsg) + CMSG_ALIGN((cmsg)->cmsg_len))))

struct linger {
    int l_onoff;
    int l_linger;
};
struct cmsghdr {
    size_t cmsg_len;
    int cmsg_level;
    int cmsg_type;
};
struct iovec {
    void *iov_base;
    size_t iov_len;
};

typedef unsigned short sa_family_t;
typedef unsigned int socklen_t;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};
struct sockaddr_storage {
    sa_family_t ss_family;
    __ss_aligntype __ss_align;
    char __ss_padding[(128 - (2 * sizeof(__ss_aligntype)))];
};

struct msghdr {
    void *msg_name;
    int msg_namelen;
    struct iovec *msg_iov;
    size_t msg_iovlen;
    void *msg_control;
    size_t msg_controllen;
    unsigned int msg_flags;
};

#define AF_UNSPEC	0
#define AF_UNIX	1
#define AF_INET6	10
#define AF_INET	2

#define PF_INET	AF_INET
#define PF_INET6	AF_INET6
#define PF_UNIX	AF_UNIX
#define PF_UNSPEC	AF_UNSPEC

#define SOCK_STREAM	1
#define SOCK_PACKET	10
#define SOCK_DGRAM	2
#define SOCK_RAW	3
#define SOCK_RDM	4
#define SOCK_SEQPACKET	5

#define SO_DEBUG	1
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SO_BSDCOMPAT	14
#define SO_REUSEADDR	2
#define SO_TYPE	3
#define SO_ACCEPTCONN	30
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_KEEPALIVE	9

#define SIOCGIFNAME	0x8910
#define SIOCGIFCONF	0x8912
#define SIOCGIFFLAGS	0x8913
#define SIOCGIFADDR	0x8915
#define SIOCGIFDSTADDR	0x8917
#define SIOCGIFBRDADDR	0x8919
#define SIOCGIFNETMASK	0x891b
#define SIOCGIFMTU	0x8921
#define SIOCGIFHWADDR	0x8927

#define SHUT_RD	0
#define SHUT_WR	1
#define SHUT_RDWR	2

#define MSG_WAITALL	0x100
#define MSG_TRUNC	0x20
#define MSG_NOSIGNAL	0x4000
#define MSG_EOR	0x80
#define MSG_OOB	1
#define MSG_PEEK	2
#define MSG_DONTROUTE	4
#define MSG_CTRUNC	8

extern int bind(int, const struct sockaddr *, socklen_t);
extern int getnameinfo(const struct sockaddr *, socklen_t, char *,
		       socklen_t, char *, socklen_t, unsigned int);
extern int getsockname(int, struct sockaddr *, socklen_t *);
extern int listen(int, int);
extern int setsockopt(int, int, int, const void *, socklen_t);
extern int accept(int, struct sockaddr *, socklen_t *);
extern int connect(int, const struct sockaddr *, socklen_t);
extern ssize_t recv(int, void *, size_t, int);
extern ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *,
			socklen_t *);
extern ssize_t recvmsg(int, struct msghdr *, int);
extern ssize_t send(int, const void *, size_t, int);
extern ssize_t sendmsg(int, const struct msghdr *, int);
extern ssize_t sendto(int, const void *, size_t, int,
		      const struct sockaddr *, socklen_t);
extern int getpeername(int, struct sockaddr *, socklen_t *);
extern int getsockopt(int, int, int, void *, socklen_t *);
extern int shutdown(int, int);
extern int socket(int, int, int);
extern int socketpair(int, int, int, int);
extern int sockatmark(int);
extern ssize_t __recv_chk(int, void *, size_t, size_t, int);
extern ssize_t __recvfrom_chk(int, void *, size_t, size_t, int,
			      struct sockaddr *, socklen_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/stat.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define S_ISBLK(m)	(((m)&amp;S_IFMT)==S_IFBLK)
#define S_ISCHR(m)	(((m)&amp;S_IFMT)==S_IFCHR)
#define S_ISDIR(m)	(((m)&amp;S_IFMT)==S_IFDIR)
#define S_ISFIFO(m)	(((m)&amp;S_IFMT)==S_IFIFO)
#define S_ISLNK(m)	(((m)&amp;S_IFMT)==S_IFLNK)
#define S_ISREG(m)	(((m)&amp;S_IFMT)==S_IFREG)
#define S_ISSOCK(m)	(((m)&amp;S_IFMT)==S_IFSOCK)
#define S_TYPEISMQ(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_TYPEISSEM(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_TYPEISSHM(buf)	((buf)->st_mode - (buf)->st_mode)
#define S_IRWXU	(S_IREAD|S_IWRITE|S_IEXEC)
#define S_IROTH	(S_IRGRP>>3)
#define S_IRGRP	(S_IRUSR>>3)
#define S_IRWXO	(S_IRWXG>>3)
#define S_IRWXG	(S_IRWXU>>3)
#define S_IWOTH	(S_IWGRP>>3)
#define S_IWGRP	(S_IWUSR>>3)
#define S_IXOTH	(S_IXGRP>>3)
#define S_IXGRP	(S_IXUSR>>3)
#define S_ISVTX	01000
#define S_IXUSR	0x0040
#define S_IWUSR	0x0080
#define S_IRUSR	0x0100
#define S_ISGID	0x0400
#define S_ISUID	0x0800
#define S_IFIFO	0x1000
#define S_IFCHR	0x2000
#define S_IFDIR	0x4000
#define S_IFBLK	0x6000
#define S_IFREG	0x8000
#define S_IFLNK	0xa000
#define S_IFSOCK	0xc000
#define S_IFMT	0xf000
#define st_atime	st_atim.tv_sec
#define st_ctime	st_ctim.tv_sec
#define st_mtime	st_mtim.tv_sec
#define S_IREAD	S_IRUSR
#define S_IWRITE	S_IWUSR
#define S_IEXEC	S_IXUSR

extern int __fxstat(int, int, struct stat *);
extern int __fxstat64(int, int, struct stat64 *);
extern int __lxstat(int, const char *, struct stat *);
extern int __lxstat64(int, const char *, struct stat64 *);
extern int __xmknod(int, const char *, mode_t, dev_t *);
extern int __xstat(int, const char *, struct stat *);
extern int __xstat64(int, const char *, struct stat64 *);
extern int mkfifo(const char *, mode_t);
extern int chmod(const char *, mode_t);
extern int fchmod(int, mode_t);
extern mode_t umask(mode_t);
extern int mkfifoat(int, const char *, mode_t);
extern int mkdirat(int, const char *, mode_t);
extern int fchmodat(int, const char *, mode_t, int);
extern int __fxstatat(int, int, const char *, struct stat *, int);
extern int __fxstatat64(int, int, const char *, struct stat64 *, int);
extern int __xmknodat(int, int, const char *, mode_t, dev_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/statfs.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NFS_SUPER_MAGIC	0x6969

extern int fstatfs64(int, struct statfs64 *);
extern int statfs64(const char *, struct statfs64 *);
extern int fstatfs(int, struct statfs *);
extern int statfs(const char *, struct statfs *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/statvfs.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int fstatvfs(int, struct statvfs *);
extern int fstatvfs64(int, struct statvfs64 *);
extern int statvfs(const char *, struct statvfs *);
extern int statvfs64(const char *, struct statvfs64 *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/time.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ITIMER_REAL	0
#define ITIMER_VIRTUAL	1
#define ITIMER_PROF	2

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef int __itimer_which_t;

struct timespec {
    time_t tv_sec;
    long int tv_nsec;
};

struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct itimerval {
    struct timeval it_interval;
    struct timeval it_value;
};
extern int getitimer(__itimer_which_t, struct itimerval *);
extern int setitimer(__itimer_which_t, const struct itimerval *,
		     struct itimerval *);
extern int adjtime(const struct timeval *, struct timeval *);
extern int gettimeofday(struct timeval *, struct timezone *);
extern int utimes(const char *, const struct timeval *);
extern int futimesat(int, const char *, const struct timeval);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/timeb.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
};
extern int ftime(struct timeb *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/times.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct tms {
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};
extern clock_t times(struct tms *);
</SCREEN>
</SECT2>
<!-- empty header file All/sys/timex.h -->
<SECT2>
<TITLE>sys/types.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#define FD_SETSIZE	1024
#define FD_ZERO(fdsetp)	bzero(fdsetp, sizeof(*(fdsetp)))
#define FD_ISSET(d,set)	\
	((set)->fds_bits[((d)/(8*sizeof(long)))]&amp;(1&lt;&lt;((d)%(8*sizeof(long)))))
#define FD_CLR(d,set)	\
	((set)->fds_bits[((d)/(8*sizeof(long)))]&amp;=~(1&lt;&lt;((d)%(8*sizeof(long)))))
#define FD_SET(d,set)	\
	((set)->fds_bits[((d)/(8*sizeof(long)))]|=(1&lt;&lt;((d)%(8*sizeof(long)))))

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long int u_int64_t;
typedef unsigned int uid_t;
typedef int pid_t;
typedef long int off_t;
typedef int key_t;
typedef long int suseconds_t;
typedef unsigned int u_int;
typedef struct {
    int __val[2];
} fsid_t;
typedef unsigned int useconds_t;
typedef long int blksize_t;
typedef long int fd_mask;
typedef void *timer_t;
typedef int clockid_t;

typedef unsigned int id_t;

typedef unsigned long long int ino64_t;
typedef long long int loff_t;
typedef long int blkcnt_t;
typedef unsigned long int fsblkcnt_t;
typedef unsigned long int fsfilcnt_t;
typedef long long int blkcnt64_t;
typedef unsigned long long int fsblkcnt64_t;
typedef unsigned long long int fsfilcnt64_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned long int u_long;

typedef unsigned long int ino_t;
typedef unsigned int gid_t;
typedef unsigned long long int dev_t;
typedef unsigned int mode_t;
typedef unsigned long int nlink_t;
typedef char *caddr_t;

typedef struct {
    unsigned long int fds_bits[__FDSET_LONGS];
} fd_set;

typedef long int clock_t;
typedef long int time_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/uio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern ssize_t readv(int, const struct iovec *, int);
extern ssize_t writev(int, const struct iovec *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/un.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UNIX_PATH_MAX	108

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[UNIX_PATH_MAX];
};
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/utsname.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SYS_NMLN	65

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};
extern int uname(struct utsname *);
</SCREEN>
</SECT2>
<!-- empty header file All/sys/vfs.h -->
<SECT2>
<TITLE>sys/wait.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define WIFSIGNALED(status)	(!WIFSTOPPED(status) &amp;&amp; !WIFEXITED(status))
#define WIFSTOPPED(status)	(((status) &amp; 0xff) == 0x7f)
#define WEXITSTATUS(status)	(((status) &amp; 0xff00) >> 8)
#define WTERMSIG(status)	((status) &amp; 0x7f)
#define WCOREDUMP(status)	((status) &amp; 0x80)
#define WIFEXITED(status)	(WTERMSIG(status) == 0)
#define WNOHANG	0x00000001
#define WUNTRACED	0x00000002
#define WCOREFLAG	0x80
#define WSTOPSIG(status)	WEXITSTATUS(status)

typedef enum {
    P_ALL,
    P_PID,
    P_PGID
} idtype_t;
extern int waitid(idtype_t, id_t, siginfo_t *, int);
extern pid_t wait(int *);
extern pid_t waitpid(pid_t, int *, int);
extern pid_t wait4(pid_t, int *, int, struct rusage *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>syslog.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define LOG_MAKEPRI(fac, pri)	(((fac) &lt;&lt; 3) | (pri))
#define LOG_PRI(p)	((p) &amp; LOG_PRIMASK)	/* extract priority */
#define LOG_EMERG	0	/* system is unusable */
#define LOG_PRIMASK	0x07	/* mask to extract priority part */
#define LOG_ALERT	1	/* action must be taken immediately */
#define LOG_CRIT	2	/* critical conditions */
#define LOG_ERR	3		/* error conditions */
#define LOG_WARNING	4	/* warning conditions */
#define LOG_NOTICE	5	/* normal but significant condition */
#define LOG_INFO	6	/* informational */
#define LOG_DEBUG	7	/* debug-level messages */

#define LOG_FAC(p)	(((p) &amp; LOG_FACMASK) >> 3)	/* facility of pri */
#define LOG_KERN	(0&lt;&lt;3)	/* kernel messages */
#define LOG_AUTHPRIV	(10&lt;&lt;3)	/* security/authorization messages (private) */
#define LOG_FTP	(11&lt;&lt;3)		/* ftp daemon */
#define LOG_USER	(1&lt;&lt;3)	/* random user-level messages */
#define LOG_MAIL	(2&lt;&lt;3)	/* mail system */
#define LOG_DAEMON	(3&lt;&lt;3)	/* system daemons */
#define LOG_AUTH	(4&lt;&lt;3)	/* security/authorization messages */
#define LOG_SYSLOG	(5&lt;&lt;3)	/* messages generated internally by syslogd */
#define LOG_LPR	(6&lt;&lt;3)		/* line printer subsystem */
#define LOG_NEWS	(7&lt;&lt;3)	/* network news subsystem */
#define LOG_UUCP	(8&lt;&lt;3)	/* UUCP subsystem */
#define LOG_CRON	(9&lt;&lt;3)	/* clock daemon */
#define LOG_FACMASK	0x03f8	/* mask to extract facility part */

#define LOG_LOCAL0	(16&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL1	(17&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL2	(18&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL3	(19&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL4	(20&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL5	(21&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL6	(22&lt;&lt;3)	/* reserved for local use */
#define LOG_LOCAL7	(23&lt;&lt;3)	/* reserved for local use */

#define LOG_UPTO(pri)	((1 &lt;&lt; ((pri)+1)) - 1)	/* all priorities through pri */
#define LOG_MASK(pri)	(1 &lt;&lt; (pri))	/* mask for one priority */

#define LOG_PID	0x01		/* log the pid with each message */
#define LOG_CONS	0x02	/* log on the console if errors in sending */
#define LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
#define LOG_NDELAY	0x08	/* don't delay open */
#define LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
#define LOG_PERROR	0x20	/* log to stderr as well */

extern void closelog(void);
extern void openlog(const char *, int, int);
extern int setlogmask(int);
extern void syslog(int, const char *, ...);
extern void vsyslog(int, const char *, va_list);
extern void __syslog_chk(int, int, const char *, ...);
extern void __vsyslog_chk(int, int, const char *, va_list);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>tar.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define REGTYPE	'0'
#define LNKTYPE	'1'
#define SYMTYPE	'2'
#define CHRTYPE	'3'
#define BLKTYPE	'4'
#define DIRTYPE	'5'
#define FIFOTYPE	'6'
#define CONTTYPE	'7'
#define AREGTYPE	'\0'
#define TVERSION	"00"
#define TOEXEC	00001
#define TOWRITE	00002
#define TOREAD	00004
#define TGEXEC	00010
#define TGWRITE	00020
#define TGREAD	00040
#define TUEXEC	00100
#define TUWRITE	00200
#define TUREAD	00400
#define TSVTX	01000
#define TSGID	02000
#define TSUID	04000
#define TVERSLEN	2
#define TMAGLEN	6
#define TMAGIC	"ustar"
</SCREEN>
</SECT2>
<SECT2>
<TITLE>termios.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define TCIFLUSH	0
#define TCOOFF	0
#define TCSANOW	0
#define BS0	0000000
#define CR0	0000000
#define FF0	0000000
#define NL0	0000000
#define TAB0	0000000
#define VT0	0000000
#define OPOST	0000001
#define OCRNL	0000010
#define ONOCR	0000020
#define ONLRET	0000040
#define OFILL	0000100
#define OFDEL	0000200
#define NL1	0000400
#define TCOFLUSH	1
#define TCOON	1
#define TCSADRAIN	1
#define TCIOFF	2
#define TCIOFLUSH	2
#define TCSAFLUSH	2
#define TCION	3

typedef unsigned int speed_t;
typedef unsigned char cc_t;
typedef unsigned int tcflag_t;

#define NCCS	32

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[NCCS];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

#define VINTR	0
#define VQUIT	1
#define VLNEXT	15
#define VERASE	2
#define VKILL	3
#define VEOF	4

#define IGNBRK	0000001
#define BRKINT	0000002
#define IGNPAR	0000004
#define PARMRK	0000010
#define INPCK	0000020
#define ISTRIP	0000040
#define INLCR	0000100
#define IGNCR	0000200
#define ICRNL	0000400
#define IXANY	0004000
#define IMAXBEL	0020000

#define CS5	0000000

#define ECHO	0000010

#define B0	0000000
#define B50	0000001
#define B75	0000002
#define B110	0000003
#define B134	0000004
#define B150	0000005
#define B200	0000006
#define B300	0000007
#define B600	0000010
#define B1200	0000011
#define B1800	0000012
#define B2400	0000013
#define B4800	0000014
#define B9600	0000015
#define B19200	0000016
#define B38400	0000017

extern speed_t cfgetispeed(const struct termios *);
extern speed_t cfgetospeed(const struct termios *);
extern void cfmakeraw(struct termios *);
extern int cfsetispeed(struct termios *, speed_t);
extern int cfsetospeed(struct termios *, speed_t);
extern int cfsetspeed(struct termios *, speed_t);
extern int tcflow(int, int);
extern int tcflush(int, int);
extern pid_t tcgetsid(int);
extern int tcsendbreak(int, int);
extern int tcsetattr(int, int, const struct termios *);
extern int tcdrain(int);
extern int tcgetattr(int, struct termios *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>time.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define CLK_TCK	((clock_t)__sysconf(2))
#define CLOCK_REALTIME	0
#define TIMER_ABSTIME	1
#define CLOCKS_PER_SEC	1000000l

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    char *tm_zone;
};
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};

extern int __daylight;
extern long int __timezone;
extern char *__tzname[];
extern char *asctime(const struct tm *);
extern clock_t clock(void);
extern char *ctime(const time_t *);
extern char *ctime_r(const time_t *, char *);
extern double difftime(time_t, time_t);
extern struct tm *getdate(const char *);
extern int getdate_err;
extern struct tm *gmtime(const time_t *);
extern struct tm *localtime(const time_t *);
extern time_t mktime(struct tm *);
extern int stime(const time_t *);
extern size_t strftime(char *, size_t, const char *, const struct tm *);
extern char *strptime(const char *, const char *, struct tm *);
extern time_t time(time_t *);
extern int nanosleep(const struct timespec *, struct timespec *);
extern int daylight;
extern long int timezone;
extern char *tzname[];
extern void tzset(void);
extern char *asctime_r(const struct tm *, char *);
extern struct tm *gmtime_r(const time_t *, struct tm *);
extern struct tm *localtime_r(const time_t *, struct tm *);
extern int clock_getcpuclockid(pid_t, clockid_t *);
extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_nanosleep(clockid_t, int, const struct timespec *,
			   struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int timer_create(clockid_t, struct sigevent *, timer_t *);
extern int timer_delete(timer_t);
extern int timer_getoverrun(timer_t);
extern int timer_gettime(timer_t, struct itimerspec *);
extern int timer_settime(timer_t, int, const struct itimerspec *,
			 struct itimerspec *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ucontext.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int getcontext(ucontext_t *);
extern void makecontext(ucontext_t *, void (*)(void)
			, int, ...);
extern int setcontext(const struct ucontext *);
extern int swapcontext(ucontext_t *, const struct ucontext *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ulimit.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UL_GETFSIZE	1
#define UL_SETFSIZE	2

extern long int ulimit(int, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define SEEK_SET	0
#define STDIN_FILENO	0
#define SEEK_CUR	1
#define STDOUT_FILENO	1
#define SEEK_END	2
#define STDERR_FILENO	2

typedef long long int off64_t;

#define F_OK	0
#define X_OK	1
#define W_OK	2
#define R_OK	4

#define _POSIX_VDISABLE	'\0'
#define _POSIX_CHOWN_RESTRICTED	1
#define _POSIX_JOB_CONTROL	1
#define _POSIX_NO_TRUNC	1
#define _POSIX_SHELL	1
#define _POSIX_FSYNC	200112
#define _POSIX_MAPPED_FILES	200112
#define _POSIX_MEMLOCK	200112
#define _POSIX_MEMLOCK_RANGE	200112
#define _POSIX_MEMORY_PROTECTION	200112
#define _POSIX_SEMAPHORES	200112
#define _POSIX_SHARED_MEMORY_OBJECTS	200112
#define _POSIX_TIMERS	200112
#define _POSIX2_C_BIND	200112L
#define _POSIX2_VERSION	200112L
#define _POSIX_THREADS	200112L
#define _POSIX_VERSION	200112L

#define _PC_LINK_MAX	0
#define _PC_MAX_CANON	1
#define _PC_ASYNC_IO	10
#define _PC_PRIO_IO	11
#define _PC_FILESIZEBITS	13
#define _PC_REC_INCR_XFER_SIZE	14
#define _PC_REC_MIN_XFER_SIZE	16
#define _PC_REC_XFER_ALIGN	17
#define _PC_ALLOC_SIZE_MIN	18
#define _PC_MAX_INPUT	2
#define _PC_2_SYMLINKS	20
#define _PC_NAME_MAX	3
#define _PC_PATH_MAX	4
#define _PC_PIPE_BUF	5
#define _PC_CHOWN_RESTRICTED	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_SYNC_IO	9

#define _SC_ARG_MAX	0
#define _SC_CHILD_MAX	1
#define _SC_PRIORITY_SCHEDULING	10
#define _SC_XOPEN_XPG4	100
#define _SC_CHAR_BIT	101
#define _SC_CHAR_MAX	102
#define _SC_CHAR_MIN	103
#define _SC_INT_MAX	104
#define _SC_INT_MIN	105
#define _SC_LONG_BIT	106
#define _SC_WORD_BIT	107
#define _SC_MB_LEN_MAX	108
#define _SC_NZERO	109
#define _SC_TIMERS	11
#define _SC_SSIZE_MAX	110
#define _SC_SCHAR_MAX	111
#define _SC_SCHAR_MIN	112
#define _SC_SHRT_MAX	113
#define _SC_SHRT_MIN	114
#define _SC_UCHAR_MAX	115
#define _SC_UINT_MAX	116
#define _SC_ULONG_MAX	117
#define _SC_USHRT_MAX	118
#define _SC_NL_ARGMAX	119
#define _SC_ASYNCHRONOUS_IO	12
#define _SC_NL_LANGMAX	120
#define _SC_NL_MSGMAX	121
#define _SC_NL_NMAX	122
#define _SC_NL_SETMAX	123
#define _SC_NL_TEXTMAX	124
#define _SC_XBS5_ILP32_OFF32	125
#define _SC_XBS5_ILP32_OFFBIG	126
#define _SC_XBS5_LP64_OFF64	127
#define _SC_XBS5_LPBIG_OFFBIG	128
#define _SC_XOPEN_LEGACY	129
#define _SC_PRIORITIZED_IO	13
#define _SC_XOPEN_REALTIME	130
#define _SC_XOPEN_REALTIME_THREADS	131
#define _SC_ADVISORY_INFO	132
#define _SC_BARRIERS	133
#define _SC_BASE	134
#define _SC_C_LANG_SUPPORT	135
#define _SC_C_LANG_SUPPORT_R	136
#define _SC_CLOCK_SELECTION	137
#define _SC_CPUTIME	138
#define _SC_THREAD_CPUTIME	139
#define _SC_SYNCHRONIZED_IO	14
#define _SC_DEVICE_IO	140
#define _SC_DEVICE_SPECIFIC	141
#define _SC_DEVICE_SPECIFIC_R	142
#define _SC_FD_MGMT	143
#define _SC_FIFO	144
#define _SC_PIPE	145
#define _SC_FILE_ATTRIBUTES	146
#define _SC_FILE_LOCKING	147
#define _SC_FILE_SYSTEM	148
#define _SC_MONOTONIC_CLOCK	149
#define _SC_FSYNC	15
#define _SC_MULTI_PROCESS	150
#define _SC_SINGLE_PROCESS	151
#define _SC_NETWORKING	152
#define _SC_READER_WRITER_LOCKS	153
#define _SC_SPIN_LOCKS	154
#define _SC_REGEXP	155
#define _SC_REGEX_VERSION	156
#define _SC_SHELL	157
#define _SC_SIGNALS	158
#define _SC_SPAWN	159
#define _SC_MAPPED_FILES	16
#define _SC_SPORADIC_SERVER	160
#define _SC_THREAD_SPORADIC_SERVER	161
#define _SC_SYSTEM_DATABASE	162
#define _SC_SYSTEM_DATABASE_R	163
#define _SC_TIMEOUTS	164
#define _SC_TYPED_MEMORY_OBJECTS	165
#define _SC_USER_GROUPS	166
#define _SC_USER_GROUPS_R	167
#define _SC_2_PBS	168
#define _SC_2_PBS_ACCOUNTING	169
#define _SC_MEMLOCK	17
#define _SC_2_PBS_LOCATE	170
#define _SC_2_PBS_MESSAGE	171
#define _SC_2_PBS_TRACK	172
#define _SC_SYMLOOP_MAX	173
#define _SC_STREAMS	174
#define _SC_2_PBS_CHECKPOINT	175
#define _SC_V6_ILP32_OFF32	176
#define _SC_V6_ILP32_OFFBIG	177
#define _SC_V6_LP64_OFF64	178
#define _SC_V6_LPBIG_OFFBIG	179
#define _SC_MEMLOCK_RANGE	18
#define _SC_HOST_NAME_MAX	180
#define _SC_TRACE	181
#define _SC_TRACE_EVENT_FILTER	182
#define _SC_TRACE_INHERIT	183
#define _SC_TRACE_LOG	184
#define _SC_LEVEL1_ICACHE_SIZE	185
#define _SC_LEVEL1_ICACHE_ASSOC	186
#define _SC_LEVEL1_ICACHE_LINESIZE	187
#define _SC_LEVEL1_DCACHE_SIZE	188
#define _SC_LEVEL1_DCACHE_ASSOC	189
#define _SC_MEMORY_PROTECTION	19
#define _SC_LEVEL1_DCACHE_LINESIZE	190
#define _SC_LEVEL2_CACHE_SIZE	191
#define _SC_LEVEL2_CACHE_ASSOC	192
#define _SC_LEVEL2_CACHE_LINESIZE	193
#define _SC_LEVEL3_CACHE_SIZE	194
#define _SC_LEVEL3_CACHE_ASSOC	195
#define _SC_LEVEL3_CACHE_LINESIZE	196
#define _SC_LEVEL4_CACHE_SIZE	197
#define _SC_LEVEL4_CACHE_ASSOC	198
#define _SC_LEVEL4_CACHE_LINESIZE	199
#define _SC_CLK_TCK	2
#define _SC_MESSAGE_PASSING	20
#define _SC_SEMAPHORES	21
#define _SC_SHARED_MEMORY_OBJECTS	22
#define _SC_AIO_LISTIO_MAX	23
#define _SC_IPV6	235
#define _SC_RAW_SOCKETS	236
#define _SC_AIO_MAX	24
#define _SC_AIO_PRIO_DELTA_MAX	25
#define _SC_DELAYTIMER_MAX	26
#define _SC_MQ_OPEN_MAX	27
#define _SC_MQ_PRIO_MAX	28
#define _SC_VERSION	29
#define _SC_NGROUPS_MAX	3
#define _SC_PAGESIZE	30
#define _SC_PAGE_SIZE	30
#define _SC_RTSIG_MAX	31
#define _SC_SEM_NSEMS_MAX	32
#define _SC_SEM_VALUE_MAX	33
#define _SC_SIGQUEUE_MAX	34
#define _SC_TIMER_MAX	35
#define _SC_BC_BASE_MAX	36
#define _SC_BC_DIM_MAX	37
#define _SC_BC_SCALE_MAX	38
#define _SC_BC_STRING_MAX	39
#define _SC_OPEN_MAX	4
#define _SC_COLL_WEIGHTS_MAX	40
#define _SC_EQUIV_CLASS_MAX	41
#define _SC_EXPR_NEST_MAX	42
#define _SC_LINE_MAX	43
#define _SC_RE_DUP_MAX	44
#define _SC_CHARCLASS_NAME_MAX	45
#define _SC_2_VERSION	46
#define _SC_2_C_BIND	47
#define _SC_2_C_DEV	48
#define _SC_2_FORT_DEV	49
#define _SC_STREAM_MAX	5
#define _SC_2_FORT_RUN	50
#define _SC_2_SW_DEV	51
#define _SC_2_LOCALEDEF	52
#define _SC_PII	53
#define _SC_PII_XTI	54
#define _SC_PII_SOCKET	55
#define _SC_PII_INTERNET	56
#define _SC_PII_OSI	57
#define _SC_POLL	58
#define _SC_SELECT	59
#define _SC_TZNAME_MAX	6
#define _SC_IOV_MAX	60
#define _SC_UIO_MAXIOV	60
#define _SC_PII_INTERNET_STREAM	61
#define _SC_PII_INTERNET_DGRAM	62
#define _SC_PII_OSI_COTS	63
#define _SC_PII_OSI_CLTS	64
#define _SC_PII_OSI_M	65
#define _SC_T_IOV_MAX	66
#define _SC_THREADS	67
#define _SC_THREAD_SAFE_FUNCTIONS	68
#define _SC_GETGR_R_SIZE_MAX	69
#define _SC_JOB_CONTROL	7
#define _SC_GETPW_R_SIZE_MAX	70
#define _SC_LOGIN_NAME_MAX	71
#define _SC_TTY_NAME_MAX	72
#define _SC_THREAD_DESTRUCTOR_ITERATIONS	73
#define _SC_THREAD_KEYS_MAX	74
#define _SC_THREAD_STACK_MIN	75
#define _SC_THREAD_THREADS_MAX	76
#define _SC_THREAD_ATTR_STACKADDR	77
#define _SC_THREAD_ATTR_STACKSIZE	78
#define _SC_THREAD_PRIORITY_SCHEDULING	79
#define _SC_SAVED_IDS	8
#define _SC_THREAD_PRIO_INHERIT	80
#define _SC_THREAD_PRIO_PROTECT	81
#define _SC_THREAD_PROCESS_SHARED	82
#define _SC_NPROCESSORS_CONF	83
#define _SC_NPROCESSORS_ONLN	84
#define _SC_PHYS_PAGES	85
#define _SC_AVPHYS_PAGES	86
#define _SC_ATEXIT_MAX	87
#define _SC_PASS_MAX	88
#define _SC_XOPEN_VERSION	89
#define _SC_REALTIME_SIGNALS	9
#define _SC_XOPEN_XCU_VERSION	90
#define _SC_XOPEN_UNIX	91
#define _SC_XOPEN_CRYPT	92
#define _SC_XOPEN_ENH_I18N	93
#define _SC_XOPEN_SHM	94
#define _SC_2_CHAR_TERM	95
#define _SC_2_C_VERSION	96
#define _SC_2_UPE	97
#define _SC_XOPEN_XPG2	98
#define _SC_XOPEN_XPG3	99

#define _CS_PATH	0
#define _POSIX_REGEXP	1
#define _CS_XBS5_ILP32_OFF32_CFLAGS	1100
#define _CS_XBS5_ILP32_OFF32_LDFLAGS	1101
#define _CS_XBS5_ILP32_OFF32_LIBS	1102
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS	1103
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS	1104
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS	1105
#define _CS_XBS5_ILP32_OFFBIG_LIBS	1106
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS	1107
#define _CS_XBS5_LP64_OFF64_CFLAGS	1108
#define _CS_XBS5_LP64_OFF64_LDFLAGS	1109
#define _CS_XBS5_LP64_OFF64_LIBS	1110
#define _CS_XBS5_LP64_OFF64_LINTFLAGS	1111
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS	1112
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS	1113
#define _CS_XBS5_LPBIG_OFFBIG_LIBS	1114
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS	1115

#define _XOPEN_XPG4	1
#define _XOPEN_VERSION	500

#define F_ULOCK	0
#define F_LOCK	1
#define F_TLOCK	2
#define F_TEST	3

extern int getdtablesize(void);
extern char **__environ;
extern pid_t __getpgid(pid_t);
extern void _exit(int);
extern int acct(const char *);
extern unsigned int alarm(unsigned int);
extern int chown(const char *, uid_t, gid_t);
extern int chroot(const char *);
extern size_t confstr(int, char *, size_t);
extern char *ctermid(char *);
extern char *cuserid(char *);
extern int daemon(int, int);
extern int execl(const char *, const char *, ...);
extern int execle(const char *, const char *, ...);
extern int execlp(const char *, const char *, ...);
extern int execv(const char *, char *const);
extern int execvp(const char *, char *const);
extern int fdatasync(int);
extern int ftruncate64(int, off64_t);
extern int getdomainname(char *, size_t);
extern long int gethostid(void);
extern char *getlogin(void);
extern int getlogin_r(char *, size_t);
extern int getopt(int, char *const, const char *);
extern pid_t getpgrp(void);
extern pid_t getsid(pid_t);
extern char *getwd(char *);
extern int lockf(int, int, off_t);
extern int lockf64(int, int, off64_t);
extern int mkstemp(char *);
extern int nice(int);
extern char *optarg;
extern int opterr;
extern int optind;
extern int optopt;
extern int rename(const char *, const char *);
extern int setegid(gid_t);
extern int seteuid(uid_t);
extern int sethostname(const char *, size_t);
extern int setpgrp(void);
extern void swab(const void *, void *, ssize_t);
extern void sync(void);
extern pid_t tcgetpgrp(int);
extern int tcsetpgrp(int, pid_t);
extern int truncate(const char *, off_t);
extern int truncate64(const char *, off64_t);
extern char *ttyname(int);
extern unsigned int ualarm(useconds_t, useconds_t);
extern int usleep(useconds_t);
extern int close(int);
extern int fsync(int);
extern off_t lseek(int, off_t, int);
extern int pause(void);
extern ssize_t read(int, void *, size_t);
extern ssize_t write(int, const void *, size_t);
extern char *crypt(const char *, const char *);
extern void encrypt(char *, int);
extern void setkey(const char *);
extern int access(const char *, int);
extern int brk(void *);
extern int chdir(const char *);
extern int dup(int);
extern int dup2(int, int);
extern int execve(const char *, char *const, char *const);
extern int fchdir(int);
extern int fchown(int, uid_t, gid_t);
extern pid_t fork(void);
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int, gid_t);
extern int gethostname(char *, size_t);
extern pid_t getpgid(pid_t);
extern pid_t getpid(void);
extern uid_t getuid(void);
extern int lchown(const char *, uid_t, gid_t);
extern int link(const char *, const char *);
extern int mkdir(const char *, mode_t);
extern long int pathconf(const char *, int);
extern int pipe(int);
extern ssize_t readlink(const char *, char *, size_t);
extern int rmdir(const char *);
extern void *sbrk(intptr_t);
extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
extern int setgid(gid_t);
extern int setpgid(pid_t, pid_t);
extern int setregid(gid_t, gid_t);
extern int setreuid(uid_t, uid_t);
extern pid_t setsid(void);
extern int setuid(uid_t);
extern unsigned int sleep(unsigned int);
extern int symlink(const char *, const char *);
extern long int sysconf(int);
extern int unlink(const char *);
extern pid_t vfork(void);
extern ssize_t pread(int, void *, size_t, off_t);
extern ssize_t pwrite(int, const void *, size_t, off_t);
extern char **_environ;
extern long int fpathconf(int, int);
extern int ftruncate(int, off_t);
extern char *getcwd(char *, size_t);
extern int getpagesize(void);
extern pid_t getppid(void);
extern int isatty(int);
extern loff_t lseek64(int, loff_t, int);
extern ssize_t pread64(int, void *, size_t, off64_t);
extern ssize_t pwrite64(int, const void *, size_t, off64_t);
extern int ttyname_r(int, char *, size_t);
extern char *__getcwd_chk(char *, size_t, size_t);
extern ssize_t __read_chk(int, void *, size_t, size_t);
extern ssize_t __readlink_chk(const char *, char *, size_t, size_t);
extern ssize_t readlinkat(int, const char *, char *, size_t);
extern int linkat(int, const char *, int, const char *, int);
extern int unlinkat(int, const char *, int);
extern int fchownat(int, const char *, uid_t, gid_t, int);
extern int symlinkat(const char *, int, const char *);
extern int faccessat(int, const char *, int, int);
extern int fexecve(int, char *const, char *const);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utime.h</TITLE>
<PARA>
</PARA>
<SCREEN>

struct utimbuf {
    time_t actime;
    time_t modtime;
};
extern int utime(const char *, const struct utimbuf *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define UT_HOSTSIZE	256
#define UT_LINESIZE	32
#define UT_NAMESIZE	32
#define ut_addr	ut_addr_v6[0]
#define ut_time	ut_tv.tv_sec
#define ut_name	ut_user		/* Backwards compatability */

struct exit_status {
    short e_termination;
    short e_exit;
};

#define EMPTY	0		/* No valid user accounting information. */
#define RUN_LVL	1		/* The system's runlevel. */
#define BOOT_TIME	2	/* Time of system boot. */
#define NEW_TIME	3	/* Time after system clock changed. */
#define OLD_TIME	4	/* Time when system clock changed. */
#define INIT_PROCESS	5	/* Process spawned by the init process. */
#define LOGIN_PROCESS	6	/* Session leader of a logged in user. */
#define USER_PROCESS	7	/* Normal process. */
#define DEAD_PROCESS	8	/* Terminated process. */
#define ACCOUNTING	9

extern void endutent(void);
extern struct utmp *getutent(void);
extern void setutent(void);
extern int getutent_r(struct utmp *, struct utmp **);
extern int utmpname(const char *);
extern int login_tty(int);
extern void login(const struct utmp *);
extern int logout(const char *);
extern void logwtmp(const char *, const char *, const char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utmpx.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern void endutxent(void);
extern struct utmpx *getutxent(void);
extern struct utmpx *getutxid(const struct utmpx *);
extern struct utmpx *getutxline(const struct utmpx *);
extern struct utmpx *pututxline(const struct utmpx *);
extern void setutxent(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wchar.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define WEOF	(0xffffffffu)
#define WCHAR_MAX	0x7FFFFFFF
#define WCHAR_MIN	0x80000000

extern wchar_t *fgetws_unlocked(wchar_t *, int, FILE *);
extern wint_t fputwc_unlocked(wchar_t, FILE *);
extern int fputws_unlocked(const wchar_t *, FILE *);
extern wint_t getwchar_unlocked(void);
extern wint_t putwc_unlocked(wchar_t, FILE *);
extern wint_t putwchar_unlocked(wchar_t);
extern double __wcstod_internal(const wchar_t *, wchar_t * *, int);
extern float __wcstof_internal(const wchar_t *, wchar_t * *, int);
extern long int __wcstol_internal(const wchar_t *, wchar_t * *, int, int);
extern long double __wcstold_internal(const wchar_t *, wchar_t * *, int);
extern unsigned long int __wcstoul_internal(const wchar_t *, wchar_t * *,
					    int, int);
extern wchar_t *wcscat(wchar_t *, const wchar_t *);
extern wchar_t *wcschr(const wchar_t *, wchar_t);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t *, const wchar_t *);
extern size_t wcscspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsdup(const wchar_t *);
extern wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t * *);
extern int wcswidth(const wchar_t *, size_t);
extern size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int wctob(wint_t);
extern int wcwidth(wchar_t);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t);
extern size_t mbrlen(const char *, size_t, mbstate_t *);
extern size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern int mbsinit(const mbstate_t *);
extern size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t,
			 mbstate_t *);
extern size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
extern wchar_t *wcpcpy(wchar_t *, const wchar_t *);
extern wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t);
extern size_t wcrtomb(char *, wchar_t, mbstate_t *);
extern size_t wcslen(const wchar_t *);
extern size_t wcsnrtombs(char *, const wchar_t * *, size_t, size_t,
			 mbstate_t *);
extern size_t wcsrtombs(char *, const wchar_t * *, size_t, mbstate_t *);
extern double wcstod(const wchar_t *, wchar_t * *);
extern float wcstof(const wchar_t *, wchar_t * *);
extern long int wcstol(const wchar_t *, wchar_t * *, int);
extern long double wcstold(const wchar_t *, wchar_t * *);
extern long long int wcstoq(const wchar_t *, wchar_t * *, int);
extern unsigned long int wcstoul(const wchar_t *, wchar_t * *, int);
extern unsigned long long int wcstouq(const wchar_t *, wchar_t * *, int);
extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcscasecmp(const wchar_t *, const wchar_t *);
extern int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern size_t wcsnlen(const wchar_t *, size_t);
extern long long int wcstoll(const wchar_t *, wchar_t * *, int);
extern unsigned long long int wcstoull(const wchar_t *, wchar_t * *, int);
extern wint_t btowc(int);
extern wint_t fgetwc(FILE *);
extern wint_t fgetwc_unlocked(FILE *);
extern wchar_t *fgetws(wchar_t *, int, FILE *);
extern wint_t fputwc(wchar_t, FILE *);
extern int fputws(const wchar_t *, FILE *);
extern int fwide(FILE *, int);
extern int fwprintf(FILE *, const wchar_t *, ...);
extern int fwscanf(FILE *, const wchar_t *, ...);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
extern int swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE *, const wchar_t *, va_list);
extern int vfwscanf(FILE *, const wchar_t *, va_list);
extern int vswprintf(wchar_t *, size_t, const wchar_t *, va_list);
extern int vswscanf(const wchar_t *, const wchar_t *, va_list);
extern int vwprintf(const wchar_t *, va_list);
extern int vwscanf(const wchar_t *, va_list);
extern size_t wcsftime(wchar_t *, size_t, const wchar_t *,
		       const struct tm *);
extern int wprintf(const wchar_t *, ...);
extern int wscanf(const wchar_t *, ...);
extern int __fwprintf_chk(FILE *, int, const wchar_t *, ...);
extern int __swprintf_chk(wchar_t *, size_t, int, size_t, const wchar_t *,
			  ...);
extern wchar_t *__wcscat_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcscpy_chk(wchar_t *, const wchar_t *, size_t);
extern wchar_t *__wcsncpy_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern wchar_t *__wmemmove_chk(wchar_t *, const wchar_t *, size_t, size_t);
extern FILE *open_wmemstream(wchar_t * *, size_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef unsigned long int wctype_t;
typedef unsigned int wint_t;
typedef const int32_t *wctrans_t;
typedef struct {
    int count;
    wint_t value;
} __mbstate_t;

typedef __mbstate_t mbstate_t;
extern int iswblank(wint_t);
extern wint_t towlower(wint_t);
extern wint_t towupper(wint_t);
extern wctrans_t wctrans(const char *);
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswctype(wint_t, wctype_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern wctype_t wctype(const char *);
extern wint_t towctrans(wint_t, wctrans_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wordexp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

enum {
    WRDE_DOOFFS = 1,
    WRDE_APPEND = 2,
    WRDE_NOCMD = 4,
    WRDE_REUSE = 8,
    WRDE_SHOWERR = 16,
    WRDE_UNDEF = 32
};

typedef struct {
    size_t we_wordc;
    char **we_wordv;
    size_t we_offs;
} wordexp_t;

enum {
    WRDE_NOSYS = -1,
    WRDE_NOSPACE = 1,
    WRDE_BADCHAR = 2,
    WRDE_BADVAL = 3,
    WRDE_CMDSUB = 4,
    WRDE_SYNTAX = 5
};
extern int wordexp(const char *, wordexp_t *, int);
extern void wordfree(wordexp_t *);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libcman>
<TITLE>Interface Definitions for libc</TITLE>
<PARA>
The interfaces defined on the following pages are included in libc and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libc> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="baselib--IO-feof-3"> <REFMETA>
<REFENTRYTITLE>_IO_feof</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_feof
</REFNAME>
<REFPURPOSE>
alias for feof
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>_IO_feof</FUNCTION></FUNCDEF>
 <PARAMDEF>_IO_FILE *
  <PARAMETER><REPLACEABLE>__fp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>_IO_feof</FUNCTION> tests the end-of-file indicator for the 
stream pointed to by <PARAMETER>__fp</PARAMETER>, returning a non-zero 
value if it is set.  
</PARA>
<PARA>
<FUNCTION>_IO_feof</FUNCTION> is not in the source standard; it is only 
in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-getc-3"> <REFMETA>
<REFENTRYTITLE>_IO_getc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_getc
</REFNAME>
<REFPURPOSE>
alias for getc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>_IO_getc</FUNCTION></FUNCDEF>
 <PARAMDEF>_IO_FILE *
  <PARAMETER><REPLACEABLE>__fp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>_IO_getc</FUNCTION> reads the next character from 
<PARAMETER>__fp</PARAMETER> and returns it as an unsigned char cast 
to an int, or <VARNAME>EOF</VARNAME> on end-of-file or error.
</PARA>
<PARA>
<FUNCTION>_IO_getc</FUNCTION> is not in the source standard; it is 
only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-putc-3"> <REFMETA>
<REFENTRYTITLE>_IO_putc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_putc
</REFNAME>
<REFPURPOSE>
alias for putc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>_IO_putc</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__c</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>_IO_FILE *
  <PARAMETER><REPLACEABLE>__fp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>_IO_putc</FUNCTION> writes the character 
<PARAMETER>__c</PARAMETER>, cast to an unsigned char, to 
<PARAMETER>__fp</PARAMETER>.
</PARA>
<PARA>
<FUNCTION>_IO_putc</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-puts-3"> <REFMETA>
<REFENTRYTITLE>_IO_puts</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_puts
</REFNAME>
<REFPURPOSE>
alias for puts
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>_IO_puts</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__c</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>_IO_puts</FUNCTION> writes the string <PARAMETER>__s</PARAMETER> 
and a trailing newline to <VARNAME>stdout</VARNAME>.
</PARA>
<PARA>
<FUNCTION>_IO_puts</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---assert-fail-1"> <REFMETA>
<REFENTRYTITLE>__assert_fail</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__assert_fail
</REFNAME>
<REFPURPOSE>abort the program after false assertion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>__assert_fail</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>assertion</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>file</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned int 
  <PARAMETER><REPLACEABLE>line</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>function</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__assert_fail</FUNCTION> function is used to
implement the <FUNCTION>assert</FUNCTION> interface of
<XREF LINKEND=STD.SUSv3>.
The <FUNCTION>__assert_fail</FUNCTION> function 
shall print the given <parameter>file</parameter> filename,
<parameter>line</parameter> line number, 
<parameter>function</parameter> function name and a message
on the standard error stream in an unspecified format, and abort
program execution via the <function>abort</function> function.
For example:
<BLOCKQUOTE>
<PARA>
a.c:10: foobar: Assertion a == b failed.
</PARA>
</BLOCKQUOTE>
</PARA>
<PARA>
If <PARAMETER>function</PARAMETER> is <LITERAL>NULL</LITERAL>, 
<function>__assert_fail</function> shall omit
information about the function.
</PARA><PARA>
<PARAMETER>assertion</PARAMETER>, <PARAMETER>file</PARAMETER>, and
<PARAMETER>line</PARAMETER> shall be non-<LITERAL>NULL</LITERAL>.
</PARA>
<PARA>
The <FUNCTION>__assert_fail</FUNCTION> function
is not in the source standard; 
it is only in the binary standard.
The <FUNCTION>assert</FUNCTION> interface is not in the binary standard;
it is only in the source standard. The <FUNCTION>assert</FUNCTION> may
be implemented as a macro.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __chk_fail -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---ctype-b-loc"> <REFMETA>
<REFENTRYTITLE>__ctype_b_loc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_b_loc</REFNAME>
<REFPURPOSE>
accessor function for __ctype_b array for ctype functions
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>8 July 2004</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;ctype.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>const unsigned short * *
    <FUNCTION>__ctype_b_loc</FUNCTION>
  </FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>8 July 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__ctype_b_loc</FUNCTION>
function shall return a pointer into an array of
characters in the current locale that contains characteristics for each
character in the current character set. The array shall contain a total of 
<CONSTANT>384</CONSTANT>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CONSTANT>-128</CONSTANT> and 
<CONSTANT>255</CONSTANT>). If the application is multithreaded, the 
array shall be local to the current thread. 
</PARA>
<PARA>
This interface is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>The <FUNCTION>__ctype_b_loc</FUNCTION> function shall return a pointer
to the array of characters to be used for the <FUNCTION>ctype</FUNCTION>
family of functions (see <FILENAME>&lt;ctype.h&gt;</FILENAME>).
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---ctype-get-mb-cur-max-1"> <REFMETA>
<REFENTRYTITLE>__ctype_get_mb_cur_max</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_get_mb_cur_max</REFNAME>
<REFPURPOSE>
maximum length of a multibyte character in the current locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>__ctype_get_mb_cur_max</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__ctype_get_mb_cur_max</FUNCTION> returns the maximum 
length of a multibyte character in the current locale.
</PARA>
<PARA>
<FUNCTION>__ctype_get_mb_cur_max</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---ctype-tolower-loc"> <REFMETA>
<REFENTRYTITLE>__ctype_tolower_loc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_tolower_loc
</REFNAME>
<REFPURPOSE>
accessor function for __ctype_b_tolower array for ctype tolower() function
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>8 July 2004</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;ctype.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int32_t * *
  <FUNCTION>__ctype_tolower_loc</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>8 July 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__ctype_tolower_loc</FUNCTION>
function shall return a pointer into an array of
characters in the current locale that contains lower case equivalents for each
character in the current character set. The array shall contain a total of 
<CONSTANT>384</CONSTANT>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CONSTANT>-128</CONSTANT> and 
<CONSTANT>255</CONSTANT>). If the application is multithreaded, the 
array shall be local to the current thread. 
</PARA>
<PARA>
This interface is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>The <FUNCTION>__ctype_tolower_loc</FUNCTION> function shall return a pointer
to the array of characters to be used for the <FUNCTION>ctype</FUNCTION>
family of functions (see <FILENAME>&lt;ctype.h&gt;</FILENAME>).
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---ctype-toupper-loc"> <REFMETA>
<REFENTRYTITLE>__ctype_toupper_loc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_toupper_loc
</REFNAME>
<REFPURPOSE>
accessor function for <function>__ctype_b_toupper</function>
array for ctype <function>toupper</function> function
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>8 July 2004</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;ctype.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int32_t * *
  <FUNCTION>__ctype_toupper_loc</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>8 July 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__ctype_toupper_loc</FUNCTION>
function shall return a pointer into an array of
characters in the current locale that contains upper case equivalents for each
character in the current character set. The array shall contain a total of 
<CONSTANT>384</CONSTANT>
characters, and can be indexed with any signed or unsigned char (i.e. with an
index value between <CONSTANT>-128</CONSTANT> and 
<CONSTANT>255</CONSTANT>). If the application is multithreaded, the 
array shall be local to the current thread. 
</PARA>
<PARA>
This interface is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>The <FUNCTION>__ctype_toupper_loc</FUNCTION> function shall return a pointer
to the array of characters to be used for the <FUNCTION>ctype</FUNCTION>
family of functions (see <FILENAME>&lt;ctype.h&gt;</FILENAME>).
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---cxa-atexit"> <REFMETA>
<REFENTRYTITLE>__cxa_atexit</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__cxa_atexit</REFNAME>
<REFPURPOSE>
register a function to be called by exit or when a shared library is unloaded
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__cxa_atexit</FUNCTION></FUNCDEF>
 <PARAMDEF>void <FUNCPARAMS>*func</FUNCPARAMS> 
  <FUNCPARAMS>void *</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void *
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>void *
  <PARAMETER><REPLACEABLE>dso_handle</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
As described in the <xref linkend="std.cxxabi">,
<FUNCTION>__cxa_atexit</FUNCTION> registers a destructor function to be called by 
<function>exit</function> or when a shared library is unloaded. 
When a shared library is unloaded, any destructor function associated with that
shared library, identified by <parameter>dso_handle</parameter>, shall be called
with the single argument <parameter>arg</parameter>, and then that function shall
be removed, or marked as complete, from the list of functions to run at 
<function>exit</function>.
On a call to <function>exit</function>,
any remaining functions registered shall be called 
with the single argument <parameter>arg</parameter>.
Destructor functions shall always be called in the reverse order to their
registration (i.e. the most recently registered function shall be called first),
</PARA>
<PARA>
The <FUNCTION>__cxa_atexit</FUNCTION> function is used to implement
<FUNCTION>atexit</FUNCTION>, as described in <XREF LINKEND=STD.SUSv3>.
Calling <literal>atexit(func)</literal> from the statically linked part of
an application shall be equivalent to
<literal>__cxa_atexit(func, NULL, NULL)</literal>.
</PARA>
<PARA>
<FUNCTION>__cxa_atexit</FUNCTION> is not in the source standard; 
it is only in the binary standard.
<NOTE><PARA>
<FUNCTION>atexit</FUNCTION> is not in the binary standard; 
it is only in the source standard.
</PARA></NOTE>
</PARA>
</REFSECT1>
</REFENTRY>


<refentry id="baselib---cxa-finalize">
<refmeta>
<refentrytitle>__cxa_finalize</refentrytitle>
<refmiscinfo></refmiscinfo>
</refmeta>

<refnamediv>
<refname>__cxa_finalize</refname>
<refpurpose>call destructors of global (or local static) C++
objects and exit functions registered with atexit
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void
<function>__cxa_finalize</function>
</funcdef>
<paramdef>void *
<parameter>d</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>As described in the Itanium&reg; C++ ABI, the C runtime library shall
maintain a list of termination function entries containing the
following information:</para>

<itemizedlist>
<listitem><para>
A pointer to a termination function.
</para></listitem>
<listitem><para>
An operand to be passed to the function.
</para></listitem>
<listitem><para>
A handle identifying the home shared library of the
entry.
</para></listitem>
</itemizedlist>

<para>The list is populated by entries of two kinds:</para>

<itemizedlist>
<listitem><para>
Destructors of global (or local static) C++ objects that require
destruction on exit.
</para></listitem>
<listitem><para>
Functions registered by the user with atexit().
</para></listitem>
</itemizedlist>

<para>In the former case an entry consists of a pointer to the destructor,
a pointer to the corresponding object and a handle for the home shared
library of the object. In the latter case the pointer to the function
is the pointer passed to atexit(), while the other pointers are NULL.</para>

<para>When __cxa_finalize(d) is called, it shall walk the termination function
list, calling each in turn if d matches the handle of the termination
function entry. If d is NULL, it shall call all the termination
funtions. Multiple calls to __cxa_finalize shall not result in calling
termination function entries multiple times; the implementation may either
remove entries or mark them finished. The termination functions shall
always be called in the reverse order of their registration (i.e. the
most recently registered function shall be called first).</para>

<para>An application shall not call __cxa_finalize() directly. The
implementation shall arrange for__cxa_finalize() to be called during
early shared library unload (e.g. dlclose()) with a handle to the shared
library. When the main program calls exit, the implementation shall cause
any remaining __cxa_atexit-registered functions to be called, either by
calling __cxa_finalize(NULL), or by walking the registration list
itself.</para>

<para>__cxa_finalize() is not in the source standard; it is only in the binary
standard.</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib---daylight"> <REFMETA>
<REFENTRYTITLE>__daylight</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__daylight
</REFNAME>
<REFPURPOSE>
daylight savings time flag
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
int <VARNAME>__daylight</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The integer variable <VARNAME>__daylight</VARNAME> 
shall implement the daylight savings time flag <VARNAME>daylight</VARNAME>
as specified in the 
<XREF LINKEND="std.SUSv3"> header file <FILENAME>&lt;time.h&gt;</FILENAME>.
</PARA>
<PARA>
<VARNAME>__daylight</VARNAME> is not in the source standard;
it is only in the binary standard. <VARNAME>daylight</VARNAME>
is not in the binary standard; it is only in the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---environ"> <REFMETA>
<REFENTRYTITLE>__environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char * *<VARNAME>__environ</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<VARNAME>__environ</VARNAME> is an alias for <VARNAME>environ</VARNAME>
- user environment.
</PARA>
<PARA>
<VARNAME>__environ</VARNAME> has the same specification as 
<VARNAME>environ</VARNAME>.
</PARA>
<PARA>
<VARNAME>__environ</VARNAME> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---errno-location"> <REFMETA>
<REFENTRYTITLE>__errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__errno_location
</REFNAME>
<REFPURPOSE>address of errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int *
  <FUNCTION>__errno_location</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__errno_location</FUNCTION> function shall return
the address of the <varname>errno</varname> variable for the current
thread.
</PARA><PARA>
<FUNCTION>__errno_location</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __fgets_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---fpending"> <REFMETA>
<REFENTRYTITLE>__fpending</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__fpending</REFNAME>
<REFPURPOSE>
returns in bytes the amount of output pending on a stream
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>__fpending</FUNCTION></FUNCDEF>
 <PARAMDEF>FILE *
  <PARAMETER><REPLACEABLE>stream</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__fpending</FUNCTION> returns the amount of output in bytes 
pending on a stream.
</PARA>

<PARA>
<FUNCTION>__fpending</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<!-- MISSING DEFINITION FOR __fprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __fwprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- content in __xstat.sgml -->

<!-- content in __xstat64.sgml -->

<!-- MISSING DEFINITION FOR __fxstatat -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __fxstatat64 -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __getcwd_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---getpagesize"> <REFMETA>
<REFENTRYTITLE>__getpagesize</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpagesize</REFNAME>
<REFPURPOSE>
alias for getpagesize - get current page size 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__getpagesize</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__getpagesize</FUNCTION> is an alias for 
<FUNCTION>getpagesize</FUNCTION> - get current page size.
</PARA>
<PARA>
<FUNCTION>__getpagesize</FUNCTION> has the same specification as 
<FUNCTION>getpagesize</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__getpagesize</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---getpgid-1"> <REFMETA>
<REFENTRYTITLE>__getpgid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpgid</REFNAME>
<REFPURPOSE>
get the process group id
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>pid_t 
  <FUNCTION>__getpgid</FUNCTION></FUNCDEF>
 <PARAMDEF>pid_t 
  <PARAMETER><REPLACEABLE>pid</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__getpgid</FUNCTION> has the same specification as 
<FUNCTION>getpgid</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__getpgid</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---h-errno-location"> <REFMETA>
<REFENTRYTITLE>__h_errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__h_errno_location
</REFNAME>
<REFPURPOSE>address of h_errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int *
  <FUNCTION>__h_errno_location</FUNCTION></FUNCDEF>
  <VOID> 
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__h_errno_location</FUNCTION> returns the address of the 
<VARNAME>h_errno</VARNAME> variable, where <VARNAME>h_errno</VARNAME> 
is as specified in <XREF LINKEND="STD.SUSv3">.
</PARA>
<PARA>
<FUNCTION>__h_errno_location</FUNCTION> is not in the source standard; 
it is only in the binary standard. Note that <VARNAME>h_errno</VARNAME> 
itself is only in the source standard; it is not in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinf"> <REFMETA>
<REFENTRYTITLE>__isinf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinf</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isinf</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isinf</FUNCTION> has the same specification as 
<FUNCTION>isinf</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__isinf</FUNCTION> is known to be double.
</PARA>
<PARA>
<FUNCTION>__isinf</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinff"> <REFMETA>
<REFENTRYTITLE>__isinff</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinff</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isinff</FUNCTION></FUNCDEF>
 <PARAMDEF>float 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isinff</FUNCTION> has the same specification as 
<FUNCTION>isinf</FUNCTION> in <XREF LINKEND="STD.SUSv3">
except that the argument 
type for <FUNCTION>__isinff</FUNCTION> is known to be float.
</PARA>
<PARA>
<FUNCTION>__isinff</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isinfl"> <REFMETA>
<REFENTRYTITLE>__isinfl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isinfl</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isinfl</FUNCTION></FUNCDEF>
 <PARAMDEF>long double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isinfl</FUNCTION> has the same specification as 
<FUNCTION>isinf</FUNCTION> in the <XREF LINKEND="STD.SUSv3">,
except that the argument 
type for <FUNCTION>__isinfl</FUNCTION> is known to be long double.
</PARA>
<PARA>
<FUNCTION>__isinfl</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnan"> <REFMETA>
<REFENTRYTITLE>__isnan</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnan</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isnan</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isnan</FUNCTION> has the same specification as 
<FUNCTION>isnan</FUNCTION> in <XREF LINKEND="STD.SUSv3">,
except that the argument 
type for <FUNCTION>__isnan</FUNCTION> is known to be double.
</PARA>
<PARA>
<FUNCTION>__isnan</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnanf"> <REFMETA>
<REFENTRYTITLE>__isnanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnanf</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isnanf</FUNCTION></FUNCDEF>
 <PARAMDEF>float 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isnanf</FUNCTION> has the same specification as 
<FUNCTION>isnan</FUNCTION> in <XREF LINKEND="STD.SUSv3">,
except that the argument 
type for <FUNCTION>__isnanf</FUNCTION> is known to be float.
</PARA>
<PARA>
<FUNCTION>__isnanf</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---isnanl"> <REFMETA>
<REFENTRYTITLE>__isnanl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__isnanl</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__isnanl</FUNCTION></FUNCDEF>
 <PARAMDEF>long double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__isnanl</FUNCTION> has the same specification as 
<FUNCTION>isnan</FUNCTION> in <XREF LINKEND="STD.SUSv3">,
except that the argument 
type for <FUNCTION>__isnanl</FUNCTION> is known to be long double.
</PARA>
<PARA>
<FUNCTION>__isnanl</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-current-sigrtmax-1"> <REFMETA>
<REFENTRYTITLE>__libc_current_sigrtmax</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_current_sigrtmax</REFNAME>
<REFPURPOSE>return number of available real-time signal with lowest priority
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__libc_current_sigrtmax</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__libc_current_sigrtmax</FUNCTION> returns the number of 
an available real-time signal with the lowest priority.
</PARA>
<PARA>
<FUNCTION>__libc_current_sigrtmax</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-current-sigrtmin-1"> <REFMETA>
<REFENTRYTITLE>__libc_current_sigrtmin</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_current_sigrtmin</REFNAME>
<REFPURPOSE>
return number of available real-time signal with highest priority
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__libc_current_sigrtmin</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__libc_current_sigrtmin</FUNCTION> returns the number of 
an available real-time signal with the highest priority.
</PARA>
<PARA>
<FUNCTION>__libc_current_sigrtmin</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---libc-start-main-"> <REFMETA>
<REFENTRYTITLE>__libc_start_main</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_start_main
</REFNAME>
<REFPURPOSE>
initialization routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>__libc_start_main</FUNCTION></FUNCDEF>
 <PARAMDEF>int <FUNCPARAMS>*main</FUNCPARAMS> 
               <FUNCPARAMS>int, char * *, char * *</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>argc</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * * 
  <PARAMETER><REPLACEABLE>ubp_av</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>void <FUNCPARAMS>*init</FUNCPARAMS> <FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void <FUNCPARAMS>*fini</FUNCPARAMS> <FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void <FUNCPARAMS>*rtld_fini</FUNCPARAMS> <FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void <FUNCPARAMS>*
  <REPLACEABLE>stack_end</REPLACEABLE></FUNCPARAMS></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__libc_start_main</FUNCTION> function shall
perform any necessary initialization of the execution
environment, call the <parameter>main</parameter> function
with appropriate arguments, and handle the return from <function>
main</function>. If the <function>main</function> function returns,
the return value shall be passed to the <function>exit</function> function.
<NOTE>
<PARA>
While this specification is intended to be implementation independent,
process and library initialization may include:
<itemizedlist>
<listitem><para>
performing any necessary security checks if the effective user ID is
not the same as the real user ID.
</para></listitem>
<listitem><para>
initialize the threading subsystem.
</para></listitem>
<listitem><para>
registering the <parameter>rtld_fini</parameter> to release resources when this
dynamic shared object exits (or is unloaded).
</para></listitem>
<listitem><para>
registering the <parameter>fini</parameter> handler to run at program exit.
</para></listitem>
<listitem><para>
calling the initializer function <function>(*<parameter>init</parameter>)</function>.
</para></listitem>
<listitem><para>
calling <function>main</function> with appropriate arguments.
</para></listitem>
<listitem><para>
calling <function>exit</function> with the return value from
<function>main</function>.
</para></listitem>
</itemizedlist>
This list is an example only.
</PARA>
</NOTE>
</PARA>
<PARA>
<FUNCTION>__libc_start_main</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
The section on Process Initialization in each of 
the architecture specific parts of &ISOSTD;.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="libutil---lxstat-2"> <REFMETA>
<REFENTRYTITLE>__lxstat</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__lxstat
</REFNAME>
<REFPURPOSE>inline wrapper around call to lxstat
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;ctype.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__lxstat</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>version</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>__path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat 
  <PARAMETER>__statbuf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__lxstat</FUNCTION> is an inline wrapper around call to 
<FUNCTION>lxstat</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__lxstat</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- content in __xstat64.sgml -->

<!-- MISSING DEFINITION FOR __memcpy_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __memmove_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---mempcpy"> <REFMETA>
<REFENTRYTITLE>__mempcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__mempcpy</REFNAME>
<REFPURPOSE>
copy given number of bytes of source to destination
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>5 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void *
  <FUNCTION>__mempcpy</FUNCTION></FUNCDEF>
 <PARAMDEF>void * restrict 
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const void * restrict 
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>5 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__mempcpy</FUNCTION> copies <PARAMETER>n</PARAMETER> 
bytes of <PARAMETER>src</PARAMETER> to <PARAMETER>dest</PARAMETER>,
returning a pointer to the byte after the last written byte.
</PARA>
<PARA>
If copying takes place between objects that overlap, the behavior is
undefined.
</PARA>
<PARA>
If either <PARAMETER>dest</PARAMETER> or <PARAMETER>src</PARAMETER> 
is a null pointer, the behavior is undefined.
</PARA>
<PARA>
If <PARAMETER>n</PARAMETER> is <LITERAL>0</LITERAL> and the other parameters
are valid, the return value is <PARAMETER>dest</PARAMETER>.
</PARA>
<PARA>
<FUNCTION>__mempcpy</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __mempcpy_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __memset_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __printf_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---rawmemchr"> <REFMETA>
<REFENTRYTITLE>__rawmemchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__rawmemchr</REFNAME>
<REFPURPOSE>
scan memory
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void * 
  <FUNCTION>__rawmemchr</FUNCTION></FUNCDEF>
 <PARAMDEF>const void * 
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>c</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>11 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__rawmemchr</FUNCTION> function shall locate the first occurrence of
<PARAMETER>c</PARAMETER>
(converted to an unsigned char) in the object pointed to by <PARAMETER>s</PARAMETER>. If the byte does
not occur in the object, then the behavior is undefined.
</PARA>
<PARA>
<FUNCTION>__rawmemchr</FUNCTION> is a weak alias for
<FUNCTION>rawmemchr</FUNCTION>. It is similar to 
<FUNCTION>memchr</FUNCTION>, but it has no length limit. 
</PARA>
<PARA>
<FUNCTION>__rawmemchr</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>

<REFSECT1>
<REFSECT1INFO>
<DATE>11 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Return Value</TITLE>
<PARA>
The <FUNCTION>__rawmemchr</FUNCTION> function shall return a pointer to the located byte.
</PARA>
</REFSECT1>

</REFENTRY>


<!-- MISSING DEFINITION FOR __read_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __readlink_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __realpath_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __recv_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __recvfrom_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---register-atfork"> <REFMETA>
<REFENTRYTITLE>__register_atfork</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__register_atfork
</REFNAME>
<REFPURPOSE>
alias for register_atfork
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>11 July 2004</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__register_atfork</FUNCTION></FUNCDEF>
 <PARAMDEF>void
  <FUNCPARAMS>*<REPLACEABLE>prepare</REPLACEABLE></FUNCPARAMS>
<FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void
  <FUNCPARAMS>*<REPLACEABLE>parent</REPLACEABLE></FUNCPARAMS>
<FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void
  <FUNCPARAMS>*<REPLACEABLE>child</REPLACEABLE></FUNCPARAMS>
<FUNCPARAMS>void</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>void *
  <PARAMETER><REPLACEABLE>__dso_handle</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>11 July 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__register_atfork</FUNCTION> implements
<FUNCTION>pthread_atfork</FUNCTION> as specified in <XREF LINKEND="std.SUSv3">.
The additional parameter <PARAMETER>__dso_handle</PARAMETER> allows a shared
object to pass in it's handle so that functions registered by
<FUNCTION>__register_atfork</FUNCTION> can be unregistered by the runtime when
the shared object is unloaded.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---sigsetjmp-1"> <REFMETA>
<REFENTRYTITLE>__sigsetjmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sigsetjmp</REFNAME>
<REFPURPOSE>
save stack context for non-local goto
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__sigsetjmp</FUNCTION></FUNCDEF>
 <PARAMDEF>jmp_buf 
  <PARAMETER><REPLACEABLE>env</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>savemask</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__sigsetjmp</FUNCTION> has the same behavior as 
<FUNCTION>sigsetjmp</FUNCTION> as specified by 
<XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
<FUNCTION>__sigsetjmp</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __snprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __sprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __stack_chk_fail -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="libutil---stpcpy-2"> <REFMETA>
<REFENTRYTITLE>__stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__stpcpy
</REFNAME>
<REFPURPOSE>alias for stpcpy
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>__stpcpy</FUNCTION></FUNCDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__stpcpy</FUNCTION> function has the same specification as
the <FUNCTION>stpcpy</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__stpcpy</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __stpcpy_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __strcat_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __strcpy_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---strdup-1"> <REFMETA>
<REFENTRYTITLE>__strdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strdup</REFNAME>
<REFPURPOSE>
alias for strdup
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>__strdup</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>string</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__strdup</FUNCTION> has the same specification as 
<FUNCTION>strdup</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__strdup</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __strncat_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __strncpy_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---strtod-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtod_internal
</REFNAME>
<REFPURPOSE>underlying function for strtod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>double 
  <FUNCTION>__strtod_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtod_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<FUNCTION>__strtod_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <LITERAL>0</LITERAL>)</FUNCTION> 
has the same specification as 
<FUNCTION>strtod(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>)</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__strtod_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtof-internal"> <REFMETA>
<REFENTRYTITLE>__strtof_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtof_internal
</REFNAME>
<REFPURPOSE>underlying function for strtof
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>float 
  <FUNCTION>__strtof_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtof_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<FUNCTION>__strtof_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <LITERAL>0</LITERAL>)</FUNCTION> 
has the same specification as 
<FUNCTION>strtof(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>)</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__strtof_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtok-r-1"> <REFMETA>
<REFENTRYTITLE>__strtok_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtok_r</REFNAME>
<REFPURPOSE>
alias for strtok_r
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>__strtok_r</FUNCTION></FUNCDEF>
 <PARAMDEF>char * restrict 
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict 
  <PARAMETER><REPLACEABLE>delim</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * * restrict 
  <PARAMETER><REPLACEABLE>save_ptr</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__strtok_r</FUNCTION> has the same specification as 
<FUNCTION>strtok_r</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__strtok_r</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtol-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtol_internal
</REFNAME>
<REFPURPOSE>alias for strtol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>long int 
  <FUNCTION>__strtol_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtol_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__strtol_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>, 
<LITERAL>0</LITERAL>)</LITERAL> has the same specification as 
<LITERAL>strtol(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>)</LITERAL>.
</PARA>
<PARA>
<FUNCTION>__strtol_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtold-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtold_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtold_internal</REFNAME>
<REFPURPOSE>underlying function for strtold
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>long double  
  <FUNCTION>__strtold_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtold_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__strtold_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <LITERAL>0</LITERAL>)</LITERAL> 
has the same specification as 
<LITERAL>strtold(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>)</LITERAL>.
</PARA>
<PARA>
<FUNCTION>__strtold_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtoll-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtoll_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoll_internal</REFNAME>
<REFPURPOSE>underlying function for strtoll
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>long long 
  <FUNCTION>__strtoll_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtoll_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__strtoll_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>, 
<LITERAL>0</LITERAL>)</LITERAL> has the same specification as 
<LITERAL>strtoll(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>)</LITERAL>.
</PARA>
<PARA>
<FUNCTION>__strtoll_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtoul-internal"> <REFMETA>
<REFENTRYTITLE>__strtoul_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoul_internal
</REFNAME>
<REFPURPOSE>underlying function for strtoul
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>unsigned long int 
  <FUNCTION>__strtoul_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtoul_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__strtoul_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>, 
<LITERAL>0</LITERAL>)</LITERAL> has the same specification as 
<LITERAL>strtoul(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>)</LITERAL>.
</PARA>
<PARA>
<FUNCTION>__strtoul_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---strtoull-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtoull_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtoull_internal</REFNAME>
<REFPURPOSE>underlying function for strtoull
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>unsigned long long 
  <FUNCTION>__strtoull_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>__nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>__endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>__group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>__group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__strtoull_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__strtoull_internal(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>, 
<LITERAL>0</LITERAL>)</LITERAL> has the same specification as 
<LITERAL>strtoull(<PARAMETER>__nptr</PARAMETER>, 
<PARAMETER>__endptr</PARAMETER>, <PARAMETER>__base</PARAMETER>)</LITERAL>.
</PARA>
<PARA>
<FUNCTION>__strtoull_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __swprintf_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---sysconf"> <REFMETA>
<REFENTRYTITLE>__sysconf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sysconf</REFNAME>
<REFPURPOSE>
get configuration information at runtime
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>long 
  <FUNCTION>__sysconf</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__sysconf</FUNCTION> gets configuration information at runtime.
</PARA>
<PARA>
<FUNCTION>__sysconf</FUNCTION> is weak alias to 
<FUNCTION>sysconf</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__sysconf</FUNCTION> has the same specification as 
<FUNCTION>sysconf</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>__sysconf</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<!-- MISSING DEFINITION FOR __syslog_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---sysv-signal-1"> <REFMETA>
<REFENTRYTITLE>__sysv_signal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sysv_signal</REFNAME>
<REFPURPOSE>
signal handling
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>__sighandler_t 
  <FUNCTION>__sysv_signal</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sig</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>__sighandler_t 
  <PARAMETER><REPLACEABLE>handler</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__sysv_signal</FUNCTION> has the same behavior as 
<FUNCTION>signal</FUNCTION> as specified by 
<XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
<FUNCTION>__sysv_signal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---timezone"> <REFMETA>
<REFENTRYTITLE>__timezone</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>
</REFNAME>
<REFPURPOSE>
global variable containing timezone
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
long int <VARNAME>__timezone</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__timezone</FUNCTION> has the same specification as 
<FUNCTION>timezone</FUNCTION> in the 
<CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3></CITETITLE>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---tzname"> <REFMETA>
<REFENTRYTITLE>__tzname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>
</REFNAME>
<REFPURPOSE>
global variable containing the timezone
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<SYNOPSIS>
char * <VARNAME>__tzname</VARNAME>[2];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<CONSTANT>__tzname</CONSTANT> has the same specification as 
<CONSTANT>tzname</CONSTANT> in the 
<CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3></CITETITLE>.
</PARA>
<PARA>
Note that the array size of <LITERAL>2</LITERAL> is explicit in the 
<CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3>
</CITETITLE>, but not in the
<CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv2>
</CITETITLE>.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __vfprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __vprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __vsnprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __vsprintf_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __vsyslog_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __wcscat_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __wcscpy_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __wcsncpy_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---wcstod-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstod_internal</REFNAME>
<REFPURPOSE>underlying function for wcstod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>double 
  <FUNCTION>__wcstod_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__wcstod_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__wcstod_internal(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <LITERAL>0</LITERAL>)</LITERAL> 
shall behave as
<LITERAL>wcstod(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>)</LITERAL> as specified by
<XREF LINKEND="STD.SUSv3">.
</PARA>
<PARA>
<FUNCTION>__wcstod_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstof-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstof_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstof_internal</REFNAME>
<REFPURPOSE>underlying function for wcstof
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>float 
  <FUNCTION>__wcstof_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__wcstof_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__wcstof_internal(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <LITERAL>0</LITERAL>)</LITERAL> 
shall behave as
<LITERAL>wcstof(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>)</LITERAL> as specified in
<XREF LINKEND="STD.SUSV3">.
</PARA>
<PARA>
<FUNCTION>__wcstof_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstol-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstol_internal</REFNAME>
<REFPURPOSE>underlying function for wcstol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>long 
  <FUNCTION>__wcstol_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__wcstol_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__wcstol_internal(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <PARAMETER>base</PARAMETER>, 
<LITERAL>0</LITERAL>)</LITERAL> shall behave as
<LITERAL>wcstol(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <PARAMETER>base</PARAMETER>)</LITERAL>
as specified by <XREF LINKEND="STD.SUSV3">.
</PARA>
<PARA>
<FUNCTION>__wcstol_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstold-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstold_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstold_internal</REFNAME>
<REFPURPOSE>underlying function for wcstold
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>long double 
  <FUNCTION>__wcstold_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__wcstold_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__wcstold_internal(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <LITERAL>0</LITERAL>)</LITERAL> 
shall behave as
<LITERAL>wcstold(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>)</LITERAL>
as specified by <XREF LINKEND="STD.SUSv3">.
</PARA>
<PARA>
<FUNCTION>__wcstold_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---wcstoul-internal-1"> <REFMETA>
<REFENTRYTITLE>__wcstoul_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__wcstoul_internal</REFNAME>
<REFPURPOSE>underlying function for wcstoul
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>unsigned long 
  <FUNCTION>__wcstoul_internal</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t * restrict 
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t * * restrict 
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<PARAMETER>group</PARAMETER> shall be <LITERAL>0</LITERAL> or the 
behavior of <FUNCTION>__wcstoul_internal</FUNCTION> is undefined. 
</PARA>
<PARA>
<FUNCTION>__wcstoul_internal(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <PARAMETER>base</PARAMETER>, 
<LITERAL>0</LITERAL>)</FUNCTION> shall behave as
<FUNCTION>wcstoul(<PARAMETER>nptr</PARAMETER>, 
<PARAMETER>endptr</PARAMETER>, <PARAMETER>base</PARAMETER>)</FUNCTION>
as specified by <XREF LINKEND="STD.SUSV3">.
</PARA>
<PARA>
<FUNCTION>__wcstoul_internal</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __wctomb_chk -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR __wmemmove_chk -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---xmknod-1"> <REFMETA>
<REFENTRYTITLE>__xmknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xmknod</REFNAME>
<REFPURPOSE>
make block or character special file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__xmknod</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>mode_t 
  <PARAMETER><REPLACEABLE>mode</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>dev_t *
  <PARAMETER><REPLACEABLE>dev</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>__xmknod</FUNCTION> function shall implement the
<FUNCTION>mknod</FUNCTION> interface from <XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
The value of <PARAMETER>ver</PARAMETER> shall be <LITERAL>1</LITERAL> or the 
behavior of <FUNCTION>__xmknod</FUNCTION> is undefined. 
</PARA>
<PARA>
<LITERAL>__xmknod(<LITERAL>1</LITERAL>, 
<PARAMETER>path</PARAMETER>, <PARAMETER>mode</PARAMETER>, 
<PARAMETER>dev</PARAMETER>)</LITERAL> shall behave as
<LITERAL>mknod(<PARAMETER>path</PARAMETER>, 
<PARAMETER>mode</PARAMETER>, <PARAMETER>dev</PARAMETER>)</LITERAL>
as specified by <XREF LINKEND="STD.SUSV3">.
</PARA>
<PARA>
The <FUNCTION>__xmknod</FUNCTION> function is not in the source standard; 
it is only in the binary standard.
<NOTE><PARA>
The <FUNCTION>mknod</FUNCTION> function is not in the binary standard; 
it is only in the source standard.
</PARA></NOTE>
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR __xmknodat -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib---xpg-basename"> <REFMETA>
<REFENTRYTITLE>__xpg_basename</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xpg_basename
</REFNAME>
<REFPURPOSE>
return the last component of a file name
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;libgen.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>char *
<function>__xpg_basename</function>
</funcdef>
<paramdef>const char *
<parameter>path</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>__xpg_basename</function> function shall return a pointer to the final component
of the pathname named by <parameter>path</parameter>, as described in 
<xref linkend="std.SUSv3"> <function>basename</function>.
</para>
<para>
This function is not in the source standard, it is only in the binary standard.
</para>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
See <xref linkend="std.SUSv3">.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xpg-sigpause"> <REFMETA>
<REFENTRYTITLE>__xpg_sigpause</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xpg_sigpause
</REFNAME>
<REFPURPOSE>
remove a signal from the signal mask and suspend the thread
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;signal.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>__xpg_sigpause</function>
</funcdef>
<paramdef>int
<parameter>sig</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>__xpg_sigpause</function> function shall implement the
<function>sigpause</function> described in
<xref linkend="std.SUSv3">.
</para>
<para>
This function is not in the source standard, it is only in the binary standard.
</para>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
See <xref linkend="std.SUSv3">.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xpg-strerror-r"> <REFMETA>
<REFENTRYTITLE>__xpg_strerror_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xpg_strerror_r
</REFNAME>
<REFPURPOSE>
return string describing error number
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;string.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>__xpg_strerror_r</function>
</funcdef>
<paramdef>int
<parameter>errnum</parameter>
</paramdef>
<paramdef>char *
<parameter>buf</parameter>
</paramdef>
<paramdef>size_t
<parameter>buflen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>__xpg_strerror_r</function> function
shall map the error number in <parameter>errnum</parameter> to a locale-dependent error
message string and shall return the string in the buffer pointed to by <parameter>strerrbuf</parameter>, with length
<parameter>buflen</parameter>, as described in 
<xref linkend="std.susv3"> <function>strerror_r</function>.
</para>
<para>
This function is not in the source standard, it is only in the binary standard.
</para>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
See <xref linkend="std.SUSv3">.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xstat"> <REFMETA>
<REFENTRYTITLE>__xstat</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xstat
</REFNAME>
<REFPURPOSE>get File Status
</REFPURPOSE>
<INDEXTERM ID="ix-baselib-xstat-1"><PRIMARY>stat</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat-2"><PRIMARY>xstat</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 1996</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__xstat</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__lxstat</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__fxstat</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fildes</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>5 March 1996</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The functions 
<function>__xstat</function>,
<function>__lxstat</function>, and
<function>__fxstat</function> shall implement
the <XREF LINKEND=STD.SUSv3> functions
<function>stat</function>,
<function>lstat</function>, and
<function>fstat</function> respectively.
</PARA>
<PARA>
<PARAMETER>ver</PARAMETER> shall be <LITERAL>3</LITERAL> or the 
behavior of these functions is undefined. 
</PARA>
<PARA>
<LITERAL>__xstat(<LITERAL>3</LITERAL>, <PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall implement
<LITERAL>stat(<PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
<LITERAL>__lxstat(<LITERAL>3</LITERAL>, <PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall implement
<LITERAL>lstat(<PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
<LITERAL>__fxstat(<LITERAL>3</LITERAL>, <PARAMETER>fildes</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall implement
<LITERAL>fstat(<PARAMETER>fildes</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.SUSv3>.
</PARA>
<PARA>
<FUNCTION>__xstat</FUNCTION>, <FUNCTION>__lxstat</FUNCTION>, and 
<FUNCTION>__fxstat</FUNCTION> are not in the source standard; 
they are only in the binary standard.
</PARA>
<PARA>
<FUNCTION>stat</FUNCTION>, <FUNCTION>lstat</FUNCTION>, and  
<FUNCTION>fstat</FUNCTION> are not in the binary standard; 
they are only in the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xstat64"> <REFMETA>
<REFENTRYTITLE>__xstat64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xstat64
</REFNAME>
<REFPURPOSE>get File Status
</REFPURPOSE>
<INDEXTERM ID="ix-baselib-xstat64-1"><PRIMARY>stat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-2"><PRIMARY>lstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-3"><PRIMARY>fstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-4"><PRIMARY>__xstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-5"><PRIMARY>__lxstat64</PRIMARY></INDEXTERM>
<INDEXTERM ID="ix-baselib-xstat64-6"><PRIMARY>__fxstat64</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Mar 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _LARGEFILE_SOURCE 1
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__xstat64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat64 *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__lxstat64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat64 *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__fxstat64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>ver</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fildes</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct stat64 *
  <PARAMETER>stat_buf</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The functions 
<function>__xstat64</function>,
<function>__lxstat64</function>, and
<function>__fxstat64</function> shall implement
the <XREF LINKEND=STD.LFS> functions
<function>stat64</function>,
<function>lstat64</function>, and
<function>fstat64</function> respectively.
</PARA>
<PARA>
<PARAMETER>ver</PARAMETER> shall be <LITERAL>3</LITERAL> or the 
behavior of these functions is undefined. 
</PARA>
<PARA>
<LITERAL>__xstat64(<LITERAL>3</LITERAL>, <PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall behave as
<LITERAL>stat(<PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.LFS>.
</PARA>
<PARA>
<LITERAL>__lxstat64(<LITERAL>3</LITERAL>, <PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall behave as
<LITERAL>lstat(<PARAMETER>path</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.LFS>.
</PARA>
<PARA>
<LITERAL>__fxstat64(<LITERAL>3</LITERAL>, <PARAMETER>fildes</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> shall behave as
<LITERAL>fstat(<PARAMETER>fildes</PARAMETER>, 
<PARAMETER>stat_buf</PARAMETER>)</LITERAL> as specified by 
<XREF LINKEND=STD.LFS>.
</PARA>
<PARA>
<FUNCTION>__xstat64</FUNCTION>, <FUNCTION>__lxstat64</FUNCTION>, and 
<FUNCTION>__fxstat64</FUNCTION> are not in the source standard; 
they are only in the binary standard.
</PARA>
<PARA>
<FUNCTION>stat64</FUNCTION>, <FUNCTION>lstat64</FUNCTION>, and  
<FUNCTION>fstat64</FUNCTION> are not in the binary standard; 
they are only in the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--environ"> <REFMETA>
<REFENTRYTITLE>_environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char * *<VARNAME>_environ</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<VARNAME>_environ</VARNAME> is an alias for 
<VARNAME>environ</VARNAME> - user environment.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--nl-msg-cat-cntr"> <REFMETA>
<REFENTRYTITLE>_nl_msg_cat_cntr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_nl_msg_cat_cntr</REFNAME>
<REFPURPOSE>
new catalog load counter
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h&gt;

extern int <VARNAME>_nl_msg_cat_cntr</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The global variable
<VARNAME>_nl_msg_cat_cntr</VARNAME> is incremented each time a new
catalog is loaded. 
This variable is only in the binary standard; it is not in the source standard.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--sys-errlist"> <REFMETA>
<REFENTRYTITLE>_sys_errlist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_errlist</REFNAME>
<REFPURPOSE>
array containing the "C" locale strings used by strerror()
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h&gt;

extern const char *const <VARNAME>_sys_errlist</VARNAME>[];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<VARNAME>_sys_errlist</VARNAME> is an array containing the "C" locale 
strings used by <FUNCTION>strerror</FUNCTION>. This normally should not 
be used directly. <FUNCTION>strerror</FUNCTION> provides all of the 
needed functionality.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--sys-siglist"> <REFMETA>
<REFENTRYTITLE>_sys_siglist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_siglist</REFNAME>
<REFPURPOSE>
array containing the names of the signal names
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h&gt;

extern const char *const <VARNAME>_sys_siglist</VARNAME>[NSIG];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<VARNAME>_sys_siglist</VARNAME> is an array containing the names of 
the signal names.
</PARA>
<PARA>
The <VARNAME>_sys_siglist</VARNAME> array 
is only in the binary standard; it is not in the source standard.
Applications wishing to access the names of signals should use
the <function>strsignal</function> function.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-acct-3"> <REFMETA>
<REFENTRYTITLE>acct</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>acct</REFNAME>
<REFPURPOSE>
switch process accounting on or off
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;dirent.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>acct</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>filename</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When <PARAMETER>filename</PARAMETER> is the name of an existing file, 
<FUNCTION>acct</FUNCTION> turns accounting on and appends a record to
<PARAMETER>filename</PARAMETER> for each terminating process. When
<PARAMETER>filename</PARAMETER> is <LITERAL>NULL</LITERAL>,
<FUNCTION>acct</FUNCTION> turns accounting off.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
<ACRONYM>BSD</ACRONYM> process accounting has not been enabled when 
the operating system kernel was compiled.  The kernel configuration 
parameter controlling this feature is 
<PARAMETER>CONFIG_BSD_PROCESS_ACCT</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process has no permission to enable process accounting.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>filename</PARAMETER> is not a regular file.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
Error writing to the <PARAMETER>filename</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EUSERS 
</TERM>
<LISTITEM>
<PARA>
There are no more free file structures or we run out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-adjtime-2"> <REFMETA>
<REFENTRYTITLE>adjtime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtime
</REFNAME>
<REFPURPOSE>
correct the time to allow synchronization of the system clock
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;time.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>adjtime</FUNCTION></FUNCDEF>
 <PARAMDEF>const struct timeval *
  <PARAMETER>delta</PARAMETER></PARAMDEF>
 <PARAMDEF>struct timeval *
  <PARAMETER>olddelta</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>adjtime</FUNCTION> makes small adjustments to the system time 
as returned by <FUNCTION>gettimeofday</FUNCTION>(2), advancing or retarding 
it by the time specified by the timeval <PARAMETER>delta</PARAMETER>. 
If <PARAMETER>delta</PARAMETER> is negative, the clock is slowed down 
by incrementing it more slowly than normal until the correction is complete. 
If <PARAMETER>delta</PARAMETER> is positive, a larger increment than
normal is used. The skew used to perform the correction is generally a
fraction of one percent. Thus, the time is always a monotonically
increasing function. A time correction from an earlier call to
<FUNCTION>adjtime</FUNCTION> may not be finished when 
<FUNCTION>adjtime</FUNCTION> is called again. If
<PARAMETER>olddelta</PARAMETER> is non-<LITERAL>NULL</LITERAL>, the 
structure pointed to will contain, upon return, the number of microseconds 
still to be corrected from the earlier call.
</PARA>
<PARA>
<FUNCTION>adjtime</FUNCTION> may be used by time servers that synchronize 
the clocks of computers in a local area network. Such time servers would 
slow down the clocks of some machines and speed up the clocks of others to 
bring them to the average network time.
</PARA><PARA>
Appropriate privilege is required to adjust the system time.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
An argument points outside the process's allocated address space.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The process does not have appropriate privilege.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<!-- MISSING DEFINITION FOR alphasort64 -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-asprintf"> <REFMETA>
<REFENTRYTITLE>asprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>asprintf</REFNAME>
<REFPURPOSE>
write formatted output to a dynamically allocated string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdio.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>asprintf</FUNCTION></FUNCDEF>
 <PARAMDEF>char ** restrict 
  <PARAMETER><REPLACEABLE>ptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict
  <PARAMETER><REPLACEABLE>format</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>asprintf</FUNCTION> function shall behave as
<FUNCTION>sprintf</FUNCTION>, except that the output string
shall be dynamically allocated space of sufficient length to hold
the resulting string. The address of this dynamically allocated string
shall be stored in the location referenced by <PARAMETER>ptr</PARAMETER>.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-basename-3"> <REFMETA>
<REFENTRYTITLE>basename</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>basename
</REFNAME>
<REFPURPOSE>
return the last component of a file name
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<!-- Nick's original. based on glibc impl
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;string.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>char *
<function>basename</function>
</funcdef>
<paramdef>const char *
<parameter>path</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
-->
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;libgen.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>char *
<function>basename</function>
</funcdef>
<paramdef>const char *
<parameter>path</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<!-- this was Nick's decription of the glibc implementation:
<para>
In the source standard, if <filename>&lt;libgen.h&gt;</filename> is included,
this shall be equivalent to <function>__xpg_basename</function>.
</para>
<para>
If <filename>&lt;string.h&gt;</filename> is included and <filename>&lt;libgen.h&gt;</filename> is not, the <function>basename</function>
shall return a pointer to the string following the final <literal>'/'</literal> character
in <parameter>path</parameter>. In this case, the string identified by <parameter>path</parameter> shall not be modified.
<note><para>
The version of <function>basename</function> defined in <xref linkend="std.SUSv3"> may modify the string identified by <parameter>path</parameter>.
</para><para>Source applications wishing to include both headers and wanting the non-POSIX version of <function>basename</function>
must include <filename>&lt;libgen.h&gt;</filename> first, and then <literal>#undef basename</literal> before including
<filename>&lt;string.h&gt;</filename>.
</para></note>
</para>
<para>
If <filename>&lt;libgen.h&gt;</filename> is not included, and <parameter>path</parameter> is <literal>"/"</literal>, or ends with a trailing
<literal>'/'</literal> character,
the <function>basename</function> function shall return a pointer to an empty string.
</para>
<para>
In the binary standard, <function>basename</function> is the version described in <filename>&lt;string.h&gt;</filename>.
</para>
-->
<!-- at least for the time being, we ended up with a simpler version: -->
<para>
In the source standard, <function>basename</function> is implemented
as a macro causing it to behave as described in <xref linkend="std.susv3">,
and is equivalent to the function <function>__xpg_basename</function>.
If the macro is undefined, <function>basename</function> from
the binary standard is used, with differences as described here:
</para>
<para>
The string identified by <parameter>path</parameter> shall not be modified.
</para>
<para>
If <parameter>path</parameter> is <literal>"/"</literal>, or ends with a 
trailing <literal>'/'</literal> character, the <function>basename</function>
function shall return a pointer to an empty string.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>basename</function> function shall return a pointer to the final component of
<parameter>path</parameter>. Otherwise, it shall return a null pointer.
</para>
</refsect1>
<refsect1>
<title>See Also</title>
<para>
<simplelist type=inline>
<member><function>__xpg_basename</function></member>
</simplelist>
</para>
</refsect1>
</refentry>

<REFENTRY ID="baselib-bind-textdomain-codeset"> <REFMETA>
<REFENTRYTITLE>bind_textdomain_codeset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bind_textdomain_codeset</REFNAME>
<REFPURPOSE>
specify encoding for message retrieval
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h>
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>char *
   <FUNCTION>bind_textdomain_codeset</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>const char *
     <PARAMETER>domainname</PARAMETER>
  </PARAMDEF>
  <PARAMDEF>const char *
     <PARAMETER>codeset</PARAMETER>
  </PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>bind_textdomain_codeset</function> function can be used to
specify the output codeset for message catalogs for domain 
<parameter>domainname</parameter>.  The <parameter>codeset</parameter>
argument shall be a valid codeset name which can be used tor the
<parameter>iconv_open</parameter> function, or a null pointer.
If the <parameter>codeset</parameter> argument is the null pointer, then 
function returns the currently selected codeset for the domain with the name
<parameter>domainname</parameter>.  It shall return a null pointer if no
codeset has yet been selected.
</PARA>
<PARA>
Each successive call to <function>bind_textdomain_codeset</function>
function overrrides the
settings made by the preceding call with the same <parameter>domainname</parameter>.
</PARA>
<PARA>
The <function>bind_textdomain_codeset</function> function shall return 
a pointer to a string containing the name of the selected codeset. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Parameters</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
domainname
</TERM>
<LISTITEM>
<PARA>
The <parameter>domainname</parameter> argument is applied to the currently 
active LC_MESSAGE locale.  It is equivalent in syntax and meaning to
the <parameter>domainname</parameter> argument 
to <parameter>textdomain</parameter>, except that the selection of the 
domain is valid only for the duration of
the call.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
codeset
</TERM>
<LISTITEM>
<PARA>
The name of the output codeset for the selected domain, or NULL to select
the current codeset.
</PARA>
<PARA>
If <PARAMETER>domainname</PARAMETER> is the null pointer, or is an empty
string, <FUNCTION>bind_textdomain_codeset</FUNCTION> shall fail, but need not
set <VarName>errno</VarName>.
</PARA>

</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Returns the currently selected codeset name.  It returns a null
pointer if no codeset has yet been selected.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory available to allocate return value.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-bindresvport-3"> <REFMETA>
<REFENTRYTITLE>bindresvport</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bindresvport</REFNAME>
<REFPURPOSE>
bind socket to privileged IP port
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/types.h&gt;
#include &lt;rpc/rpc.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>bindresvport</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct sockaddr_in *
  <PARAMETER><REPLACEABLE>sin</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If the process has appropriate privilege, the
<FUNCTION>bindresvport</FUNCTION> function shall bind
a socket to a privileged IP 
port.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<CONSTANT>EPERM</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
The process did not have appropriate privilege.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
<CONSTANT>EPFNOSUPPORT</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Address of <PARAMETER>sin</PARAMETER> did not match address family of
<PARAMETER>sd</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-bindtextdomain"> <REFMETA>
<REFENTRYTITLE>bindtextdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bindtextdomain</REFNAME>
<REFPURPOSE>
specify the location of a message catalog
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>bindtextdomain</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>dirname</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>bindtextdomain</FUNCTION> shall set the the base
directory of the hierarchy containing message catalogs for a given message
domain.
</PARA>
<PARA>
The <FUNCTION>bindtextdomain</FUNCTION> function specifies that the 
<PARAMETER>domainname</PARAMETER> message catalog can be found in the 
<PARAMETER>dirname</PARAMETER> directory hierarchy, rather than in the 
system default locale data base.
</PARA>
<PARA>
If <PARAMETER>dirname</PARAMETER> is not 
<CONSTANT>NULL</CONSTANT>, the base directory for message catalogs 
belonging  to  domain 
<PARAMETER>domainname</PARAMETER> shall be set to 
<PARAMETER>dirname</PARAMETER>. 
If <PARAMETER>dirname</PARAMETER> is <CONSTANT>NULL</CONSTANT>,
the base directory for message catalogs shall not be altered.
</PARA>
<PARA>
The function shall make
copies of the argument strings as needed.
</PARA>
<PARA>
<PARAMETER>dirname</PARAMETER> can be an absolute or relative pathname.
<NOTE><PARA>Applications that wish to use <FUNCTION>chdir</FUNCTION>
should always use absolute pathnames to avoid misadvertently
selecting the wrong or non-existant directory.
</PARA></NOTE>
</PARA>
<PARA>
If <PARAMETER>domainname</PARAMETER> is the null pointer, or is an empty
string, <FUNCTION>bindtextdomain</FUNCTION> shall fail, but need not
set <VarName>errno</VarName>.
</PARA>
<PARA>
The <function>bindtextdomain</function> function shall return 
a pointer to a string containing the name of the selected directory. 
The string shall be allocated
internally in the function and shall not be changed or freed by the user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <FUNCTION>bindtextdomain</FUNCTION> shall return a
pointer to a string containing the 
directory pathname currently bound to the domain. On failure, a 
<LITERAL>NULL</LITERAL> pointer is returned, and the global variable
<VarName>errno</VarName> may be set to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>

<PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><CONSTANT>ENOMEM</CONSTANT></TERM>
<LISTITEM>
<PARA>
Insufficient memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-cfmakeraw-3"> <REFMETA>
<REFENTRYTITLE>cfmakeraw</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfmakeraw</REFNAME>
<REFPURPOSE>
get and set terminal attributes
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;termios.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>cfmakeraw</FUNCTION></FUNCDEF>
 <PARAMDEF>struct termios *
   <PARAMETER>termios_p</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>cfmakeraw</function> function shall set the
attributes of the <structname>termios</structname> structure referenced
by <parameter>termios_p</parameter> as follows:
<SYNOPSIS>
  termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);

  termios_p->c_oflag &= ~OPOST;

  termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);

  termios_p->c_cflag &= ~(CSIZE|PARENB);

  termios_p->c_cflag |= CS8;
</SYNOPSIS>
</PARA>
<PARA>
<PARAMETER>termios_p</PARAMETER> shall point to a 
<STRUCTNAME>termios</STRUCTNAME> structure that contains the 
following members:
<SYNOPSIS>
  tcflag_t c_iflag;      /* input modes */
  tcflag_t c_oflag;      /* output modes */
  tcflag_t c_cflag;      /* control modes */
  tcflag_t c_lflag;      /* local modes */
  cc_t c_cc[NCCS];       /* control chars */
</SYNOPSIS>
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-cfsetspeed-3"> <REFMETA>
<REFENTRYTITLE>cfsetspeed</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfsetspeed
</REFNAME>
<REFPURPOSE>
set terminal input and output data rate
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;termios.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>cfsetspeed</FUNCTION></FUNCDEF>
 <PARAMDEF>struct termios *<PARAMETER>t</PARAMETER></PARAMDEF>
 <PARAMDEF>speed_t 
  <PARAMETER><REPLACEABLE>speed</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>30 November 2006</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>cfsetspeed</FUNCTION> function shall set the input and output speeds in 
<PARAMETER>t</PARAMETER> to the value specified by <PARAMETER>speed</PARAMETER>.
The effects of the 
function on the terminal as described below do not become effective, 
nor are all errors detected, until the <FUNCTION>tcsetattr</FUNCTION> 
function is called. Certain values for baud rates set in 
<STRUCTNAME>termios</STRUCTNAME> and passed to 
<FUNCTION>tcsetattr</FUNCTION> have special meanings.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
Invalid <parameter>speed</parameter> argument
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<refentry id="baselib-clearerr-unlocked-1">

<refmeta>
<refentrytitle>clearerr_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>clearerr_unlocked</refname>
<refpurpose>non-thread-safe clearerr</refpurpose>
<indexterm id="ix-baselib-clearerr-unlocked-1">
  <primary>clearerr_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>clearerr_unlocked</function> is the same as
<function>clearerr</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-daemon-3"> <REFMETA>
<REFENTRYTITLE>daemon</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>daemon</REFNAME>
<REFPURPOSE>
run in the background
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>daemon</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>nochdir</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>noclose</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>daemon</FUNCTION> function shall create a new process,
detached from the controlling terminal. If successful, the calling process
shall exit and the new process shall continue to execute the application
in the background.
If <PARAMETER>nochdir</PARAMETER> evaluates to true, the current directory
shall not be changed. Otherwise, 
<FUNCTION>daemon</FUNCTION> shall change the current working directory 
to the root (`/'). If <PARAMETER>noclose</PARAMETER> evaluates to true
the standard input, standard output, and standard error file
descriptors shall not be altered. Otherwise,
<FUNCTION>daemon</FUNCTION> shall close
the standard input, standard output and standard error file descriptors
and reopen them attached to 
<FILENAME>/dev/null</FILENAME>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On error, <RETURNVALUE>-1</RETURNVALUE> is returned, and the global 
variable <VARNAME>errno</VARNAME> is set to any of the errors 
specified for the library functions <FUNCTION>fork</FUNCTION> and 
<FUNCTION>setsid</FUNCTION>.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-dcgettext"> <REFMETA>
<REFENTRYTITLE>dcgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dcgettext</REFNAME>
<REFPURPOSE>
perform domain and category specific lookup in message catalog
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
#include &lt;locale.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>dcgettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>category</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>dcgettext</FUNCTION> function
is a domain specified version 
of <FUNCTION>gettext</FUNCTION>.
</PARA>
<PARA>
The <function>dcgettext</function>
function shall lookup the translation in the current locale of the message
identified by <parameter>msgid</parameter> in the domain specified by 
<parameter>domainname</parameter> and in the locale
category specified by <parameter>category</parameter>. 
If <parameter>domainname</parameter> is NULL, the current default
domain shall be used. 
The <parameter>msgid</parameter> argument shall be a NULL-terminated 
string to be
matched in the catalogue. 
<parameter>category</parameter> shall specify the locale category to be used
for retrieving message strings. 
The category parameter shall be one of <parameter>LC_CTYPE</parameter>,
<parameter>LC_COLLATE</parameter>, 
<parameter>LC_MESSAGES</parameter>, 
<parameter>LC_MONETARY</parameter>,
<parameter>LC_NUMERIC</parameter>, 
or <parameter>LC_TIME</parameter>. 
The default domain
shall not be changed by a call to <function>dcgettext</function>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
If a translation was found in one of the specified catalogs, it shall be
converted to the current locale's codeset and returned. The resulting
NULL-terminated string shall be allocated by the dcgettext function, and must
not be modified or freed. If no translation was found, or category was invalid,
<parameter>msgid</parameter> shall be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<FUNCTION>dcgettext</FUNCTION> shall not modify the 
<VARNAME>errno</VARNAME> global variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dcngettext"> <REFMETA>
<REFENTRYTITLE>dcngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dcngettext</REFNAME>
<REFPURPOSE>
perform domain and category specific lookup in message catalog
with plural
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
#include &lt;locale.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>dcngettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid1</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid2</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned long int 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>category</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>dcngettext</FUNCTION> function is a domain specific version of 
gettext, capable of
returning either a singular or plural form of the message. 
The <FUNCTION>dcngettext</FUNCTION>
function shall lookup the translation in the current locale of the message
identified by <PARAMETER>msgid1</PARAMETER>
in the domain specified by <PARAMETER>domainname</PARAMETER>
and in the locale
category specified by <PARAMETER>category</PARAMETER>. 
If <PARAMETER>domainname</PARAMETER> is NULL, the current default
domain shall be used. The <PARAMETER>msgid1</PARAMETER>
argument shall be a NULL-terminated string to
be matched in the catalogue. <PARAMETER>category</PARAMETER>
shall specify the locale category to be
used for retrieving message strings. The <PARAMETER>category</PARAMETER>
parameter shall be one of
<PARAMETER>LC_CTYPE</PARAMETER>, 
<PARAMETER>LC_COLLATE</PARAMETER>, 
<PARAMETER>LC_MESSAGES</PARAMETER>, 
<PARAMETER>LC_MONETARY</PARAMETER>, 
<PARAMETER>LC_NUMERIC</PARAMETER>, or 
<PARAMETER>LC_TIME</PARAMETER>. 
The
default domain shall not be changed by a call to <FUNCTION>dcngettext</FUNCTION>.
If <PARAMETER>n</PARAMETER> is 1 then the
singular version of the message is returned, otherwise one of the plural forms
is returned, depending on the value of <PARAMETER>n</PARAMETER> and the current locale settings.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
If a translation corresponding to the value of <PARAMETER>n</PARAMETER>
was found in one of the
specified catalogs for <PARAMETER>msgid1</PARAMETER>, 
it shall be converted to the current locale's
codeset and returned. The resulting NULL-terminated string 
shall be allocated by
the <FUNCTION>dcngettext</FUNCTION> function, 
and must not be modified or freed. If no translation
was found, or <PARAMETER>category</PARAMETER> was invalid, 
<PARAMETER>msgid1</PARAMETER> shall be returned 
if <PARAMETER>n</PARAMETER> has the value
1, otherwise <PARAMETER>msgid2</PARAMETER> shall be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<FUNCTION>dcngettext</FUNCTION> shall not modify the 
<VARNAME>errno</VARNAME> global variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcgettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dgettext"> <REFMETA>
<REFENTRYTITLE>dgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dgettext</REFNAME>
<REFPURPOSE>
perform lookup in message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>dgettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>dgettext</FUNCTION> is a domain specified version of 
<FUNCTION>gettext</FUNCTION>.
</PARA>
<PARA>
The <FUNCTION>dgettext</FUNCTION> function shall search the currently
selected message catalogs in the domain
<PARAMETER>domainname</PARAMETER> for a string identified by the string
<PARAMETER>msgid</PARAMETER>. If a string is located,
that string shall be returned.
The domain specified by <PARAMETER>domainname</PARAMETER> applies to the 
currently active
<SYMBOL>LC_MESSAGE</SYMBOL> locale. The default domain shall not
be changed by a call to <FUNCTION>dgettext</FUNCTION>.
<NOTE><PARA>
The usage of <PARAMETER>domainanme</PARAMETER> is equivalent in 
syntax and meaning to the <FUNCTION>textdomain</FUNCTION> function's
application of <PARAMETER>domainname</PARAMETER>, except that the 
selection of the domain in <FUNCTION>dgettext</FUNCTION> 
is valid only for the duration of the call.
</PARA></NOTE>

</PARA>
<PARA>
The <FUNCTION>dgettext</FUNCTION> function is equivalent to
<LITERAL>dcgettext(domainname, msgid, LC_MESSAGES)</LITERAL>.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success of a <PARAMETER>msgid</PARAMETER> query, the translated 
<LITERAL>NULL</LITERAL>-terminated string is returned. On error, the 
original <PARAMETER>msgid</PARAMETER> is returned. The length of the
string returned is undetermined until <FUNCTION>dgettext</FUNCTION>
is called.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<FUNCTION>dgettext</FUNCTION> shall not modify the 
<VARNAME>errno</VARNAME> global variable.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-dngettext"> <REFMETA>
<REFENTRYTITLE>dngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dngettext</REFNAME>
<REFPURPOSE>
perform lookup in message catalog for the current locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>dngettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid1</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid2</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned long int 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>dngettext</FUNCTION> shall be equivalent to a call to
<PROGRAMLISTING>dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES)</PROGRAMLISTING>
See <FUNCTION>dcngettext</FUNCTION>
for more information.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<!-- MISSING DEFINITION FOR drand48_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-duplocale-3"> <REFMETA>
<REFENTRYTITLE>duplocale</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>duplocale
</REFNAME>
<REFPURPOSE>
provide new handle for selection of locale
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;locale.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>locale_t
<function>duplocale</function>
</funcdef>
<paramdef>locale_t
<parameter>locale</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>duplocale</function> function shall 
provide a new locale object based on the locale object provided
in <parameter>locale</parameter>, suitable for use in the
<function>newlocale</function> or <function>uselocale</function> functions.
The new object may be released by calling <function>freelocale</function>.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>duplocale</function> function shall return 
a locale object. Otherwise, it shall return
<constant>NULL</constant>, and set <varname>errno</varname>
to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>The <function>duplocale</function> function shall fail if:
<variablelist>
<varlistentry>
<term><errorcode>ENOMEM</errorcode></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>setlocale</function></member>
<member><function>freelocale</function></member>
<member><function>newlocale</function></member>
<member><function>uselocale</function></member>
</simplelist>
</para>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-endutent-3"> <REFMETA>
<REFENTRYTITLE>endutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>endutent</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>endutent</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>endutent</FUNCTION> closes the <FILENAME>utmp</FILENAME> 
file. It should be called when the user code is done accessing the 
file with the other functions.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<!-- MISSING DEFINITION FOR epoll_create -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR epoll_ctl -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR epoll_wait -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR erand48_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-err-3"> <REFMETA>
<REFENTRYTITLE>err</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>err
</REFNAME>
<REFPURPOSE>display formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>err</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>eval</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>fmt</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>err</FUNCTION> function
shall display a formatted error message on the standard
error stream.
First, <function>err</function> shall write
the last component of the program name, a colon
character, and a space character. If <PARAMETER>fmt</PARAMETER> is non-NULL, it shall be used as a
format string for the <FUNCTION>printf</FUNCTION>
family of functions, and <function>err</function> shall
write the formatted message, a
colon character, and a space.
Finally,  the error message
string affiliated with the current value of the global variable 
<VarName>errno</VarName> shall be
written, followed by a newline character.
</PARA>
<PARA>
The <FUNCTION>err</FUNCTION> function shall not return, 
the program shall terminate with the exit value of <PARAMETER>eval</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<FUNCTION>error</FUNCTION>, <FUNCTION>errx</FUNCTION>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-error-n"> <REFMETA>
<REFENTRYTITLE>error</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>error</REFNAME>
<REFPURPOSE>
print error message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>error</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>exitstatus</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>errnum</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>format</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>error</FUNCTION> shall print a message to standard error.
</PARA>
<PARA>
<FUNCTION>error</FUNCTION> shall build the message from the following 
elements in their specified order:
<ORDEREDLIST NUMERATION="ARABIC">
<LISTITEM>
<PARA>
the program name. If the application has provided a function named 
<FUNCTION>error_print_progname</FUNCTION>, <FUNCTION>error</FUNCTION> 
shall call this to supply the program name; 
otherwise, <FUNCTION>error</FUNCTION> 
uses the content of the global variable <VARNAME>program_name</VARNAME>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the colon and space characters, then 
the result of using the printf-style <PARAMETER>format</PARAMETER> 
and the optional arguments.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if <PARAMETER>errnum</PARAMETER> is nonzero, 
<FUNCTION>error</FUNCTION> shall add the colon and 
space characters, then the result of 
<LITERAL>strerror(<VARNAME>errnum</VARNAME>)</LITERAL>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
a newline.
</PARA>
</LISTITEM>
</ORDEREDLIST>
</PARA>
<PARA>
If <PARAMETER>exitstatus</PARAMETER> is nonzero, 
<FUNCTION>error</FUNCTION> shall call
<LITERAL>exit(<VARNAME>exitstatus</VARNAME>)</LITERAL>.
</PARA>
<!-- There's an interaction with wide characters(?): this call makes
stderr narrow-oriented. Should put that in once we figure out what it
means and whether it would be bad in an Asian locale -->
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<FUNCTION>err</FUNCTION>, <FUNCTION>errx</FUNCTION>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-errx-3"> <REFMETA>
<REFENTRYTITLE>errx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>errx
</REFNAME>
<REFPURPOSE>display formatted error message and exit
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>errx</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>eval</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>fmt</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>errx</FUNCTION> function shall display a formatted error message on the 
standard error stream. The last component of the program name, a colon 
character, and a space shall be output. If <PARAMETER>fmt</PARAMETER> is 
non-<LITERAL>NULL</LITERAL>, it shall be used as the format string
for the <FUNCTION>printf</FUNCTION> family of functions, and
the formatted error message, a colon 
character, and a space shall be output. The output shall be followed by a 
newline character.
</PARA>
<PARA>
<FUNCTION>errx</FUNCTION> does not return, but shall exit with the value of 
<PARAMETER>eval</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<FUNCTION>error</FUNCTION>, <FUNCTION>err</FUNCTION>
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-fcntl-3"> <REFMETA>
<REFENTRYTITLE>fcntl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fcntl
</REFNAME>
<REFPURPOSE>
file control
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>fcntl</FUNCTION> is as specified in 
<XREF LINKEND=STD.SUSv3>,
but with differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Implementation may set <CONSTANT>O_LARGEFILE</CONSTANT>
</TITLE>
<PARA>
According to <XREF LINKEND="STD.SUSv3">,
only an application sets
<FUNCTION>fcntl</FUNCTION> flags, for example 
<constant>O_LARGEFILE</constant>. However, this specification
also allows an implementation to set the <constant>O_LARGEFILE</constant> 
flag in the case where the programming environment is one of
<simplelist type=inline>
<member><constant>_POSIX_V6_ILP32_OFFBIG</constant></member>
<member><constant>_POSIX_V6_LP64_OFF64</constant></member>
<member><constant>_POSIX_V6_LPBIG_OFFBIG</constant></member>
</simplelist>. See <command>getconf</command> and <command>c99</command>
in <xref linkend="std.SUSv3">
for a description of these environments.
Thus, calling <FUNCTION>fcntl</FUNCTION> with the 
<PARAMETER>F_GETFL</PARAMETER> command may return 
<constant>O_LARGEFILE</constant> as well as flags explicitly 
set by the application in the case that both the implementation and 
the application support an <type>off_t</type> of at least 64 bits.
</para>
</REFSECT2>


<REFSECT2>
<TITLE>Additional flags</TITLE>
<PARA>
In addition to the available values for <PARAMETER>cmd</PARAMETER>, as documented in <XREF LINKEND=STD.SUSv3>, this specification permits the following constants.
</PARA>
<PARA>
<CONSTANT>F_GETSIG</CONSTANT> shall get the number of the signal to be sent when input or output can occur. If the value is <LITERAL>0</LITERAL>, then <CONSTANT>SIGIO</CONSTANT> shall be sent. Otherwise, the value retrieved shall be the signal sent, and the signal handler can discover more information when installed with the <CONSTANT>SA_SIGINFO</CONSTANT> flag.
</PARA>
<PARA>
<CONSTANT>F_SETSIG</CONSTANT> shall set the number of the signal to be sent when input or output can occur. If the value is <LITERAL>0</LITERAL>, then <CONSTANT>SIGIO</CONSTANT> shall be sent. Otherwise, the value set shall be the signal to be sent, and the signal handler can discover more information when installed with the <CONSTANT>SA_SIGINFO</CONSTANT> flag.
</PARA>
<PARA>
<CONSTANT>F_GETLK64</CONSTANT> is analogous to the <CONSTANT>F_GETLK</CONSTANT> constant in <XREF LINKEND=STD.SUSv3>, but shall provide a 64-bit interface on non-64-bit architectures. It is identical to <CONSTANT>F_GETLK</CONSTANT> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.
</PARA>
<PARA>
<CONSTANT>F_SETLK64</CONSTANT> is analogous to the <CONSTANT>F_SETLK</CONSTANT> constant in <XREF LINKEND=STD.SUSv3>, but shall provide a 64-bit interface on non-64-bit architectures. It is identical to <CONSTANT>F_SETLK</CONSTANT> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.
</PARA>
<PARA>
<CONSTANT>F_SETLKW64</CONSTANT> is analogous to the <CONSTANT>F_SETLKW</CONSTANT> constant in <XREF LINKEND=STD.SUSv3>, but provides a 64-bit interface on non-64-bit architectures. It is identical to <CONSTANT>F_SETLKW</CONSTANT> on a 64-bit machine, but is provided in 64-bit environments for source code consistency among architectures.
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<refentry id="baselib-feof-unlocked-1">

<refmeta>
<refentrytitle>feof_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>feof_unlocked</refname>
<refpurpose>non-thread-safe feof</refpurpose>
<indexterm id="ix-baselib-feof-unlocked-1">
  <primary>feof_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>feof_unlocked</function> is the same as
<function>feof</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-ferror-unlocked-1">

<refmeta>
<refentrytitle>ferror_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ferror_unlocked</refname>
<refpurpose>non-thread-safe ferror</refpurpose>
<indexterm id="ix-baselib-ferror-unlocked-1">
  <primary>ferror_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>ferror_unlocked</function> is the same as
<function>ferror</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fflush-unlocked-1">

<refmeta>
<refentrytitle>fflush_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fflush_unlocked</refname>
<refpurpose>non thread safe fflush</refpurpose>
<indexterm id="ix-baselib-fflush-unlocked-1">
  <primary>fflush_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fflush_unlocked</function> is the same as
<function>fflush</function> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fgetc-unlocked-1">

<refmeta>
<refentrytitle>fgetc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fgetc_unlocked</refname>
<refpurpose>non-thread-safe fgetc</refpurpose>
<indexterm id="ix-baselib-fgetc-unlocked-1">
  <primary>fgetc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fgetc_unlocked</function> is the same as
<function>fgetc</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fgets-unlocked-1">

<refmeta>
<refentrytitle>fgets_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fgets_unlocked</refname>
<refpurpose>non-thread-safe fgets</refpurpose>
<indexterm id="ix-baselib-fgets-unlocked-1">
  <primary>fgets_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fgets_unlocked</function> is the same as
<function>fgets</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fgetwc-unlocked-1">

<refmeta>
<refentrytitle>fgetwc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fgetwc_unlocked</refname>
<refpurpose>non thread safe fgetwc</refpurpose>
<indexterm id="ix-baselib-fgetwc-unlocked-1">
  <primary>fgetwc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fgetwc_unlocked</function> is the same as
<function>fgetwc</function> except that it need not be thread safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fgetws-unlocked-1">

<refmeta>
<refentrytitle>fgetws_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fgetws_unlocked</refname>
<refpurpose>non-thread-safe fgetws</refpurpose>
<indexterm id="ix-baselib-fgetws-unlocked-1">
  <primary>fgetws_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fgetws_unlocked</function> is the same as
<function>fgetws</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fileno-unlocked-1">

<refmeta>
<refentrytitle>fileno_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fileno_unlocked</refname>
<refpurpose>non-thread-safe fileno</refpurpose>
<indexterm id="ix-baselib-fileno-unlocked-1">
  <primary>fileno_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fileno_unlocked</function> is the same as
<function>fileno</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-flock-2"> <REFMETA>
<REFENTRYTITLE>flock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>flock</REFNAME>
<REFPURPOSE>
apply or remove an advisory lock on an open file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>flock</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>operation</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>flock</FUNCTION> applies or removes an advisory 
lock on the open file <PARAMETER>fd</PARAMETER>. Valid 
<PARAMETER>operation</PARAMETER> types are:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
LOCK_SH
</TERM>
<LISTITEM>
<PARA>
Shared lock. More than one process may hold a shared lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_EX
</TERM>
<LISTITEM>
<PARA>
Exclusive lock. Only one process may hold an exclusive lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_UN
</TERM>
<LISTITEM>
<PARA>
Unlock.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_NB
</TERM>
<LISTITEM>
<PARA>
Don't block when locking. May be specified (by 
<EMPHASIS>or</EMPHASIS>ing) along with one of 
the other operations.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
A single file may not simultaneously have both shared and exclusive locks.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EWOULDBLOCK
</TERM>
<LISTITEM>
<PARA>
The file is locked and the <LITERAL>LOCK_NB</LITERAL> flag was selected.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>fd</PARAMETER> is not a not an open file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EINTR
</TERM>
<LISTITEM>
<PARA>
While waiting to acquire a lock, the  call  was  interrupted  by
delivery of a signal caught by a handler.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
The operation is invalid.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EWOULDBLOCK
</TERM>
<LISTITEM>
<PARA>
The implementation ran out of memory for allocating lock records.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<refentry id="baselib-fputc-unlocked-1">

<refmeta>
<refentrytitle>fputc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fputc_unlocked</refname>
<refpurpose>non-thread-safe fputc</refpurpose>
<indexterm id="ix-baselib-fputc-unlocked-1">
  <primary>fputc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fputc_unlocked</function> is the same as
<function>fputc</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fputs-unlocked-1">

<refmeta>
<refentrytitle>fputs_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fputs_unlocked</refname>
<refpurpose>non-thread-safe fputs</refpurpose>
<indexterm id="ix-baselib-fputs-unlocked-1">
  <primary>fputs_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fputs_unlocked</function> is the same as
<function>fputs</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fputwc-unlocked-1">

<refmeta>
<refentrytitle>fputwc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fputwc_unlocked</refname>
<refpurpose>non-thread-safe fputwc</refpurpose>
<indexterm id="ix-baselib-fputwc-unlocked-1">
  <primary>fputwc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fputwc_unlocked</function> is the same as
<function>fputwc</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fputws-unlocked-1">

<refmeta>
<refentrytitle>fputws_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fputws_unlocked</refname>
<refpurpose>non-thread-safe fputws</refpurpose>
<indexterm id="ix-baselib-fputws-unlocked-1">
  <primary>fputws_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fputws_unlocked</function> is the same as
<function>fputws</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-fread-unlocked-1">

<refmeta>
<refentrytitle>fread_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fread_unlocked</refname>
<refpurpose>non-thread-safe fread</refpurpose>
<indexterm id="ix-baselib-fread-unlocked-1">
  <primary>fread_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fread_unlocked</function> is the same as
<function>fread</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-freelocale-3"> <REFMETA>
<REFENTRYTITLE>freelocale</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>freelocale
</REFNAME>
<REFPURPOSE>
free a locale object
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;locale.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>freelocale</function>
</funcdef>
<paramdef>locale_t
<parameter>locale</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>freelocale</function> function shall free
the locale object <parameter>locale</parameter>, and release any
resources associated with it.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None defined.</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>setlocale</function></member>
<member><function>newlocale</function></member>
<member><function>duplocale</function></member>
<member><function>uselocale</function></member>
</simplelist>
</para>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-fscanf"> <REFMETA>
<REFENTRYTITLE>fscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>fscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-fstatfs-2"> <REFMETA>
<REFENTRYTITLE>fstatfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fstatfs</REFNAME>
<REFPURPOSE>(deprecated)</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/statfs.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>fstatfs</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct statfs *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>
Description
</TITLE>
<PARA>
The <FUNCTION>fstatfs</FUNCTION> function returns information about a mounted 
file system.  The file system is identified by <PARAMETER>fd</PARAMETER>,
a file descriptor of an open file within the mounted filesystem.
The results are placed in the structure pointed to by
<PARAMETER>buf</PARAMETER>.
</PARA>
<PARA>
Fields that are undefined for a particular file system shall
be set to
<LITERAL>0</LITERAL>.
</PARA>
<NOTE>
<PARA>
Application developers should use the <FUNCTION>fstatvfs</FUNCTION> function
to obtain general file system information. Applications should only
use the <FUNCTION>fstatfs</FUNCTION> function if they must determine
the file system type, which need not be provided by 
<FUNCTION>fstatvfs</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <FUNCTION>fstatfs</FUNCTION> function shall
return <RETURNVALUE>0</RETURNVALUE> and set the fields of the
structure idenfitied by <PARAMETER>buf</PARAMETER> accordingly.
On error, the <FUNCTION>fstatfs</FUNCTION> function shall
return <RETURNVALUE>-1</RETURNVALUE> and set
<VARNAME>errno</VARNAME> accordingly.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>fd</PARAMETER> is not a valid open file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>buf</PARAMETER> points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS
</TERM>
<LISTITEM>
<PARA>
The filesystem <PARAMETER>fd</PARAMETER> is open on does not support 
<FUNCTION>statfs</FUNCTION>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-fstatfs64"> <REFMETA>
<REFENTRYTITLE>fstatfs64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fstatfs64</REFNAME>
<REFPURPOSE>(deprecated)</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/statfs.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>fstatfs64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct statfs64 *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>fstatfs64</FUNCTION> function returns information about a mounted 
file system.  The file system is identified by <PARAMETER>fd</PARAMETER>,
a file descriptor of an open file within the mounted filesystem.
The results are placed in the structure pointed to by
<PARAMETER>buf</PARAMETER>.
</PARA>
<PARA>
Fields that are undefined for a particular file system shall
be set to
<LITERAL>0</LITERAL>.
</PARA>
<PARA>
<FUNCTION>fstatfs64</FUNCTION> is a large-file
version of the <FUNCTION>fstatfs</FUNCTION> function.
</PARA>
<NOTE>
<PARA>
Application developers should use the <FUNCTION>fstatvfs64</FUNCTION> function
to obtain general file system information. Applications should only
use the <FUNCTION>fstatfs64</FUNCTION> function if they must determine
the file system type, which need not be provided by 
<FUNCTION>fstatvfs64</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <FUNCTION>fstatfs64</FUNCTION> function shall
return <RETURNVALUE>0</RETURNVALUE> and set the fields of the
structure idenfitied by <PARAMETER>buf</PARAMETER> accordingly.
On error, the <FUNCTION>fstatfs64</FUNCTION> function shall
return <RETURNVALUE>-1</RETURNVALUE> and set
<VARNAME>errno</VARNAME> accordingly.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>See <FUNCTION>fstatfs</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR futimesat -->
<!-- Lets just hope nobody notices -->
<refentry id="baselib-fwrite-unlocked-1">

<refmeta>
<refentrytitle>fwrite_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>fwrite_unlocked</refname>
<refpurpose>non-thread-safe fwrite</refpurpose>
<indexterm id="ix-baselib-fwrite-unlocked-1">
  <primary>fwrite_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>fwrite_unlocked</function> is the same as
<function>fwrite</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-fwscanf"> <REFMETA>
<REFENTRYTITLE>fwscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>fwscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-getdomainname"> <REFMETA>
<REFENTRYTITLE>getdomainname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getdomainname</REFNAME>
<REFPURPOSE>
get NIS domain name (DEPRECATED).
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>int 
    <FUNCTION>getdomainname</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>char *
    <PARAMETER>name</PARAMETER>
  </PARAMDEF>
  <PARAMDEF>size_t
    <PARAMETER>namelen</PARAMETER>
  </PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>
<para>
If the Network Information System (NIS) is in use, 
<FUNCTION>getdomainname</FUNCTION> shall
copy the NIS domain name to the supplied buffer identified by 
<PARAMETER>name</PARAMETER>,
with maximum length <PARAMETER>namelen</PARAMETER>. 
If the NIS domain name is not currently set, 
<FUNCTION>getdomainname</FUNCTION> shall
copy the string <literal>"(none)"</literal> to the <PARAMETER>name</PARAMETER>.
If <PARAMETER>namelen</PARAMETER> is less than
the length of the string
to be copied, <FUNCTION>getdomainname</FUNCTION>
shall either truncate the string to <PARAMETER>namelen</PARAMETER>
characters and place it in <PARAMETER>name</PARAMETER>
(without a terminating null character),
or shall fail with <errorname>EINVAL</errorname>.
</PARA>
<PARA>
<note><para>
The NIS domain name is not the same as the domain portion of
a fully qualified domain name (for example, in DNS).
</para>
<para>
The LSB does not include other NIS functions, nor does it specify how NIS may
affect other database functions. No conforming application can make use of this information
beyond noting whether or not the domain name has been set. If the name is set to a value
other than the string <literal>"(none)"</literal>, the application should not imply that
NIS is in use. Similarly, if it is set to <literal>"(none)"</literal>, the application should not assume
that NIS is not in use, although NIS functionality may be restricted in this case.
</para></note>
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success,
<FUNCTION>getdomainname</FUNCTION> shall return 
<RETURNVALUE>0</RETURNVALUE>. Otherwise, it shall return
<RETURNVALUE>-1</RETURNVALUE> and set <VARNAME>errno</VARNAME>
to indicate the error.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>name</PARAMETER> is a null pointer.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
The buffer identified by <PARAMETER>name</PARAMETER> and 
<PARAMETER>namelen</PARAMETER> is of insufficient size to store the NIS domain name string, and the implementation considers this an error.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<REFSECT1>
<TITLE>Future Directions</TITLE>
<PARA>
The LSB does not include other NIS interfaces, and a future version
of this specification may remove this interface.
Application developers should avoid using this interface where possible.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-getdtablesize"> <REFMETA>
<REFENTRYTITLE>getdtablesize</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getdtablesize</REFNAME>
<REFPURPOSE>
get file descriptor table size (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>int 
    <FUNCTION>getdtablesize</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>void
  </PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>
<para>
The function <FUNCTION>getdtablesize</FUNCTION> returns
the number of files a process can have open.
</para>
<note><para>
The <function>getdtablesize</function> function is deprecated.
Portable applications should call <function>sysconf</function>
with the <constant>_SC_PAGE_SIZE</constant> option instead.
</para></note>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>getdtablesize</function>
function returns the current soft limit as if obtained by
a call to <function>sysconf</function>
with the <constant>_SC_PAGE_SIZE</constant> option.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<para>
No errors are defined.
</para>
</refsect1>

</REFENTRY>

<!-- MISSING DEFINITION FOR getgrent_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-getgrouplist-3"> <REFMETA>
<REFENTRYTITLE>getgrouplist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getgrouplist
</REFNAME>
<REFPURPOSE>
get groups a user belongs to
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;grp.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>getgrouplist</function>
</funcdef>
<paramdef>const char *
<parameter>user</parameter>
</paramdef>
<paramdef>gid_t
<parameter>group</parameter>
</paramdef>
<paramdef>gid_t *
<parameter>groups</parameter>
</paramdef>
<paramdef>int *
<parameter>ngroups</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<REFSECT1INFO>
<DATE>21 May 2007</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>getgrouplist</function> function shall
fill in the array <parameter>groups</parameter> with 
the supplementary groups for the user specified
by <parameter>user</parameter>. On entry, 
<parameter>ngroups</parameter> shall refer to an integer
containing the maximum number of 
elements in the <parameter>groups</parameter> array.
The group <parameter>group</parameter> shall also be included
in the values returned in <parameter>groups</parameter>.
It is expected that <parameter>group</parameter> would be specified as the
user's primary group from the password file (obtainable
via <function>getpwnam</function> or a similar function).
</PARA>
</REFSECT1>

<REFSECT1><TITLE>Return Value</TITLE>
<PARA>
If on entry the value referenced by <parameter>ngroups</parameter>
was greater than or equal to the number of supplementary
group identifiers to be copied to the array identified by
<parameter>groups</parameter>, 
<function>getgrouplist</function> shall return the number of 
group identifiers actually copied, and shall set the value
referenced by <parameter>ngroups</parameter> to this value.
</PARA>
<PARA>
If on entry the value referenced by <parameter>ngroups</parameter>
was less than the number of supplementary
group identifiers, <function>getgrouplist</function> shall return
<constant>-1</constant>. The initial <parameter>ngroups</parameter>
entries in <parameter>groups</parameter> shall be overwritten.
</PARA>
<PARA>
If the number of groups exceeds the input
<parameter>ngroups</parameter> value, then as well as returning
<constant>-1</constant>, <parameter>ngroups</parameter> shall be set
to the number of groups that would have been placed in
<parameter>groups</parameter> if it had been large enough.

<note>
<para>
In such a case, the caller can use the information returned to make a
further <function>getgrouplist</function> call with a correctly sized
<parameter>groups</parameter> array.
</para>
</note>

</PARA>
<PARA>
If <parameter>user</parameter> does not refer to a valid user on the system,
then the behavior of this function is undefined.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None defined.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<FUNCTION>getgroups</FUNCTION>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gethostbyaddr-r-3"> <REFMETA>
<REFENTRYTITLE>gethostbyaddr_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyaddr_r
</REFNAME>
<REFPURPOSE>
find network host database entry matching host name (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;netdb.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>gethostbyaddr_r</function>
</funcdef>
<paramdef>const void * restrict
<parameter>addr</parameter>
</paramdef>
<paramdef>socklen_t
<parameter>len</parameter>
</paramdef>
<paramdef>int
<parameter>type</parameter>
</paramdef>
<paramdef>struct hostent * restrict
<parameter>result_buf</parameter>
</paramdef>
<paramdef>char * restrict
<parameter>buf</parameter>
</paramdef>
<paramdef>size_t
<parameter>buflen</parameter>
</paramdef>
<paramdef>struct hostent * * restrict
<parameter>result</parameter>
</paramdef>
<paramdef>int *
<parameter>h_errnop</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<TITLE>Description</TITLE>

<note><para>
The <function>gethostbyaddr_r</function> function is deprecated;
applications should use <function>getaddrinfo</function> instead.
</para></note>

<PARA>
<FUNCTION>gethostbyaddr_r</FUNCTION> is a reentrant version of 
<FUNCTION>gethostbyaddr</FUNCTION> that searches the network host 
database for a host address match.
</PARA>
<PARA>
The <function>gethostbyaddr_r</function> function shall search the network host database
for an entry of address family <parameter>type</parameter> with
the host with address <parameter>addr</parameter>. The <parameter>len</parameter> argument contains the length of the address referenced by
<parameter>addr</parameter>. 
</PARA>
<PARA>
If <parameter>type</parameter> is <constant>AF_INET</constant>, the <parameter>addr</parameter> argument shall be an
<structname>in_addr</structname> structure. 
If <parameter>type</parameter> is <constant>AF_INET6</constant>, the <parameter>addr</parameter> argument shall be an
<structname>in6_addr</structname> structure. 
If <parameter>type</parameter> is any other value, the behavior is unspecified.
</PARA>
<PARA>
The application must provide a buffer for the <function>gethostbyaddr_r</function> to use during
the lookup process. The buffer is referenced by <parameter>buf</parameter>, and is of size <parameter>buflen</parameter>.
If the buffer is not of sufficient size, <function>gethostbyaddr_r</function> may fail and return
<errorcode>ERANGE</errorcode>.
If a matching entry is found in the database, <function>gethostbyaddr_r</function> shall
copy the relevant information to the application supplied <structname>hostent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
Additional error information shall be set in the variable referenced by <parameter>h_errnop</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>gethostbyaddr_r</function> function shall return zero. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
If the <function>gethostbyaddr_r</function> function returns returns any other
value, then the variable referenced by <parameter>h_errnop</parameter> shall be set to indicate the cause as
for <function>gethostbyaddr</function>.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gethostbyname2-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname2</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname2
</REFNAME>
<REFPURPOSE>
find network host database entry matching host name (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
<FUNCDEF>int 
<FUNCTION>gethostbyname2</FUNCTION></FUNCDEF>
<PARAMDEF>const char * restrict 
<PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
<PARAMDEF>int
<PARAMETER><REPLACEABLE>af</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description</TITLE>

<note><para>
The <function>gethostbyname2</function> function is deprecated;
applications should use <function>getaddrinfo</function> instead.
</para></note>

<PARA>
The <function>gethostbyname2</function> function shall search the
network host database for an entry with name <parameter>name</parameter>.
This function is similar to the <function>gethostbyname</function>
function but additionally allows the search to be restricted to
a particular address family specified by <parameter>af</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>gethostbyname2</function> function shall return a
pointer to a <structname>hostent</structname> structure if the requested entry was
found, and a null pointer otherwise.
</PARA>
<PARA>
On unsuccessful completion, <function>gethostbyname2</function> shall
set <varname>h_errno</varname> as
for <function>gethostbyname</function> in <XREF LINKEND="std.SUSv3">.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
The <function>gethostbyname2</function> shall set <varname>h_errno</varname>
as for <function>gethostbyname</function> in <XREF LINKEND="std.SUSv3">.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gethostbyname2-r-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname2_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname2_r
</REFNAME>
<REFPURPOSE>
find network host database entry matching host name (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>gethostbyname2_r</FUNCTION></FUNCDEF>
 <PARAMDEF>const char * restrict 
  <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int
  <PARAMETER><REPLACEABLE>af</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct hostent * restrict 
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char * restrict  
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>buflen</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct hostent ** restrict <PARAMETER>result</PARAMETER></PARAMDEF>
 <PARAMDEF>int * restrict 
  <PARAMETER><REPLACEABLE>h_errnop</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description</TITLE>

<note><para>
The <function>gethostbyname2_r</function> function is deprecated;
applications should use <function>getaddrinfo</function> instead.
</para></note>

<PARA>
The <function>gethostbyname2_r</function> function shall search the
network host database for an entry with name <parameter>name</parameter>.
<FUNCTION>gethostbyname2_r</FUNCTION> is a reentrant version of 
<FUNCTION>gethostbyname2</FUNCTION>.  These functions are similar to
the <FUNCTION>gethostbyname</FUNCTION> and 
<FUNCTION>gethostbyname_r</FUNCTION> functions but additionally
allow the search to be restricted to a particular address family
specified by <parameter>af</parameter>.
</PARA>
<PARA>
The application must provide a buffer for the <function>gethostbyname2_r
</function> function to use during the lookup process. The buffer is referenced
by <parameter>buf</parameter>, and is of size <parameter>buflen</parameter>.
If the buffer is not of sufficient size, <function>gethostbyname_r</function>
may fail and return <errorcode>ERANGE</errorcode>.
If a matching entry is found in the database, 
<function>gethostbyname_r</function> shall
copy the relevant information to the application-supplied
<structname>hostent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this
structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall
be set to a null pointer.
Additional error information shall be set in the variable referenced
by <parameter>h_errnop</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>gethostbyname2_r</function> function shall
return zero. If the return value was <errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated
by <parameter>buflen</parameter>, was too small.
If the <function>gethostbyname2_r</function> function returns returns any other
value, then the variable referenced by <parameter>h_errnop</parameter>
shall be set to indicate the cause as for <function>gethostbyname_r</function>.
</PARA>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gethostbyname-r-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname_r
</REFNAME>
<REFPURPOSE>
find network host database entry matching host name (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>gethostbyname_r</FUNCTION></FUNCDEF>
 <PARAMDEF>const char * restrict 
  <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct hostent * restrict 
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char * restrict  
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>buflen</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct hostent ** restrict <PARAMETER>result</PARAMETER></PARAMDEF>
 <PARAMDEF>int * restrict 
  <PARAMETER><REPLACEABLE>h_errnop</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description</TITLE>

<note><para>
The <function>gethostbyname_r</function> function is deprecated;
applications should use <function>getaddrinfo</function> instead.
</para></note>

<PARA>
<FUNCTION>gethostbyname_r</FUNCTION> is a reentrant version of 
<FUNCTION>gethostbyname</FUNCTION> that searches the network host 
database for a host name match.
</PARA>
<PARA>
The <function>gethostbyname_r</function> function shall search the network host database
for an entry with name <parameter>name</parameter>.
</PARA>
<PARA>
The application must provide a buffer for the <function>gethostbyname_r</function> to use during
the lookup process. The buffer is referenced by <parameter>buf</parameter>, and is of size <parameter>buflen</parameter>.
If the buffer is not of sufficient size, <function>gethostbyname_r</function> may fail and return
<errorcode>ERANGE</errorcode>.
If a matching entry is found in the database, <function>gethostbyname_r</function> shall
copy the relevant information to the application supplied <structname>hostent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
Additional error information shall be set in the variable referenced by <parameter>h_errnop</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>gethostbyname_r</function> function shall return zero. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
If the <function>gethostbyname_r</function> function returns returns any other
value, then the variable referenced by <parameter>h_errnop</parameter> shall be set to indicate the cause as
for <function>gethostbyname</function>.
</PARA>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-getloadavg-3"> <REFMETA>
<REFENTRYTITLE>getloadavg</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getloadavg
</REFNAME>
<REFPURPOSE>
get system load averages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdlib.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>getloadavg</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>loadavg</REPLACEABLE>[]</PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>nelem</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>getloadavg</FUNCTION> returns the number of processes in 
the system run queue averaged over various periods of time. Up to 
<PARAMETER>nelem</PARAMETER> samples are retrieved and assigned to 
successive elements of <PARAMETER>loadavg</PARAMETER>[]. The system 
imposes a maximum of <LITERAL>3</LITERAL> samples, representing 
averages over the last <LITERAL>1</LITERAL>, <LITERAL>5</LITERAL>, 
and <LITERAL>15</LITERAL> minutes, respectively.
</PARA>
</REFSECT1>
<!--     BSDI BSD/OS                      June 4, 1993       -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="libutil-getopt-3"> <REFMETA>
<REFENTRYTITLE>getopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getopt-3"><PRIMARY>getopt</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>getopt</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>argc</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * const 
  <PARAMETER><REPLACEABLE>argv</REPLACEABLE>[]</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>optstring</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
<SYNOPSIS>
extern char <VARNAME>*optarg</VARNAME>;
extern int <VARNAME>optind</VARNAME>, <VARNAME>opterr</VARNAME>, <VARNAME>optopt</VARNAME>;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getopt</FUNCTION> function shall parse command line arguments
as described in <XREF LINKEND=STD.SUSv3>, with the following exceptions,
where LSB and POSIX specifications vary.
LSB systems shall
implement the modified behaviors described below.
</PARA>
<REFSECT2>
<TITLE>Argument Ordering</TITLE>
<PARA>
The <function>getopt</function> function can process command line arguments
referenced by <parameter>argv</parameter> in one of three ways:
<VARIABLELIST>
<VARLISTENTRY>
<TERM>PERMUTE</TERM><LISTITEM><PARA>the order of arguments in
<parameter>argv</parameter> is altered so that all options (and
their arguments) are moved in front of all of the operands.
This is the default behavior.
<NOTE><PARA>This behavior has undefined results if 
<PARAMETER>argv</PARAMETER> is not modifiable. This is to support
historic behavior predating the use of <token>const</token> and
<XREF LINKEND=STD.ISOC99>. The function prototype was aligned
with <XREF LINKEND=STD.SUSv3> despite the fact that it modifies
<PARAMETER>argv</PARAMETER>, 
and the library maintainers are unwilling to change this.
</PARA></NOTE>
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>REQUIRE_ORDER</TERM><LISTITEM><PARA>The arguments in
<parameter>argv</parameter> are processed in exactly the order
given, and option processing stops when the first non-option argument
is reached, or when the element of argv is "--". This ordering
can be enforced either by setting the environment variable
<VARNAME>POSIXLY_CORRECT</VARNAME>, or by setting the first character
of <parameter>optstring</parameter> to '+'.
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>RETURN_IN_ORDER</TERM><LISTITEM><PARA>The order of arguments
is not altered, and all arguments are processed. Non-option arguments
(operands) are handled as if they were the argument to an option with
the value 1 ('\001'). This ordering is selected by setting the first
character of <parameter>optstring</parameter> to '-';
</PARA></LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Option Characteristics</TITLE>
<PARA>
<EMPHASIS>LSB</EMPHASIS> specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
an element of <PARAMETER>argv</PARAMETER> that starts with 
"<TOKEN>-</TOKEN>" (and is not exactly "<TOKEN>-</TOKEN>" or 
"<TOKEN>--</TOKEN>") is an option element.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
characters of an option element, aside from the initial 
"<TOKEN>-</TOKEN>", are option characters.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
<EMPHASIS>POSIX</EMPHASIS> specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
applications using <FUNCTION>getopt</FUNCTION> shall obey the following 
syntax guidelines:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
option name is a single alphanumeric character from the portable character set
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
option is preceded by the '<TOKEN>-</TOKEN>' delimiter character
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
options without option-arguments should be accepted when grouped behind 
one '<TOKEN>-</TOKEN>' delimiter
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
each option and option-argument is a separate argument
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
option-arguments are not optional
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
all options should precede operands on the command line
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the argument "<TOKEN>--</TOKEN>" is accepted as a delimiter 
indicating the end of options and the consideration of subsequent 
arguments, if any, as operands
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
historical implementations of <FUNCTION>getopt</FUNCTION> support 
other characters as options as an allowed extension, but applications 
that use extensions are not maximally portable.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
support for multi-byte option characters is only possible when such 
characters can be represented as type <LITERAL>int</LITERAL>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
applications that call any utility with a first operand starting with 
'<TOKEN>-</TOKEN>' should usually specify "<TOKEN>--</TOKEN>" 
to mark the end of the options. Standard utilities that do not support 
this guideline indicate that fact in the OPTIONS section of the utility 
description.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Extensions</TITLE>
<PARA>
<EMPHASIS>LSB</EMPHASIS> specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if a character is followed by two colons, the option takes an optional 
argument; if there is text in the current <PARAMETER>argv</PARAMETER> element, 
it is returned in <PARAMETER>optarg</PARAMETER>, otherwise 
<PARAMETER>optarg</PARAMETER> is set to <LITERAL>0</LITERAL>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if <PARAMETER>optstring</PARAMETER> contains <LITERAL>W</LITERAL> followed 
by a semi-colon (<TOKEN>;</TOKEN>),
then <LITERAL>-W foo</LITERAL> is treated as the 
long option <LITERAL>--foo</LITERAL>. 
<NOTE><PARA>See <function>getopt_long</function> for a description
of long options.</PARA></NOTE>
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The first character of <PARAMETER>optstring</PARAMETER> shall modify 
the behavior of <FUNCTION>getopt</FUNCTION> as follows:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if the first character is '+', then 
<CONSTANT>REQUIRE_ORDER</CONSTANT> processing shall be in
effect (see above)
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if the first character is '-', then 
<CONSTANT>RETURN_IN_ORDER</CONSTANT> processing shall be in
effect (see above)
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if the first character is ':', then 
<FUNCTION>getopt</FUNCTION> shall return ':' instead of '?'
to indicate a missing option argument, and shall not print any
diagnostic message to <VARNAME>stderr</VARNAME>.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
<EMPHASIS>POSIX</EMPHASIS> specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the <OPTION>-W</OPTION> option is reserved for implementation extensions.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Return Values</TITLE>
<PARA>
<EMPHASIS>LSB</EMPHASIS> specifies the following additional
<FUNCTION>getopt</FUNCTION> return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
<RETURNVALUE>'\001'</RETURNVALUE> is returned
if <CONSTANT>RETURN_IN_ORDER</CONSTANT> argument ordering is in effect,
and the next argument is an operand, not an option. The argument is
available in <varname>optarg</varname>.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
Any other return value has the same meaning as for
<EMPHASIS>POSIX</EMPHASIS>.
</PARA>
<PARA>
<EMPHASIS>POSIX</EMPHASIS> specifies the following 
<FUNCTION>getopt</FUNCTION> return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
'<RETURNVALUE>:</RETURNVALUE>' is returned if a parameter is missing for 
one of the options and the first character of <VARNAME>optstring</VARNAME> is 
'<TOKEN>:</TOKEN>'.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
'<RETURNVALUE>?</RETURNVALUE>' is returned if an unknown option 
character not in <VARNAME>optstring</VARNAME> is encountered, or if 
<FUNCTION>getopt</FUNCTION> detects a missing argument and the first 
character of <VARNAME>optstring</VARNAME> is not '<TOKEN>:</TOKEN>'.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
<RETURNVALUE>-1</RETURNVALUE> is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environment Variables</TITLE>
<PARA>
<EMPHASIS>LSB</EMPHASIS> specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if the variable <VARNAME>POSIXLY_CORRECT</VARNAME> is set, option 
processing stops as soon as a non-option argument is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the variable <VARNAME>_<replaceable>[PID]</replaceable>_GNU_nonoption_argv_flags_</VARNAME>
(where <replaceable>[PID]</replaceable> is the process ID for the 
current process), contains a space separated list of arguments that should
not be treated as arguments even though they appear to be so.
<NOTE><TITLE>Rationale</TITLE><PARA>
This was 
used by bash 2.0 to communicate to <EMPHASIS>GNU</EMPHASIS> libc which 
arguments resulted from wildcard expansion and so should not be 
considered as options. This behavior was removed in bash version 
2.01, but the support remains in <EMPHASIS>GNU</EMPHASIS> libc.
</PARA></NOTE>
This behavior is DEPRECATED in this version of the LSB; future revisions
of this specification may not include this requirement.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-getopt-long-3"> <REFMETA>
<REFENTRYTITLE>getopt_long</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _GNU_SOURCE
#include &lt;getopt.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>getopt_long</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>argc</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * const 
  <PARAMETER><REPLACEABLE>argv</REPLACEABLE>[]</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>opstring</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const struct option *
  <PARAMETER>longopts</PARAMETER></PARAMDEF>
 <PARAMDEF>int *
  <PARAMETER><REPLACEABLE>longindex</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>getopt_long</FUNCTION> works like <FUNCTION>getopt</FUNCTION> 
except that it also accepts long options, started out by two dashes. 
Long option names may be abbreviated if the abbreviation is unique or 
is an exact match for some defined option. A long option may take a 
parameter, of the form <LITERAL>--arg=param</LITERAL> or 
<LITERAL>--arg param</LITERAL>.
</PARA>
<PARA>
<PARAMETER>longopts</PARAMETER> is a pointer to the first element of an 
array of struct <STRUCTNAME>option</STRUCTNAME> declared in 
<FILENAME>getopt.h</FILENAME> as:
<SYNOPSIS>
  struct option {
             const char *name;
             int has_arg;
             int *flag;
             int val;
  };
</SYNOPSIS>
</PARA>
<PARA>
The fields in this structure have the following meaning:
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>name</STRUCTFIELD></TERM>
<LISTITEM><PARA>The name of the long option.</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>has_arg</STRUCTFIELD></TERM>
<LISTITEM><PARA>
One of: 
<SIMPLELIST>
<MEMBER>
<constant>no_argument</constant> (or 0) if the option does not take an argument,
</MEMBER>
<MEMBER>
<constant>required_argument</constant> (or 1) if the option requires an argument,  or
</MEMBER>
<MEMBER>
<constant>optional_argument</constant>  (or  2) if the option takes an optional argument.
</MEMBER>
</SIMPLELIST>
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>flag</STRUCTFIELD></TERM>
<LISTITEM><PARA>
specifies how results are returned for a long option.   
If  flag
is  <constant>NULL</constant>,  then  
<function>getopt_long</function> shall return <structfield>val</structfield>.
(For example, the
calling program may set val to the equivalent short option character.)
Otherwise, <function>getopt_long</function> returns 
<RETURNVALUE>0</RETURNVALUE>, and <structfield>flag</structfield> shall point to
a variable which shall be set to <structfield>val</structfield>
if the option is found, but left unchanged if the option is not found.
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>val</STRUCTFIELD></TERM>
<LISTITEM><PARA>The value to return, or to load into the variable pointed to
by flag.
</PARA></LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
<PARA>
If <PARAMETER>longindex</PARAMETER> is not <constant>NULL</constant>,
it points to a variable which is set to the index of the long option
relative to <PARAMETER>longopts</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>getopt_long</FUNCTION> returns the option character if a short 
option was found successfully, or "<RETURNVALUE>:</RETURNVALUE>" if 
there was a missing parameter for one of the options, or 
"<RETURNVALUE>?</RETURNVALUE>" for an unknown option character, or 
<RETURNVALUE>-1</RETURNVALUE> for the end of the option list.
</PARA>
<PARA>
For a long option, 
<function>getopt_long</function> returns <structfield>val</structfield> 
if <structfield>flag</structfield> is <LITERAL>NULL</LITERAL>, and <RETURNVALUE>0</RETURNVALUE> 
otherwise. Error and <RETURNVALUE>-1</RETURNVALUE> returns are the 
same as for <FUNCTION>getopt</FUNCTION>, plus 
"<RETURNVALUE>?</RETURNVALUE>" for an ambiguous match or an 
extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getopt-long-only-3"> <REFMETA>
<REFENTRYTITLE>getopt_long_only</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long_only</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _GNU_SOURCE
#include &lt;getopt.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>getopt_long_only</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>argc</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * const 
  <PARAMETER><REPLACEABLE>argv</REPLACEABLE>[]</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>optstring</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const struct option *
  <PARAMETER>longopts</PARAMETER></PARAMDEF>
 <PARAMDEF>int *
  <PARAMETER><REPLACEABLE>longindex</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>getopt_long_only</FUNCTION> is like 
<FUNCTION>getopt_long</FUNCTION>, but "<TOKEN>-</TOKEN>" as well as 
"<TOKEN>--</TOKEN>" can indicate a long option. If an option that 
starts with "<TOKEN>-</TOKEN>" (not "<TOKEN>--</TOKEN>") doesn't 
match a long option, but does match a short option, it is parsed as 
a short option instead.
</PARA>
<note><para>
The <function>getopt_long_only</function> function is intended only
for supporting certain programs whose command line syntax was designed
before the Utility Syntax Guidelines of <xref linkend="STD.SUSv3" >
were developed.  New programs should generally call
<function>getopt_long</function> instead, which provides the --option
syntax for long options, which is preferred by GNU and consistent with
<xref linkend="STD.SUSv3" >.
</para></note>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>getopt_long_only</FUNCTION> returns the option character if the 
option was found successfully, or "<RETURNVALUE>:</RETURNVALUE>" if 
there was a missing parameter for one of the options, or 
"<RETURNVALUE>?</RETURNVALUE>" for an unknown option character, or 
<RETURNVALUE>-1</RETURNVALUE> for the end of the option list.
</PARA>
<PARA>
<FUNCTION>getopt_long_only</FUNCTION> also returns the option character 
when a short option is recognized. For a long option, they return val 
if flag is <LITERAL>NULL</LITERAL>, and <RETURNVALUE>0</RETURNVALUE> 
otherwise. Error and <RETURNVALUE>-1</RETURNVALUE> returns are the 
same as for <FUNCTION>getopt</FUNCTION>, plus 
"<RETURNVALUE>?</RETURNVALUE>" for an ambiguous match or an 
extraneous parameter.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getpagesize"> <REFMETA>
<REFENTRYTITLE>getpagesize</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getpagesize</REFNAME>
<REFPURPOSE>
get memory page size (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>int 
    <FUNCTION>getpagesize</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>void
  </PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>
<para>
The function <FUNCTION>getpagesize</FUNCTION> returns
the number of bytes in a meory page.
</para>
<note><para>
The <function>getpagesize</function> function is deprecated.
Portable applications should use
<literal>sysconf</literal>(<constant>_SC_PAGE_SIZE</constant>) instead.
</para></note>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>getpagesize</function>
function returns the current page size.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<para>
No errors are defined.
</para>
</refsect1>

</REFENTRY>

<REFENTRY ID="baselib-getprotobyname-r"> <REFMETA>
<REFENTRYTITLE>getprotobyname_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotobyname_r
</REFNAME>
<REFPURPOSE>
retrieve information from the network protocol database by protocol name, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>

<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getprotobyname_r</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER>name</PARAMETER></PARAMDEF>
 <PARAMDEF>struct protoent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct protoent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>

</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getprotobyname_r</FUNCTION> function is a reentrant version 
of the <FUNCTION>getprotobyname</FUNCTION> function.
</PARA>
<PARA>
The <function>getprotobyname_r</function> function shall search the network protocol database
for an entry with the name <parameter>name</parameter>.
</PARA>
<para>
If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>protoent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>protoent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>getprotobyname_r</function> function 
shall return <LITERAL>0</LITERAL>. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, 
indicated by <parameter>buflen</parameter>, was too small.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-getprotobynumber-r"> <REFMETA>
<REFENTRYTITLE>getprotobynumber_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotobynumber_r
</REFNAME>
<REFPURPOSE>
retrieve information from the network protocol database by protocol number, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getprotobynumber_r</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>proto</PARAMETER></PARAMDEF>
 <PARAMDEF>struct protoent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct protoent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getprotobynumber_r</FUNCTION> function 
is a reentrant version of the <FUNCTION>getprotobynumber</FUNCTION> function.
</PARA>
<PARA>
The <function>getprotobynumber_r</function> function shall search the network protocol database
for an entry with protocol number <parameter>proto</parameter>.
</PARA>
<para>
If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>protoent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>protoent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>getprotobynumber_r</function> function shall return <LITERAL>0</LITERAL>. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
</PARA>
</REFSECT1>


</REFENTRY>

<REFENTRY ID="baselib-getprotoent-r"> <REFMETA>
<REFENTRYTITLE>getprotoent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotoent_r
</REFNAME>
<REFPURPOSE>
read the next entry of the protocol database, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getprotoent_r</FUNCTION></FUNCDEF>
 <PARAMDEF>struct protoent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct protoent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getprotoent_r</FUNCTION> function 
is a reentrant version of the <FUNCTION>getprotoent</FUNCTION> function.
</PARA>

<PARA>
The <function>getprotoent_r</function> function shall search the network protocol database
for the next entry.
</PARA>
<para>
If the next entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>protoent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no next entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>protoent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>getprotoent_r</function> function shall return zero. 
</para>
<para>
If the return value was 
<errorcode>ENOENT</errorcode>,
there were no more entries in the database.
</para>
<para>
If the return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
</PARA>

</REFSECT1>


</REFENTRY>

<!-- MISSING DEFINITION FOR getpwent_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-getservbyname-r"> <REFMETA>
<REFENTRYTITLE>getservbyname_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservbyname_r
</REFNAME>
<REFPURPOSE>
retrieve information from the network services database by service name, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getservbyname_r</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER>name</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER>proto</PARAMETER></PARAMDEF>
 <PARAMDEF>struct servent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct servent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getservbyname_r</FUNCTION> function is a reentrant version of the 
<FUNCTION>getservbyname</FUNCTION> function. 
</PARA>
<PARA>
The <function>getservbyname_r</function> function shall search the network services database
for an entry with the name <parameter>name</parameter>.
The <PARAMETER>proto</PARAMETER> parameter 
shall restrict the search to entries with the specified protocol. 
If <PARAMETER>proto</PARAMETER> is <LITERAL>NULL</LITERAL>, 
<FUNCTION>getservbyname_r</FUNCTION> may return entries with any protocol.
</PARA>
<para>
If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>servent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>servent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>getservbyname_r</function> function shall return zero. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
</PARA>
</REFSECT1>


</REFENTRY>

<REFENTRY ID="baselib-getservbyport-r"> <REFMETA>
<REFENTRYTITLE>getservbyport_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservbyport_r
</REFNAME>
<REFPURPOSE>
retrieve information from the network services database by service port, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getservbyport_r</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>port</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER>proto</PARAMETER></PARAMDEF>
 <PARAMDEF>struct servent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct servent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getservbyport_r</FUNCTION> function is a reentrant version 
of the <FUNCTION>getservbyport</FUNCTION> function.
</PARA>
<PARA>
The <function>getservbyport_r</function> function shall search the network services database
for an entry with the port <parameter>port</parameter>.
The <PARAMETER>proto</PARAMETER> parameter 
shall restrict the search to entries with the specified protocol. 
If <PARAMETER>proto</PARAMETER> is <LITERAL>NULL</LITERAL>, 
<FUNCTION>getservbyport_r</FUNCTION> may return entries with any protocol.
</PARA>
<para>
If a matching entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>servent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no matching entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>servent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>getservbyport_r</function> function shall return zero. If the 
return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
</PARA>
</REFSECT1>


</REFENTRY>

<REFENTRY ID="baselib-getservent-r"> <REFMETA>
<REFENTRYTITLE>getservent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservent_r
</REFNAME>
<REFPURPOSE>
read the next entry of the network services database, reentrantly
</REFPURPOSE>
</REFNAMEDIV>


<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;netdb.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>getservent_r</FUNCTION></FUNCDEF>
 <PARAMDEF>struct servent *
  <PARAMETER>result_buf</PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>buflen</PARAMETER></PARAMDEF>
 <PARAMDEF>struct servent * *
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getservent_r</FUNCTION> function is a reentrant version of the <FUNCTION>getservent</FUNCTION> function.
</PARA>

<PARA>
The <function>getservent_r</function> function shall search the network services database
for the next entry.
</PARA>
<para>
If the next entry is found in the database, this function shall
copy the relevant information to the application-supplied <structname>servent</structname> structure referenced by 
<parameter>result_buf</parameter>, and return a pointer to this structure in *<parameter>result</parameter>.
If no next entry is found, *<parameter>result</parameter> shall be set to a null pointer.
</PARA>
<para>
The array <parameter>buf</parameter> shall contain the string fields 
referenced by the <structname>servent</structname> structure that
was returned. The parameter <parameter>buflen</parameter> 
shall specify the array's size. 1024 bytes should be enough
for most uses.
</para>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>

<PARA>
On success, the <function>getservent_r</function> function shall return <LITERAL>0</LITERAL>. 
</para>
<para>
If the return value was 
<errorcode>ENOENT</errorcode>,
there were no more entries in the database.
</para>
<para>
If the return value was 
<errorcode>ERANGE</errorcode>,
the size of the buffer <parameter>buf</parameter>, indicated by <parameter>buflen</parameter>, was too small.
</PARA>

</REFSECT1>

</REFENTRY>

<refentry id="baselib-getsockopt-1">

<refmeta>
<refentrytitle>getsockopt</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>getsockopt</refname>
<refpurpose>get socket options</refpurpose>
<indexterm id="ix-baselib-getsockopt-1">
  <primary>getsockopt</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>getsockopt</function>
</funcdef>
<paramdef>int
<parameter>socket</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>int
<parameter>option_name</parameter>
</paramdef>
<paramdef>void * restrict
<parameter>option_value</parameter>
</paramdef>
<paramdef>socklen_t * restrict
<parameter>option_len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
The <function>getsockopt</function> function shall behave as specified in 
<CITETITLE><XREF LINKEND="STD.SUSV3"></CITETITLE>, 
with the following extensions.
</para>

<refsect2>
<title>IP Protocol Level Options</title>
<para>
If the <parameter>level</parameter> parameter is 
<constant>IPPROTO_IP</constant>, the following values shall be supported for
<parameter>option_name</parameter> (see <xref linkend="std.rfc791"> for
further details):
<variablelist>
<varlistentry>
<term><constant>IP_OPTIONS</constant></term>
<listitem><para>
Get the Internet Protocol options sent with
every packet from this socket. 
The <parameter>option_value</parameter> shall point to a
memory buffer in which the options shall be placed; 
on entry <parameter>option_len</parameter> shall point to an integer value
indicating the maximum size of the memory buffer, in bytes. On successful
return, the value referenced by <parameter>option_len</parameter> shall
be updated to the size of data copied to the buffer. For IPv4, the
maximum length of options is 40 bytes.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>IP_TTL</constant></term>
<listitem><para>
Get the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <parameter>option_value</parameter> shall point to a buffer large
enough to hold the time to live value (at least 1 byte),
and <parameter>option_len</parameter>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <parameter>option_len</parameter> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <parameter>option_value</parameter>
shall point to an integer containing the time to live value.
</para></listitem>
</varlistentry>

<varlistentry>
<term><constant>IP_TOS</constant></term>
<listitem><para>
Get the Internet Protocol type of service indicator
used when sending packets with this socket.
The <parameter>option_value</parameter> shall point to a buffer large
enough to hold the type of service indicator (at least 1 byte),
and <parameter>option_len</parameter>
shall point to an integer value holding the maximum size of that buffer.
On successful return, the value
referenced by <parameter>option_len</parameter> shall be updated
to contain the number of bytes copied into the buffer, which shall be no
larger than the initial value,
and <parameter>option_value</parameter>
shall point to an integer containing the time to live value.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect2>

</refsect1>
</refentry>

<REFENTRY ID="baselib-gettext"> <REFMETA>
<REFENTRYTITLE>gettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gettext</REFNAME>
<REFPURPOSE>
search message catalogs for a string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>gettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description</TITLE>
<PARA>
The <FUNCTION>gettext</FUNCTION> function shall search the currently 
selected message catalogs for a string identified by the string
<PARAMETER>msgid</PARAMETER>. If a string is located, 
that string shall be returned.
</PARA>
<PARA>
The <FUNCTION>gettext</FUNCTION> function is equivalent to
<LITERAL>dcgettext(NULL, msgid, LC_MESSAGES)</LITERAL>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>

<PARA>
If a string is found in the currently selected message catalogs for
<PARAMETER>msgid</PARAMETER>, then a pointer to that string shall be returned.
Otherwise, a pointer to <PARAMETER>msgid</PARAMETER> shall be returned.
</PARA>
<PARA>
Applications shall not modify the string returned by <FUNCTION>
gettext</FUNCTION>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None.</PARA>
<PARA>
The <FUNCTION>gettext</FUNCTION> function shall not modify 
<VARNAME>errno</VARNAME>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-getutent-3"> <REFMETA>
<REFENTRYTITLE>getutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent
</REFNAME>
<REFPURPOSE>
access user accounting database entries	
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>struct utmp
  *<FUNCTION>getutent</FUNCTION></FUNCDEF>
 <VOID> 
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getutent</FUNCTION> function shall read the
next entry from the user accounting database.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
Upon successful completion, <function>getutent</function>
shall return a 
pointer to a <structname>utmp</structname> structure containing a copy
of the requested entry in the user accounting database.
Otherwise, a null pointer shall be returned. The return value may point
to a static area which is overwritten by a subsequent call to
<function>getutent</function>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
None defined.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getutent-r-3"> <REFMETA>
<REFENTRYTITLE>getutent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent_r
</REFNAME>
<REFPURPOSE>
access user accounting database entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>getutent_r</FUNCTION></FUNCDEF>
 <PARAMDEF>struct utmp *
  <PARAMETER>buffer</PARAMETER></PARAMDEF>
 <PARAMDEF>struct utmp **
  <PARAMETER>result</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>getutent_r</FUNCTION> function is a reentrant version of the 
<FUNCTION>getutent</FUNCTION> function.
On entry, <parameter>buffer</parameter> should point to a user supplied
buffer to which the next entry in the database will be copied, and
<parameter>result</parameter> should point to a location where the
result will be stored.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <function>getutent_r</function> shall return 0 and set
the location referenced by <parameter>result</parameter> to a pointer
to <parameter>buffer</parameter>. Otherwise, <function>getutent_r</function>
shall return <constant>-1</constant> and set the location referenced
by <parameter>result</parameter> to <constant>NULL</constant>.
</PARA>
</REFSECT1>
</REFENTRY>

<refentry id="baselib-getwc-unlocked-1">

<refmeta>
<refentrytitle>getwc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>getwc_unlocked</refname>
<refpurpose>non-thread-safe getwc</refpurpose>
<indexterm id="ix-baselib-getwc-unlocked-1">
  <primary>getwc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>getwc_unlocked</function> is the same as
<function>getwc</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-getwchar-unlocked-1">

<refmeta>
<refentrytitle>getwchar_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>getwchar_unlocked</refname>
<refpurpose>non-thread-safe getwchar</refpurpose>
<indexterm id="ix-baselib-getwchar-unlocked-1">
  <primary>getwchar_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>getwchar_unlocked</function> is the same as
<function>getwchar</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-glob64"> <REFMETA>
<REFENTRYTITLE>glob64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>glob64</REFNAME>
<REFPURPOSE>
find pathnames matching a pattern  (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 December 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;glob.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>glob64</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>pattern</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <FUNCPARAMS>*<REPLACEABLE>errfunc</REPLACEABLE></FUNCPARAMS> 
  <FUNCPARAMS>const char *, int</FUNCPARAMS></PARAMDEF>
 <PARAMDEF>glob64_t *
  <PARAMETER><REPLACEABLE>pglob</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>glob64</FUNCTION> is a large-file
version of the <FUNCTION>glob</FUNCTION> function defined in
<XREF LINKEND=STD.SUSv3>.
It shall search for pathnames matching
<PARAMETER>pattern</PARAMETER> according to the rules used by
the shell, <FILENAME>/bin/sh</FILENAME>.
No tilde expansion or parameter substitution is done; see
<FUNCTION>wordexp</FUNCTION>.
</PARA>
<PARA>
The results of a <FUNCTION>glob64</FUNCTION>
call are stored in the structure pointed to by <PARAMETER>pglob</PARAMETER>,
which is a <VARNAME>glob64_t</VARNAME> declared in 
<FILENAME>glob.h</FILENAME> with the following members:

<SYNOPSIS>
typedef struct
{
  size_t <STRUCTFIELD>gl_pathc</STRUCTFIELD>;
  char **<STRUCTFIELD>gl_pathv</STRUCTFIELD>;
  size_t <STRUCTFIELD>gl_offs</STRUCTFIELD>;
  int <STRUCTFIELD>gl_flags</STRUCTFIELD>;
  void (*<STRUCTFIELD>gl_closedir</STRUCTFIELD>) (void *);
  struct dirent64 *(*<STRUCTFIELD>gl_readdir64</STRUCTFIELD>) (void *);
  void *(*<STRUCTFIELD>gl_opendir</STRUCTFIELD>) (const char *);
  int (*<STRUCTFIELD>gl_lstat</STRUCTFIELD>) (const char *, struct stat *);
  int (*<STRUCTFIELD>gl_stat</STRUCTFIELD>) (const char *, struct stat *);
}
glob64_t;
</SYNOPSIS>
</PARA>
<PARA>
Structure members with the same name as corresponding members of a 
<VARNAME>glob_t</VARNAME> as
defined in <XREF LINKEND=STD.SUSv3> shall have the same purpose.
</PARA>
<PARA>
Other members are defined as follows:
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_flags</STRUCTFIELD></TERM>
<LISTITEM><PARA>reserved for internal use
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_closedir</STRUCTFIELD></TERM>
<LISTITEM><PARA>pointer to a function capable of closing a directory opened by 
<STRUCTFIELD>gl_opendir</STRUCTFIELD>
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_readdir64</STRUCTFIELD></TERM>
<LISTITEM><PARA>pointer to a function capable of reading entries in a large 
directory
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_opendir</STRUCTFIELD></TERM>
<LISTITEM><PARA>pointer to a function capable of opening a large directory
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_stat</STRUCTFIELD></TERM>
<LISTITEM><PARA>pointer to a function capable of returning file status 
for a large file
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>gl_lstat</STRUCTFIELD></TERM>
<LISTITEM><PARA>pointer to a function capable of returning file status 
information for a large file or symbolic link
</PARA></LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
<PARA>
A large file or large directory is one with a size which cannot be
represented by a variable of type <type>off_t</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. Other possible 
returns are:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
GLOB_NOSPACE
</TERM>
<LISTITEM>
<PARA>
out of memory
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
GLOB_ABORTED
</TERM>
<LISTITEM>
<PARA>
read error
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
GLOB_NOMATCH
</TERM>
<LISTITEM>
<PARA>
no match found
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-globfree64"> <REFMETA>
<REFENTRYTITLE>globfree64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>globfree64</REFNAME>
<REFPURPOSE>
free memory from glob64() (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 December 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;glob.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>globfree64</FUNCTION></FUNCDEF>
 <PARAMDEF>glob64_t *
  <PARAMETER><REPLACEABLE>pglob</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>globfree64</FUNCTION> frees the dynamically allocated 
storage from an earlier call to <FUNCTION>glob64</FUNCTION>.
</PARA>
<PARA>
<FUNCTION>globfree64</FUNCTION> is a large-file
version of the <FUNCTION>globfree</FUNCTION> function defined in
<XREF LINKEND=STD.SUSv3>.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-hcreate-r"> <REFMETA>
<REFENTRYTITLE>hcreate_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>hcreate_r
</REFNAME>
<REFPURPOSE>
allocate space for a hash search table, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;search.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>hcreate_r</FUNCTION></FUNCDEF>
 <PARAMDEF>size_t
  <PARAMETER>nel</PARAMETER></PARAMDEF>
 <PARAMDEF>struct hsearch_data *
  <PARAMETER>htab</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>hcreate_r</FUNCTION> function is a reentrant version 
of the <FUNCTION>hcreate</FUNCTION> function.
</PARA>
<PARA>
<FUNCTION>hcreate_r</FUNCTION> shall initialize the object referenced by 
<PARAMETER>htab</PARAMETER> with a hash table containing at least 
<PARAMETER>nel</PARAMETER> elements. Unlike its non-reentrant equivalent, 
<FUNCTION>hcreate</FUNCTION>, the <FUNCTION>hcreate_r</FUNCTION> function 
may work with more than one hash table.
</PARA>
<PARA>
The memory for the <PARAMETER>htab</PARAMETER> object may be dynamically allocated. 
It must be initialized with <LITERAL>0</LITERAL> before <FUNCTION>hcreate_r</FUNCTION> is called.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <FUNCTION>hcreate_r</FUNCTION> shall return a non-zero value. 
</PARA>
<PARA>
On failure, <function>hcreate_r</function> shall return <LITERAL>0</LITERAL>. This usually happens 
because not enough memory was available.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-hdestroy-r"> <REFMETA>
<REFENTRYTITLE>hdestroy_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>hdestroy_r
</REFNAME>
<REFPURPOSE>
dispose of a hash search table, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;search.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void
  <FUNCTION>hdestroy_r</FUNCTION></FUNCDEF>
 <PARAMDEF>struct hsearch_data *
  <PARAMETER>htab</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>hdestroy_r</FUNCTION> function is a 
reentrant version of the <FUNCTION>hdestroy</FUNCTION> function.
</PARA>
<PARA>
<FUNCTION>hdestroy_r</FUNCTION> frees the resources allocated by 
<FUNCTION>hcreate_r</FUNCTION> for the object <PARAMETER>htab</PARAMETER>.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-hsearch-r"> <REFMETA>
<REFENTRYTITLE>hsearch_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>hsearch_r
</REFNAME>
<REFPURPOSE>
search a hash table, reentrantly
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;search.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int
  <FUNCTION>hsearch_r</FUNCTION></FUNCDEF>
 <PARAMDEF>ENTRY
  <PARAMETER>item</PARAMETER></PARAMDEF>
 <PARAMDEF>ACTION
  <PARAMETER>action</PARAMETER></PARAMDEF>
 <PARAMDEF>ENTRY * *
  <PARAMETER>retval</PARAMETER></PARAMDEF>
 <PARAMDEF>struct hsearch_data *
  <PARAMETER>htab</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>hsearch_r</FUNCTION> is a reentrant version 
of the <FUNCTION>hsearch</FUNCTION> function, 
but instead of operating on a single global hash table, 
<FUNCTION>hsearch_r</FUNCTION> operates on the table described by the object that 
<PARAMETER>htab</PARAMETER> references. This object can be initialized with the function
<FUNCTION>hcreate_r</FUNCTION>.
</PARA>
<PARA>
Unlike the <FUNCTION>hsearch</FUNCTION> function, 
<FUNCTION>hsearch_r</FUNCTION> returns 
a pointer to the found entry in the variable 
referred to by <PARAMETER>retval</PARAMETER>, rather than directly.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <FUNCTION>hsearch_r</FUNCTION> shall return a non-zero value.
</PARA>
<PARA>
On failure, <function>hsearch_r</function> shall return <LITERAL>0</LITERAL>
and set <varname>errno</varname> to an appropriate value.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
ENOMEM  
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>action</PARAMETER> was set to <CONSTANT>ENTER</CONSTANT>, 
but the table was full.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ESRCH 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>action</PARAMETER> was set to <CONSTANT>FIND</CONSTANT>, 
but no matching element was found in the table.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-inet-aton-3"> <REFMETA>
<REFENTRYTITLE>inet_aton</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inet_aton
</REFNAME>
<REFPURPOSE>
Internet address manipulation routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>anet_iton</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>cp</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct in_addr *
  <PARAMETER>inp</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>inet_aton</FUNCTION> converts the Internet host address 
<PARAMETER>cp</PARAMETER> from the standard IPv4 numbers-and-dots 
notation into binary data and stores it in the structure that
<PARAMETER>inp</PARAMETER> points to.
</PARA>
<PARA>
<FUNCTION>inet_aton</FUNCTION> returns a 
nonzero value if the address is valid, 
<RETURNVALUE>0</RETURNVALUE> if not.
</PARA>
<PARA>
<NOTE>
<PARA>
Note that on some LSB architectures, the host byte order is Least 
Significant Byte first, whereas the network byte order, 
as used on the Internet, is Most Significant Byte first.
</PARA>
</NOTE>
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-initgroups-3"> <REFMETA>
<REFENTRYTITLE>initgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>initgroups
</REFNAME>
<REFPURPOSE>
initialize the supplementary group access list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;grp.h&gt;
#include &lt;sys/types.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>initgroups</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>user</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>gid_t 
  <PARAMETER><REPLACEABLE>group</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
If the process has appropriate privilege,
the <FUNCTION>initgroups</FUNCTION> function shall initialize the 
Supplementary Group IDs for the current process
by reading the group database and using all groups of which 
<PARAMETER>user</PARAMETER> is a member. The additional group 
<PARAMETER>group</PARAMETER> is also added to the list.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process does not have sufficient privileges.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to allocate group information structure.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<FUNCTION>setgroups</FUNCTION>
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<!-- MISSING DEFINITION FOR initstate_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-inotify-add-watch"> <REFMETA>
<REFENTRYTITLE>inotify_add_watch</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inotify_add_watch
</REFNAME>
<REFPURPOSE>
add a watch to a watch list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/inotify.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>inotify_add_watch</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>fd</PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER>path</PARAMETER></PARAMDEF>
 <PARAMDEF>uint32_t
  <PARAMETER>mask</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>inotify_add_watch</FUNCTION> shall add a watch to,
or modify an existing watch on,
the watch list of the inotify instance 
specified by the file descriptor <PARAMETER>fd</PARAMETER>,
for the file specified by <PARAMETER>path</PARAMETER>,
to monitor the events specified by the bitmask <PARAMETER>mask</PARAMETER>.
The caller must have read access to the file.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, <function>inotify_add_watch</function> 
shall return the unique, non-negative watch descriptor
associated with the file <PARAMETER>path</PARAMETER>
and the inotify instance specified by the file descriptor <PARAMETER>fd</PARAMETER>.
</PARA>
<PARA>
If <PARAMETER>path</PARAMETER> was already on the watch list, 
then <function>inotify_add_watch</function> shall return
the existing watch descriptor.
</PARA>
<PARA>
If <PARAMETER>path</PARAMETER> was not already on the watch list, 
then <function>inotify_add_watch</function>
shall allocate a new watch descriptor.
</PARA>
<para>
<function>inotify_add_watch</function> shall not work recursively. 
Monitoring subdirectories of <parameter>path</parameter>
shall require adding watches to them.
</para>
<PARA>
On failure, <function>inotify_add_watch</function> shall return <LITERAL>-1</LITERAL>
and set <varname>errno</varname> to an appropriate value.
</PARA>
</REFSECT1>



<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
EACCESS  
</TERM>
<LISTITEM>
<PARA>
The caller does not have read access to <PARAMETER>path</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EBADF 
</TERM>
<LISTITEM>
<PARA>
The file descriptor <PARAMETER>fd</PARAMETER> is invalid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>path</PARAMETER> is outside of 
the address space accessible by the process.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>mask</PARAMETER> contains no legal events, or 
<PARAMETER>fd</PARAMETER> is not a valid inotify file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
There is not enough kernel memory available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSPC 
</TERM>
<LISTITEM>
<PARA>
The maximum number of watches has been created for this user, 
or the kernel cannot allocate a resource.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>


<REFSECT1>
<TITLE>
Application Usage
</TITLE>

<REFSECT2>
<TITLE>
Reading
</TITLE>

<PARA>
The function <function>read</function> can be used 
to determine which inotify events have occurred. 
A blocking file descriptor will make 
<function>read</function> block until at least one event has occurred.
</PARA>
<PARA>
If successful, <function>read</function> will return at least one 
of the following <varname>inotify_event</varname> structures in a buffer:
</PARA>

<PARA>
<informalexample>
  <programlisting>
struct inotify_event {
    int      wd;
    uint32_t mask;
    uint32_t cookie;
    uint32_t len;
    char     path[];
};
  </programlisting>
</informalexample>
</PARA>

<PARA>
<varname>wd</varname> is a watch descriptor that 
specifies the watch associated with the event.
It is obtained from a previous invocation of 
<function>inotify_add_watch</function>.
</PARA>
<PARA>
<varname>mask</varname> is a bit mask describing inotify events. 
See the section on masks below.
</PARA>
<PARA>
<varname>cookie</varname> is an integer associating related inotify events.
The integer value is unique, and currently
only enables the application to associate 
<constant>IN_MOVE_FROM</constant> and
<constant>IN_MOVE_TO</constant> rename events.
</PARA>
<PARA>
<varname>len</varname> is a count of the bytes in <varname>path</varname>, 
including null bytes. 
This means that the total length of an <varname>inotify_event</varname> 
structure is
<informalexample>
  <programlisting>
sizeof(inotify_event)+len
  </programlisting>
</informalexample>
</PARA>
<PARA>
<varname>path</varname> is only returned when an event occurs for a file within
a watched directory. This string is null-terminated, and it may contain 
more null bytes so that future reads will be aligned properly on an
address boundary.
</PARA>
<PARA>
In kernels before 2.6.21, <function>read</function> 
returns <literal>0</literal> when the buffer given to it is too small
to return data about the next event. In subsequent kernels, it fails with the 
error <constant>EINVAL</constant>.
</PARA>
<PARA>
For a given file descriptor, the inotify events are returned in an ordered queue.
Events on a file descriptor will always be returned in the correct order of occurrence.
If two or more inotify events for a given file descriptor have identical values for all
fields, then only one <varname>inotify_event</varname> 
will be returned to represent all of them.
</PARA>
<PARA>
The number of bytes that can be read from an inotify file descriptor
can be determined by making a 
<constant>FIONREAD</constant> <function>ioctl</function> call.
</PARA>
</REFSECT2>

<REFSECT2>
<TITLE>
Masks
</TITLE>
<PARA>
The <parameter>mask</parameter> argument of 
<function>inotify_add_watch</function> and the <varname>mask</varname> field of the 
<varname>inotify_event</varname> structure are bit masks that specify inotify events. 
The bits in the list below can be set in the <parameter>mask</parameter> argument of 
<function>inotify_add_watch</function> and returned in the 
<varname>mask</varname> field of <varname>inotify_event</varname>.
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
IN_ACCESS
</TERM>
<LISTITEM>
<PARA>
File was read.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_ALL_EVENTS
</TERM>
<LISTITEM>
<PARA>
Bit mask of all events in this list.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_ATTRIB
</TERM>
<LISTITEM>
<PARA>
File's metadata changed (including timestamps and permissions).
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_CLOSE
</TERM>
<LISTITEM>
<PARA>
Same as
<informalexample>
  <programlisting>
IN_CLOSE_WRITE | IN_CLOSE_NOWRITE
  </programlisting>
</informalexample>
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_CLOSE_WRITE
</TERM>
<LISTITEM>
<PARA>
File that was opened for writing was closed.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_CLOSE_NOWRITE
</TERM>
<LISTITEM>
<PARA>
File that was not opened for writing was closed.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_CREATE
</TERM>
<LISTITEM>
<PARA>
File or directory was created in a watched directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_DELETE
</TERM>
<LISTITEM>
<PARA>
File or directory was deleted in a watched directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_DELETE_SELF
</TERM>
<LISTITEM>
<PARA>
Watched file or directory was deleted.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_MODIFY
</TERM>
<LISTITEM>
<PARA>
File was changed.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_MOVE
</TERM>
<LISTITEM>
<PARA>
Same as
<informalexample>
  <programlisting>
IN_MOVED_FROM | IN_MOVED_TO
  </programlisting>
</informalexample>
</PARA>
</LISTITEM>
</VARLISTENTRY>


<VARLISTENTRY>
<TERM>
IN_MOVE_SELF
</TERM>
<LISTITEM>
<PARA>
Watched file or directory was moved
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_MOVED_FROM
</TERM>
<LISTITEM>
<PARA>
File was moved out of watched directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_MOVED_TO
</TERM>
<LISTITEM>
<PARA>
File was moved into watched directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_OPEN
</TERM>
<LISTITEM>
<PARA>
File was opened.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
All of the events above, except for 
<constant>IN_DELETE_SELF</constant> and <constant>IN_MOVE_SELF</constant>, 
cause the name field of the <varname>inotify_event</varname> structure to contain 
the name of the file or directory being monitored.
</PARA>

<PARA>
The following bit is valid for <function>inotify_add_watch</function> only.
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
IN_ONESHOT
</TERM>
<LISTITEM>
<PARA>
Monitor path for an event, and then remove it from the watch list.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
The following bits are valid for the <varname>inotify_event</varname> structure only.
</PARA>

<VARIABLELIST>

<VARLISTENTRY>
<TERM>
IN_IGNORED
</TERM>
<LISTITEM>
<PARA>
Watch was removed, either explicitly (via <function>inotify_rm_watch</function>) 
or implicitly (file deletion or file system unmounting).
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_ISDIR
</TERM>
<LISTITEM>
<PARA>
Object being watched is a directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_Q_OVERFLOW
</TERM>
<LISTITEM>
<PARA>
The event queue overflowed (<parameter>wd</parameter> is set to <literal>-1</literal>).
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
IN_UNMOUNT
</TERM>
<LISTITEM>
<PARA>
File system of object being watched was unmounted.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT2>

<REFSECT2>
<TITLE>Notes
</TITLE>
<PARA>
It is possible to monitor file descriptors with the functions <function>epoll</function>, 
<function>poll</function>, and <function>select</function>.
</PARA>
<PARA>
When all of the file descriptors that point to an inotify instance
have been closed, the instance and its associated resources and 
watches are freed by the kernel.
</PARA>
</REFSECT2>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>inotify_init</function></member>
<member><function>inotify_rm_watch</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-inotify-init"> <REFMETA>
<REFENTRYTITLE>inotify_init</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inotify_init
</REFNAME>
<REFPURPOSE>
instantiate inotify
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/inotify.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>inotify_init</FUNCTION></FUNCDEF>
 <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>inotify_init</FUNCTION> shall create one instance of inotify.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, <function>inotify_init</function> shall return a file descriptor pointing to the new inotify instance.
</PARA>
<PARA>
On failure, <function>inotify_init</function> shall return -1 and set <varname>errno</varname> to an appropriate value.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
EMFILE  
</TERM>
<LISTITEM>
<PARA>
The maximum number of inotify instances has been created for this user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENFILE 
</TERM>
<LISTITEM>
<PARA>
The maximum number of file descriptors has been created on the system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
There is not enough kernel memory available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>inotify_add_watch</function></member>
<member><function>inotify_rm_watch</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-inotify-rm-watch"> <REFMETA>
<REFENTRYTITLE>inotify_rm_watch</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inotify_rm_watch
</REFNAME>
<REFPURPOSE>
remove a watch from an inotify watch list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/inotify.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>inotify_rm_watch</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>fd</PARAMETER></PARAMDEF>
 <PARAMDEF>uint32_t
  <PARAMETER>wd</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>inotify_rm_watch</FUNCTION> shall remove the watch 
associated with the watch descriptor <PARAMETER>wd</PARAMETER> 
from the watch list of the inotify instance 
associated with the file descriptor <PARAMETER>fd</PARAMETER>.
</PARA>
<PARA>
If a watch is removed, its watch descriptor shall generate the <constant>IN_IGNORED</constant> event.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, <function>inotify_rm_watch</function> shall return <LITERAL>0</LITERAL>.
</PARA>
<PARA>
On failure, <FUNCTION>inotify_rm_watch</FUNCTION> shall return <LITERAL>-1</LITERAL>
and set <varname>errno</varname> to an appropriate value.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
EBADF 
</TERM>
<LISTITEM>
<PARA>
The file descriptor <PARAMETER>fd</PARAMETER> is invalid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>wd</PARAMETER> is invalid, or <PARAMETER>fd</PARAMETER> 
is not a valid inotify file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>inotify_add_watch</function></member>
<member><function>inotify_init</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-ioctl-2"> <REFMETA>
<REFENTRYTITLE>ioctl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ioctl
</REFNAME>
<REFPURPOSE>
control device
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 August 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/ioctl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>ioctl</FUNCTION>
 </FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fildes</REPLACEABLE></PARAMETER>
 </PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>request</REPLACEABLE></PARAMETER>
 </PARAMDEF>
 <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 August 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>ioctl</FUNCTION> function shall manipulate the underlying device 
parameters of special files. <PARAMETER>fildes</PARAMETER> shall be 
an open file descriptor referring to a special file.
The <FUNCTION>ioctl</FUNCTION> function shall take three parameters;
the type and value of the third parameter 
is dependent on the device and <PARAMETER>request</PARAMETER>.
</PARA>
<PARA>
Conforming LSB applications shall not call <FUNCTION>ioctl</FUNCTION> 
except in situations explicitly stated in this specification.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
An <FUNCTION>ioctl</FUNCTION> may use the return value as an
output parameter and return a non-negative value on success. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<errorcode>EBADF</errorcode>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>fildes</PARAMETER> is not a valid descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<errorcode>EFAULT</errorcode>
</TERM>
<LISTITEM>
<PARA>
The third parameter references an inaccessible memory area.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<errorcode>ENOTTY</errorcode>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>fildes</PARAMETER> is not associated with a character special device.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<errorcode>ENOTTY </errorcode>
</TERM>
<LISTITEM>
<PARA>
The specified request does not apply to the kind of object that
<PARAMETER>fildes</PARAMETER> references.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<errorcode>EINVAL </errorcode>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>request</PARAMETER> or the third parameter is not valid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Relationship to POSIX (Informative)</TITLE>
<PARA>
It should be noted that <XREF LINKEND="STD.SUSv3"> contains an interface 
named <function>ioctl</function>. The LSB only defines behavior when
<parameter>fildes</parameter> refers to a socket 
(see <xref linkend="baselib-sockio-2">)
or terminal device
(see <xref linkend="baselib-ttyio-2">), while 
<XREF LINKEND="STD.SUSv3"> only defines behavior when 
<parameter>fildes</parameter> refers to a STREAMS device. An implementation
may support both behaviors; the LSB does not require any STREAMS support.
</PARA>
</REFSECT1>
</REFENTRY>
<REFENTRY ID="baselib-sockio-2"> <REFMETA>
<REFENTRYTITLE>sockio</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sockio
</REFNAME>
<REFPURPOSE>
socket ioctl commands
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 August 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;
#include &lt;netinet/in.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>ioctl</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sockfd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>request</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>void *
  <PARAMETER><REPLACEABLE>argp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 August 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Socket <function>ioctl</function> commands are a subset of the 
<FUNCTION>ioctl</FUNCTION> calls, which can perform a variety of 
functions on sockets. <PARAMETER>sockfd</PARAMETER> shall be an
open file descriptor referring to a socket (see the
<FUNCTION>socket</FUNCTION> or <FUNCTION>accept</FUNCTION> functions).
</PARA>
<PARA>
Socket <function>ioctl</function> commands apply to the underlying 
network interfaces, and affect the entire system, not just the file 
descriptor used to issue the <FUNCTION>ioctl</FUNCTION>.
</PARA>
<PARA>
The following values for <parameter>request</parameter>
are accepted:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFCONF</SYMBOL> (Deprecated)
</TERM>
<LISTITEM>
<PARA>
Get the interface configuration list for the system.
<NOTE>
<PARA>
The <SYMBOL>SIOCGIFCONF</SYMBOL> interface is
superceded by the 
<FUNCTION>if_nameindex</FUNCTION> family of functions (see
<XREF LINKEND=STD.SUSv3>).
A future version of this specification may withdraw this value
for <parameter>request</parameter>.
</PARA>
</NOTE>
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifconf</STRUCTNAME> structure, as described in
<filename>&lt;net/if.h&gt;</filename>. Before calling, the caller 
shall set the
<STRUCTFIELD>ifc_ifcu.ifcu_req</STRUCTFIELD> field 
to point to an array of <STRUCTNAME>ifreq</STRUCTNAME> structures, and 
set <STRUCTFIELD>ifc_len</STRUCTFIELD> to the size in bytes of this allocated 
array. Upon return, <STRUCTFIELD>ifc_len</STRUCTFIELD> 
will contain the size in bytes of the array which was actually used.
If it is the same as the length upon calling, the caller 
should assume that the array was too small and try again with a 
larger array.
</PARA>
<PARA>
On success, <SYMBOL>SIOCGIFCONF</SYMBOL> shall return a nonnegative value.
<NOTE><TITLE>Rationale</TITLE>
<PARA>
Historical UNIX systems disagree on the meaning of the return value.
</PARA>
</NOTE>
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFFLAGS</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the interface flags for the indicated interface.
<PARAMETER>argp</PARAMETER> shall point to a 
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_ifru.ifru_flags</STRUCTFIELD> field is set 
with the interface flags.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFADDR</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the interface address for the given interface.
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_ifru.ifru_addr</STRUCTFIELD> field is set 
with the interface address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFBRDADDR</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the interface broadcast address for the given interface.
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_ifru.ifru_broadcast</STRUCTFIELD> field is set 
with the interface broadcast address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFDSTADDR</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the point-to-point address for the given interface.
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_dstaddr</STRUCTFIELD> field is set 
with the point-to-point address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFNAME</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the name of an interface.
<PARAMETER>argp</PARAMETER> shall point to a 
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_ifindex</STRUCTFIELD> 
field with the number (index) of the interface, and upon return, the 
<STRUCTFIELD>ifr_name</STRUCTFIELD> field is set 
with the interface name.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFNETMASK</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the network mask for the given interface. 
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_ifru.ifru_netmask</STRUCTFIELD> field is set 
with the network mask.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>SIOCGIFMTU</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the Maximum Transmission Unit (MTU) size for the given interface. 
<PARAMETER>argp</PARAMETER> shall point to a
<STRUCTNAME>ifreq</STRUCTNAME> structure. Before calling, the 
caller should fill in the <STRUCTFIELD>ifr_name</STRUCTFIELD> 
field with the interface name, and upon return, the 
<STRUCTFIELD>ifr_ifru.ifru_mtu</STRUCTFIELD> field is set 
with the MTU.
Note: The range of valid values for MTU varies for an interface
depending on the interface type.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<SYMBOL>FIONREAD</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the amount of queued unread data in the receive buffer.
<PARAMETER>argp</PARAMETER> shall point to an integer where the result is to be placed.
<NOTE><PARA>Some implementations may also support the use of <SYMBOL>FIONREAD</SYMBOL>
on other types of file descriptor. However, the LSB only specifies its behavior for a socket
related file descriptor.
</PARA></NOTE>
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

<!--
<PARA>
The <STRUCTNAME>sockaddr</STRUCTNAME> structure is as specified in 
<XREF LINKEND=STD.SUSv3>.
</PARA>
-->
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, if <parameter>request</parameter> is
<TOKEN>SIOCGIFCONF</TOKEN>, a non-negative integer shall be returned.
If request is not <TOKEN>SIOCGIFCONF</TOKEN>, on success 
<RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF  
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>sockfd</PARAMETER> is not a valid descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>argp</PARAMETER> references an inaccessible memory area.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTTY 
</TERM>
<LISTITEM>
<PARA>
The specified <PARAMETER>request</PARAMETER> does not apply to the kind of 
object that the descriptor <PARAMETER>sockfd</PARAMETER> references.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
Either <PARAMETER>request</PARAMETER> or <PARAMETER>argp</PARAMETER>
is invalid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOTCONN 
</TERM>
<LISTITEM>
<PARA>
The operation is only defined on a connected socket, but the socket wasn't
connected.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-ttyio-2"> <REFMETA>
<REFENTRYTITLE>ttyio</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ttyio
</REFNAME>
<REFPURPOSE>
tty ioctl commands
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>07 Dec 2004</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>ioctl</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned long 
  <PARAMETER><REPLACEABLE>request</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int *
  <PARAMETER><REPLACEABLE>argp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>14 July 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Tty <EMPHASIS>ioctl</EMPHASIS> commands are a subset of the 
<FUNCTION>ioctl</FUNCTION> calls, which can perform a variety of 
functions on tty devices. <PARAMETER>fd</PARAMETER> shall be 
an open file descriptor referring to a terminal device.
</PARA>
<PARA>
The following <FUNCTION>ioctl</FUNCTION>s are provided:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
<SYMBOL>TIOCGWINSZ</SYMBOL>
</TERM>
<LISTITEM>
<PARA>
Get the size attributes of the terminal or pseudo-terminal identified by
<parameter>fd</parameter>. On entry, <PARAMETER>argp</PARAMETER> shall reference
a <STRUCTNAME>winsize</STRUCTNAME> structure.
On return, the structure will have 
<structfield>ws_row</structfield> set to the number of rows of text (i.e. lines of text)
that can be viewed on the device, and
<structfield>ws_col</structfield> set to the number of columns (i.e. text width).
<!--
<structfield>ws_xpixel</structfield> set to the actual width in pixels, and 
<structfield>ws_ypixel</structfield> the actual height in pixels.
-->
<NOTE><PARA>The number of columns stored in <structfield>ws_col</structfield>
assumes that the terminal device is using a mono-spaced font.
</PARA></NOTE>
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF  
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>fd</PARAMETER> is not a valid descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>argp</PARAMETER> references an inaccessible memory area.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>request</PARAMETER> and <PARAMETER>argp</PARAMETER> are not valid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

</REFENTRY>


<!-- MISSING DEFINITION FOR jrand48_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-kill-3"> <REFMETA>
<REFENTRYTITLE>kill</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>kill
</REFNAME>
<REFPURPOSE>
send a signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;signal.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>kill</FUNCTION></FUNCDEF>
 <PARAMDEF>pid_t 
  <PARAMETER><REPLACEABLE>pid</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sig</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>kill</FUNCTION> is as specified in the
<CITETITLE PUBWORK="BOOK">
<XREF LINKEND='STD.SUSv3'>
</CITETITLE>, but with differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Process ID -1 doesn't affect calling process
</TITLE>
<PARA>
If <PARAMETER>pid</PARAMETER> is specified as <LITERAL>-1</LITERAL>,
<PARAMETER>sig</PARAMETER> shall not be sent to the calling process.
Other than this, the rules in the <CITETITLE PUBWORK="BOOK">
<XREF LINKEND='STD.SUSv3'>
</CITETITLE> apply.
<NOTE><TITLE>Rationale</TITLE>
<PARA>
This was a deliberate Linus decision after an unpopular experiment in
including the calling process in the 2.5.1 kernel.  See "What does it
mean to signal everybody?", Linux Weekly News, 20 December 2001,
<ulink url="http://lwn.net/2001/1220/kernel.php3"
>http://lwn.net/2001/1220/kernel.php3</ulink>
</PARA>
</NOTE>
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR lcong48_r -->
<!-- Lets just hope nobody notices -->
<refentry id="baselib-link-1">

<refmeta>
<refentrytitle>link</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>link</refname>
<refpurpose>create a link to a file</refpurpose>
<indexterm id="ix-baselib-link-1">
  <primary>link</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;unistd.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>link</function>
</funcdef>
<paramdef>const char *
<parameter>path1</parameter>
</paramdef>
<paramdef>const char *
<parameter>path2</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
The <function>link</function> function shall behave as specified in 
<CITETITLE><XREF LINKEND="STD.SUSV3"></CITETITLE>, 
except with differences as listed below.
</para>

<refsect2>
<title>Need Not Follow Symlinks</title>
<para>

<XREF LINKEND="STD.SUSV3"> specifies that pathname resolution
shall follow symbolic links during pathname resolution unless the
function is required to act on the symbolic link itself, or certain 
arguments direct that the function act on the symbolic link itself. The
<function>link</function> function in <XREF LINKEND="STD.SUSv3">
contains no such requirement to operate on a symbolic link. 
However, a conforming
LSB implementation need not follow a symbolic link 
for the <parameter>path1</parameter> argument. 
</para>
</refsect2>

</refsect1>
</refentry>

<!-- MISSING DEFINITION FOR lrand48_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-mbsnrtowcs-3"> <REFMETA>
<REFENTRYTITLE>mbsnrtowcs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mbsnrtowcs
</REFNAME>
<REFPURPOSE>
convert a multibyte string to a wide character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>mbsnrtowcs</FUNCTION></FUNCDEF>
 <PARAMDEF>wchar_t *
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * *
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>nms</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>len</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>mbstate_t *
  <PARAMETER><REPLACEABLE>ps</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>mbsnrtowcs</FUNCTION> is like <FUNCTION>mbsrtowcs</FUNCTION>, 
except that the number of bytes to be converted, starting at 
<PARAMETER>src</PARAMETER>, is limited to <PARAMETER>nms</PARAMETER>.
</PARA>
<PARA>
If <PARAMETER>dest</PARAMETER> is not a 
<LITERAL>NULL</LITERAL> pointer, <FUNCTION>mbsnrtowcs</FUNCTION> 
converts at most <PARAMETER>nms</PARAMETER> bytes from the multibyte 
string <PARAMETER>src</PARAMETER> to a wide-character string starting 
at <PARAMETER>dest</PARAMETER>. At most, <PARAMETER>len</PARAMETER> 
wide characters are written to <PARAMETER>dest</PARAMETER>. The shift 
state <PARAMETER>ps</PARAMETER> is updated.
</PARA>
<PARA>
The conversion is effectively performed by repeatedly calling:
<SYNOPSIS> 
mbrtowc(dest, *src, n, ps)</SYNOPSIS>
where <PARAMETER>n</PARAMETER> is some positive number, as long as this 
call succeeds, and then incrementing <PARAMETER>dest</PARAMETER> by one 
and <PARAMETER>src</PARAMETER> by the number of bytes consumed.
</PARA>
<PARA>
The conversion can stop for three reasons:
</PARA>
<PARA>
<ITEMIZEDLIST MARK='BULLET'>
<LISTITEM>
<PARA>
An invalid multibyte sequence has been encountered. In this case 
<PARAMETER>src</PARAMETER> is left pointing to the invalid multibyte 
sequence, (size_t)(-1) is returned, and <VARNAME>errno</VARNAME> is 
set to <ERRORNAME>EILSEQ</ERRORNAME>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The <PARAMETER>nms</PARAMETER> limit forces a stop, or 
<PARAMETER>len</PARAMETER> non-<TOKEN>L'\0'</TOKEN> wide characters 
have been stored at <PARAMETER>dest</PARAMETER>. In this case, 
<PARAMETER>src</PARAMETER> is left pointing to the next multibyte 
sequence to be converted, and the number of wide characters written 
to <PARAMETER>dest</PARAMETER> is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The multibyte string has been completely converted, including the 
terminating <TOKEN>'\0'</TOKEN> (which has the side effect of bringing 
back <PARAMETER>ps</PARAMETER> to the initial state). In this case, 
<PARAMETER>src</PARAMETER> is set to <LITERAL>NULL</LITERAL>, and the 
number of wide characters written to <PARAMETER>dest</PARAMETER>, 
excluding the terminating <TOKEN>L'\0'</TOKEN> character, is returned.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
If <PARAMETER>dest</PARAMETER> is <LITERAL>NULL</LITERAL>, 
<PARAMETER>len</PARAMETER> is ignored, and the conversion proceeds 
as above, except that the converted wide characters are not written 
out to memory, and that no destination length limit exists.
</PARA>
<PARA>
In both of the above cases, if <PARAMETER>ps</PARAMETER> is a 
<LITERAL>NULL</LITERAL> pointer, a static anonymous state only known 
to <FUNCTION>mbsnrtowcs</FUNCTION> is used instead.
</PARA>
<PARA>
The programmer shall ensure that there is room for at least 
<PARAMETER>len</PARAMETER> wide characters at <PARAMETER>dest</PARAMETER>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>mbsnrtowcs</FUNCTION> returns the number of wide characters 
that make up the converted part of the wide character string, not 
including the terminating null wide character. If an invalid multibyte 
sequence was encountered, (size_t)(-1) is returned, and the global
variable <VARNAME>errno</VARNAME> is set to <ERRORNAME>EILSEQ</ERRORNAME>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of <FUNCTION>mbsnrtowcs</FUNCTION> depends on the 
<VARNAME>LC_CTYPE</VARNAME> category of the current locale.
</PARA>
<PARA>
Passing <TOKEN>NULL</TOKEN> as <PARAMETER>ps</PARAMETER> is not 
multi-thread safe.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-memmem-3"> <REFMETA>
<REFENTRYTITLE>memmem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memmem</REFNAME>
<REFPURPOSE>
locate bytes
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _GNU_SOURCE
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void *
  <FUNCTION>memmem</FUNCTION></FUNCDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>haystack</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>haystacklen</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>needle</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>needlelen</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>memmem</FUNCTION> finds the start of the first 
occurrence of the byte array referenced by 
<PARAMETER>needle</PARAMETER> 
of length <PARAMETER>needlelen</PARAMETER> in the memory 
area <PARAMETER>haystack</PARAMETER> of length 
<PARAMETER>haystacklen</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
If <PARAMETER>needle</PARAMETER> is found,
<FUNCTION>memmem</FUNCTION> returns a pointer to it.
If <PARAMETER>needlelen</PARAMETER> is <LITERAL>0</LITERAL>, 
<PARAMETER>memmem</PARAMETER> returns <PARAMETER>haystack</PARAMETER>.
If <PARAMETER>needle</PARAMETER> is not found in 
<PARAMETER>haystack</PARAMETER>, <FUNCTION>memmem</FUNCTION>
returns <LITERAL>NULL</LITERAL>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Earlier versions of the C library (prior to glibc 2.1) contained a
<function>memmem</function> with various problems, and application
developers should treat this function with care.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-memrchr"> <REFMETA>
<REFENTRYTITLE>memrchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memrchr</REFNAME>
<REFPURPOSE>
scan memory for a character
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void *
  <FUNCTION>memrchr</FUNCTION></FUNCDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>c</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>memrchr</FUNCTION> function shall locate the last
occurence of <PARAMETER>c</PARAMETER> (converted to an unsigned char)
in the initial <PARAMETER>n</PARAMETER> bytes (each interpreted as
an unsigned char) of the object pointed to by
<PARAMETER>s</PARAMETER>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
The <function>memrchr</function> shall return a pointer to the located
byte, or a null pointer if the byte does not occur in the object.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>No errors are defined.</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA><FUNCTION>memchr</FUNCTION></PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-mkstemp64"> <REFMETA>
<REFENTRYTITLE>mkstemp64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mkstemp64</REFNAME>
<REFPURPOSE>
create a unique temporary file (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>19 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>mkstemp64</FUNCTION></FUNCDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>template</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>19 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>mkstemp64</FUNCTION> shall generates a unique temporary file
name from <PARAMETER>template</PARAMETER>. The last six characters
of template shall be <LITERAL>XXXXXX</LITERAL> and these are replaced 
with a string that makes the file name unique; the file is
then created and an open file descriptor returned as described
for <function>mkstemp</function>.
</PARA>
<PARA>
<FUNCTION>mkstemp64</FUNCTION> is a large-file version of
the <FUNCTION>mkstemp</FUNCTION> function as defined in
<XREF LINKEND=STD.SUSv3>.
The only difference is 
that the temporary file is opened with <function>open64</function>
instead of with <function>open</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <function>mkstemp64</function> returns the file
descriptor of the temporary file.  Otherwise <function>mkstemp64</function>
shall return <RETURNVALUE>-1</RETURNVALUE> and
set <VARNAME>errno</VARNAME> to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
See <function>mkstemp</function> for possible error values.
</PARA>
</REFSECT1>
</REFENTRY>


<!-- MISSING DEFINITION FOR mrand48_r -->
<!-- Lets just hope nobody notices -->
<refentry id="baselib-mremap"> <refmeta>
<refentrytitle>mremap</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>mremap</refname>
<refpurpose>
remap a virtual memory address
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;sys/mman.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>void * <function>mremap</function></funcdef>
<paramdef>void * <parameter>old_address</parameter></paramdef>
<paramdef>size_t <parameter>old_size</parameter></paramdef>
<paramdef>size_t <parameter>new_size</parameter></paramdef>
<paramdef>int <parameter>flags</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The <function>mremap</function> function expands (or shrinks)
an existing memory mapping, potentially moving it at
the same time, depending on the flags argument and the
available virtual address space.
</para>
<para>
<varname>old_address</varname> is the old address of the
virtual memory block to be resized. 
Note that <varname>old_address</varname> must be page aligned. 
<varname>old_size</varname> is the old size of the virtual memory block. 
<varname>new_size</varname> is the requested size of the
virtual memory block after the resize.
</para>
<para>
In Linux the memory is divided into pages. A user process has (one or)
several linear virtual memory segments. Each virtual memory segment
has one or more mappings to real memory pages (in the page table).
Each virtual memory segment has its own protection (access rights),
which may cause a segmentation violation if the memory is accessed
incorrectly (e.g., writing to a read-only segment). Accessing virtual
memory outside of the segments will also cause a segmentation violation.
</para>
<para>
<function>mremap</function> uses the Linux page table
scheme. <function>mremap</function> changes the mapping between
virtual addresses and memory pages. This can be used to implement a
very efficient form of <function>realloc</function>.
</para>
<para>
The flags bit-mask argument may be 0, or include the following flag:
</para>
<variablelist>
<varlistentry>
<term>
MREMAP_MAYMOVE
</term>
<listitem>
<para>
By default, if there is not sufficient space to expand a mapping
at its current location, then <function>mremap</function> fails.
If this flag is specified, then the kernel is permitted to relocate
the mapping to a new virtual address, if necessary. If the mapping
is relocated, then absolute pointers into the old mapping location
become invalid (offsets relative to the starting address of the
mapping should be employed).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
MREMAP_FIXED
</term>
<listitem>
<para>
This flag serves a similar purpose to the <constant>MAP_FIXED</constant>
flag of <function>mmap</function>. If this flag is specified,
then <function>mremap</function>accepts a fifth argument,
<type>void *</type><varname>new_address</varname>,
which specifies a pagealigned address to which the mapping must
be moved. Any previous mapping at the address range specified by
<varname>new_address</varname> and <varname>new_size</varname> is
unmapped. If <constant>MREMAP_FIXED</constant> is specified, then
<constant>MREMAP_MAYMOVE</constant> must also be specified.
</para>
</listitem>
</varlistentry>
</variablelist>
<para>
If the memory segment specified by <varname>old_address</varname>
and <varname>old_size</varname> is locked (using
<function>mlock</function> or similar), then this lock is maintained
when the segment is resized and/or relocated. As a consequence, the
amount of memory locked by the process may change.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>mremap</function> function returns a pointer
to the new virtual memory area on success.  On error, the value
<constant>MAP_FAILED</constant> is returned, and <varname>errno</varname>
is set appropriately.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<variablelist>
<varlistentry>
<term>
<errorcode>EAGAIN</errorcode>
</term>
<listitem>
<para>
The caller tried to expand a memory segment that is locked, but this was
not possible without exceeding the <constant>RLIMIT_MEMLOCK</constant>
resource limit.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<errorcode>EFAULT</errorcode>
</term>
<listitem>
<para>
"Segmentation fault." Some address in the range old_address to
<varname>old_address</varname>+<varname>old_size</varname> is
an invalid virtual memory address for this process. You can also get
<errorcode>EFAULT</errorcode> even if there exist mappings that cover the
whole address space requested, but those mappings are of different types.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<errorcode>EINVAL</errorcode>
</term>
<listitem>
<para>
An invalid argument was given. Possible causes are:
<varname>old_address</varname> was not page aligned;
a value other than <constant>MREMAP_MAYMOVE</constant>
or <constant>MREMAP_FIXED</constant> was specified in
<varname>flags;</varname> <varname>new_size</varname> was zero;
<varname>new_size</varname> or <varname>new_address</varname>
was invalid;
or the new address range specified by <varname>new_address</varname>
and <varname>new_size</varname> overlapped the old address range specified
by <varname>old_address</varname> and <varname>old_size</varname>;
or <constant>MREMAP_FIXED</constant> was specified without also specifying
<constant>MREMAP_MAYMOVE.</constant>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<errorcode>ENOMEM</errorcode>
</term>
<listitem>
<para>
The memory area cannot be expanded at the current virtual address,
and the <constant>MREMAP_MAYMOVE</constant> flag is not set in
<varname>flags</varname>, or, there is not enough (virtual) memory
available.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect1>

</refentry>

<REFENTRY ID="baselib-newlocale-3"> <REFMETA>
<REFENTRYTITLE>newlocale</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>newlocale
</REFNAME>
<REFPURPOSE>
allocate a locale object
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;locale.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>locale_t
<function>newlocale</function>
</funcdef>
<paramdef>int
<parameter>category_mask</parameter>
</paramdef>
<paramdef>const char *
<parameter>locale</parameter>
</paramdef>
<paramdef>locale_t
<parameter>base</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>newlocale</function> function shall initialize
a locale object. If <parameter>base</parameter> is 
<constant>NULL</constant>, then <function>newlocale</function>
shall first allocate the object; otherwise it shall use the locale
object referenced by <parameter>base</parameter>.
</para>
<para>
The object shall be initialized for the locale named
by <parameter>locale</parameter>, and for the categories selected
in <parameter>category_mask</parameter>. The 
<parameter>category_mask</parameter> value is a bitwise
inclusive OR of the required 
<literal>LC_<replaceable>name</replaceable>_MASK</literal>
<!-- should I list these??? nick -->
values, or the value <constant>LC_ALL_MASK</constant>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>newlocale</function> function shall return 
the initialized locale object. Otherwise, it shall return
<constant>NULL</constant>, and set <varname>errno</varname>
to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>The <function>newlocale</function> function shall fail if:
<variablelist>
<varlistentry>
<term><errorcode>ENOMEM</errorcode></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><errorcode>EINVAL</errorcode></term>
<listitem><para>
An invalid <parameter>category_mask</parameter> was provided, or
the <parameter>locale</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><errorcode>ENOENT</errorcode></term>
<listitem><para>
For any of the categories in <parameter>category_mask</parameter>,
the locale data is not available.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</REFSECT1>
<refsect1>
<title>Application Usage (Informative)</title>
<para>
The only portable way to allocate a locale object is to call
<function>newlocale</function> with a <constant>NULL</constant>
<parameter>base</parameter>. The allocated object may be reinitialized
to a new locale by passing it back to <function>newlocale</function>.
The new object may be released by calling <function>freelocale</function>.
</para>
</refsect1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>setlocale</function></member>
<member><function>freelocale</function></member>
<member><function>duplocale</function></member>
<member><function>uselocale</function></member>
</simplelist>
</para>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-ngettext"> <REFMETA>
<REFENTRYTITLE>ngettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ngettext</REFNAME>
<REFPURPOSE>
search message catalogs for plural string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>ngettext</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid1</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>msgid2</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned long int 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>ngettext</FUNCTION> function shall search the currently 
selected message catalogs for a string matching the singular string
<PARAMETER>msgid1</PARAMETER>. If a string is located, and if
<PARAMETER>n</PARAMETER> is 1, that string shall be returned.
If <PARAMETER>n</PARAMETER> is not 1, a pluralized version
(dependent on <PARAMETER>n</PARAMETER>) of the string shall be returned.
</PARA>
<PARA>
The <FUNCTION>ngettext</FUNCTION> function is equivalent to
<FUNCTION>dcngettext(NULL, msgid1, msgid2, n, LC_MESSAGES)</FUNCTION>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>

<PARA>
If a string is found in the currently selected message catalogs for
<PARAMETER>msgid1</PARAMETER>, then if <PARAMETER>n</PARAMETER> is
<CONSTANT>1</CONSTANT> a pointer to the located string shall be returned.
If <PARAMETER>n</PARAMETER> is not <CONSTANT>1</CONSTANT>, a pointer to an
appropriately pluralized version of the string shall be returned.
If no message could be found in the currently selected mesage catalogs,
then if <PARAMETER>n</PARAMETER> is <CONSTANT>1</CONSTANT>,
a pointer to <PARAMETER>msgid1</PARAMETER> shall be returned, otherwise
a pointer to <PARAMETER>msgid2</PARAMETER> shall be returned.
</PARA>
<PARA>
Applications shall not modify the string returned by <FUNCTION>
ngettext</FUNCTION>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None.</PARA>
<PARA>
The <FUNCTION>ngettext</FUNCTION> function shall not modify 
<VARNAME>errno</VARNAME>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
gettext, dgettext, ngettext, 
dngettext, dcgettext, dcngettext, textdomain,
bindtextdomain, bind_textdomain_codeset
</PARA>
</REFSECT1>

</REFENTRY>


<!-- MISSING DEFINITION FOR nrand48_r -->
<!-- Lets just hope nobody notices -->
<refentry id="baselib-openat64"> 
<refmeta>
<refentrytitle>openat64</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>openat64</refname>
<refpurpose>
open a file relative to a directory file descriptor (Large File Support)
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<refsynopsisdivinfo>
<date>19 June 2008</date>
</refsynopsisdivinfo>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fcntl.h&gt;
</funcsynopsisinfo>
<funcprototype>
 <funcdef>int
  <function>openat64</function></funcdef>
 <paramdef>int 
  <parameter><replaceable>fd</replaceable></parameter></paramdef>
 <paramdef>const char *
  <parameter><replaceable>path</replaceable></parameter></paramdef>
 <paramdef>int 
  <parameter><replaceable>oflag</replaceable></parameter></paramdef>
 <varargs>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<refsect1info>
<date>19 June 2008</date>
</refsect1info>
<title>Description</title>
<para>
<function>openat64</function> shall establish a connection
between a file and a file descriptor. It shall be identical
<function>open64</function> except in the case where
<parameter>path</parameter> specifies a relative path. In
this case, the file to be opened shall be determined relative to
the directory associated with the file descriptor
<parameter>fd</parameter> instead of the current working directory.
</para>
<para>
<function>openat64</function> is a large-file version of
the <function>openat</function> function as defined in
<xref linkend=std.SUSv4>.
It differs from <function>openat</function> in the
same way that <function>open64</function> differs from
<function>open</function>, that the open is done in
large-file mode.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>openat64</function> returns a new
file descriptor.
Otherwise <function>openat64</function>
shall return <RETURNVALUE>-1</RETURNVALUE> and
set <VARNAME>errno</VARNAME> to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
See <function>openat</function> for possible error values.
</para>
</refsect1>
</refentry>

<REFENTRY ID="baselib-pmap-getport-3"> <REFMETA>
<REFENTRYTITLE>pmap_getport</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pmap_getport</REFNAME>
<REFPURPOSE>
find the port number assigned to a service registered with a
portmapper.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>6 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/pmap_clnt.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>u_short *
  <FUNCTION>pmap_getport</FUNCTION></FUNCDEF>
 <PARAMDEF>struct sockaddr_in *
  <PARAMETER><REPLACEABLE>address</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const u_long
  <PARAMETER><REPLACEABLE>program</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const u_long *
  <PARAMETER><REPLACEABLE>version</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>u_int 
  <PARAMETER><REPLACEABLE>protocol</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>6 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>pmap_getport</FUNCTION> function shall
return the port number assigned to a service registered with a
RPC Binding service running on a given target system,
using the protocol described in
<XREF LINKEND="STD.RFC1833">.
The <function>pmap_getport</function> function shall be called given the
RPC program number <parameter>program</parameter>,
the program version <parameter>version</parameter>, and transport
protocol <parameter>protocol</parameter>. Conforming implementations shall
support both <constant>IPPROTO_UDP</constant> and 
<constant>IPPROTO_TCP</constant> protocols. On entry,
<parameter>address</parameter> shall specify the address of the 
system on which the portmapper to be
contacted resides. The value of <varname>address->sin_port</varname>
shall be ignored, and the standard
value for the portmapper port shall always be used.
</PARA>
<NOTE><PARA>Security and network restrictions may prevent a
conforming application from contacting a remote RPC Binding
Service.</PARA></NOTE>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <FUNCTION>pmap_getport</FUNCTION> function shall return 
the port number in host byte order of the RPC application
registered with the remote portmapper. On failure, 
if either the program was not
registered or the remote portmapper service could not be reached, 
the <function>pmap_getport</function> function
shall return 0. If the remote portmap service could not be reached, the status
is left in the global variable <varname>rpc_createerr</varname>.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<REFENTRY ID="baselib-pmap-set-3"> <REFMETA>
<REFENTRYTITLE>pmap_set</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pmap_set</REFNAME>
<REFPURPOSE>
establishes mapping to machine's RPC Bind service.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>12 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/pmap_clnt.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>bool_t
  <FUNCTION>pmap_set</FUNCTION></FUNCDEF>
 <PARAMDEF>const u_long
  <PARAMETER><REPLACEABLE>program</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const u_long
  <PARAMETER><REPLACEABLE>version</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int
  <PARAMETER><REPLACEABLE>protocol</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>u_short
  <PARAMETER><REPLACEABLE>port</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>12 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pmap_set</FUNCTION> establishes a mapping between the
triple <PARAMETER>[program,version,protocol]</PARAMETER> and
<PARAMETER>port</PARAMETER> on the machine's RPC Bind
service. The value of <PARAMETER>protocol</PARAMETER>
is most likely <VARNAME>IPPROTO_UDP</VARNAME> or <VARNAME>IPPROTO_TCP
</VARNAME>. Automatically done by <FUNCTION>svc_register</FUNCTION>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>pmap_set</FUNCTION> returns non-zero if it suceeds, 0 otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<REFENTRY ID="baselib-pmap-unset-3"> <REFMETA>
<REFENTRYTITLE>pmap_unset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pmap_unset</REFNAME>
<REFPURPOSE>
destroys RPC Binding
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/pmap_clnt.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>bool_t
  <FUNCTION>pmap_unset</FUNCTION></FUNCDEF>
 <PARAMDEF>u_long
  <PARAMETER><REPLACEABLE>prognum</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>u_long
  <PARAMETER><REPLACEABLE>versnum</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>17 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
As a user interface to the RPC Bind service, 
<FUNCTION>pmap_unset</FUNCTION> destroys all mapping between the triple 
[<PARAMETER>prognum</PARAMETER>,<PARAMETER>versnum</PARAMETER>,
<PARAMETER>*</PARAMETER>] and <VARNAME>ports</VARNAME> on the machine's 
RPC Bind service.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>pmap_unset</FUNCTION> returns non-zero if it succeeds, zero otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<REFENTRY ID="baselib-posix-fadvise64"> <REFMETA>
<REFENTRYTITLE>posix_fadvise64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>posix_fadvise64</REFNAME>
<REFPURPOSE>
File advisory information (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fcntl.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>posix_fadvise64</function>
</funcdef>
<paramdef>int
<parameter>fd</parameter>
</paramdef>
<paramdef>off64_t
<parameter>offset</parameter>
</paramdef>
<paramdef>off64_t
<parameter>len</parameter>
</paramdef>
<paramdef>int
<parameter>advice</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 August 2007</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<para>
The <FUNCTION>posix_fadvise64</FUNCTION> function is a large-file
version of the <FUNCTION>posix_fadvise</FUNCTION> function defined in
<XREF LINKEND=STD.SUSv3>.
It shall advise the implementation on the expected behavior of the
application with respect to the data in the file associated with the open file descriptor, 
<parameter>fd</parameter>, starting
at <parameter>offset</parameter> and continuing for <parameter>len</parameter> bytes. 
The specified range need not currently exist in the file. If <parameter>len</parameter>
is zero, all data following <parameter>offset</parameter> is specified. 
The implementation may use this information to
optimize handling of the specified data. The <function>posix_fadvise</function> function shall have no effect on the
semantics of other operations on the specified data, although it may affect the performance of
other operations.
</para>
<PARA>
The advice to be applied to the data is specified by the <parameter>advice</parameter> parameter, as specified
in <function>posix_fadvise</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <function>posix_fadvise64</function> shall return <RETURNVALUE>0</RETURNVALUE>. Otherwise
an error number shall be returned to indicate the error.
See <function>posix_fadvise</function> for possible error values.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-posix-fallocate64"> <REFMETA>
<REFENTRYTITLE>posix_fallocate64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>posix_fallocate64</REFNAME>
<REFPURPOSE>file space control (Large File Support)</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fcntl.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>posix_fallocate64</function>
</funcdef>
<paramdef>int
<parameter>fd</parameter>
</paramdef>
<paramdef>off64_t
<parameter>offset</parameter>
</paramdef>
<paramdef>off64_t
<parameter>len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>posix_fallocate64</FUNCTION> function is a large file version of
<function>posix_fallocate</function>. It shall behave as <function>posix_fallocate</function>
in <xref linkend="std.susv3">, except that the <parameter>offset</parameter> and <parameter>len</parameter>
arguments are <varname>off64_t</varname> objects rather than <varname>off_t</varname>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
See <function>posix_fallocate</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>See <FUNCTION>posix_fallocate</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-psignal-3"> <REFMETA>
<REFENTRYTITLE>psignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>psignal</REFNAME>
<REFPURPOSE>
print signal message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;signal.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>psignal</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sig</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
<SYNOPSIS>
extern const char *const <VARNAME>sys_siglist</VARNAME>[]
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>psignal</FUNCTION> function shall 
display a message on the <varname>stderr</varname> stream.
If <PARAMETER>s</PARAMETER> is not the null pointer, and does 
not point to an empty string (e.g. <LITERAL>"\0"</LITERAL>), the
message shall consist 
of the string <PARAMETER>s</PARAMETER>, a colon, a space, and a string 
describing the signal number <PARAMETER>sig</PARAMETER>; otherwise
<function>psignal</function> shall display only a message describing
the signal number <PARAMETER>sig</PARAMETER>. If 
<PARAMETER>sig</PARAMETER> is invalid, the message displayed shall 
indicate an unknown signal.
</PARA>
<PARA>
The array <VARNAME>sys_siglist</VARNAME> holds the signal description 
strings indexed by signal number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>psignal</FUNCTION> returns no value.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<refentry id="baselib-putwc-unlocked-1">

<refmeta>
<refentrytitle>putwc_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>putwc_unlocked</refname>
<refpurpose>non-thread-safe putwc</refpurpose>
<indexterm id="ix-baselib-putwc-unlocked-1">
  <primary>putwc_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>putwc_unlocked</function> is the same as
<function>putwc</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<refentry id="baselib-putwchar-unlocked-1">

<refmeta>
<refentrytitle>putwchar_unlocked</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>putwchar_unlocked</refname>
<refpurpose>non-thread-safe putwchar</refpurpose>
<indexterm id="ix-baselib-putwchar-unlocked-1">
  <primary>putwchar_unlocked</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>putwchar_unlocked</function> is the same as
<function>putwchar</function>, except that it need not be thread-safe.
That is, it may only be invoked in the ways which are legal for
<function>getc_unlocked</function>.
</para>

</refsect1>
</refentry>

<REFENTRY ID="baselib-random-r-3"> <REFMETA>
<REFENTRYTITLE>random_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>random_r
</REFNAME>
<REFPURPOSE>
generate random number (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>29 May 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>random_r</FUNCTION></FUNCDEF>
 <PARAMDEF>struct random_data * restrict
  <PARAMETER>buf</PARAMETER></PARAMDEF>
 <PARAMDEF>int32_t * restrict 
  <PARAMETER><REPLACEABLE>result</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>29 May 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>random_r</FUNCTION> is a reentrant version of 
<FUNCTION>random</FUNCTION>, which generates a pseudorandom number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Future Directions</TITLE>
<PARA>
Since this function requires support from other functions not specified in
this specification (most notably <function>initstate_r</function>), a future
version of this specification may remove this interface.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-readdir64-r"> <REFMETA>
<REFENTRYTITLE>readdir64_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>readdir64_r</REFNAME>
<REFPURPOSE>read a directory (Large File Support)</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;dirent.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>readdir64_r</function>
</funcdef>
<paramdef>DIR *
<parameter>dirp</parameter>
</paramdef>
<paramdef>struct dirent64 *
<parameter>entry</parameter>
</paramdef>
<paramdef>struct dirent64 * *
<parameter>result</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>readdir64_r</FUNCTION> function is a large file version of
<function>readdir_r</function>. It shall behave as <function>readdir_r</function>
in <xref linkend="std.susv3">, except that the <parameter>entry</parameter> and <parameter>result</parameter>
arguments are <varname>dirent64</varname> structures rather than <varname>dirent</varname>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
See <function>readdir_r</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>See <FUNCTION>readdir_r</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<refentry id="baselib-regexec-2">

<refmeta>
<refentrytitle>regexec</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>regexec</refname>
<refpurpose>regular expression matching</refpurpose>
<indexterm id="ix-baselib-regexec-2">
  <primary>regexec</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
The <function>regexec</function> function shall behave as specified in 
<CITETITLE><XREF LINKEND="STD.SUSV3"></CITETITLE>, 
except with differences as listed below.
</para>

<refsect2>
<title>Differences</title>
<para>
Certain aspects of regular expression matching are optional;
see <xref linkend="localization-regex">.
</para>
</refsect2>

</refsect1>
</refentry>

<REFENTRY ID="baselib-scanf"> <REFMETA>
<REFENTRYTITLE>scanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>scanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<!-- MISSING DEFINITION FOR sched_getaffinity -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR sched_setaffinity -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-sched-setscheduler"> <REFMETA>
<REFENTRYTITLE>sched_setscheduler</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sched_setscheduler</REFNAME>
<REFPURPOSE>set scheduling policy and parameters</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sched.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
<FUNCDEF>int
<FUNCTION>sched_setscheduler</FUNCTION>
</FUNCDEF>
<PARAMDEF>pid_t
<PARAMETER>pid</PARAMETER>
</PARAMDEF>
<PARAMDEF>int
<PARAMETER>policy</PARAMETER>
</PARAMDEF>
<PARAMDEF>const struct sched_param *
<PARAMETER>param</PARAMETER>
</PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description</TITLE>
<PARA>
The <FUNCTION>sched_setscheduler</FUNCTION> 
shall behave as described in <xref linkend="std.susv3">,
except as noted below.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <returnvalue>0</returnvalue> is returned
instead of the former scheduling policy.
</PARA>
</REFSECT1>
</REFENTRY>

<!-- MISSING DEFINITION FOR seed48_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-sendfile"> <REFMETA>
<REFENTRYTITLE>sendfile</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sendfile
</REFNAME>
<REFPURPOSE>
transfer data between two file descriptors
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/sendfile.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>ssize_t <FUNCTION>sendfile</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>out_fd</PARAMETER></PARAMDEF>
 <PARAMDEF>int
  <PARAMETER>in_fd</PARAMETER></PARAMDEF>
 <PARAMDEF>off_t *
  <PARAMETER>offset</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>count</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>30 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sendfile</FUNCTION> function shall copy data 
between the file descriptor <PARAMETER>in_fd</PARAMETER>, which must not be a socket, 
and the file descriptor <PARAMETER>out_fd</PARAMETER>, which must be a socket. 
<PARAMETER>in_fd</PARAMETER> should be opened for reading, 
and <PARAMETER>out_fd</PARAMETER> should be opened for writing. 
</PARA>
<PARA>
The <PARAMETER>offset</PARAMETER> parameter points to 
a variable set to the file offset at which 
<FUNCTION>sendfile</FUNCTION> shall start reading from <PARAMETER>in_fd</PARAMETER>, 
unless it is <LITERAL>NULL</LITERAL>. 
On exit, this variable shall contain the offset of 
the byte immediately after the last byte read. 
<FUNCTION>sendfile</FUNCTION> shall not change the current file offset 
of <PARAMETER>in_fd</PARAMETER>, unless it is <LITERAL>NULL</LITERAL>. 
In that case, <FUNCTION>sendfile</FUNCTION> shall adjust the current file offset 
to show how many bytes were read.
</PARA>
<PARA>
The <PARAMETER>count</PARAMETER> parameter specifies how many bytes to copy.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <FUNCTION>sendfile</FUNCTION> shall return 
the number of bytes written to <PARAMETER>out_fd</PARAMETER>. 
</PARA>
<PARA>
On failure, <FUNCTION>sendfile</FUNCTION> shall return 
<LITERAL>-1</LITERAL> and set <VARNAME>errno</VARNAME> appropriately, as follows. 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
EAGAIN
</TERM>
<LISTITEM>
<PARA>
Non-blocking I/O with <CONSTANT>O_NONBLOCK</CONSTANT> 
has been chosen, but the write would block.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
The input file is not open for reading, 
or the output file is not open for writing.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
Bad address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL
</TERM>
<LISTITEM>
<PARA>
An <FUNCTION>mmap</FUNCTION>-like operation is unavailable for 
<PARAMETER>in_fd</PARAMETER>, or file descriptor is locked or invalid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO
</TERM>
<LISTITEM>
<PARA>
There was an unspecified error while reading.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
There is not enough memory to read from <PARAMETER>in_fd</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
<FUNCTION>sendfile</FUNCTION> is usually faster than combining 
<FUNCTION>read</FUNCTION> and <FUNCTION>write</FUNCTION> calls, 
because it is part of the kernel. 
However, if it fails with <CONSTANT>EINVAL</CONSTANT>, 
falling back to <FUNCTION>read</FUNCTION> and <FUNCTION>write</FUNCTION> may be advisable.
</PARA>
<PARA>
It is advisable for performance reasons to use the 
<CONSTANT>TCP_CORK</CONSTANT> option of the <FUNCTION>tcp</FUNCTION> function 
when sending header data with file contents to a TCP socket. 
This minimizes the number of packets.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>See Also
</TITLE>
<PARA>
<FUNCTION>mmap</FUNCTION>, <FUNCTION>open</FUNCTION>, 
<FUNCTION>socket</FUNCTION>, <FUNCTION>splice</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-sendfile64"> <REFMETA>
<REFENTRYTITLE>sendfile64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sendfile64
</REFNAME>
<REFPURPOSE>
transfer data between two file descriptors (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/sendfile.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>ssize_t <FUNCTION>sendfile64</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER>out_fd</PARAMETER></PARAMDEF>
 <PARAMDEF>int
  <PARAMETER>in_fd</PARAMETER></PARAMDEF>
 <PARAMDEF>off64_t *
  <PARAMETER>offset</PARAMETER></PARAMDEF>
 <PARAMDEF>size_t
  <PARAMETER>count</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>30 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sendfile64</FUNCTION> function is a large-file version
of the <FUNCTION>sendfile</FUNCTION> function.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-setbuffer-3"> <REFMETA>
<REFENTRYTITLE>setbuffer</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setbuffer
</REFNAME>
<REFPURPOSE>
stream buffering operation
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdio.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>setbuffer</FUNCTION></FUNCDEF>
 <PARAMDEF>FILE *
  <PARAMETER><REPLACEABLE>stream</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>size</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>setbuffer</FUNCTION> is an alias for the call to 
<FUNCTION>setvbuf</FUNCTION>. It works the same, except that the 
size of the buffer in <FUNCTION>setbuffer</FUNCTION> is up to 
the caller, rather than being determined by the default 
<PARAMETER>BUFSIZ</PARAMETER>.  
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setgroups-2"> <REFMETA>
<REFENTRYTITLE>setgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setgroups
</REFNAME>
<REFPURPOSE>
set list of supplementary group IDs
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;grp.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>setgroups</FUNCTION></FUNCDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>size</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const gid_t *
  <PARAMETER><REPLACEABLE>list</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
If the process has appropriate privilege,
the <FUNCTION>setgroups</FUNCTION> function shall set
the supplementary group IDs for 
the current process. <PARAMETER>list</PARAMETER> shall reference
an array of <PARAMETER>size</PARAMETER> group IDs. A process
may have at most <CONSTANT>NGROUPS_MAX</CONSTANT> supplementary
group IDs.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On successful completion, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the <VARNAME>errno</VARNAME> is set to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<ERRORCODE>EFAULT</ERRORCODE>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>list</PARAMETER> has an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
<ERRORCODE>EPERM</ERRORCODE>
</TERM>
<LISTITEM>
<PARA>
The process does not have appropriate privileges.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
<ERRORCODE>EINVAL</ERRORCODE>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>size</PARAMETER> is greater than <VARNAME>NGROUPS_MAX</VARNAME>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>



<REFENTRY ID="baselib-sethostname-2"> <REFMETA>
<REFENTRYTITLE>sethostname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostname
</REFNAME>
<REFPURPOSE>
set host name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
#include &lt;sys/param.h.h&gt;
#include &lt;sys/utsname.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>sethostname</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>len</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
If the process has appropriate privileges, the
<FUNCTION>sethostname</FUNCTION> function shall change the host name for the 
current machine. The <PARAMETER>name</PARAMETER> shall point to a
null-terminated string of at most <PARAMETER>len</PARAMETER> bytes
that holds the new hostname.
</PARA>
<PARA>
If the symbol <CONSTANT>HOST_NAME_MAX</CONSTANT> is defined, or if
<FUNCTION>sysconf(_SC_HOST_NAME_MAX)</FUNCTION> returns a value greater
than 0, this value shall represent the maximum length of the new hostname.
Otherwise, if the symbol <CONSTANT>MAXHOSTLEN</CONSTANT> is defined, this value
shall represent the maximum length for the new hostname. If none of these
values are defined, the maximum length shall be the size of the
<structfield>nodename</structfield> field of the
<structname>utsname</structname> structure.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>len</PARAMETER> is negative or larger than the maximum allowed size.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
the process did not have appropriate privilege.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>name</PARAMETER> is an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Rationale
</TITLE>
<PARA>
<XREF LINKEND=STD.SUSv3>
guarantees that:
<BLOCKQUOTE>
<PARA>
Maximum length of a host name (not including the terminating null) 
as returned from the <function>gethostname</function> function shall be at least 255 bytes.
</PARA>
</BLOCKQUOTE>
</PARA>
<PARA>
The glibc C library does not currently define <CONSTANT>HOST_NAME_MAX</CONSTANT>,
and although it provides the name <CONSTANT>_SC_HOST_NAME_MAX</CONSTANT>
a call to <FUNCTION>sysconf</FUNCTION> returns <RETURNVALUE>-1</RETURNVALUE>
and does not alter <varname>errno</varname> in this case (indicating that
there is no restriction on the hostname length). However, the glibc
manual idicates that some implementations may have 
<CONSTANT>MAXHOSTNAMELEN</CONSTANT> as a means of detecting the maximum length,
while the Linux kernel at release 2.4 and 2.6 stores this hostname
in the <structname>utsname</structname> structure.
While the glibc manual suggests simply shortening the name until
<function>sethostname</function> succeeds, the LSB requires
that one of the first four mechanisms works.
Future versions of glibc may provide a more reasonable result from 
<LITERAL>sysconf</LITERAL>(<CONSTANT>_SC_HOST_NAME_MAX</CONSTANT>).
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<refentry id="baselib-setsockopt-2">

<refmeta>
<refentrytitle>setsockopt</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>setsockopt</refname>
<refpurpose>set socket options</refpurpose>
<indexterm id="ix-baselib-setsockopt-2">
  <primary>setsockopt</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>setsockopt</function>
</funcdef>
<paramdef>int
<parameter>socket</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>int
<parameter>option_name</parameter>
</paramdef>
<paramdef>const void *
<parameter>option_value</parameter>
</paramdef>
<paramdef>socklen_t
<parameter>option_len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
The <function>setsockopt</function> function shall behave as specified in
<CITETITLE><XREF LINKEND="STD.SUSV3"></CITETITLE>,
with the following extensions.
</para>

<refsect2>
<title>IP Protocol Level Options</title>
<para>
If the <parameter>level</parameter> parameter is
<constant>IPPROTO_IP</constant>, the following values shall be supported for
<parameter>option_name</parameter> (see <xref linkend="std.rfc791"> for
further details):
<variablelist>
<varlistentry>
<term><constant>IP_OPTIONS</constant></term>
<listitem><para>
Set the Internet Protocol options sent with
every packet from this socket.
The <parameter>option_value</parameter> shall point to a
memory buffer containing the options and
<parameter>option_len</parameter> shall contain the size in bytes
of that buffer.
For IPv4, the maximum length of options is 40 bytes.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>IP_TOS</constant></term>
<listitem><para>
Set the Type of Service flags
to use when sending packets with this socket.
The <parameter>option_value</parameter> shall point to a value
containing the type of service value. The least significant two bits
of the value shall contain the new Type of Service indicator. Use of other
bits in the value is unspecified.
The <parameter>option_len</parameter> parameter shall hold the size, in bytes,
of the buffer referred to by <parameter>option_value</parameter>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>IP_TTL</constant></term>
<listitem><para>
Set the current unicast Internet Protocol
Time To Live value used when sending packets with this socket.
The <parameter>option_value</parameter> shall point to a value
containing the time to live value, which shall be between
1 and 255.
The <parameter>option_len</parameter> parameter shall hold the size, in bytes,
of the buffer referred to by <parameter>option_value</parameter>.
</para></listitem>
</varlistentry>

<VARLISTENTRY>
<TERM>
<CONSTANT>IP_MULTICAST_TTL</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Sets the Time To Live value of outgoing multicast packets for this
socket. <PARAMETER>optval</PARAMETER> shall point to an integer which contains
the new TTL value. If the new TTL value is <constant>-1</constant>, the implementation
should use an unspecified default TTL value. If the new TTL value is out of the range
of acceptable values (0-255), <function>setsockopt</function> shall return
<constant>-1</constant> and set <varname>errno</varname> to indicate the error.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<CONSTANT>IP_MULTICAST_LOOP</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Sets a boolean flag indicating whether multicast packets originating locally
should be looped back to the local sockets.
<PARAMETER>optval</PARAMETER> shall point to an integer which contains
the new flag value.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<CONSTANT>IP_ADD_MEMBERSHIP</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Join a multicast group.
<PARAMETER>optval</PARAMETER> shall point to a
<STRUCTNAME>ip_mreq</STRUCTNAME> structure. Before calling, the
caller should fill in the <STRUCTFIELD>imr_multiaddr</STRUCTFIELD>
field with the multicast group address and the
<STRUCTFIELD>imr_address</STRUCTFIELD> field with the address of the local
interface. If <STRUCTFIELD>imr_address</STRUCTFIELD> is set to INADDR_ANY,
then an appropriate interface is chosen by the system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<CONSTANT>IP_DROP_MEMBERSHIP</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Leave a multicast group.
<PARAMETER>optval</PARAMETER> shall point to a
<STRUCTNAME>ip_mreq</STRUCTNAME> structure containing the same values as were
used with <CONSTANT>IP_ADD_MEMBERSHIP</CONSTANT>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
<CONSTANT>IP_MULTICAST_IF</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Set the local device for a multicast socket.
<PARAMETER>optval</PARAMETER> shall point to a
<STRUCTNAME>ip_mreq</STRUCTNAME> structure initialized in the same manner as
with <CONSTANT>IP_ADD_MEMBERSHIP</CONSTANT>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</variablelist>
</para>
<para>
The <STRUCTNAME>ip_mreq</STRUCTNAME> structure contains two
<STRUCTNAME>struct in_addr</STRUCTNAME> fields:
<STRUCTFIELD>imr_multiaddr</STRUCTFIELD> and
<STRUCTFIELD>imr_address</STRUCTFIELD>.
</para>
</refsect2>

</refsect1>
<REFSECT1>	 
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>0</RETURNVALUE> is returned. 
On error, <RETURNVALUE>-1</RETURNVALUE> is returned and
the global variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
As defined in <XREF LINKEND="STD.SUSV3">.
</PARA>
</REFSECT1>
</refentry>

<!-- MISSING DEFINITION FOR setstate_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-setutent-3"> <REFMETA>
<REFENTRYTITLE>setutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setutent
</REFNAME>
<REFPURPOSE>
access user accounting database entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>setutent</FUNCTION></FUNCDEF>
 <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>setutent</FUNCTION> function shall 
reset the user accounting database such that the next
call to <function>getutent</function> shall return the first
record in the database.
It is recommended to
call it before any of the other functions that operate on
the user accounting databases (e.g.
<function>getutent</function>)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigandset"> <REFMETA>
<REFENTRYTITLE>sigandset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigandset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical AND
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;signal.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>sigandset</FUNCTION></FUNCDEF>
 <PARAMDEF>sigset_t *
  <PARAMETER><REPLACEABLE>set</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const sigset_t *
  <PARAMETER><REPLACEABLE>left</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const sigset_t *
  <PARAMETER><REPLACEABLE>right</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sigandset</FUNCTION> function shall combine the two signal 
sets referenced
by <PARAMETER>left</PARAMETER> and <PARAMETER>right</PARAMETER>,
using a logical AND operation, and shall place the result in the location
referenced by <PARAMETER>set</PARAMETER>,
The resulting signal set shall contain only signals that are in both
the set referenced by <PARAMETER>left</PARAMETER> and the set referenced by
<PARAMETER>right</PARAMETER>.
</PARA>
<PARA>
Applications shall call <FUNCTION>sigemptyset</FUNCTION> or
<FUNCTION>sigfillset</FUNCTION> at least once for each object
of type <TYPE>sigset_t</TYPE> to initialize it.  If an uninitialized
or <LITERAL>NULL</LITERAL> object is passed to
<FUNCTION>sigandset</FUNCTION>, the results are undefined.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
<function>sigandset</function> returns <returnvalue>0</returnvalue>.
There are no defined error returns.
<!-- On success, <function>sigandset</function> shall return <returnvalue>0
</returnvalue>. Otherise, <function>sigandset</function> shall return
<returnvalue>-1</returnvalue> and set <varname>errno</varname> to indicate
the error. -->
</PARA>
</REFSECT1>

<!--
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><CONSTANT>EINVAL</CONSTANT></TERM>
<LISTITEM>
<PARA>
One or more of 
<PARAMETER>set</PARAMETER>,
<PARAMETER>left</PARAMETER>, or
<PARAMETER>right</PARAMETER> was a null pointer.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT1>
-->

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<function>sigorset</function>
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigisemptyset"> <REFMETA>
<REFENTRYTITLE>sigisemptyset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigisemptyset</REFNAME>
<REFPURPOSE>
check for empty signal set
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;signal.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>sigisemptyset</FUNCTION></FUNCDEF>
 <PARAMDEF>const sigset_t *
  <PARAMETER><REPLACEABLE>set</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sigisemptyset</FUNCTION> function shall
check for empty signal set referenced by <PARAMETER>set</PARAMETER>. 
</PARA>
<PARA>
Applications shall call <FUNCTION>sigemptyset</FUNCTION> or
<FUNCTION>sigfillset</FUNCTION> at least once for each object
of type <TYPE>sigset_t</TYPE> to initialize it.  If an uninitialized
or <LITERAL>NULL</LITERAL> object is passed to
<FUNCTION>sigisemptyset</FUNCTION>, the results are undefined.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
The <FUNCTION>sigisemptyset</FUNCTION> function shall return
a positive non-zero value if the signal set referenced by 
<PARAMETER>set</PARAMETER> is empty, or zero if this set is empty.
There are no defined error returns.
<!-- On error, <FUNCTION>sigisemptyset</FUNCTION> shall return <returnvalue>-1
</returnvalue> and set <varname>errno</varname> to indicate the error. -->
</PARA>
</REFSECT1>

<!--
<REFSECT1>
<TITLE>Errors</Title>
<PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><CONSTANT>EINVAL</CONSTANT></TERM>
<LISTITEM>
<PARA>
<PARAMETER>set</PARAMETER> is a null pointer.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT1>
-->

</REFENTRY>



<REFENTRY ID="baselib-sigorset"> <REFMETA>
<REFENTRYTITLE>sigorset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigorset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical OR
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;signal.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>sigorset</FUNCTION></FUNCDEF>
 <PARAMDEF>sigset_t *
  <PARAMETER><REPLACEABLE>set</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const sigset_t *
  <PARAMETER><REPLACEABLE>left</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const sigset_t *
  <PARAMETER><REPLACEABLE>right</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sigorset</FUNCTION> function shall combine the two signal 
sets referenced
by <PARAMETER>left</PARAMETER> and <PARAMETER>right</PARAMETER>,
using a logical OR operation, and shall place the result in the location
referenced by <PARAMETER>set</PARAMETER>,
The resulting signal set shall contain only signals that are in either
the set referenced by <PARAMETER>left</PARAMETER> or the set referenced by
<PARAMETER>right</PARAMETER>.
</PARA>
<PARA>
Applications shall call <FUNCTION>sigemptyset</FUNCTION> or
<FUNCTION>sigfillset</FUNCTION> at least once for each object
of type <TYPE>sigset_t</TYPE> to initialize it.  If an uninitialized
or <LITERAL>NULL</LITERAL> object is passed to
<FUNCTION>sigorset</FUNCTION>, the results are undefined.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
<function>sigorset</function> returns <returnvalue>0</returnvalue>.
There are no defined error returns.
<!-- On success, <function>sigorset</function> shall return <returnvalue>0
</returnvalue>. Otherise, <function>sigorset</function> shall return
<returnvalue>-1</returnvalue> and set <varname>errno</varname> to indicate
the error. -->
</PARA>
</REFSECT1>

<!--
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><CONSTANT>EINVAL</CONSTANT></TERM>
<LISTITEM>
<PARA>
One or more of 
<PARAMETER>set</PARAMETER>,
<PARAMETER>left</PARAMETER>, or
<PARAMETER>right</PARAMETER> was a null pointer.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT1>
-->

<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<function>sigandset</function>
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigpause-3"> <REFMETA>
<REFENTRYTITLE>sigpause</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigpause
</REFNAME>
<REFPURPOSE>
remove a signal from the signal mask and suspend the thread (deprecated)
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;signal.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>sigpause</function>
</funcdef>
<paramdef>int
<parameter>sig</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<para>
The <function>sigpause</function> function is deprecated from the LSB and
is expected to disappear from a future version of the LSB. Conforming applications
should use <function>sigsuspend</function> instead.
</para>

<!-- this was Nick's decription of the glibc implementation:
<para>
In the source standard, if <constant>_XOPEN_SOURCE</constant> is defined, the <function>__xpg_sigpause</function>
function is used, and <function>sigpause</function> shall behave as described in
<xref linkend="std.susv3">. 
If <constant>_XOPEN_SOURCE</constant> is not defined, this function is used.
</para>
<para>
In the binary standard, <function>sigpause</function> is the version described here.
</para>
-->
<!-- at least for the time being, we ended up with a simpler version: -->
<para>
In the source standard, <function>sigpause</function> is implemented
as a macro causing it to behave as described in <xref linkend="std.susv3">,
and is equivalent to the function <function>__xpg_sigpause</function>.
If the macro is undefined, <function>sigpause</function> from
the binary standard is used, with differences as described here:
</para>

<para>
The <function>sigpause</function> function shall block those signals
indicated by <parameter>sig</parameter> and suspend execution of the
thread until a signal is delivered. When a signal is delivered,
the original signal mask shall be restored.
</para>
</refsect1>
<refsect1>
<title>See Also</title>
<para>
<simplelist type=inline>
<member><function>__xpg_sigpause</function></member>
</simplelist>
</para>
</refsect1>
</refentry>

<REFENTRY ID="baselib-sigreturn-2"> <REFMETA>
<REFENTRYTITLE>sigreturn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigreturn
</REFNAME>
<REFPURPOSE>
return from signal handler and cleanup stack frame
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>sigreturn</FUNCTION></FUNCDEF>
 <PARAMDEF>struct sigcontext *
  <PARAMETER><REPLACEABLE>scp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>sigreturn</function> function is used by the system 
to cleanup after a signal handler has returned.
This function is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>sigreturn</FUNCTION> never returns.
</PARA>
</REFSECT1>

<!-- LDP GENERAL PUBLIC LICENSE  -->
<!-- Version 1a, November 1998   -->

</REFENTRY>

<!-- MISSING DEFINITION FOR srand48_r -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR srandom_r -->
<!-- Lets just hope nobody notices -->
<REFENTRY ID="baselib-sscanf"> <REFMETA>
<REFENTRYTITLE>sscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>sscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-statfs-2"> <REFMETA>
<REFENTRYTITLE>statfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statfs</REFNAME>
<REFPURPOSE>(deprecated)</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/statfs.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>statfs</FUNCTION></FUNCDEF>
 <PARAMDEF>const char 
  <PARAMETER><REPLACEABLE>*path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF><FUNCPARAMS>struct <STRUCTNAME>statfs</STRUCTNAME> *
  <PARAMETER>buf</PARAMETER></FUNCPARAMS></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>statfs</FUNCTION> function returns information about a mounted 
file system.  The file system is identified by <PARAMETER>path</PARAMETER>,
a path name of a file within the mounted filesystem.
The results are placed in the structure pointed to by
</PARA>
<PARA>
Fields that are undefined for a particular file system shall
be set to
<LITERAL>0</LITERAL>.
</PARA>
<NOTE>
<PARA>
Application developers should use the <FUNCTION>statvfs</FUNCTION> function
to obtain general file system information. Applications should only
use the <FUNCTION>statfs</FUNCTION> function if they must determine
the file system type, which need not be provided by 
<FUNCTION>statvfs</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <FUNCTION>statfs</FUNCTION> function shall
return <RETURNVALUE>0</RETURNVALUE> and set the fields of the
structure idenfitied by <PARAMETER>buf</PARAMETER> accordingly.
On error, the <FUNCTION>statfs</FUNCTION> function shall
return <RETURNVALUE>-1</RETURNVALUE> and set
<VARNAME>errno</VARNAME> accordingly.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
ENOTDIR
</TERM>
<LISTITEM>
<PARA>
A component of the path prefix of <PARAMETER>path</PARAMETER> is 
not a directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENAMETOOLONG
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>path</PARAMETER> is too long.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOENT 
</TERM>
<LISTITEM>
<PARA>
The file referred to by <PARAMETER>path</PARAMETER> does not exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
Search permission is denied for a component of the path prefix of 
<PARAMETER>path</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ELOOP
</TERM>
<LISTITEM>
<PARA>
Too many symbolic links were encountered in translating 
<PARAMETER>path</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>buf</PARAMETER> or <PARAMETER>path</PARAMETER> points to 
an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient kernel memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
The filesystem <PARAMETER>path</PARAMETER> is on does not support 
<FUNCTION>statfs</FUNCTION>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-statfs64"> <REFMETA>
<REFENTRYTITLE>statfs64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statfs64</REFNAME>
<REFPURPOSE>(deprecated)</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/statfs.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>statfs64</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF><FUNCPARAMS>struct <STRUCTNAME>statfs64</STRUCTNAME> *
  <PARAMETER>buf</PARAMETER></FUNCPARAMS></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>statfs64</FUNCTION> function returns information about a mounted 
file system.  The file system is identified by <PARAMETER>path</PARAMETER>,
a path name of a file within the mounted filesystem.
The results are placed in the structure pointed to by
<PARAMETER>buf</PARAMETER>.
</PARA>
<PARA>
<FUNCTION>statfs64</FUNCTION> is a large-file
version of the <FUNCTION>statfs</FUNCTION> function.
</PARA>
<PARA>
Fields that are undefined for a particular file system shall
be set to
<LITERAL>0</LITERAL>.
</PARA>
<NOTE>
<PARA>
Application developers should use the <FUNCTION>statvfs64</FUNCTION> function
to obtain general file system information. Applications should only
use the <FUNCTION>statfs64</FUNCTION> function if they must determine
the file system type, which need not be provided by 
<FUNCTION>statvfs64</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <FUNCTION>statfs64</FUNCTION> function shall
return <RETURNVALUE>0</RETURNVALUE> and set the fields of the
structure idenfitied by <PARAMETER>buf</PARAMETER> accordingly.
On error, the <FUNCTION>statfs64</FUNCTION> function shall
return <RETURNVALUE>-1</RETURNVALUE> and set
<VARNAME>errno</VARNAME> accordingly.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>See <FUNCTION>fstatfs</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-stime-2"> <REFMETA>
<REFENTRYTITLE>stime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stime
</REFNAME>
<REFPURPOSE>
set time
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _SVID_SOURCE
#include &lt;time.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>stime</FUNCTION></FUNCDEF>
 <PARAMDEF>const time_t *
  <PARAMETER><REPLACEABLE>t</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If the process has appropriate privilege, the <FUNCTION>stime</FUNCTION>
function shall set the system's idea of the time and date. 
Time, referenced by <PARAMETER>t</PARAMETER>, is measured in seconds 
from the epoch (defined in
<XREF LINKEND=STD.SUSv3> as 00:00:00 UTC January 1, 1970).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <function>stime</function> shall return 
<RETURNVALUE>0</RETURNVALUE>.
Otherwise, <function>stime</function> shall return 
<RETURNVALUE>-1</RETURNVALUE> and
<VARNAME>errno</VARNAME> shall be set to indicate the error.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<CONSTANT>
EPERM
</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
The process does not have appropriate privilege.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
<CONSTANT>
EINVAL
</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
<PARAMETER>t</PARAMETER> is a null pointer.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-stpcpy-3"> <REFMETA>
<REFENTRYTITLE>stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpcpy</REFNAME>
<REFPURPOSE>
copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>stpcpy</FUNCTION></FUNCDEF>
 <PARAMDEF>char * restrict
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>stpcpy</FUNCTION> function shall
copy the string pointed to by 
<PARAMETER>src</PARAMETER> (including the terminating null
character) to the array pointed to by <PARAMETER>dest</PARAMETER>. 
The strings may not overlap, and the destination string 
<PARAMETER>dest</PARAMETER> shall be large enough to receive the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>stpcpy</FUNCTION> returns a pointer to the end of the string 
<PARAMETER>dest</PARAMETER> (that is, the address of the terminating 
null character) rather than the beginning.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Example
</TITLE>
<PARA>
This program uses <FUNCTION>stpcpy</FUNCTION> to concatenate 
<LITERAL>foo</LITERAL> and <LITERAL>bar</LITERAL> to produce 
<LITERAL>foobar</LITERAL>, which it then prints.
<SYNOPSIS>
  #include &lt;string.h>

  int
  main (void)
  {
    char buffer[256];
    char *to = buffer;
    to = stpcpy (to, "foo");
    to = stpcpy (to, "bar");
    printf ("%s\n", buffer);
  }
</SYNOPSIS>
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-stpncpy-3"> <REFMETA>
<REFENTRYTITLE>stpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpncpy</REFNAME>
<REFPURPOSE>
copy a fixed-size string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>stpncpy</FUNCTION></FUNCDEF>
 <PARAMDEF>char * restrict
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>stpncpy</FUNCTION> function
shall copy at most <PARAMETER>n</PARAMETER> 
characters from the string pointed to by <PARAMETER>src</PARAMETER>, 
including the terminating null character, to the array 
pointed to by <PARAMETER>dest</PARAMETER>. Exactly <PARAMETER>n</PARAMETER>
characters are written at <PARAMETER>dest</PARAMETER>. If the length 
<FUNCTION>strlen</FUNCTION><PARAMETER>(src)</PARAMETER> is smaller than 
<PARAMETER>n</PARAMETER>, the remaining characters in 
<PARAMETER>dest</PARAMETER> are filled with <TOKEN>'\0'</TOKEN> characters. 
If the length <LITERAL>strlen</LITERAL><PARAMETER>(src)</PARAMETER> 
is greater than or equal to <PARAMETER>n</PARAMETER>, 
<PARAMETER>dest</PARAMETER> will not be null terminated.
</PARA>
<PARA>
The strings may not overlap.
</PARA>
<PARA>
The programmer shall ensure that there is room for at least
<PARAMETER>n</PARAMETER> characters at <PARAMETER>dest</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <FUNCTION>stpncpy</FUNCTION> function shall return
a pointer to the terminating 
<TOKEN>NULL</TOKEN> in <PARAMETER>dest</PARAMETER>, or, if 
<PARAMETER>dest</PARAMETER> is not <TOKEN>NULL</TOKEN>-terminated, 
<PARAMETER>dest</PARAMETER> + <PARAMETER>n</PARAMETER>.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strcasestr"> <REFMETA>
<REFENTRYTITLE>strcasestr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strcasestr</REFNAME>
<REFPURPOSE>
locate a substring ignoring case
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>strcasestr</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>s1</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>s2</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strcasestr</FUNCTION> shall behave as 
<FUNCTION>strstr</FUNCTION>, 
except that it shall ignore the case of both strings.
The <FUNCTION>strcasestr</FUNCTION> function shall be locale aware;
that is <FUNCTION>strcasestr</FUNCTION> shall behave as if both
strings had been converted to lower case in the current locale
before the comparison is performed.

</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Upon successful completion, 
<FUNCTION>strcasestr</FUNCTION> shall return a pointer to the located
string or a null pointer if the string is not found. 
If <PARAMETER>s2</PARAMETER> points to a string
with zero length, the function shall return <PARAMETER>s1</PARAMETER>.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strerror-r"> <REFMETA>
<REFENTRYTITLE>strerror_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strerror_r</REFNAME>
<REFPURPOSE>
return string describing error number
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>strerror_r</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>errnum</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>buflen</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<!-- this was Nick's decription of the glibc implementation:
<PARA>
If the symbol <symbol>_XOPEN_SOURCE</symbol> is defined with a value of <literal>600</literal>, or the
symbol <symbol>_POSIX_C_SOURCE</symbol> is defined with a value of <literal>200112L</literal>, the
<function>strerror_r</function> function shall behave as described in <xref linkend="std.susv3">,
and is equivalent to the function <function>__xpg_strerror_r</function>. Otherwise,
the <function>strerror_r</function> function shall behave as specified in
<xref linkend="std.susv3">, except as described below.
</para>
-->
<!-- at least for the time being, we ended up with a simpler version: -->
<para>
In the source standard, <function>strerror_r</function> is implemented
as a macro causing it to behave as described in <xref linkend="std.susv3">,
and is equivalent to the function <function>__xpg_strerror_r</function>.
If the macro is undefined, <function>strerror_r</function> from
the binary standard is used, with differences as described here.
</para>

<para>
The <function>strerror_r</function> function shall return a pointer to
the string corresponding to the error number <parameter>errnum</parameter>. 
The returned pointer may point within 
the buffer <parameter>buf</parameter> (at most 
<parameter>buflen</parameter> bytes).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>strerror_r</function> shall return a pointer
to the generated message string (determined by the setting of the
<envar>LC_MESSAGES</envar> category in the current locale).
Otherwise, <function>strerror_r</function> shall return the string
corresponding to <returnvalue>"Unknown error"</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>See Also</title>
<para>
<simplelist type=inline>
<member><function>__xpg_strerror_r</function></member>
</simplelist>
</para>
</refsect1>
</refentry>


<REFENTRY ID="baselib-strndup"> <REFMETA>
<REFENTRYTITLE>strndup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strndup</REFNAME>
<REFPURPOSE>
return a malloc'd copy of at most the specified number of bytes of a string 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>strndup</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>string</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strndup</FUNCTION> function shall return a 
<FUNCTION>malloc</FUNCTION>'d copy of at most <PARAMETER>n</PARAMETER> 
bytes of <PARAMETER>string</PARAMETER>. The resultant string shall be 
terminated even if no <TOKEN>NULL</TOKEN> terminator appears 
before <PARAMETER>string</PARAMETER>+<PARAMETER>n</PARAMETER>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <function>strndup</function> shall return a pointer to a newly
allocated block of memory containing a copy of at most <parameter>n</parameter>
bytes of <parameter>string</parameter>. Otherwise, <function>strndup</function>
shall return <returnvalue>NULL</returnvalue> and set <varname>errno</varname>
to indicate the error.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<CONSTANT>
ENOMEM
</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Insufficient memory available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strnlen-3"> <REFMETA>
<REFENTRYTITLE>strnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>strnlen</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>maxlen</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strnlen</FUNCTION> function shall compute the
number of bytes in the array to which <PARAMETER>s</PARAMETER>
points, stopping at <PARAMETER>maxlen</PARAMETER> bytes.
A null byte and any bytes following it are not counted.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <FUNCTION>strnlen</FUNCTION> function shall return the length
of <PARAMETER>s</PARAMETER> if that is less than 
<PARAMETER>maxlen</PARAMETER>, or <PARAMETER>maxlen</PARAMETER>
if there is no null byte in the first <PARAMETER>maxlen</PARAMETER> bytes.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
No errors are defined.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-strptime-3"> <REFMETA>
<REFENTRYTITLE>strptime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strptime
</REFNAME>
<REFPURPOSE>
parse a time string
</REFPURPOSE>
</REFNAMEDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strptime</FUNCTION> shall behave as specified in the
<CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3>
</CITETITLE> with differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Number of leading zeroes may be limited
</TITLE>
<PARA>
The <CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3>
</CITETITLE> specifies fields for which "leading zeros are
permitted but not required"; however, applications shall not expect to 
be able to supply more leading zeroes for these fields than would be 
implied by the range of the field. Implementations may choose to 
either match an input with excess leading zeroes, or treat this as a 
non-matching input.  For example, <VARNAME>%j</VARNAME> has a range of 
<LITERAL>001</LITERAL> to <LITERAL>366</LITERAL>, so <LITERAL>0</LITERAL>, 
<LITERAL>00</LITERAL>, <LITERAL>000</LITERAL>, <LITERAL>001</LITERAL>, 
and <LITERAL>045</LITERAL> are acceptable inputs, but inputs such as 
<LITERAL>0000</LITERAL>, <LITERAL>0366</LITERAL> and the like are not.
</PARA>
</REFSECT2>

</REFSECT1>

<REFSECT1>
<TITLE>Rationale
</TITLE>
<PARA>
<EMPHASIS>glibc</EMPHASIS> developers consider it appropriate behavior 
to forbid excess leading zeroes.  When trying to parse a given input
against several format strings, forbidding excess leading zeroes could
be helpful.  For example, if one matches <LITERAL>0011-12-26</LITERAL> 
against <LITERAL>%m-%d-%Y</LITERAL> and then against 
<LITERAL>%Y-%m-%d</LITERAL>, it seems useful for the first match to fail, 
as it would be perverse to parse that date as November 12, year 26.  
The second pattern parses it as December 26, year 11.
</PARA>
<PARA>
The <CITETITLE PUBWORK="BOOK"><XREF LINKEND=STD.SUSv3></CITETITLE> is 
not explicit that an unlimited number of leading zeroes are required, 
although it may imply this. The <ACRONYM>LSB</ACRONYM> explicitly 
allows implementations to have either behavior. Future versions of this 
standard may require implementations to forbid excess leading zeroes.
</PARA>
<PARA>
An Interpretation Request is
currently pending against <XREF LINKEND=STD.SUSV3> for this matter.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-strsep-3"> <REFMETA>
<REFENTRYTITLE>strsep</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsep</REFNAME>
<REFPURPOSE>
extract token from string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>strsep</FUNCTION></FUNCDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>stringp</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>delim</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strsep</FUNCTION> function shall find the first token
in the string referenced by the pointer <PARAMETER>stringp</PARAMETER>,
using the characters in <PARAMETER>delim</PARAMETER> as delimiters.
</PARA>
<PARA>
If <PARAMETER>stringp</PARAMETER> is <TOKEN>NULL</TOKEN>, 
<FUNCTION>strsep</FUNCTION> shall return <RETURNVALUE>NULL</RETURNVALUE> 
and do nothing else. 
</PARA>
<PARA>
If <PARAMETER>stringp</PARAMETER> is non-<TOKEN>NULL</TOKEN>, 
<FUNCTION>strsep</FUNCTION> shall find the first token in the 
string referenced by
<PARAMETER>stringp</PARAMETER>, where tokens are delimited by characters 
in the string <PARAMETER>delim</PARAMETER>. This token shall be terminated 
with a <TOKEN>\0</TOKEN> character by overwriting the delimiter, and 
<PARAMETER>stringp</PARAMETER> shall be updated to point past the token. In 
case no delimiter was found, the token is taken to be the entire string 
referenced by
<PARAMETER>stringp</PARAMETER>, and the location referenced by
<PARAMETER>stringp</PARAMETER> is 
made <TOKEN>NULL</TOKEN>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>strsep</FUNCTION> shall return a pointer to the 
beginning of the token.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The <FUNCTION>strsep</FUNCTION> function was introduced as a replacement for 
<FUNCTION>strtok</FUNCTION>, since the latter cannot handle empty 
fields. However, <FUNCTION>strtok</FUNCTION> conforms to 
<XREF LINKEND=STD.ISOC99> and to <XREF LINKEND=STD.SUSv3> and hence is more portable.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also
</TITLE>
<PARA>
<FUNCTION>strtok</FUNCTION>, <FUNCTION>strtok_r</FUNCTION>. 
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strsignal-3"> <REFMETA>
<REFENTRYTITLE>strsignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsignal</REFNAME>
<REFPURPOSE>
return string describing signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#define _GNU_SOURCE
#include &lt;string.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>strsignal</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>sig</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
<SYNOPSIS>
extern const char * const <VARNAME>sys_siglist</VARNAME>[];
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>strsignal</FUNCTION> function shall return a pointer to
a string describing the signal 
number <PARAMETER>sig</PARAMETER>. 
The string can only be used until the next call to <function>strsignal
</function>.
</PARA>
<PARA>
The array <VARNAME>sys_siglist</VARNAME> holds the signal description 
strings indexed by signal number. This array should not be accessed 
directly by applications.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
If <PARAMETER>sig</PARAMETER> is a valid signal number,
<FUNCTION>strsignal</FUNCTION> shall return a pointer to
the appropriate description 
string. Otherwise, <FUNCTION>strsignal</FUNCTION> shall return
either a pointer to the string <LITERAL>"unknown signal"</LITERAL>, or
a null pointer.
</PARA>
<PARA>
Although the function is not declared as returning a pointer to a constant
character string, applications shall not modify the returned string.
</PARA>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strtoq-3"> <REFMETA>
<REFENTRYTITLE>strtoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtoq
</REFNAME>
<REFPURPOSE>
convert string value to a long or quad_t integer
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>long long 
  <FUNCTION>strtoq</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>strtoq</FUNCTION> converts the string <PARAMETER>nptr</PARAMETER> 
to a quadt value. The conversion is done according to the given base, which 
shall be between <LITERAL>2</LITERAL> and <LITERAL>36</LITERAL> inclusive, 
or be the special value <LITERAL>0</LITERAL>.
</PARA><PARA>
<PARAMETER>nptr</PARAMETER> may begin with an arbitrary amount of white 
space (as determined by <FUNCTION>isspace</FUNCTION>), followed by a 
single optional <TOKEN>+</TOKEN> or <TOKEN>-</TOKEN> sign character. If 
<PARAMETER>base</PARAMETER> is <LITERAL>0</LITERAL> or <LITERAL>16</LITERAL>, 
the string may then include a <TOKEN>0x</TOKEN> prefix, and the number will 
be read in base 16; otherwise, a <LITERAL>0</LITERAL> base is taken as 
10 (decimal), unless the next character is <LITERAL>0</LITERAL>, in which 
case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to a long value in the obvious 
manner, stopping at the first character which is not a valid digit in the 
given base. (In bases above 10, the letter <LITERAL>A</LITERAL> in either 
upper or lower case represents 10, <LITERAL>B</LITERAL> represents 11, and 
so forth, with <LITERAL>Z</LITERAL> representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>strtoq</FUNCTION> returns the result of the conversion, 
unless the value would underflow or overflow. If an underflow occurs, 
<FUNCTION>strtoq</FUNCTION> returns <VARNAME>QUAD_MIN</VARNAME>. If 
an overflow occurs, <FUNCTION>strtoq</FUNCTION> returns 
<VARNAME>QUAD_MAX</VARNAME>. In both cases, the global variable 
<VARNAME>errno</VARNAME> is set to <ERRORNAME>ERANGE</ERRORNAME>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strtouq-3"> <REFMETA>
<REFENTRYTITLE>strtouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtouq
</REFNAME>
<REFPURPOSE>
convert a string to an unsigned long long
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>unsigned long long 
  <FUNCTION>strtouq</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char * *
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>strtouq</FUNCTION> converts the string <PARAMETER>nptr</PARAMETER> 
to an <type>unsigned long long</type>
value. The conversion is done according to the given base, which 
shall be between <LITERAL>2</LITERAL> and <LITERAL>36</LITERAL> inclusive, 
or be the special value <LITERAL>0</LITERAL>.
</PARA><PARA>
<PARAMETER>nptr</PARAMETER> may begin with an arbitrary amount of white 
space (as determined by <FUNCTION>isspace</FUNCTION>), followed by a 
single optional <TOKEN>+</TOKEN> or <TOKEN>-</TOKEN> sign character. If 
<PARAMETER>base</PARAMETER> is <LITERAL>0</LITERAL> or <LITERAL>16</LITERAL>, 
the string may then include a <TOKEN>0x</TOKEN> prefix, and the number will 
be read in base 16; otherwise, a <LITERAL>0</LITERAL> base is taken as 
10 (decimal), unless the next character is <LITERAL>0</LITERAL>, in which 
case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to an unsigned long value in the 
obvious manner, stopping at the end of the string or at the first character 
that does not produce a valid digit in the given base. (In bases above 10, 
the letter <LITERAL>A</LITERAL> in either upper or lower case represents 10, 
<LITERAL>B</LITERAL> represents 11, and so forth, with <LITERAL>Z</LITERAL> 
representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, <FUNCTION>strtouq</FUNCTION> returns either the result of 
the conversion or, if there was a leading minus sign, the negation of 
the result of the conversion, unless the original (non-negated) value 
would overflow. In the case of an overflow the function returns 
<VARNAME>UQUAD_MAX</VARNAME> and the global variable <VARNAME>errno</VARNAME> 
is set to <ERRORNAME>ERANGE</ERRORNAME>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-svc-register-3"> <REFMETA>
<REFENTRYTITLE>svc_register</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>svc_register</REFNAME>
<REFPURPOSE>
register Remote Procedure Call interface
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/rpc.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>bool_t
  <FUNCTION>svc_register</FUNCTION></FUNCDEF>
 <PARAMDEF>SVCXPRT *
  <PARAMETER><REPLACEABLE>xprt</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>rpcprog_t
  <PARAMETER><REPLACEABLE>prognum</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>rpcvers_t
  <PARAMETER><REPLACEABLE>versnum</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>__dispatch_fn_t
  <PARAMETER><REPLACEABLE>dispatch</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>rpcprot_t
  <PARAMETER><REPLACEABLE>protocol</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>17 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>svc_register</FUNCTION> function shall associate
the program identified by <PARAMETER>prognum</PARAMETER> at version
<PARAMETER>versnum</PARAMETER>
with the service dispatch procedure, <PARAMETER>dispatch</PARAMETER>.
If <PARAMETER>protocol</PARAMETER> is zero, the service is not registered with the
<VARNAME>portmap</VARNAME> service.  If <PARAMETER>protocol</PARAMETER> is
non-zero, then a mapping of the triple [<PARAMETER>prognum</PARAMETER>,
<PARAMETER>versnum</PARAMETER>, <PARAMETER>protocol</PARAMETER>] to 
<VARNAME>xprt->xp_port</VARNAME> is established with the local 
<VARNAME>portmap</VARNAME> service.  The
procedure <PARAMETER>dispatch</PARAMETER> has the following form:
</PARA>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
<FUNCDEF>int
<FUNCTION>dispatch</FUNCTION></FUNCDEF>
<PARAMDEF>struct svc_req *
<PARAMETER>request</PARAMETER>
</PARAMDEF>
<PARAMDEF>SVCXPRT *
<PARAMETER>xprt</PARAMETER>
</PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>svc_register</FUNCTION> returns 
<RETURNVALUE>1</RETURNVALUE> if it succeeds, and 
<RETURNVALUE>zero</RETURNVALUE> 
otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<REFENTRY ID="baselib-svc-run-3"> <REFMETA>
<REFENTRYTITLE>svc_run</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>svc_run</REFNAME>
<REFPURPOSE>
waits for RPC requests to arrive and calls service procedure
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>12 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/svc.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void
  <FUNCTION>svc_run</FUNCTION></FUNCDEF>
  <VOID>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>12 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>svc_run</FUNCTION> function shall wait for RPC
requests to arrive, read and unpack each request, and dispatch
it to the appropriate registered handler.
Under normal conditions, <FUNCTION>svc_run</FUNCTION> shall not return;
it shall only return if serious errors occur that prevent further
processing.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<refentry id="BASELIB-SVC-SENDREPLY-3"> <refmeta>
<refentrytitle>svc_sendreply</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>svc_sendreply</refname>
<refpurpose>
called by RPC service's dispatch routine
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<refsynopsisdivinfo>
<date>17 June 2003</date>
</refsynopsisdivinfo>
	<funcsynopsis> 
	<funcprototype> 
		<funcdef>bool_t <function>svc_sendreply</function></funcdef> 
		<paramdef>SVCXPRT *<parameter>xprt</parameter></paramdef>
		<paramdef>xdrproc_t <parameter>outproc</parameter></paramdef>
		<paramdef>caddr_t <parameter>out</parameter></paramdef> 
</funcprototype> 
</funcsynopsis> 
</refsynopsisdiv>
<refsect1>

<title>Description
</title>
<para>Called by an RPC service's dispatch routine to send the  results of a remote procedure call.  
The parameter <parameter>xprt</parameter> is the request's associated transport handle; 
<parameter>outproc</parameter> is the XDR routine which is used  to  encode  the  results;  
and  <parameter>out</parameter>  is the address of the results.  
This routine returns one if it succeeds,  zero  otherwise.
</para>
</refsect1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</refentry>


<REFENTRY ID="baselib-svctcp-create-3"> <REFMETA>
<REFENTRYTITLE>svctcp_create</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>svctcp_create</REFNAME>
<REFPURPOSE>
create a TCP/IP-based RPC service transport
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>17 June 2003</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;rpc/rpc.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>SVCXPRT *
  <FUNCTION>svctcp_create</FUNCTION></FUNCDEF>
 <PARAMDEF>int
  <PARAMETER><REPLACEABLE>sock</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>u_int
  <PARAMETER><REPLACEABLE>send_buf_size</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>u_int
  <PARAMETER><REPLACEABLE>recv_buf_size</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>17 June 2003</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>svctcp_create</FUNCTION> creates a TCP/IP-based RPC service transport, 
to which it returns a pointer.  The transport is associated with the socket
<PARAMETER>sock</PARAMETER>, which may be <VARNAME>RPC_ANYSOCK</VARNAME>, in 
which case a new socket is created.  If the socket is not bound to a local TCP
port, then this routine binds it to an arbitrary port.  Upon completion, 
<VARNAME>xprt->xp_sock</VARNAME> is the transport's socket descriptor,
and <VARNAME>xprt->xp_port</VARNAME> is the transport's port number.  Since 
TCP-based RPC uses buffered I/O, users may specify the size of buffers;
values of zero choose suitable defaults.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>svctcp_create</FUNCTION> returns NULL if it fails, or a pointer to 
the RPC service transport otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<refentry id="BASELIB-SVCUDP-CREATE-3"> 
	<refmeta>
	<refentrytitle>svcudp_create</refentrytitle>
	<refmiscinfo>Base Libraries</refmiscinfo>
	</refmeta>
	<refnamediv>
		<refname>svcudp_create</refname>
		<refpurpose>
		create a UDP-based RPC service transport
		</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	
	<funcsynopsis> 
	<funcsynopsisinfo>SVCXPRT *</funcsynopsisinfo>	
	<funcprototype> 
		<funcdef><function>svcudp_create</function></funcdef> 
		<paramdef>int <parameter>sock</parameter></paramdef>		
	</funcprototype>	 	
	</funcsynopsis> 
	</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The <FUNCTION>svcudp_create</FUNCTION> function shall
create a UDP/IP-based RPC service transport, and return
a pointer to its descriptor. The transport is associated
with the socket <parameter>sock</parameter>, which may be
<CONSTANT>RPC_ANYSOCK</CONSTANT>, in which case a new socket shall
be created. If the socket is not bound to a local UDP port, then
<FUNCTION>svcudp_create</FUNCTION> shall bind it to an arbitrary port.
</para>
<para>
If <FUNCTION>svcudp_create</FUNCTION> returns successfully, then the
<STRUCTFIELD>xp_sock</STRUCTFIELD> field in the result shall be the
transport's socket descriptor, and the <STRUCTFIELD>xp_port</STRUCTFIELD>
field shall be the transport's port number.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
Upon successful completion, <FUNCTION>svcudp_create</FUNCTION> shall
return a pointer to a RPC service transport; otherwise, a null pointer
shall be returned.
</para>
</refsect1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</refentry>


<REFENTRY ID="baselib-swscanf"> <REFMETA>
<REFENTRYTITLE>swscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>swscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<refentry id='baselib-sysconf'>
<refmeta>
<refentrytitle>sysconf</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>sysconf</refname>
<refpurpose>Get configuration information at runtime</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;unistd.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>long <function>sysconf</function></funcdef>
    <paramdef>int <parameter>name</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1 id='description'>
<title>DESCRIPTION</title>
<para>
<function>sysconf</function> is as specified in
<xref LINKEND=STD.SUSv3>,
but with differences as listed below.
</para>

<refsect2 id='extra.variables'><title>Extra Variables</title>
<para>These additional values extend the list in <xref LINKEND=STD.SUSv3>.
</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'></emphasis> - <emphasis remap='B'>_SC_PHYS_PAGES</emphasis></term>
  <listitem>
<para>The number of pages of physical memory.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'></emphasis> - <emphasis remap='B'>_SC_AVPHYS_PAGES</emphasis></term>
  <listitem>
<para>The number of currently available pages of physical memory.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'></emphasis> - <emphasis remap='B'>_SC_NPROCESSORS_CONF</emphasis></term>
  <listitem>
<para>The number of processors configured.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'></emphasis> - <emphasis remap='B'>_SC_NPROCESSORS_ONLN</emphasis></term>
  <listitem>
<para>The number of processors currently online (available).</para>
  </listitem>
  </varlistentry>
</variablelist>
</refsect2>
</refsect1>
</refentry>


<REFENTRY ID="baselib-system-3"> <REFMETA>
<REFENTRYTITLE>system</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>system
</REFNAME>
<REFPURPOSE>
execute a shell command
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdlib.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>system</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>string</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>system</FUNCTION> function shall behave as described in
<XREF LINKEND=STD.SUSv3>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The fact that <FUNCTION>system</FUNCTION> ignores interrupts is often 
not what a program wants. <XREF LINKEND=STD.SUSv3>
describes some of the consequences; an 
additional consequence is that a program calling <FUNCTION>system</FUNCTION> 
from a loop cannot be reliably interrupted. Many programs will want to use 
the <FUNCTION>exec</FUNCTION> family of functions instead.
</PARA>
<PARA>
Do not use <FUNCTION>system</FUNCTION> from a program with 
<VARNAME>suid</VARNAME> or <VARNAME>sgid</VARNAME> privileges, 
because unexpected values for some environment variables might be used 
to subvert system integrity. Use the <FUNCTION>exec</FUNCTION>
family of functions instead, but not <FUNCTION>execlp</FUNCTION>
or <FUNCTION>execvp</FUNCTION>. <FUNCTION>system</FUNCTION> will 
not, in fact, work properly from programs with <VARNAME>suid</VARNAME> 
or <VARNAME>sgid</VARNAME> privileges on systems on which 
<FILENAME>/bin/sh</FILENAME> is <COMMAND>bash</COMMAND> version 2, 
since <COMMAND>bash</COMMAND> 2 drops privileges on startup. 
(Debian uses a modified <COMMAND>bash</COMMAND> which does not do 
this when invoked as <COMMAND>sh</COMMAND>.)
</PARA>
<PARA>
The check for the availability of <FILENAME>/bin/sh</FILENAME> 
is not actually performed; it is always assumed to be available. 
<XREF LINKEND=STD.ISOC99> specifies the check, but 
<XREF LINKEND=STD.SUSv3> specifies that the return shall 
always be nonzero, since a system without the 
shell is not conforming, and it is this that is implemented.
</PARA>
<PARA>
It is possible for the shell command to return 
<RETURNVALUE>127</RETURNVALUE>, so that code is not a sure 
indication that the <FUNCTION>execve</FUNCTION> call failed; check 
the global variable <VARNAME>errno</VARNAME> to make sure.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-textdomain"> <REFMETA>
<REFENTRYTITLE>textdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>textdomain</REFNAME>
<REFPURPOSE>
set the current default message domain
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;libintl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char *
  <FUNCTION>textdomain</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>domainname</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>textdomain</FUNCTION> function shall set
the current default message 
domain to <PARAMETER>domainname</PARAMETER>. 
Subsequent calls to <FUNCTION>gettext</FUNCTION> and 
<FUNCTION>ngettext</FUNCTION> use the default message domain.
</PARA>

<PARA>
If <PARAMETER>domainname</PARAMETER> is <TOKEN>NULL</TOKEN>, 
the default message domain shall not be altered.
</PARA>
<PARA>
If <PARAMETER>domainname</PARAMETER> is "", <FUNCTION>textdomain</FUNCTION>
shall reset the default domain to the system default of "messages". 
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
On success, <FUNCTION>textdomain</FUNCTION> shall return the currently 
selected domain. Otherwise, a null pointer shall be returned, and
<VARNAME>errno</VARNAME> is set to indicate the error.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<CONSTANT>ENOMEM</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Insufficent memory available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

</REFENTRY>


<REFENTRY ID="baselib-unlink-3"> <REFMETA>
<REFENTRYTITLE>unlink</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>unlink
</REFNAME>
<REFPURPOSE>
remove a directory entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>unlink</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>path</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>unlink</FUNCTION> is as specified in 
<XREF LINKEND="STD.SUSV3">,
but with differences as listed below.
</PARA>
<PARA>
See also <xref linkend="exec-link-unlink" >.
</PARA>

<REFSECT2>
<TITLE>May return <ERRORNAME>EISDIR</ERRORNAME> on directories
</TITLE>
<PARA>
If <PARAMETER>path</PARAMETER> specifies a directory, the
implementation may return <ERRORNAME>EISDIR</ERRORNAME> 
instead of <ERRORNAME>EPERM</ERRORNAME> as specified by
<XREF LINKEND="STD.SUSV3">.
<NOTE>
<TITLE>Rationale</TITLE>
<PARA>
The Linux kernel has deliberately chosen <ERRORNAME>EISDIR</ERRORNAME> 
for this case and does not expect to change.
</PARA>
</NOTE>
</PARA>
</REFSECT2>

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-uselocale-3"> <REFMETA>
<REFENTRYTITLE>uselocale</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>uselocale
</REFNAME>
<REFPURPOSE>
set locale for thread
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;locale.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>locale_t
<function>uselocale</function>
</funcdef>
<paramdef>locale_t
<parameter>newloc</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>uselocale</FUNCTION> function shall set the locale for the
calling thread to the locale specified by <parameter>newloc</parameter>.
</PARA>
<PARA>
If <parameter>newloc</parameter> is the value 
<constant>LC_GLOBAL_LOCALE</constant>,
the thread's locale shall be set to the process current
global locale, as set
by <function>setlocale</function>.
If <parameter>newloc</parameter> is <constant>NULL</constant>, the
thread's locale is not altered.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
The <function>uselocale</function> function shall return the previous locale,
or <constant>LC_GLOBAL_LOCALE</constant> if the thread local locale
has not been previously set.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None defined.</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>setlocale</function></member>
<member><function>freelocale</function></member>
<member><function>duplocale</function></member>
<member><function>newlocale</function></member>
</simplelist>
</para>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-utmpname-3"> <REFMETA>
<REFENTRYTITLE>utmpname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>utmpname
</REFNAME>
<REFPURPOSE>
set user accounting database
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;utmp.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>utmpname</function>
</funcdef>
<paramdef>const char *
<parameter>dbname</parameter>
</paramdef>
 
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<REFSECT1>
<REFSECT1INFO>
<DATE>03 November 2004</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>utmpname</FUNCTION> function shall cause the user
accounting database
used by the <SIMPLELIST TYPE=inline>
<MEMBER><FUNCTION>getutent</FUNCTION></MEMBER>
<MEMBER><FUNCTION>getutent_r</FUNCTION></MEMBER>
<MEMBER><FUNCTION>getutxent</FUNCTION></MEMBER>
<MEMBER><FUNCTION>getutxid</FUNCTION></MEMBER>
<MEMBER><FUNCTION>getutxline</FUNCTION></MEMBER>
<MEMBER>and <FUNCTION>pututxline</FUNCTION></MEMBER>
</SIMPLELIST> functions to be that named by <PARAMETER>dbname</PARAMETER>,
instead of the system default database. See
<XREF LINKEND='FHS-user-accounting-dbs'> for further information.
<NOTE><PARA>
The LSB does not specify the format of the user accounting database,
nor the names of the file or files that may contain it. 
</PARA></NOTE>
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
None defined.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-vasprintf"> <REFMETA>
<REFENTRYTITLE>vasprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vasprintf</REFNAME>
<REFPURPOSE>
write formatted output to a dynamically allocated string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>vasprintf</FUNCTION></FUNCDEF>
 <PARAMDEF>char * * restrict 
  <PARAMETER><REPLACEABLE>ptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict 
  <PARAMETER><REPLACEABLE>format</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>va_list 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>vasprintf</FUNCTION> function shall write
formatted output to a 
dynamically allocated string, and store
the address of that string in the location
referenced by <PARAMETER>ptr</PARAMETER>.
It shall behave as <FUNCTION>asprintf</FUNCTION>,
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined
by <FILENAME>&lt;stdarg.h&gt;</FILENAME>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-vdprintf"> <REFMETA>
<REFENTRYTITLE>vdprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vdprintf</REFNAME>
<REFPURPOSE>
write formatted output to a file descriptor
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdio.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>vdprintf</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char * restrict 
  <PARAMETER><REPLACEABLE>format</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>va_list 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>vdprintf</FUNCTION> function shall behave as 
<FUNCTION>vfprintf</FUNCTION>, except that 
<function>vdprintf</function> shall write output to the file associated with the file descriptor
specified by the <parameter>fd</parameter> argument, rather than place output on a
stream (as defined by <XREF LINKEND=STD.SUSV3>).
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
Refer to <FUNCTION>fprintf</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-verrx-3"> <REFMETA>
<REFENTRYTITLE>verrx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>verrx
</REFNAME>
<REFPURPOSE>display formatted error message and exit
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdarg.h&gt;
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>verrx</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>eval</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>fmt</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>va_list 
  <PARAMETER><REPLACEABLE>args</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>verrx</FUNCTION> shall behave as <FUNCTION>errx</FUNCTION>
except that instead of being called with a variable number
of arguments, it is called with an argument list as defined by
<FILENAME>&lt;stdarg.h&gt;</FILENAME>.
</PARA>
<PARA>
<FUNCTION>verrx</FUNCTION> does not return, but exits with the value 
of <PARAMETER>eval</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-vfscanf"> <REFMETA>
<REFENTRYTITLE>vfscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vfscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-vfwscanf"> <REFMETA>
<REFENTRYTITLE>vfwscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vfwscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-vscanf"> <REFMETA>
<REFENTRYTITLE>vscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-vsscanf"> <REFMETA>
<REFENTRYTITLE>vsscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vsscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-vswscanf"> <REFMETA>
<REFENTRYTITLE>vswscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vswscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-vsyslog-3"> <REFMETA>
<REFENTRYTITLE>vsyslog</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>vsyslog
</REFNAME>
<REFPURPOSE>
log to system log
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;stdarg.h&gt;
#include &lt;syslog.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>vsyslog</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>priority</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>message</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>va_list 
  <PARAMETER><REPLACEABLE>arglist</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>vsyslog</FUNCTION> function
is identical to <FUNCTION>syslog</FUNCTION> 
as specified in <XREF LINKEND=STD.SUSv3>,
except that <PARAMETER>arglist</PARAMETER> 
(as defined by <FILENAME>stdarg.h</FILENAME>) replaces the variable 
number of arguments.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-vwscanf"> <REFMETA>
<REFENTRYTITLE>vwscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vwscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-wait4-2"> <REFMETA>
<REFENTRYTITLE>wait4</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wait4
</REFNAME>
<REFPURPOSE>
wait for process termination, BSD style
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;sys/types.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/wait.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>pid_t 
  <FUNCTION>wait4</FUNCTION></FUNCDEF>
 <PARAMDEF>pid_t 
  <PARAMETER><REPLACEABLE>pid</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int *
  <PARAMETER><REPLACEABLE>status</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>options</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>struct rusage *
  <PARAMETER>rusage</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wait4</FUNCTION> suspends execution of the current process 
until a child (as specified by <PARAMETER>pid</PARAMETER>) has exited, 
or until a signal is delivered whose action is to terminate the 
current process or to call a signal handling function. If a child (as 
requested by <PARAMETER>pid</PARAMETER>) has already exited by the 
time of the call (a so-called "zombie" process), the function returns 
immediately. Any system resources used by the child are freed.
</PARA><PARA>
The value of <PARAMETER>pid</PARAMETER> can be one of:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
&lt; -1   
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to the 
absolute value of <PARAMETER>pid</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
-1     
</TERM>
<LISTITEM>
<PARA>
wait for any child process; this is equivalent to calling 
<FUNCTION>wait3</FUNCTION>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
0      
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to that of 
the calling process.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
&gt; 0    
</TERM>
<LISTITEM>
<PARA>
wait for the child whose process ID is equal to the value of 
<PARAMETER>pid</PARAMETER>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
The value of options is a bitwise or of zero or more of the following 
constants:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WNOHANG
</TERM>
<LISTITEM>
<PARA>
return immediately if no child is there to be waited for.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WUNTRACED
</TERM>
<LISTITEM>
<PARA>
return for children that are stopped, and whose status has not been 
reported.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If status is not <TOKEN>NULL</TOKEN>, <FUNCTION>wait4</FUNCTION> 
stores status information in the location 
<PARAMETER>status</PARAMETER>. This status can be evaluated with the 
following macros:
<NOTE>
<PARA>
These macros take the <VARNAME>status</VARNAME> value (an 
<LITERAL>int</LITERAL>) as an argument -- not a pointer to the 
value!
</PARA>
</NOTE>
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WIFEXITED(status)
</TERM>
<LISTITEM>
<PARA>
is nonzero if the child exited normally.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WEXITSTATUS(status)
</TERM>
<LISTITEM>
<PARA>
evaluates to the least significant eight bits of the return code of 
the child that terminated, which may have been set as the argument to 
a call to <FUNCTION>exit</FUNCTION> or as the argument for a return 
statement in the main program. This macro can only be evaluated if 
<FUNCTION>WIFEXITED</FUNCTION> returned nonzero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSIGNALED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process exited because of a signal that was 
not caught.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WTERMSIG(status)
</TERM>
<LISTITEM>
<PARA>
returns the number of the signal that caused the child process to 
terminate. This macro can only be evaluated if 
<FUNCTION>WIFSIGNALED</FUNCTION> returned nonzero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSTOPPED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process that caused the return is currently 
stopped; this is only possible if the call was done using 
<FUNCTION>WUNTRACED</FUNCTION>.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WSTOPSIG(status)
</TERM>

<LISTITEM>
<PARA>
returns the number of the signal that caused the child to stop. This 
macro can only be evaluated if <FUNCTION>WIFSTOPPED</FUNCTION> 
returned nonzero.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If <PARAMETER>rusage</PARAMETER> is not <TOKEN>NULL</TOKEN>, the 
struct <STRUCTNAME>rusage</STRUCTNAME> (as defined in 
<FILENAME>sys/resource.h</FILENAME>) that it points to will be filled 
with accounting information. See <FUNCTION>getrusage</FUNCTION> 
for details.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the process ID of the child that exited is returned. On 
error, <RETURNVALUE>-1</RETURNVALUE> is returned (in particular, when 
no unwaited-for child processes of the specified kind exist), or 
<RETURNVALUE>0</RETURNVALUE> if <FUNCTION>WNOHANG</FUNCTION> was used 
and no child was available yet. In the latter two cases, the global 
variable <VARNAME>errno</VARNAME> is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ECHILD 
</TERM>
<LISTITEM>
<PARA>
No unwaited-for child process as specified does exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ERESTARTSYS
</TERM>
<LISTITEM>
<PARA>
A <FUNCTION>WNOHANG</FUNCTION> was not set and an unblocked signal or
a <VARNAME>SIGCHILD</VARNAME> was caught. This error is returned by 
the system call. The library interface is not allowed to return 
<ERRORNAME>ERESTARTSYS</ERRORNAME>, but will return
<ERRORNAME>EINTR</ERRORNAME>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-warn-3"> <REFMETA>
<REFENTRYTITLE>warn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warn
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>warn</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>fmt</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>warn</FUNCTION> function
shall display a formatted error message on the standard
error stream.
The output shall consist of the last component of the program name, a colon
character, and a space character. If <PARAMETER>fmt</PARAMETER> is non-NULL, it shall be used as a
format string for the <FUNCTION>printf</FUNCTION>
family of functions, and the formatted message, a
colon character, and a space are written to <VarName>stderr</VarName>.
Finally,  the error message
string affiliated with the current value of the global variable 
<VarName>errno</VarName> shall be
written to <VarName>stderr</VarName>, followed by a newline character.
</PARA>
</REFSECT1>

<!-- 4th Berkeley Distribution        June 9, 1993  -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-warnx-3"> <REFMETA>
<REFENTRYTITLE>warnx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warnx
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;err.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>warnx</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>fmt</REPLACEABLE></PARAMETER></PARAMDEF>
  <VARARGS>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>warnx</FUNCTION> function shall display a formatted error message on the 
standard error stream. The last component of the program name, a colon 
character, and a space shall be output. If <PARAMETER>fmt</PARAMETER> is 
non-<LITERAL>NULL</LITERAL>, it shall be used as the format string
for the <FUNCTION>printf</FUNCTION> family of functions, and
the formatted error message, a colon 
character, and a space shall be output. The output shall be followed by a 
newline character.
</PARA>
</REFSECT1>
<!--        4th Berkeley Distribution        June 9, 1993    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-wcpcpy-3"> <REFMETA>
<REFENTRYTITLE>wcpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpcpy
</REFNAME>
<REFPURPOSE>
copy a wide character string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>wchar_t *
  <FUNCTION>wcpcpy</FUNCTION></FUNCDEF>
 <PARAMDEF>wchar_t *
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcpcpy</FUNCTION> is the wide-character equivalent of 
<FUNCTION>stpcpy</FUNCTION>. It copies the wide character string 
<PARAMETER>src</PARAMETER>, including the terminating 
null wide character code, to the array <PARAMETER>dest</PARAMETER>.
</PARA>
<PARA>
The strings may not overlap.
</PARA>
<PARA>
The programmer shall ensure that there is room for at least 
<FUNCTION>wcslen</FUNCTION><PARAMETER>(src)</PARAMETER><LITERAL>+1</LITERAL> 
wide characters at <PARAMETER>dest</PARAMETER>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>wcpcpy</FUNCTION> returns a pointer to the end of the 
wide-character string <PARAMETER>dest</PARAMETER>, that is, a pointer to 
the terminating null wide character code.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcpncpy-3"> <REFMETA>
<REFENTRYTITLE>wcpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpncpy
</REFNAME>
<REFPURPOSE>
copy a fixed-size string of wide characters, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>wchar_t *
  <FUNCTION>wcpncpy</FUNCTION></FUNCDEF>
 <PARAMDEF>wchar_t *
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>n</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcpncpy</FUNCTION> is the wide-character equivalent of 
<FUNCTION>stpncpy</FUNCTION>. It copies at most <PARAMETER>n</PARAMETER> 
wide characters from the wide-character string <PARAMETER>src</PARAMETER>, 
including the terminating null wide character code, to the 
array <PARAMETER>dest</PARAMETER>. Exactly <PARAMETER>n</PARAMETER> 
wide characters are written at <PARAMETER>dest</PARAMETER>. If the 
length <FUNCTION>wcslen</FUNCTION><PARAMETER>(src)</PARAMETER> is 
smaller than <PARAMETER>n</PARAMETER>, the remaining wide characters 
in the array <PARAMETER>dest</PARAMETER> are filled 
with null wide character codes. If the length 
<FUNCTION>wcslen</FUNCTION><PARAMETER>(src)</PARAMETER> is greater 
than or equal to <PARAMETER>n</PARAMETER>, the string 
<PARAMETER>dest</PARAMETER> will not be 
terminated with a null wide character code.
</PARA>
<PARA>
The strings may not overlap.
</PARA>
<PARA>
The programmer shall ensure that there is room for at least 
<PARAMETER>n</PARAMETER> wide characters at <PARAMETER>dest</PARAMETER>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>wcpncpy</FUNCTION> returns a pointer to the wide character one past
the last non-null wide character written.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcscasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcscasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcscasecmp
</REFNAME>
<REFPURPOSE>
compare two wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>wcscasecmp</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>s1</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>s2</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcscasecmp</FUNCTION> is the wide-character equivalent of 
<FUNCTION>strcasecmp</FUNCTION>. It compares the wide-character string 
<PARAMETER>s1</PARAMETER> and the wide-character string 
<PARAMETER>s2</PARAMETER>, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <FUNCTION>wcscasecmp</FUNCTION> function shall return <RETURNVALUE>0</RETURNVALUE> 
if the wide-character strings <PARAMETER>s1</PARAMETER> and 
<PARAMETER>s2</PARAMETER> are equal except for case distinctions. It 
shall return a positive integer if <PARAMETER>s1</PARAMETER> is greater 
than <PARAMETER>s2</PARAMETER>, ignoring case. It shall return a negative 
integer if <PARAMETER>s1</PARAMETER> is less than 
<PARAMETER>s2</PARAMETER>, ignoring case.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of <FUNCTION>wcscasecmp</FUNCTION> depends upon the 
<VARNAME>LC_CTYPE</VARNAME> category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsdup-3"> <REFMETA>
<REFENTRYTITLE>wcsdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsdup
</REFNAME>
<REFPURPOSE>
duplicate a wide-character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>wchar_t *
  <FUNCTION>wcsdup</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>wcsdup</FUNCTION> function is the wide-character equivalent of 
<FUNCTION>strdup</FUNCTION>. 
The <FUNCTION>wcsdup</FUNCTION> function shall return a pointer to a new wide character string, which is a duplicate
of the wide character string pointed to by 
<PARAMETER>s</PARAMETER>.
The returned pointer can be passed to <FUNCTION>free</FUNCTION>.
A null pointer is returned if the new string cannot be created.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <FUNCTION>wcsdup</FUNCTION> function returns a pointer to a new wide-character 
string on success. Otherwise, it shall return <RETURNVALUE>NULL</RETURNVALUE> and set
<VARNAME>errno</VARNAME> to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<CONSTANT>
ENOMEM
</CONSTANT>
</TERM>
<LISTITEM>
<PARA>
Insufficient memory available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsncasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcsncasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsncasecmp</REFNAME>
<REFPURPOSE>
compare two fixed-size wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;wchar.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>wcsncasecmp</function>
</funcdef>
<paramdef>const wchar_t *
<parameter>s1</parameter>
</paramdef>
<paramdef>const wchar_t *
<parameter>s2</parameter>
</paramdef>
<paramdef>size_t
<parameter>n</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcsncasecmp</FUNCTION> is the wide-character equivalent of 
<FUNCTION>strncasecmp</FUNCTION>. It compares the wide-character string 
<PARAMETER>s1</PARAMETER> and the wide-character string 
<PARAMETER>s2</PARAMETER>, but at most <PARAMETER>n</PARAMETER> wide
characters from each string, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>wcscasecmp</FUNCTION> returns <RETURNVALUE>0</RETURNVALUE> 
if the wide-character strings <PARAMETER>s1</PARAMETER> and 
<PARAMETER>s2</PARAMETER>, truncated to at most length 
<PARAMETER>n</PARAMETER>, are equal except for case distinctions. It 
returns a positive integer if truncated <PARAMETER>s1</PARAMETER> is 
greater than truncated <PARAMETER>s2</PARAMETER>, ignoring case. It 
returns a negative integer if truncated <PARAMETER>s1</PARAMETER> is 
smaller than truncated <PARAMETER>s2</PARAMETER>, ignoring case.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of <FUNCTION>wcsncasecmp</FUNCTION> depends upon the 
<VARNAME>LC_CTYPE</VARNAME> category of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcsnlen-3"> <REFMETA>
<REFENTRYTITLE>wcsnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size wide-character string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>wcsnlen</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t *
  <PARAMETER><REPLACEABLE>s</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>maxlen</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcsnlen</FUNCTION> is the wide-character equivalent of 
<FUNCTION>strnlen</FUNCTION>. It returns the number of wide-characters in 
the string <PARAMETER>s</PARAMETER>, not including the terminating 
null wide character code, but at most <PARAMETER>maxlen</PARAMETER>. 
In doing this, <FUNCTION>wcsnlen</FUNCTION> looks only at the first 
<PARAMETER>maxlen</PARAMETER> wide-characters at <PARAMETER>s</PARAMETER> 
and never beyond <PARAMETER>s</PARAMETER> + <PARAMETER>maxlen</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>wcsnlen</FUNCTION> returns 
<FUNCTION>wcslen</FUNCTION><PARAMETER>(s)</PARAMETER> if that is less than 
<PARAMETER>maxlen</PARAMETER>, or <PARAMETER>maxlen</PARAMETER> if there is 
no null wide character code among the first 
<PARAMETER>maxlen</PARAMETER> wide characters pointed to by 
<PARAMETER>s</PARAMETER>.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFENTRY>


<REFENTRY ID="baselib-wcsnrtombs-3"> <REFMETA>
<REFENTRYTITLE>wcsnrtombs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnrtombs</REFNAME>
<REFPURPOSE>
convert a wide character string to a multi-byte string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>size_t 
  <FUNCTION>wcsnrtombs</FUNCTION></FUNCDEF>
 <PARAMDEF>char *
  <PARAMETER><REPLACEABLE>dest</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const wchar_t * *
  <PARAMETER><REPLACEABLE>src</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>nwc</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>len</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>mbstate_t *
  <PARAMETER><REPLACEABLE>ps</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>wcsnrtombs</FUNCTION> is like <FUNCTION>wcsrtombs</FUNCTION>,
except that the number of wide characters to be converted, starting at 
<PARAMETER>src</PARAMETER>, is limited to <PARAMETER>nwc</PARAMETER>.
</PARA>
<PARA>
If <PARAMETER>dest</PARAMETER> is not a <TOKEN>NULL</TOKEN> pointer, 
<FUNCTION>wcsnrtombs</FUNCTION> converts at most 
<PARAMETER>nwc</PARAMETER> wide characters from the wide-character 
string <PARAMETER>src</PARAMETER> to a multibyte string starting at 
<PARAMETER>dest</PARAMETER>. At most <PARAMETER>len</PARAMETER> bytes 
are written to <PARAMETER>dest</PARAMETER>. The shift state 
<PARAMETER>ps</PARAMETER> is updated.
</PARA>
<PARA>
The conversion is effectively performed by repeatedly calling:
<SYNOPSIS>
wcrtomb(dest, *src, ps)</SYNOPSIS>
as long as this call succeeds, and then incrementing 
<PARAMETER>dest</PARAMETER> by the number of bytes written and 
<PARAMETER>src</PARAMETER> by <LITERAL>1</LITERAL>.
</PARA>
<PARA>
The conversion can stop for three reasons:
</PARA>
<PARA>
<ITEMIZEDLIST MARK='BULLET'>
<LISTITEM>
<PARA>
A wide character has been encountered that cannot be represented as a
multibyte sequence (according to the current locale). In this case 
<PARAMETER>src</PARAMETER> is left pointing to the invalid wide character, 
(size_t)(-1) is returned, and <VARNAME>errno</VARNAME> is 
set to <ERRORNAME>EILSEQ</ERRORNAME>.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
<PARAMETER>nws</PARAMETER> wide characters have been converted without
encountering a null wide character code, or the length limit forces a stop. 
In this case, <PARAMETER>src</PARAMETER> is left pointing to the next 
wide character to be converted, and the number bytes written to 
<PARAMETER>dest</PARAMETER> is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The wide-character string has been completely converted, including the 
terminating null wide character code (which has the side effect of bringing 
back <PARAMETER>ps</PARAMETER> to the initial state). In this case, 
<PARAMETER>src</PARAMETER> is set to <LITERAL>NULL</LITERAL>, and the 
number of bytes written to <PARAMETER>dest</PARAMETER>, excluding the 
terminating null wide character code, is returned.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
If <PARAMETER>dest</PARAMETER> is <LITERAL>NULL</LITERAL>, 
<PARAMETER>len</PARAMETER> is ignored, and the conversion proceeds 
as above, except that the converted bytes are not written 
out to memory, and that no destination length limit exists.
</PARA>
<PARA>
In both of the above cases, if <PARAMETER>ps</PARAMETER> is a 
<LITERAL>NULL</LITERAL> pointer, a static anonymous state only known 
to <FUNCTION>wcsnrtombs</FUNCTION> is used instead.
</PARA>
<PARA>
The programmer shall ensure that there is room for at least 
<PARAMETER>len</PARAMETER> bytes at <PARAMETER>dest</PARAMETER>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
<FUNCTION>wcsnrtombs</FUNCTION> returns the number of bytes that 
make up the converted part of multibyte sequence, not including 
the terminating null wide character code. If a wide character was 
encountered which could not be converted, (size_t)(-1) is returned, 
and the global variable <VARNAME>errno</VARNAME> set to 
<ERRORNAME>EILSEQ</ERRORNAME>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of <FUNCTION>wcsnrtombs</FUNCTION> depends on the 
<VARNAME>LC_CTYPE</VARNAME> category of the current locale.
</PARA>
<PARA>
Passing <TOKEN>NULL</TOKEN> as <PARAMETER>ps</PARAMETER> is not 
multi-thread safe.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstoq"> <REFMETA>
<REFENTRYTITLE>wcstoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstoq</REFNAME>
<REFPURPOSE>
convert wide string to long long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>long long int 
  <FUNCTION>wcstoq</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t * restrict 
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t ** restrict 
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>wcstoq</FUNCTION> function shall convert
the initial portion of the wide 
string <PARAMETER>nptr</PARAMETER> to <LITERAL>long long int</LITERAL> 
representation. It is identical to <FUNCTION>wcstoll</FUNCTION>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Refer to <FUNCTION>wcstoll</FUNCTION>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
Refer to <FUNCTION>wcstoll</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstouq"> <REFMETA>
<REFENTRYTITLE>wcstouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstouq</REFNAME>
<REFPURPOSE>
convert wide string to unsigned long long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;wchar.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>unsigned long long 
  <FUNCTION>wcstouq</FUNCTION></FUNCDEF>
 <PARAMDEF>const wchar_t * restrict 
  <PARAMETER><REPLACEABLE>nptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>wchar_t ** restrict 
  <PARAMETER><REPLACEABLE>endptr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>base</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>wcstouq</FUNCTION> function shall convert
the initial portion of the wide 
string <PARAMETER>nptr</PARAMETER> to <LITERAL>unsigned long long 
int</LITERAL> representation.
It is identical to <FUNCTION>wcstoull</FUNCTION>.
</PARA>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
Refer to <FUNCTION>wcstoull</FUNCTION>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
Refer to <FUNCTION>wcstoull</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wscanf"> <REFMETA>
<REFENTRYTITLE>wscanf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wscanf</REFNAME>
<REFPURPOSE>
convert formatted input
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>scanf</FUNCTION> family of functions shall behave as
described in <xref linkend="std.SUSv3">, except as noted below.
</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>
<PARA>
The 
<literal>%s</literal>, 
<literal>%S</literal> and 
<literal>%[</literal> conversion specifiers shall accept an 
option length modifier
<literal>a</literal>, 
which shall cause a memory buffer to be allocated to hold the string converted.
In such a case, the argument corresponding to the conversion specifier should be
a reference to a pointer value that will receive a pointer to the allocated
buffer. If there is insufficient memory to allocate a buffer, the 
function may set 
<varname>errno</varname> to <errorcode>ENOMEM</errorcode> and a 
conversion error results.
<note>
<para>This directly conflicts with the <xref linkend="std.ISOC99"> usage of
<literal>%a</literal> as a conversion specifier for hexadecimal float
values. While this conversion specifier should be supported, a format
specifier such as <literal>"%aseconds"</literal> will have a different
meaning on an LSB conforming system.
</para>
</note>
</PARA>
</REFSECT1>
</REFENTRY>



<REFENTRY ID="baselib-xdr-u-int-3"> <REFMETA>
<REFENTRYTITLE>xdr_u_int</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>xdr_u_int</REFNAME>
<REFPURPOSE>
library routines for external data representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 Oct 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>xdr_u_int</FUNCTION></FUNCDEF>
 <PARAMDEF>XDR * 
  <PARAMETER><REPLACEABLE>xdrs</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned int *
  <PARAMETER><REPLACEABLE>up</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>30 Oct 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>xdr_u_int</FUNCTION> is a filter primitive that translates between
C unsigned integers and their external representations.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <RETURNVALUE>1</RETURNVALUE> is returned. 
On error, <RETURNVALUE>0</RETURNVALUE> is returned.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-xdrstdio-create-3"> <REFMETA>
<REFENTRYTITLE>xdrstdio_create</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>xdrstdio_create</REFNAME>
<REFPURPOSE>
library routines for external data representation
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;rpc/xdr.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>xdrstdio_create</function>
</funcdef>
<paramdef>XDR *
<parameter>xdrs</parameter>
</paramdef>
<paramdef>FILE *
<parameter>file</parameter>
</paramdef>
<paramdef>enum xdr_op
<parameter>op</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<REFSECT1INFO>
<DATE>21 August 2007</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>xdrstdio_create</FUNCTION> function
shall initialize the XDR stream object referred to by <parameter>xdrs</parameter>.
The XDR stream data shall be written to, or read from, the standard I/O stream associated
with <parameter>file</parameter>. If the operation <parameter>op</parameter> is 
<symbol>XDR_ENCODE</symbol>, encoded data shall be written to <parameter>file</parameter>.
If <parameter>op</parameter> is <symbol>XDR_DECODE</symbol>, encoded data shall be read from 
<parameter>file</parameter>.
If <parameter>op</parameter> is <symbol>XDR_FREE</symbol>, 
the XDR stream object may be used to deallocate storage allocated by a previous <symbol>XDR_DECODE</symbol>.
</PARA>
<PARA>
The associated destroy function shall flush the <parameter>file</parameter> I/O stream, but not close
it.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>
</REFENTRY>

</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libm>
<TITLE>Interfaces for libm</TITLE>
<PARA>
<XREF LINKEND="lib-libm-def"> defines the library name and shared object name
for the libm library
</PARA>
<TABLE id="lib-libm-def">
<TITLE>libm Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libm</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>See archLSB.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libm.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
<MEMBER ID='REFSTD.libm.2'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
<MEMBER ID='REFSTD.libm.3'>
[SVID.3] <XREF LINKEND="std.SVID.3">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Math -->
<SECT2>
<!--libgroup-->
<TITLE>Math</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Math</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Math specified in <XREF linkend="tbl-libm-math-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libm-math-ints">
<TITLE>libm - Math Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>__finite</primary></indexterm>__finite <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__finitef</primary></indexterm>__finitef <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__finitel</primary></indexterm>__finitel <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__fpclassify</primary></indexterm>__fpclassify <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>__fpclassifyf</primary></indexterm>__fpclassifyf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__signbit</primary></indexterm>__signbit <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>__signbitf</primary></indexterm>__signbitf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>acos</primary></indexterm>acos <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>acosf</primary></indexterm>acosf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>acosh</primary></indexterm>acosh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>acoshf</primary></indexterm>acoshf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>acoshl</primary></indexterm>acoshl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>acosl</primary></indexterm>acosl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asin</primary></indexterm>asin <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asinf</primary></indexterm>asinf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asinh</primary></indexterm>asinh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>asinhf</primary></indexterm>asinhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asinhl</primary></indexterm>asinhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>asinl</primary></indexterm>asinl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atan</primary></indexterm>atan <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>atan2</primary></indexterm>atan2 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atan2f</primary></indexterm>atan2f <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atan2l</primary></indexterm>atan2l <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atanf</primary></indexterm>atanf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>atanh</primary></indexterm>atanh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atanhf</primary></indexterm>atanhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atanhl</primary></indexterm>atanhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>atanl</primary></indexterm>atanl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cabs</primary></indexterm>cabs <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cabsf</primary></indexterm>cabsf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cabsl</primary></indexterm>cabsl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cacos</primary></indexterm>cacos <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cacosf</primary></indexterm>cacosf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cacosh</primary></indexterm>cacosh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cacoshf</primary></indexterm>cacoshf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cacoshl</primary></indexterm>cacoshl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cacosl</primary></indexterm>cacosl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>carg</primary></indexterm>carg <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cargf</primary></indexterm>cargf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cargl</primary></indexterm>cargl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>casin</primary></indexterm>casin <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>casinf</primary></indexterm>casinf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>casinh</primary></indexterm>casinh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>casinhf</primary></indexterm>casinhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>casinhl</primary></indexterm>casinhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>casinl</primary></indexterm>casinl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catan</primary></indexterm>catan <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catanf</primary></indexterm>catanf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>catanh</primary></indexterm>catanh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catanhf</primary></indexterm>catanhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catanhl</primary></indexterm>catanhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>catanl</primary></indexterm>catanl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cbrt</primary></indexterm>cbrt <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cbrtf</primary></indexterm>cbrtf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cbrtl</primary></indexterm>cbrtl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ccos</primary></indexterm>ccos <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ccosf</primary></indexterm>ccosf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ccosh</primary></indexterm>ccosh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ccoshf</primary></indexterm>ccoshf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ccoshl</primary></indexterm>ccoshl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ccosl</primary></indexterm>ccosl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ceil</primary></indexterm>ceil <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ceilf</primary></indexterm>ceilf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ceill</primary></indexterm>ceill <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cexp</primary></indexterm>cexp <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cexpf</primary></indexterm>cexpf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cexpl</primary></indexterm>cexpl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cimag</primary></indexterm>cimag <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cimagf</primary></indexterm>cimagf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cimagl</primary></indexterm>cimagl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clog</primary></indexterm>clog <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clog10</primary></indexterm>clog10 <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clog10f</primary></indexterm>clog10f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>clog10l</primary></indexterm>clog10l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>clogf</primary></indexterm>clogf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clogl</primary></indexterm>clogl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>conj</primary></indexterm>conj <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>conjf</primary></indexterm>conjf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>conjl</primary></indexterm>conjl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>copysign</primary></indexterm>copysign <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>copysignf</primary></indexterm>copysignf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>copysignl</primary></indexterm>copysignl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cos</primary></indexterm>cos <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cosf</primary></indexterm>cosf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cosh</primary></indexterm>cosh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>coshf</primary></indexterm>coshf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>coshl</primary></indexterm>coshl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cosl</primary></indexterm>cosl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cpow</primary></indexterm>cpow <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cpowf</primary></indexterm>cpowf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cpowl</primary></indexterm>cpowl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cproj</primary></indexterm>cproj <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cprojf</primary></indexterm>cprojf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>cprojl</primary></indexterm>cprojl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>creal</primary></indexterm>creal <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>crealf</primary></indexterm>crealf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>creall</primary></indexterm>creall <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csin</primary></indexterm>csin <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csinf</primary></indexterm>csinf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csinh</primary></indexterm>csinh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>csinhf</primary></indexterm>csinhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csinhl</primary></indexterm>csinhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csinl</primary></indexterm>csinl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csqrt</primary></indexterm>csqrt <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>csqrtf</primary></indexterm>csqrtf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>csqrtl</primary></indexterm>csqrtl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctan</primary></indexterm>ctan <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctanf</primary></indexterm>ctanf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ctanh</primary></indexterm>ctanh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctanhf</primary></indexterm>ctanhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctanhl</primary></indexterm>ctanhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ctanl</primary></indexterm>ctanl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>drem</primary></indexterm>drem <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dremf</primary></indexterm>dremf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dreml</primary></indexterm>dreml <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>erf</primary></indexterm>erf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erfc</primary></indexterm>erfc <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>erfcf</primary></indexterm>erfcf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>erfcl</primary></indexterm>erfcl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>erff</primary></indexterm>erff <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erfl</primary></indexterm>erfl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>exp</primary></indexterm>exp <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>exp10</primary></indexterm>exp10 <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>exp10f</primary></indexterm>exp10f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>exp10l</primary></indexterm>exp10l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>exp2</primary></indexterm>exp2 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>exp2f</primary></indexterm>exp2f <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>expf</primary></indexterm>expf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>expl</primary></indexterm>expl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>expm1</primary></indexterm>expm1 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>expm1f</primary></indexterm>expm1f <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>expm1l</primary></indexterm>expm1l <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fabs</primary></indexterm>fabs <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fabsf</primary></indexterm>fabsf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fabsl</primary></indexterm>fabsl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fdim</primary></indexterm>fdim <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fdimf</primary></indexterm>fdimf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fdiml</primary></indexterm>fdiml <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>feclearexcept</primary></indexterm>feclearexcept <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fedisableexcept</primary></indexterm>fedisableexcept <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>feenableexcept</primary></indexterm>feenableexcept <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fegetenv</primary></indexterm>fegetenv <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fegetexcept</primary></indexterm>fegetexcept <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>fegetexceptflag</primary></indexterm>fegetexceptflag <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fegetround</primary></indexterm>fegetround <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>feholdexcept</primary></indexterm>feholdexcept <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>feraiseexcept</primary></indexterm>feraiseexcept <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fesetenv</primary></indexterm>fesetenv <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fesetexceptflag</primary></indexterm>fesetexceptflag <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fesetround</primary></indexterm>fesetround <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fetestexcept</primary></indexterm>fetestexcept <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>feupdateenv</primary></indexterm>feupdateenv <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>finite</primary></indexterm>finite <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>finitef</primary></indexterm>finitef <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>finitel</primary></indexterm>finitel <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>floor</primary></indexterm>floor <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>floorf</primary></indexterm>floorf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>floorl</primary></indexterm>floorl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fma</primary></indexterm>fma <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmaf</primary></indexterm>fmaf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fmal</primary></indexterm>fmal <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmax</primary></indexterm>fmax <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmaxf</primary></indexterm>fmaxf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmaxl</primary></indexterm>fmaxl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fmin</primary></indexterm>fmin <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fminf</primary></indexterm>fminf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fminl</primary></indexterm>fminl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmod</primary></indexterm>fmod <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>fmodf</primary></indexterm>fmodf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>fmodl</primary></indexterm>fmodl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>frexp</primary></indexterm>frexp <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>frexpf</primary></indexterm>frexpf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>frexpl</primary></indexterm>frexpl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>gamma</primary></indexterm>gamma <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gammaf</primary></indexterm>gammaf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gammal</primary></indexterm>gammal <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>hypot</primary></indexterm>hypot <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>hypotf</primary></indexterm>hypotf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>hypotl</primary></indexterm>hypotl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ilogb</primary></indexterm>ilogb <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ilogbf</primary></indexterm>ilogbf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ilogbl</primary></indexterm>ilogbl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>j0</primary></indexterm>j0 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>j0f</primary></indexterm>j0f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>j0l</primary></indexterm>j0l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>j1</primary></indexterm>j1 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>j1f</primary></indexterm>j1f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>j1l</primary></indexterm>j1l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>jn</primary></indexterm>jn <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>jnf</primary></indexterm>jnf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>jnl</primary></indexterm>jnl <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ldexp</primary></indexterm>ldexp <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ldexpf</primary></indexterm>ldexpf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>ldexpl</primary></indexterm>ldexpl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lgamma</primary></indexterm>lgamma <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lgamma_r</primary></indexterm>lgamma_r <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lgammaf</primary></indexterm>lgammaf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lgammaf_r</primary></indexterm>lgammaf_r <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>lgammal</primary></indexterm>lgammal <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lgammal_r</primary></indexterm>lgammal_r <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>llrint</primary></indexterm>llrint <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>llrintf</primary></indexterm>llrintf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>llrintl</primary></indexterm>llrintl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>llround</primary></indexterm>llround <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>llroundf</primary></indexterm>llroundf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>llroundl</primary></indexterm>llroundl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log</primary></indexterm>log <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log10</primary></indexterm>log10 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>log10f</primary></indexterm>log10f <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log10l</primary></indexterm>log10l <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log1p</primary></indexterm>log1p <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log1pf</primary></indexterm>log1pf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>log1pl</primary></indexterm>log1pl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log2</primary></indexterm>log2 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log2f</primary></indexterm>log2f <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>log2l</primary></indexterm>log2l <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>logb</primary></indexterm>logb <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>logbf</primary></indexterm>logbf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>logbl</primary></indexterm>logbl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>logf</primary></indexterm>logf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>logl</primary></indexterm>logl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lrint</primary></indexterm>lrint <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lrintf</primary></indexterm>lrintf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lrintl</primary></indexterm>lrintl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>lround</primary></indexterm>lround <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lroundf</primary></indexterm>lroundf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>lroundl</primary></indexterm>lroundl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>matherr</primary></indexterm>matherr <LINK LINKEND="REFSTD.libm.3">[SVID.3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>modf</primary></indexterm>modf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>modff</primary></indexterm>modff <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>modfl</primary></indexterm>modfl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nan</primary></indexterm>nan <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nanf</primary></indexterm>nanf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nanl</primary></indexterm>nanl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nearbyint</primary></indexterm>nearbyint <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nearbyintf</primary></indexterm>nearbyintf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nearbyintl</primary></indexterm>nearbyintl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nextafter</primary></indexterm>nextafter <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nextafterf</primary></indexterm>nextafterf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nextafterl</primary></indexterm>nextafterl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nexttoward</primary></indexterm>nexttoward <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nexttowardf</primary></indexterm>nexttowardf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>nexttowardl</primary></indexterm>nexttowardl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pow</primary></indexterm>pow <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pow10</primary></indexterm>pow10 <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pow10f</primary></indexterm>pow10f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pow10l</primary></indexterm>pow10l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>powf</primary></indexterm>powf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>powl</primary></indexterm>powl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>remainder</primary></indexterm>remainder <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>remainderf</primary></indexterm>remainderf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>remainderl</primary></indexterm>remainderl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>remquo</primary></indexterm>remquo <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>remquof</primary></indexterm>remquof <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>remquol</primary></indexterm>remquol <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rint</primary></indexterm>rint <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>rintf</primary></indexterm>rintf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>rintl</primary></indexterm>rintl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>round</primary></indexterm>round <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>roundf</primary></indexterm>roundf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>roundl</primary></indexterm>roundl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalb</primary></indexterm>scalb <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalbf</primary></indexterm>scalbf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalbl</primary></indexterm>scalbl <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scalbln</primary></indexterm>scalbln <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalblnf</primary></indexterm>scalblnf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalblnl</primary></indexterm>scalblnl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalbn</primary></indexterm>scalbn <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scalbnf</primary></indexterm>scalbnf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>scalbnl</primary></indexterm>scalbnl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>significand</primary></indexterm>significand <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>significandf</primary></indexterm>significandf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>significandl</primary></indexterm>significandl <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sin</primary></indexterm>sin <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sincos</primary></indexterm>sincos <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sincosf</primary></indexterm>sincosf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sincosl</primary></indexterm>sincosl <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>sinf</primary></indexterm>sinf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sinh</primary></indexterm>sinh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sinhf</primary></indexterm>sinhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sinhl</primary></indexterm>sinhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sinl</primary></indexterm>sinl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sqrt</primary></indexterm>sqrt <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sqrtf</primary></indexterm>sqrtf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sqrtl</primary></indexterm>sqrtl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tan</primary></indexterm>tan <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tanf</primary></indexterm>tanf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tanh</primary></indexterm>tanh <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tanhf</primary></indexterm>tanhf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tanhl</primary></indexterm>tanhl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tanl</primary></indexterm>tanl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgamma</primary></indexterm>tgamma <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgammaf</primary></indexterm>tgammaf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgammal</primary></indexterm>tgammal <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>trunc</primary></indexterm>trunc <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>truncf</primary></indexterm>truncf <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>truncl</primary></indexterm>truncl <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>y0</primary></indexterm>y0 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>y0f</primary></indexterm>y0f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>y0l</primary></indexterm>y0l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>y1</primary></indexterm>y1 <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>y1f</primary></indexterm>y1f <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>y1l</primary></indexterm>y1l <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>yn</primary></indexterm>yn <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ynf</primary></indexterm>ynf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ynl</primary></indexterm>ynl <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Math specified in <XREF linkend="tbl-libm-math-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libm-math-depints">
<TITLE>libm - Math Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>drem</primary></indexterm>drem <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dremf</primary></indexterm>dremf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dreml</primary></indexterm>dreml <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>finite</primary></indexterm>finite <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>finitef</primary></indexterm>finitef <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>finitel</primary></indexterm>finitel <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gamma</primary></indexterm>gamma <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gammaf</primary></indexterm>gammaf <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gammal</primary></indexterm>gammal <LINK LINKEND="REFSTD.libm.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>matherr</primary></indexterm>matherr <LINK LINKEND="REFSTD.libm.3">[SVID.3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Math specified in <XREF linkend="tbl-libm-math-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libm-math-data">
<TITLE>libm - Math Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>signgam</primary></indexterm>signgam <LINK LINKEND="REFSTD.libm.2">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libm-ddefs>
<TITLE>Data Definitions for libm</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libm.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>complex.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define complex	_Complex

extern double cabs(double complex);
extern float cabsf(float complex);
extern long double cabsl(long double complex);
extern double complex cacos(double complex);
extern float complex cacosf(float complex);
extern double complex cacosh(double complex);
extern float complex cacoshf(float complex);
extern long double complex cacoshl(long double complex);
extern long double complex cacosl(long double complex);
extern double carg(double complex);
extern float cargf(float complex);
extern long double cargl(long double complex);
extern double complex casin(double complex);
extern float complex casinf(float complex);
extern double complex casinh(double complex);
extern float complex casinhf(float complex);
extern long double complex casinhl(long double complex);
extern long double complex casinl(long double complex);
extern double complex catan(double complex);
extern float complex catanf(float complex);
extern double complex catanh(double complex);
extern float complex catanhf(float complex);
extern long double complex catanhl(long double complex);
extern long double complex catanl(long double complex);
extern double complex ccos(double complex);
extern float complex ccosf(float complex);
extern double complex ccosh(double complex);
extern float complex ccoshf(float complex);
extern long double complex ccoshl(long double complex);
extern long double complex ccosl(long double complex);
extern double complex cexp(double complex);
extern float complex cexpf(float complex);
extern long double complex cexpl(long double complex);
extern double cimag(double complex);
extern float cimagf(float complex);
extern long double cimagl(long double complex);
extern double complex clog(double complex);
extern double complex clog10(double complex);
extern float complex clog10f(float complex);
extern long double complex clog10l(long double complex);
extern float complex clogf(float complex);
extern long double complex clogl(long double complex);
extern double complex conj(double complex);
extern float complex conjf(float complex);
extern long double complex conjl(long double complex);
extern double complex cpow(double complex, double complex);
extern float complex cpowf(float complex, float complex);
extern long double complex cpowl(long double complex, long double complex);
extern double complex cproj(double complex);
extern float complex cprojf(float complex);
extern long double complex cprojl(long double complex);
extern double creal(double complex);
extern float crealf(float complex);
extern long double creall(long double complex);
extern double complex csin(double complex);
extern float complex csinf(float complex);
extern double complex csinh(double complex);
extern float complex csinhf(float complex);
extern long double complex csinhl(long double complex);
extern long double complex csinl(long double complex);
extern double complex csqrt(double complex);
extern float complex csqrtf(float complex);
extern long double complex csqrtl(long double complex);
extern double complex ctan(double complex);
extern float complex ctanf(float complex);
extern double complex ctanh(double complex);
extern float complex ctanhf(float complex);
extern long double complex ctanhl(long double complex);
extern long double complex ctanl(long double complex);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fenv.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern int fedisableexcept(int);
extern int feenableexcept(int);
extern int fegetexcept(void);
extern int feclearexcept(int);
extern int fegetenv(fenv_t *);
extern int fegetexceptflag(fexcept_t *, int);
extern int fegetround(void);
extern int feholdexcept(fenv_t *);
extern int feraiseexcept(int);
extern int fesetenv(const fenv_t *);
extern int fesetexceptflag(const fexcept_t *, int);
extern int fesetround(int);
extern int fetestexcept(int);
extern int feupdateenv(const fenv_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>math.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define DOMAIN	1
#define SING	2

#define FP_NAN	0
#define FP_INFINITE	1
#define FP_ZERO	2
#define FP_SUBNORMAL	3
#define FP_NORMAL	4

#define isnormal(x)	(fpclassify (x) == FP_NORMAL)	/* Return nonzero value if X is neither zero, subnormal, Inf, n */

#define HUGE_VAL	0x1.0p2047
#define HUGE_VALF	0x1.0p255f

#define NAN	((float)0x7fc00000UL)
#define M_1_PI	0.31830988618379067154
#define M_LOG10E	0.43429448190325182765
#define M_2_PI	0.63661977236758134308
#define M_LN2	0.69314718055994530942
#define M_SQRT1_2	0.70710678118654752440
#define M_PI_4	0.78539816339744830962
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2	1.41421356237309504880
#define M_LOG2E	1.4426950408889634074
#define M_PI_2	1.57079632679489661923
#define M_LN10	2.30258509299404568402
#define M_E	2.7182818284590452354
#define M_PI	3.14159265358979323846
#define INFINITY	HUGE_VALF

#define MATH_ERRNO	1	/* errno set by math functions. */
#define MATH_ERREXCEPT	2	/* Exceptions raised by math functions. */

#define isunordered(u, v)	\
	(__extension__({ __typeof__(u) __u = (u); __typeof__(v) __v = (v);fpclassify (__u) == FP_NAN || fpclassify (__v) == FP_NAN; }))	/* Return nonzero value if arguments are unordered. */
#define islessgreater(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &amp;&amp; (__x &lt; __y || __y &lt; __x); }))	/* Return nonzero value if either X is less than Y or Y is less */
#define isless(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &amp;&amp; __x &lt; __y; }))	/* Return nonzero value if X is less than Y. */
#define islessequal(x, y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &amp;&amp; __x &lt;= __y; }))	/* Return nonzero value if X is less than or equal to Y. */
#define isgreater(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &amp;&amp; __x > __y; }))	/* Return nonzero value if X is greater than Y. */
#define isgreaterequal(x,y)	\
	(__extension__({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);!isunordered (__x, __y) &amp;&amp; __x >= __y; }))	/* Return nonzero value if X is greater than or equal to Y. */

extern int __finite(double);
extern int __finitef(float);
extern int __finitel(long double);
extern int __isinf(double);
extern int __isinff(float);
extern int __isinfl(long double);
extern int __isnan(double);
extern int __isnanf(float);
extern int __isnanl(long double);
extern int __signbit(double);
extern int __signbitf(float);
extern int __fpclassify(double);
extern int __fpclassifyf(float);
extern int signgam;
extern double copysign(double, double);
extern int finite(double);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double modf(double, double *);
extern double acos(double);
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
extern double asin(double);
extern double atan(double);
extern double atan2(double, double);
extern double cbrt(double);
extern double ceil(double);
extern double cos(double);
extern double cosh(double);
extern double erf(double);
extern double erfc(double);
extern double exp(double);
extern double expm1(double);
extern double fabs(double);
extern double floor(double);
extern double fmod(double, double);
extern double gamma(double);
extern double hypot(double, double);
extern int ilogb(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double lgamma(double);
extern double log(double);
extern double log10(double);
extern double log1p(double);
extern double logb(double);
extern double nextafter(double, double);
extern double pow(double, double);
extern double remainder(double, double);
extern double rint(double);
extern double scalb(double, double);
extern double sin(double);
extern double sinh(double);
extern double sqrt(double);
extern double tan(double);
extern double tanh(double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
extern double drem(double, double);
extern float copysignf(float, float);
extern long double copysignl(long double, long double);
extern int finitef(float);
extern int finitel(long double);
extern float frexpf(float, int *);
extern long double frexpl(long double, int *);
extern float ldexpf(float, int);
extern long double ldexpl(long double, int);
extern float modff(float, float *);
extern long double modfl(long double, long double *);
extern double scalbln(double, long int);
extern float scalblnf(float, long int);
extern long double scalblnl(long double, long int);
extern double scalbn(double, int);
extern float scalbnf(float, int);
extern long double scalbnl(long double, int);
extern float acosf(float);
extern float acoshf(float);
extern long double acoshl(long double);
extern long double acosl(long double);
extern float asinf(float);
extern float asinhf(float);
extern long double asinhl(long double);
extern long double asinl(long double);
extern float atan2f(float, float);
extern long double atan2l(long double, long double);
extern float atanf(float);
extern float atanhf(float);
extern long double atanhl(long double);
extern long double atanl(long double);
extern float cbrtf(float);
extern long double cbrtl(long double);
extern float ceilf(float);
extern long double ceill(long double);
extern float cosf(float);
extern float coshf(float);
extern long double coshl(long double);
extern long double cosl(long double);
extern float dremf(float, float);
extern long double dreml(long double, long double);
extern float erfcf(float);
extern long double erfcl(long double);
extern float erff(float);
extern long double erfl(long double);
extern double exp10(double);
extern float exp10f(float);
extern long double exp10l(long double);
extern double exp2(double);
extern float exp2f(float);
extern float expf(float);
extern long double expl(long double);
extern float expm1f(float);
extern long double expm1l(long double);
extern float fabsf(float);
extern long double fabsl(long double);
extern double fdim(double, double);
extern float fdimf(float, float);
extern long double fdiml(long double, long double);
extern float floorf(float);
extern long double floorl(long double);
extern double fma(double, double, double);
extern float fmaf(float, float, float);
extern long double fmal(long double, long double, long double);
extern double fmax(double, double);
extern float fmaxf(float, float);
extern long double fmaxl(long double, long double);
extern double fmin(double, double);
extern float fminf(float, float);
extern long double fminl(long double, long double);
extern float fmodf(float, float);
extern long double fmodl(long double, long double);
extern float gammaf(float);
extern long double gammal(long double);
extern float hypotf(float, float);
extern long double hypotl(long double, long double);
extern int ilogbf(float);
extern int ilogbl(long double);
extern float j0f(float);
extern long double j0l(long double);
extern float j1f(float);
extern long double j1l(long double);
extern float jnf(int, float);
extern long double jnl(int, long double);
extern double lgamma_r(double, int *);
extern float lgammaf(float);
extern float lgammaf_r(float, int *);
extern long double lgammal(long double);
extern long double lgammal_r(long double, int *);
extern long long int llrint(double);
extern long long int llrintf(float);
extern long long int llrintl(long double);
extern long long int llround(double);
extern long long int llroundf(float);
extern long long int llroundl(long double);
extern float log10f(float);
extern long double log10l(long double);
extern float log1pf(float);
extern long double log1pl(long double);
extern double log2(double);
extern float log2f(float);
extern long double log2l(long double);
extern float logbf(float);
extern long double logbl(long double);
extern float logf(float);
extern long double logl(long double);
extern long int lrint(double);
extern long int lrintf(float);
extern long int lrintl(long double);
extern long int lround(double);
extern long int lroundf(float);
extern long int lroundl(long double);
extern double nan(const char *);
extern float nanf(const char *);
extern long double nanl(const char *);
extern double nearbyint(double);
extern float nearbyintf(float);
extern long double nearbyintl(long double);
extern float nextafterf(float, float);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern double pow10(double);
extern float pow10f(float);
extern long double pow10l(long double);
extern float powf(float, float);
extern long double powl(long double, long double);
extern float remainderf(float, float);
extern long double remainderl(long double, long double);
extern double remquo(double, double, int *);
extern float remquof(float, float, int *);
extern long double remquol(long double, long double, int *);
extern float rintf(float);
extern long double rintl(long double);
extern double round(double);
extern float roundf(float);
extern long double roundl(long double);
extern float scalbf(float, float);
extern long double scalbl(long double, long double);
extern double significand(double);
extern float significandf(float);
extern long double significandl(long double);
extern void sincos(double, double *, double *);
extern void sincosf(float, float *, float *);
extern void sincosl(long double, long double *, long double *);
extern float sinf(float);
extern float sinhf(float);
extern long double sinhl(long double);
extern long double sinl(long double);
extern float sqrtf(float);
extern long double sqrtl(long double);
extern float tanf(float);
extern float tanhf(float);
extern long double tanhl(long double);
extern long double tanl(long double);
extern double tgamma(double);
extern float tgammaf(float);
extern long double tgammal(long double);
extern double trunc(double);
extern float truncf(float);
extern long double truncl(long double);
extern float y0f(float);
extern long double y0l(long double);
extern float y1f(float);
extern long double y1l(long double);
extern float ynf(int, float);
extern long double ynl(int, long double);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libmman>
<TITLE>Interface Definitions for libm</TITLE>
<PARA>
The interfaces defined on the following pages are included in libm and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libm> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="baselib---finite"> <REFMETA>
<REFENTRYTITLE>__finite</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__finite</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__finite</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__finite</FUNCTION> has the same specification as 
<FUNCTION>isfinite</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__finite</FUNCTION> is known to be double.
</PARA>
<PARA>
<FUNCTION>__finite</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---finitef"> <REFMETA>
<REFENTRYTITLE>__finitef</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__finitef</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__finitef</FUNCTION></FUNCDEF>
 <PARAMDEF>float 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__finitef</FUNCTION> has the same specification as 
<FUNCTION>isfinite</FUNCTION> in <XREF LINKEND="STD.SUSv3">
except that the argument 
type for <FUNCTION>__finitef</FUNCTION> is known to be float.
</PARA>
<PARA>
<FUNCTION>__finitef</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---finitel"> <REFMETA>
<REFENTRYTITLE>__finitel</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__finitel</REFNAME>
<REFPURPOSE>
test for infinity
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__finitel</FUNCTION></FUNCDEF>
 <PARAMDEF>long double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__finitel</FUNCTION> has the same specification as 
<FUNCTION>isfinite</FUNCTION> in the <XREF LINKEND="STD.SUSv3">,
except that the argument 
type for <FUNCTION>__finitel</FUNCTION> is known to be long double.
</PARA>
<PARA>
<FUNCTION>__finitel</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---fpclassify"> <REFMETA>
<REFENTRYTITLE>__fpclassify</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__fpclassify</REFNAME>
<REFPURPOSE>
Classify real floating type
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__fpclassify</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__fpclassify</FUNCTION> has the same specification as 
<FUNCTION>fpclassify</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__fpclassify</FUNCTION> is known to be double.
</PARA>
<PARA>
<FUNCTION>__fpclassify</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---fpclassifyf"> <REFMETA>
<REFENTRYTITLE>__fpclassifyf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__fpclassifyf</REFNAME>
<REFPURPOSE>
Classify real floating type
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__fpclassifyf</FUNCTION></FUNCDEF>
 <PARAMDEF>float 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__fpclassifyf</FUNCTION> has the same specification as 
<FUNCTION>fpclassify</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__fpclassifyf</FUNCTION> is known to be float.
</PARA>
<PARA>
<FUNCTION>__fpclassifyf</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---signbit"> <REFMETA>
<REFENTRYTITLE>__signbit</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__signbit</REFNAME>
<REFPURPOSE>
test sign of floating point value
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>__signbit</FUNCTION></FUNCDEF>
 <PARAMDEF>double 
  <PARAMETER><REPLACEABLE>arg</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__signbit</FUNCTION> has the same specification as 
<FUNCTION>signbit</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__signbit</FUNCTION> is known to be double.
</PARA>
<PARA>
<FUNCTION>__signbit</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---signbitf"> <REFMETA>
<REFENTRYTITLE>__signbitf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__signbitf</REFNAME>
<REFPURPOSE>
test sign of floating point value
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>__signbitf</function>
</funcdef>
<paramdef>float
<parameter>arg</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>__signbitf</FUNCTION> has the same specification as 
<FUNCTION>signbit</FUNCTION> in <XREF LINKEND="STD.SUSV3">,
except that the argument 
type for <FUNCTION>__signbitf</FUNCTION> is known to be float.
</PARA>
<PARA>
<FUNCTION>__signbitf</FUNCTION> is not in the source standard; 
it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---clog10"> <REFMETA>
<REFENTRYTITLE>clog10</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>clog10</REFNAME>
<REFPURPOSE>
Logarithm of a Complex Number
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;complex.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double complex
<function>clog10</function>
</funcdef>
<paramdef>double complex
<parameter>z</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>clog10</function> function shall compute the base 10 
logarithm of the complex number <parameter>z</parameter>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <function>clog10</function> function shall return the base 10 logarithm.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---clog10f"> <REFMETA>
<REFENTRYTITLE>clog10f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>clog10f</REFNAME>
<REFPURPOSE>
Logarithm of a Complex Number
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;complex.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float complex
<function>clog10f</function>
</funcdef>
<paramdef>float complex
<parameter>z</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>clog10f</function> function shall compute the base 10 
logarithm of the complex number <parameter>z</parameter>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <function>clog10f</function> function shall return the base 10 logarithm.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---clog10l"> <REFMETA>
<REFENTRYTITLE>clog10l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>clog10l</REFNAME>
<REFPURPOSE>
Logarithm of a Complex Number
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;complex.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double complex
<function>clog10l</function>
</funcdef>
<paramdef>long double complex
<parameter>z</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>clog10l</function> function shall compute the base 10 
logarithm of the complex number <parameter>z</parameter>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The <function>clog10l</function> function shall return the base 10 logarithm.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-drem"> <REFMETA>
<REFENTRYTITLE>drem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>drem</REFNAME>
<REFPURPOSE>
Floating Point Remainder (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>drem</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>double
<parameter>y</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>drem</FUNCTION> function shall return the floating point remainder,
<parameter>x</parameter> REM <parameter>y</parameter> as required by <xref linkend=std.fltpnt>
in the same way as <function>remainder</function>.
<note><para>
This function is included only for backwards compatibility; applications should
use <function>remainder</function> instead.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>remainder</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>remainder</function></member>
<member><function>dremf</function></member>
<member><function>dreml</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-dremf"> <REFMETA>
<REFENTRYTITLE>dremf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dremf</REFNAME>
<REFPURPOSE>
Floating Point Remainder (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>dremf</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>double
<parameter>y</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>dremf</FUNCTION> function shall return the floating point remainder,
<parameter>x</parameter> REM <parameter>y</parameter> as required by <xref linkend=std.fltpnt>
in the same way as <function>remainderf</function>.
<note><para>
This function is included only for backwards compatibility; applications should
use <function>remainderf</function> instead.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>remainderf</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>remainderf</function></member>
<member><function>drem</function></member>
<member><function>dreml</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-dreml"> <REFMETA>
<REFENTRYTITLE>dreml</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dreml</REFNAME>
<REFPURPOSE>
Floating Point Remainder (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>dreml</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>double
<parameter>y</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>dreml</FUNCTION> function shall return the floating point remainder,
<parameter>x</parameter> REM <parameter>y</parameter> as required by <xref linkend=std.fltpnt>
in the same way as <function>remainderl</function>.
<note><para>
This function is included only for backwards compatibility; applications should
use <function>remainderl</function> instead.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>remainderl</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>remainderl</function></member>
<member><function>drem</function></member>
<member><function>dremf</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-exp10"> <REFMETA>
<REFENTRYTITLE>exp10</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>exp10</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>exp10</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>exp10</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>pow10</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>exp10</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>exp10</function>
shall return &plusmn;HUGE_VAL, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>pow10</function></member>
<member><function>exp10f</function></member>
<member><function>exp10l</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-exp10f"> <REFMETA>
<REFENTRYTITLE>exp10f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>exp10f</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>exp10f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>exp10f</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>pow10f</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>exp10f</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>exp10f</function>
shall return &plusmn;HUGE_VALF, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>pow10f</function></member>
<member><function>exp10</function></member>
<member><function>exp10l</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-exp10l"> <REFMETA>
<REFENTRYTITLE>exp10l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>exp10l</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>exp10l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>exp10l</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>pow10l</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>exp10l</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>exp10l</function>
shall return &plusmn;HUGE_VALL, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>pow10l</function></member>
<member><function>exp10</function></member>
<member><function>exp10f</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<refentry id="baselib-fedisableexcept"> <refmeta>
<refentrytitle>fedisableexcept</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>fedisableexcept</refname>
<refpurpose>
disable floating point exceptions
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fenv.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>fedisableexcept</function></funcdef>
<paramdef>int <parameter>excepts</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The <function>fedisableexcept</function> function disables
traps for each of the exceptions represented by 
the mask <varname>excepts</varname>.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>fedisableexcept</function> function returns 
the previous set of enabled exceptions on success.
On error, -1 is returned.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<para>
No errors are defined, but the function will fail
if not supported on the architecture.
</para>
</refsect1>

</refentry>

<refentry id="baselib-feenableexcept"> <refmeta>
<refentrytitle>feenableexcept</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>feenableexcept</refname>
<refpurpose>
enable floating point exceptions
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fenv.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>feenableexcept</function></funcdef>
<paramdef>int <parameter>excepts</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The <function>feenableexcept</function> function enables
traps for each of the exceptions represented by 
the mask <varname>excepts</varname>.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>feenableexcept</function> function returns 
the previous set of enabled exceptions on success.
On error, -1 is returned.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<para>
No errors are defined, but the function will fail
if not supported on the architecture.
</para>
</refsect1>

</refentry>

<refentry id="baselib-fegetexcept"> <refmeta>
<refentrytitle>fegetexcept</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>fegetexcept</refname>
<refpurpose>
query floating point exception handling state
</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;fenv.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int <function>fegetexcept</function></funcdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The <function>fegetexcept</function> function returns  
the set of all currently enabled exceptions.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
The <function>fegetexcept</function> function returns 
the set of all currently enabled exceptions.
</para>
</refsect1>

<refsect1>
<title>Errors</title>
<para>
No errors are defined, but the function will fail
if not supported on the architecture.
</para>
</refsect1>

</refentry>

<REFENTRY ID="baselib-finite"> <REFMETA>
<REFENTRYTITLE>finite</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>finite</REFNAME>
<REFPURPOSE>
test for infinity (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _SVID_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>finite</function>
</funcdef>
<paramdef>double
<parameter>arg</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>finite</FUNCTION> function shall test whether
its argument is neither <constant>INFINITY</constant> nor
not a number (NaN).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
On success, <function>finite</function> shall return <returnvalue>1</returnvalue>. Otherwise
the function shall return <returnvalue>0</returnvalue>.
<note><para>The <xref linkend=std.isoc99> standard defines the function <function>isfinite</function>,
which is more general purpose. The <function>finite</function> function is deprecated, and applications
should use <function>isfinite</function> instead. A future revision of this standard may remove this function.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>isfinite</function></member>
<member><function>finitef</function></member>
<member><function>finitel</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-finitef"> <REFMETA>
<REFENTRYTITLE>finitef</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>finitef</REFNAME>
<REFPURPOSE>
test for infinity (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _SVID_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>finitef</function>
</funcdef>
<paramdef>float
<parameter>arg</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>finitef</FUNCTION> function shall test whether
its argument is neither <constant>INFINITY</constant> nor
not a number (NaN).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
On success, <function>finitef</function> shall return <returnvalue>1</returnvalue>. Otherwise
the function shall return <returnvalue>0</returnvalue>.
<note><para>The <xref linkend=std.isoc99> standard defines the function <function>isfinite</function>,
which is more general purpose. The <function>finitef</function> function is deprecated, and applications
should use <function>isfinite</function> instead. A future revision of this standard may remove this function.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>isfinite</function></member>
<member><function>finite</function></member>
<member><function>finitel</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-finitel"> <REFMETA>
<REFENTRYTITLE>finitel</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>finitel</REFNAME>
<REFPURPOSE>
test for infinity (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _SVID_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>finitel</function>
</funcdef>
<paramdef>long double
<parameter>arg</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>finitel</FUNCTION> function shall test whether
its argument is neither <constant>INFINITY</constant> nor
not a number (NaN).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
On success, <function>finitel</function> shall return <returnvalue>1</returnvalue>. Otherwise
the function shall return <returnvalue>0</returnvalue>.
<note><para>The <xref linkend=std.isoc99> standard defines the function <function>isfinite</function>,
which is more general purpose. The <function>finitel</function> function is deprecated, and applications
should use <function>isfinite</function> instead. A future revision of this standard may remove this function.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>isfinite</function></member>
<member><function>finite</function></member>
<member><function>finitef</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gamma"> <REFMETA>
<REFENTRYTITLE>gamma</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gamma</REFNAME>
<REFPURPOSE>
log gamma function (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>gammaf</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>gamma</function> function is identical to 
<function>lgamma</function> in <XREF LINKEND="STD.SUSv3">.
<note><para>
The name <function>gamma</function> for this function
is deprecated and should not be used.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgamma</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgammaf</function></member>
<member><function>lgammal</function></member>
<member><function>gammaf</function></member>
<member><function>gammal</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gammaf"> <REFMETA>
<REFENTRYTITLE>gammaf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gammaf</REFNAME>
<REFPURPOSE>
log gamma function (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>gammaf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>gammaf</function> function is identical to 
<function>lgammaf</function> in <XREF LINKEND="STD.SUSv3">.
<note><para>
The name <function>gammaf</function> for this function
is deprecated and should not be used.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgammaf</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgammaf</function></member>
<member><function>lgammal</function></member>
<member><function>gamma</function></member>
<member><function>gammal</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-gammal"> <REFMETA>
<REFENTRYTITLE>gammal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gammal</REFNAME>
<REFPURPOSE>
log gamma function (DEPRECATED)
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>gammal</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <function>gammal</function> function is identical to 
<function>lgammal</function> in <XREF LINKEND="STD.SUSv3">.
<note><para>
The name <function>gammal</function> for this function
is deprecated and should not be used.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgammal</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgammaf</function></member>
<member><function>lgammal</function></member>
<member><function>gamma</function></member>
<member><function>gammaf</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-j0f"> <REFMETA>
<REFENTRYTITLE>j0f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>j0f</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>j0f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>j0f</FUNCTION> function is identical to <function>j0</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>j0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-j0l"> <REFMETA>
<REFENTRYTITLE>j0l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>j0l</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>j0l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>j0l</FUNCTION> function is identical to <function>j0</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>j0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-j1f"> <REFMETA>
<REFENTRYTITLE>j1f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>j1f</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>j1f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>j1f</FUNCTION> function is identical to <function>j1</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>j1</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-j1l"> <REFMETA>
<REFENTRYTITLE>j1l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>j1l</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>j1l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>j1l</FUNCTION> function is identical to <function>j1</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>j0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-jnf"> <REFMETA>
<REFENTRYTITLE>jnf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>jnf</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>jnf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>jnf</FUNCTION> function is identical to <function>jn</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>jn</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-jnl"> <REFMETA>
<REFENTRYTITLE>jnl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>jnl</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>jnl</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>jnl</FUNCTION> function is identical to <function>jn</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>jn</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-lgamma-r"> <REFMETA>
<REFENTRYTITLE>lgamma_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>lgamma_r</REFNAME>
<REFPURPOSE>
log gamma functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>lgamma_r</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>int *
<parameter>signp</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>lgamma_r</FUNCTION> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <function>lgamma</function>.
However, instead of setting the external integer <varname>signgam</varname>
to the sign of the Gamma function, <function>lgamma_r</function> shall set the
integer referenced by <parameter>signp</parameter> to the sign.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgamma</function> and <varname>signgam</varname>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgammaf_r</function></member>
<member><function>lgammal_r</function></member>
<member><varname>signgam</varname></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-lgammaf-r"> <REFMETA>
<REFENTRYTITLE>lgammaf_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>lgammaf_r</REFNAME>
<REFPURPOSE>
log gamma functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>lgammaf_r</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>
<paramdef>int *
<parameter>signp</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>lgammaf_r</FUNCTION> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <function>lgammaf</function>.
However, instead of setting the external integer <varname>signgam</varname>
to the sign of the Gamma function, <function>lgammaf_r</function> shall set the
integer referenced by <parameter>signp</parameter> to the sign.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgammaf</function> and <varname>signgam</varname>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgamma_r</function></member>
<member><function>lgammal_r</function></member>
<member><varname>signgam</varname></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-lgammal-r"> <REFMETA>
<REFENTRYTITLE>lgammal_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>lgammal_r</REFNAME>
<REFPURPOSE>
log gamma functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>lgammal_r</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>int *
<parameter>signp</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>lgammal_r</FUNCTION> function shall compute the natural logarithm
of the absolute value of the Gamma function, as <function>lgammal</function>.
However, instead of setting the external integer <varname>signgam</varname>
to the sign of the Gamma function, <function>lgammal_r</function> shall set the
integer referenced by <parameter>signp</parameter> to the sign.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>lgammal</function> and <varname>signgam</varname>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>lgamma</function></member>
<member><function>lgamma_r</function></member>
<member><function>lgammaf_r</function></member>
<member><varname>signgam</varname></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-pow10"> <REFMETA>
<REFENTRYTITLE>pow10</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pow10</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>pow10</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>pow10</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>exp10</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>pow10</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>pow10</function>
shall return &plusmn;HUGE_VAL, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>exp10</function></member>
<member><function>pow10f</function></member>
<member><function>pow10l</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-pow10f"> <REFMETA>
<REFENTRYTITLE>pow10f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pow10f</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>pow10f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>pow10f</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>exp10f</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>pow10f</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>pow10f</function>
shall return &plusmn;HUGE_VALF, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>exp10f</function></member>
<member><function>pow10</function></member>
<member><function>pow10l</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-pow10l"> <REFMETA>
<REFENTRYTITLE>pow10l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pow10l</REFNAME>
<REFPURPOSE>
Base-10 power function
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>pow10l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>pow10l</FUNCTION> function shall return 10<superscript><symbol>x</symbol></superscript>.
<note><para>
This function is identical to <function>exp10l</function>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>pow10l</function> shall return 10
rised to the power of <symbol>x</symbol>.
</PARA>
<PARA>
If the correct value would cause overflow, a range error shall occur and <function>pow10l</function>
shall return &plusmn;HUGE_VALL, with the same sign as the correct value of the function.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>exp10l</function></member>
<member><function>pow10</function></member>
<member><function>pow10f</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<refentry id="baselib-scalbf"> 

<refmeta>
<refentrytitle>scalbf</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>scalbf</refname>
<refpurpose>
load exponent of radix-independent floating point number
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>scalbf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>
<paramdef>double
<parameter>exp</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The <function>scalbf</function> function is identical
to <function>scalb</function>, except that the argument
<parameter>x</parameter> and the return value is of type <type>float</type>.
</para>
</refsect1>

<refsect1>
<title>Returns</title>
<para>
See <function>scalb</function>.
</para>
</refsect1>

</refentry>

<refentry ID="baselib-scalbl"> 

<refmeta>
<refentrytitle>scalbl</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>scalbl</refname>
<refpurpose>
load exponent of radix-independent floating point number
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>scalbl</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>
<paramdef>double
<parameter>exp</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The <function>scalbl</function> function is identical
to <function>scalb</function>, except that the argument
<parameter>x</parameter> and the return value is of type <type>long
double</type>.
</para>
</refsect1>

<refsect1>
<title>Returns</title>
<para>
See <function>scalb</function>.
</para>
</refsect1>

</refentry>

<REFENTRY ID="baselib-significand"> <REFMETA>
<REFENTRYTITLE>significand</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>significand</REFNAME>
<REFPURPOSE>
floating point mantissa
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>double
<function>significand</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>significand</FUNCTION> function shall return the mantissa of
<parameter>x</parameter>, <symbol>sig</symbol> such that
<parameter>x</parameter> &equiv; <symbol>sig</symbol> &times; 2<superscript>n</superscript>
scaled such that 1 &le; <symbol>sig</symbol> &lt; 2.
<note><para>
This function is intended for testing conformance to <xref linkend=std.fltpnt>, and its use is not otherwise
recommended.
</para><para>
This function is equivalent to <literal>scalb(x, (double)-ilogb(x))</literal>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>significand</function> shall return the mantissa of <parameter>x</parameter>
in the range
1 &le; <symbol>sig</symbol> &lt; 2.
</PARA>
<PARA>
If <parameter>x</parameter> is 0, &plusmn;HUGE_VAL, or NaN, the result is undefined.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>significandf</function></member>
<member><function>significandl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-significandf"> <REFMETA>
<REFENTRYTITLE>significandf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>significandf</REFNAME>
<REFPURPOSE>
floating point mantissa
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>significandf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>significandf</FUNCTION> function shall return the mantissa of
<parameter>x</parameter>, <symbol>sig</symbol> such that
<parameter>x</parameter> &equiv; <symbol>sig</symbol> &times; 2<superscript>n</superscript>
scaled such that 1 &le; <symbol>sig</symbol> &lt; 2.
<note><para>
This function is intended for testing conformance to <xref linkend=std.fltpnt>, and its use is not otherwise
recommended.
</para><para>
This function is equivalent to <literal>scalb(x, (double)-ilogb(x))</literal>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>significandf</function> shall return the mantissa of <parameter>x</parameter>
in the range
1 &le; <symbol>sig</symbol> &lt; 2.
</PARA>
<PARA>
If <parameter>x</parameter> is 0, &plusmn;HUGE_VALF, or NaN, the result is undefined.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>significand</function></member>
<member><function>significandl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-significandl"> <REFMETA>
<REFENTRYTITLE>significandl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>significandl</REFNAME>
<REFPURPOSE>
floating point mantissa
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>significandl</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>significandl</FUNCTION> function shall return the mantissa of
<parameter>x</parameter>, <symbol>sig</symbol> such that
<parameter>x</parameter> &equiv; <symbol>sig</symbol> &times; 2<superscript>n</superscript>
scaled such that 1 &le; <symbol>sig</symbol> &lt; 2.
<note><para>
This function is intended for testing conformance to <xref linkend=std.fltpnt>, and its use is not otherwise
recommended.
</para><para>
This function is equivalent to <literal>scalb(x, (double)-ilogb(x))</literal>.
</para></note>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
Upon successful completion, <function>significandl</function> shall return the mantissa of <parameter>x</parameter>
in the range
1 &le; <symbol>sig</symbol> &lt; 2.
</PARA>
<PARA>
If <parameter>x</parameter> is 0, &plusmn;HUGE_VALL, or NaN, the result is undefined.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>significand</function></member>
<member><function>significandf</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-sincos"> <REFMETA>
<REFENTRYTITLE>sincos</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sincos</REFNAME>
<REFPURPOSE>
trigonometric functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _GNU_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>sincos</function>
</funcdef>
<paramdef>double
<parameter>x</parameter>
</paramdef>
<paramdef>double *
<parameter>sin</parameter>
</paramdef>
<paramdef>double *
<parameter>cos</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sincos</FUNCTION> function shall calculate both the sine and cosine of
<parameter>x</parameter>. 
The sine shall be stored in the location referenced by <parameter>sin</parameter>,
and the cosine in the location referenced by <parameter>cosine</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
None. See <function>sin</function> and <function>cos</function> for possible error conditions.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>cos</function></member>
<member><function>sin</function></member>
<member><function>sincosf</function></member>
<member><function>sincosl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-sincosf"> <REFMETA>
<REFENTRYTITLE>sincosf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sincosf</REFNAME>
<REFPURPOSE>
trigonometric functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _GNU_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>sincosf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>
<paramdef>float *
<parameter>sin</parameter>
</paramdef>
<paramdef>float *
<parameter>cos</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sincosf</FUNCTION> function shall calculate both the sine and cosine of
<parameter>x</parameter>. 
The sine shall be stored in the location referenced by <parameter>sin</parameter>,
and the cosine in the location referenced by <parameter>cosine</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
None. See <function>sin</function> and <function>cos</function> for possible error conditions.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>cos</function></member>
<member><function>sin</function></member>
<member><function>sincos</function></member>
<member><function>sincosl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-sincosl"> <REFMETA>
<REFENTRYTITLE>sincosl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sincosl</REFNAME>
<REFPURPOSE>
trigonometric functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#define _GNU_SOURCE
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>void
<function>sincosl</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>
<paramdef>long double *
<parameter>sin</parameter>
</paramdef>
<paramdef>long double *
<parameter>cos</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>sincosl</FUNCTION> function shall calculate both the sine and cosine of
<parameter>x</parameter>. 
The sine shall be stored in the location referenced by <parameter>sin</parameter>,
and the cosine in the location referenced by <parameter>cosine</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
None. See <function>sin</function> and <function>cos</function> for possible error conditions.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>cos</function></member>
<member><function>sin</function></member>
<member><function>sincos</function></member>
<member><function>sincosl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-y0f"> <REFMETA>
<REFENTRYTITLE>y0f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>y0f</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>y0f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>y0f</FUNCTION> function is identical to <function>y0</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>y0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-y0l"> <REFMETA>
<REFENTRYTITLE>y0l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>y0l</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>y0l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>y0l</FUNCTION> function is identical to <function>y0</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>y0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-y1f"> <REFMETA>
<REFENTRYTITLE>y1f</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>y1f</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>y1f</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>y1f</FUNCTION> function is identical to <function>y1</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>y1</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-y1l"> <REFMETA>
<REFENTRYTITLE>y1l</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>y1l</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>y1l</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>y1l</FUNCTION> function is identical to <function>y1</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>j0</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-ynf"> <REFMETA>
<REFENTRYTITLE>ynf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ynf</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>float
<function>ynf</function>
</funcdef>
<paramdef>float
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>ynf</FUNCTION> function is identical to <function>yn</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>float</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>yn</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynl</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-ynl"> <REFMETA>
<REFENTRYTITLE>ynl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ynl</REFNAME>
<REFPURPOSE>
Bessel functions
</REFPURPOSE>
</REFNAMEDIV>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;math.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>long double
<function>ynl</function>
</funcdef>
<paramdef>long double
<parameter>x</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>ynl</FUNCTION> function is identical to <function>yn</function>, except that
the argument <parameter>x</parameter> and the return value
is a <type>long double</type>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Returns</TITLE>
<PARA>
See <function>yn</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>See Also</TITLE>
<PARA>
<simplelist type=inline>
<member><function>j0</function></member>
<member><function>j0f</function></member>
<member><function>j0l</function></member>
<member><function>j1</function></member>
<member><function>j1f</function></member>
<member><function>j1l</function></member>
<member><function>jn</function></member>
<member><function>jnf</function></member>
<member><function>jnl</function></member>
<member><function>y0</function></member>
<member><function>y0f</function></member>
<member><function>y0l</function></member>
<member><function>y1</function></member>
<member><function>y1f</function></member>
<member><function>y1l</function></member>
<member><function>yn</function></member>
<member><function>ynf</function></member>
</simplelist>
</PARA>
</REFSECT1>
</REFENTRY>

</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libpthread>
<TITLE>Interfaces for libpthread</TITLE>
<PARA>
<XREF LINKEND="lib-libpthread-def"> defines the library name and shared object name
for the libpthread library
</PARA>
<TABLE id="lib-libpthread-def">
<TITLE>libpthread Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libpthread</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libpthread.so.0</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libpthread.1'>
[LFS] <XREF LINKEND="std.LFS">
</MEMBER>
<MEMBER ID='REFSTD.libpthread.2'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
<MEMBER ID='REFSTD.libpthread.3'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
<MEMBER ID='REFSTD.libpthread.4'>
[SUSv4] <XREF LINKEND="std.SUSv4">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Realtime Threads -->
<SECT2>
<!--libgroup-->
<TITLE>Realtime Threads</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Realtime Threads</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Realtime Threads specified in <XREF linkend="tbl-libpthread-realt-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libpthread-realt-ints">
<TITLE>libpthread - Realtime Threads Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_getinheritsched</primary></indexterm>pthread_attr_getinheritsched <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getschedpolicy</primary></indexterm>pthread_attr_getschedpolicy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getscope</primary></indexterm>pthread_attr_getscope <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setinheritsched</primary></indexterm>pthread_attr_setinheritsched <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_setschedpolicy</primary></indexterm>pthread_attr_setschedpolicy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setscope</primary></indexterm>pthread_attr_setscope <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_getschedparam</primary></indexterm>pthread_getschedparam <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_getprioceiling</primary></indexterm>pthread_mutex_getprioceiling(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_mutex_setprioceiling</primary></indexterm>pthread_mutex_setprioceiling(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_getprioceiling</primary></indexterm>pthread_mutexattr_getprioceiling(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_getprotocol</primary></indexterm>pthread_mutexattr_getprotocol(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_setprioceiling</primary></indexterm>pthread_mutexattr_setprioceiling(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_mutexattr_setprotocol</primary></indexterm>pthread_mutexattr_setprotocol(GLIBC_2.4) <LINK LINKEND="REFSTD.libpthread.4">[SUSv4]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_setschedparam</primary></indexterm>pthread_setschedparam <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_setschedprio</primary></indexterm>pthread_setschedprio(GLIBC_2.3.4) <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Advanced Realtime Threads -->
<SECT2>
<!--libgroup-->
<TITLE>Advanced Realtime Threads</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Advanced Realtime Threads</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Advanced Realtime Threads specified in <XREF linkend="tbl-libpthread-advan-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libpthread-advan-ints">
<TITLE>libpthread - Advanced Realtime Threads Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>pthread_barrier_destroy</primary></indexterm>pthread_barrier_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_barrier_init</primary></indexterm>pthread_barrier_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_barrier_wait</primary></indexterm>pthread_barrier_wait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_barrierattr_destroy</primary></indexterm>pthread_barrierattr_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_barrierattr_getpshared</primary></indexterm>pthread_barrierattr_getpshared(GLIBC_2.3.3) <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_barrierattr_init</primary></indexterm>pthread_barrierattr_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_barrierattr_setpshared</primary></indexterm>pthread_barrierattr_setpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_getcpuclockid</primary></indexterm>pthread_getcpuclockid <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_spin_destroy</primary></indexterm>pthread_spin_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_spin_init</primary></indexterm>pthread_spin_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_spin_lock</primary></indexterm>pthread_spin_lock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_spin_trylock</primary></indexterm>pthread_spin_trylock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_spin_unlock</primary></indexterm>pthread_spin_unlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Posix Threads -->
<SECT2>
<!--libgroup-->
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Posix Threads</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Posix Threads specified in <XREF linkend="tbl-libpthread-posix-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libpthread-posix-ints">
<TITLE>libpthread - Posix Threads Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>_pthread_cleanup_pop</primary></indexterm>_pthread_cleanup_pop <LINK LINKEND="REFSTD.libpthread.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>_pthread_cleanup_push</primary></indexterm>_pthread_cleanup_push <LINK LINKEND="REFSTD.libpthread.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_destroy</primary></indexterm>pthread_attr_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getdetachstate</primary></indexterm>pthread_attr_getdetachstate <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_getguardsize</primary></indexterm>pthread_attr_getguardsize <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getschedparam</primary></indexterm>pthread_attr_getschedparam <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getstack</primary></indexterm>pthread_attr_getstack <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_getstackaddr</primary></indexterm>pthread_attr_getstackaddr <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_getstacksize</primary></indexterm>pthread_attr_getstacksize <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_init</primary></indexterm>pthread_attr_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setdetachstate</primary></indexterm>pthread_attr_setdetachstate <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setguardsize</primary></indexterm>pthread_attr_setguardsize <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_setschedparam</primary></indexterm>pthread_attr_setschedparam <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setstack</primary></indexterm>pthread_attr_setstack <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setstackaddr</primary></indexterm>pthread_attr_setstackaddr <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setstacksize</primary></indexterm>pthread_attr_setstacksize <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_cancel</primary></indexterm>pthread_cancel <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_cond_broadcast</primary></indexterm>pthread_cond_broadcast <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_cond_destroy</primary></indexterm>pthread_cond_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_cond_init</primary></indexterm>pthread_cond_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_cond_signal</primary></indexterm>pthread_cond_signal <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_cond_timedwait</primary></indexterm>pthread_cond_timedwait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_cond_wait</primary></indexterm>pthread_cond_wait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_condattr_destroy</primary></indexterm>pthread_condattr_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_condattr_getpshared</primary></indexterm>pthread_condattr_getpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_condattr_init</primary></indexterm>pthread_condattr_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_condattr_setpshared</primary></indexterm>pthread_condattr_setpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_create</primary></indexterm>pthread_create <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_detach</primary></indexterm>pthread_detach <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_equal</primary></indexterm>pthread_equal <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_exit</primary></indexterm>pthread_exit <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_getconcurrency</primary></indexterm>pthread_getconcurrency <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_getspecific</primary></indexterm>pthread_getspecific <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_join</primary></indexterm>pthread_join <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_key_create</primary></indexterm>pthread_key_create <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_key_delete</primary></indexterm>pthread_key_delete <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_kill</primary></indexterm>pthread_kill <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_destroy</primary></indexterm>pthread_mutex_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_init</primary></indexterm>pthread_mutex_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_lock</primary></indexterm>pthread_mutex_lock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_mutex_timedlock</primary></indexterm>pthread_mutex_timedlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_trylock</primary></indexterm>pthread_mutex_trylock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutex_unlock</primary></indexterm>pthread_mutex_unlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_destroy</primary></indexterm>pthread_mutexattr_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_mutexattr_getpshared</primary></indexterm>pthread_mutexattr_getpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_gettype</primary></indexterm>pthread_mutexattr_gettype <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_init</primary></indexterm>pthread_mutexattr_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_mutexattr_setpshared</primary></indexterm>pthread_mutexattr_setpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_mutexattr_settype</primary></indexterm>pthread_mutexattr_settype <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_once</primary></indexterm>pthread_once <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_destroy</primary></indexterm>pthread_rwlock_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_init</primary></indexterm>pthread_rwlock_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_rwlock_rdlock</primary></indexterm>pthread_rwlock_rdlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_timedrdlock</primary></indexterm>pthread_rwlock_timedrdlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_timedwrlock</primary></indexterm>pthread_rwlock_timedwrlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_tryrdlock</primary></indexterm>pthread_rwlock_tryrdlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_rwlock_trywrlock</primary></indexterm>pthread_rwlock_trywrlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_unlock</primary></indexterm>pthread_rwlock_unlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlock_wrlock</primary></indexterm>pthread_rwlock_wrlock <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlockattr_destroy</primary></indexterm>pthread_rwlockattr_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_rwlockattr_getpshared</primary></indexterm>pthread_rwlockattr_getpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlockattr_init</primary></indexterm>pthread_rwlockattr_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_rwlockattr_setpshared</primary></indexterm>pthread_rwlockattr_setpshared <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_self</primary></indexterm>pthread_self <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_setcancelstate</primary></indexterm>pthread_setcancelstate <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_setcanceltype</primary></indexterm>pthread_setcanceltype <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_setconcurrency</primary></indexterm>pthread_setconcurrency <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_setspecific</primary></indexterm>pthread_setspecific <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pthread_sigmask</primary></indexterm>pthread_sigmask <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_testcancel</primary></indexterm>pthread_testcancel <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_close</primary></indexterm>sem_close <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_destroy</primary></indexterm>sem_destroy <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sem_getvalue</primary></indexterm>sem_getvalue <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_init</primary></indexterm>sem_init <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_open</primary></indexterm>sem_open <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_post</primary></indexterm>sem_post <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>sem_timedwait</primary></indexterm>sem_timedwait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_trywait</primary></indexterm>sem_trywait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_unlink</primary></indexterm>sem_unlink <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>sem_wait</primary></indexterm>sem_wait <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Posix Threads specified in <XREF linkend="tbl-libpthread-posix-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libpthread-posix-depints">
<TITLE>libpthread - Posix Threads Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>pthread_attr_getstackaddr</primary></indexterm>pthread_attr_getstackaddr <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pthread_attr_setstackaddr</primary></indexterm>pthread_attr_setstackaddr <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Thread aware versions of libc interfaces -->
<SECT2>
<!--libgroup-->
<TITLE>Thread aware versions of libc interfaces</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Thread aware versions of libc interfaces</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Thread aware versions of libc interfaces specified in <XREF linkend="tbl-libpthread-threa-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libpthread-threa-ints">
<TITLE>libpthread - Thread aware versions of libc interfaces Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>lseek64</primary></indexterm>lseek64 <LINK LINKEND="REFSTD.libpthread.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>open64</primary></indexterm>open64 <LINK LINKEND="REFSTD.libpthread.1">[LFS]</LINK></ENTRY>
<ENTRY><indexterm><primary>pread</primary></indexterm>pread <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pread64</primary></indexterm>pread64 <LINK LINKEND="REFSTD.libpthread.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pwrite</primary></indexterm>pwrite <LINK LINKEND="REFSTD.libpthread.3">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>pwrite64</primary></indexterm>pwrite64 <LINK LINKEND="REFSTD.libpthread.2">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE>Data Definitions for libpthread</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libpthread.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>pthread.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define PTHREAD_MUTEX_DEFAULT	0
#define PTHREAD_MUTEX_NORMAL	0
#define PTHREAD_SCOPE_SYSTEM	0
#define PTHREAD_MUTEX_RECURSIVE	1
#define PTHREAD_SCOPE_PROCESS	1
#define PTHREAD_MUTEX_ERRORCHECK	2
#define PTHREAD_RWLOCK_DEFAULT_NP	2
#define __SIZEOF_PTHREAD_BARRIERATTR_T	4
#define __SIZEOF_PTHREAD_CONDATTR_T	4
#define __SIZEOF_PTHREAD_MUTEXATTR_T	4
#define __SIZEOF_PTHREAD_COND_T	48
#define __SIZEOF_PTHREAD_RWLOCKATTR_T	8
#define pthread_cleanup_push(routine,arg)	\
        {struct _pthread_cleanup_buffer _buffer;\
        _pthread_cleanup_push(&amp;_buffer,(routine),(arg));
#define pthread_cleanup_pop(execute)	_pthread_cleanup_pop(&amp;_buffer,(execute));}
#define PTHREAD_COND_INITIALIZER	{ { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }

struct _pthread_cleanup_buffer {
    void (*__routine) (void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
    int __align;
} pthread_barrierattr_t;

typedef unsigned long int pthread_t;

typedef union {
    struct __pthread_mutex_s __data;
    char __size[__SIZEOF_PTHREAD_MUTEX_T];
    long int __align;
} pthread_mutex_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
    int __align;
} pthread_mutexattr_t;

typedef union {
    char __size[__SIZEOF_PTHREAD_ATTR_T];
    long int __align;
} pthread_attr_t;

typedef union {
    struct {
	int __lock;
	unsigned int __futex;
	unsigned long long int __total_seq;
	unsigned long long int __wakeup_seq;
	unsigned long long int __woken_seq;
	void *__mutex;
	unsigned int __nwaiters;
	unsigned int __broadcast_seq;
    } __data;
    char __size[__SIZEOF_PTHREAD_COND_T];
    long long int __align;
} pthread_cond_t;
typedef union {
    char __size[__SIZEOF_PTHREAD_CONDATTR_T];
    int __align;
} pthread_condattr_t;

typedef union {
    char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
    long int __align;
} pthread_rwlockattr_t;

#define PTHREAD_CREATE_JOINABLE	0
#define PTHREAD_INHERIT_SCHED	0
#define PTHREAD_ONCE_INIT	0
#define PTHREAD_PROCESS_PRIVATE	0
#define PTHREAD_CREATE_DETACHED	1
#define PTHREAD_EXPLICIT_SCHED	1
#define PTHREAD_PROCESS_SHARED	1

#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_DEFERRED	0
#define PTHREAD_CANCEL_ENABLE	0
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
#define PTHREAD_CANCEL_DISABLE	1

extern int pthread_barrier_destroy(pthread_barrier_t *);
extern int pthread_barrier_init(pthread_barrier_t *,
				const pthread_barrierattr_t *,
				unsigned int);
extern int pthread_barrier_wait(pthread_barrier_t *);
extern int pthread_barrierattr_destroy(pthread_barrierattr_t *);
extern int pthread_barrierattr_init(pthread_barrierattr_t *);
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
extern int pthread_getcpuclockid(pthread_t, clockid_t *);
extern int pthread_spin_destroy(pthread_spinlock_t *);
extern int pthread_spin_init(pthread_spinlock_t *, int);
extern int pthread_spin_lock(pthread_spinlock_t *);
extern int pthread_spin_trylock(pthread_spinlock_t *);
extern int pthread_spin_unlock(pthread_spinlock_t *);
extern int pthread_mutex_timedlock(pthread_mutex_t *,
				   const struct timespec *);
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *,
					  int *);
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,
					    int *);
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,
					 int *);
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *, int *);
extern int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);
extern void _pthread_cleanup_pop(struct _pthread_cleanup_buffer *, int);
extern void _pthread_cleanup_push(struct _pthread_cleanup_buffer *,
				  void (*)(void *)
				  , void *);
extern int pthread_attr_destroy(pthread_attr_t *);
extern int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
extern int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
extern int pthread_attr_getschedparam(const pthread_attr_t *,
				      struct sched_param *);
extern int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
extern int pthread_attr_getscope(const pthread_attr_t *, int *);
extern int pthread_attr_init(pthread_attr_t *);
extern int pthread_attr_setdetachstate(pthread_attr_t *, int);
extern int pthread_attr_setinheritsched(pthread_attr_t *, int);
extern int pthread_attr_setschedparam(pthread_attr_t *,
				      const struct sched_param *);
extern int pthread_attr_setschedpolicy(pthread_attr_t *, int);
extern int pthread_attr_setscope(pthread_attr_t *, int);
extern int pthread_cancel(pthread_t);
extern int pthread_cond_broadcast(pthread_cond_t *);
extern int pthread_cond_destroy(pthread_cond_t *);
extern int pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
extern int pthread_cond_signal(pthread_cond_t *);
extern int pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *,
				  const struct timespec *);
extern int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
extern int pthread_condattr_destroy(pthread_condattr_t *);
extern int pthread_condattr_init(pthread_condattr_t *);
extern int pthread_create(pthread_t *, const pthread_attr_t *,
			  void *(*)(void *p1)
			  , void *);
extern int pthread_detach(pthread_t);
extern int pthread_equal(pthread_t, pthread_t);
extern void pthread_exit(void *);
extern int pthread_getschedparam(pthread_t, int *, struct sched_param *);
extern void *pthread_getspecific(pthread_key_t);
extern int pthread_join(pthread_t, void **);
extern int pthread_key_create(pthread_key_t *, void (*)(void *)
    );
extern int pthread_key_delete(pthread_key_t);
extern int pthread_mutex_destroy(pthread_mutex_t *);
extern int pthread_mutex_init(pthread_mutex_t *,
			      const pthread_mutexattr_t *);
extern int pthread_mutex_lock(pthread_mutex_t *);
extern int pthread_mutex_trylock(pthread_mutex_t *);
extern int pthread_mutex_unlock(pthread_mutex_t *);
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *);
extern int pthread_mutexattr_init(pthread_mutexattr_t *);
extern int pthread_once(pthread_once_t *, void (*)(void)
    );
extern int pthread_rwlock_destroy(pthread_rwlock_t *);
extern int pthread_rwlock_init(pthread_rwlock_t *,
			       const pthread_rwlockattr_t *);
extern int pthread_rwlock_rdlock(pthread_rwlock_t *);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *);
extern int pthread_rwlock_unlock(pthread_rwlock_t *);
extern int pthread_rwlock_wrlock(pthread_rwlock_t *);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
					 int *);
extern int pthread_rwlockattr_init(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
extern pthread_t pthread_self(void);
extern int pthread_setcancelstate(int, int *);
extern int pthread_setcanceltype(int, int *);
extern int pthread_setschedparam(pthread_t, int,
				 const struct sched_param *);
extern int pthread_setspecific(pthread_key_t, const void *);
extern void pthread_testcancel(void);
extern int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
extern int pthread_attr_setguardsize(pthread_attr_t *, size_t);
extern int pthread_attr_setstackaddr(pthread_attr_t *, void *);
extern int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
extern int pthread_attr_setstacksize(pthread_attr_t *, size_t);
extern int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
extern int pthread_getconcurrency(void);
extern int pthread_setconcurrency(int);
extern int pthread_attr_getstack(const pthread_attr_t *, void **,
				 size_t *);
extern int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
extern int pthread_condattr_getpshared(const pthread_condattr_t *, int *);
extern int pthread_condattr_setpshared(pthread_condattr_t *, int);
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
					int *);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *,
				      const struct timespec *);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *,
				      const struct timespec *);
extern int __register_atfork(void (*)(void)
			     , void (*)(void)
			     , void (*)(void)
			     , void *);
extern int pthread_setschedprio(pthread_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef union {
    char __size[__SIZEOF_SEM_T];
    long int __align;
} sem_t;

#define SEM_FAILED	((sem_t*)0)

#define SEM_VALUE_MAX	((int)((~0u)>>1))

extern int sem_close(sem_t *);
extern int sem_destroy(sem_t *);
extern int sem_getvalue(sem_t *, int *);
extern int sem_init(sem_t *, int, unsigned int);
extern sem_t *sem_open(const char *, int, ...);
extern int sem_post(sem_t *);
extern int sem_trywait(sem_t *);
extern int sem_unlink(const char *);
extern int sem_wait(sem_t *);
extern int sem_timedwait(sem_t *, const struct timespec *);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libpthreadman>
<TITLE>Interface Definitions for libpthread</TITLE>
<PARA>
The interfaces defined on the following pages are included in libpthread and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libpthread> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="baselib--pthread-cleanup-pop"> <REFMETA>
<REFENTRYTITLE>_pthread_cleanup_pop</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_pthread_cleanup_pop</REFNAME>
<REFPURPOSE>
establish cancellation handlers
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pthread.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>_pthread_cleanup_pop</FUNCTION></FUNCDEF>
 <PARAMDEF>struct _pthread_cleanup_buffer *</PARAMDEF>
 <PARAMDEF>int</PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>_pthread_cleanup_pop</FUNCTION> function provides
an implementation of the <function>pthread_cleanup_pop</function> macro
described in
<CITETITLE PUBWORK="BOOK"><XREF LINKEND="STD.SUSv3"></CITETITLE>.
</PARA>
<PARA>
The <function>_pthread_cleanup_pop</function> function is not in the
source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--pthread-cleanup-push"> <REFMETA>
<REFENTRYTITLE>_pthread_cleanup_push</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_pthread_cleanup_push</REFNAME>
<REFPURPOSE>
establish cancellation handlers
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pthread.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>void 
  <FUNCTION>_pthread_cleanup_push</FUNCTION></FUNCDEF>
 <PARAMDEF>struct _pthread_cleanup_buffer *</PARAMDEF>
 <PARAMDEF>void (*) (void *)</PARAMDEF>
 <PARAMDEF>void *</PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>_pthread_cleanup_push</FUNCTION> function provides
an implementation of the <function>pthread_cleanup_push</function> macro
described in
<CITETITLE PUBWORK="BOOK"><XREF LINKEND="STD.SUSv3"></CITETITLE>.
</PARA>
<PARA>
The <function>_pthread_cleanup_push</function> function is not in the
source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-pread64"> <REFMETA> <REFENTRYTITLE>pread64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pread64</REFNAME>
<REFPURPOSE>
read from a file (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>19 June 2008</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>ssize_t 
  <FUNCTION>pread64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>void *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>count</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>off64_t 
  <PARAMETER><REPLACEABLE>offset</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>19 June 2008</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pread64</FUNCTION> shall read <PARAMETER>count</PARAMETER> 
bytes into <PARAMETER>buf</PARAMETER> from the file associated with the
open file descriptor <PARAMETER>fd</PARAMETER>, at the 
position specified by <PARAMETER>offset</PARAMETER>, without changing 
the file position.
</PARA>
<PARA>
<FUNCTION>pread64</FUNCTION> is a large-file version of
the <FUNCTION>pread</FUNCTION> function as defined in
<XREF LINKEND=STD.SUSv3>.
It differs from <function>pread</function>
in that the <parameter>offset</parameter> parameter is an
<type>off64_t</type> instead of an <type>off_t</type>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <FUNCTION>pread64</FUNCTION> shall return the number 
of bytes actually read. Otherwise <function>pread64</function>
shall return <RETURNVALUE>-1</RETURNVALUE> and
set <VARNAME>errno</VARNAME> to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
See <function>pread</function> for possible error values.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-pwrite64"> <REFMETA>
<REFENTRYTITLE>pwrite64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>pwrite64</REFNAME>
<REFPURPOSE>
write on a file (Large File Support)
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;unistd.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>ssize_t 
  <FUNCTION>pwrite64</FUNCTION></FUNCDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>fd</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>buf</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>size_t 
  <PARAMETER><REPLACEABLE>count</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>off64_t 
  <PARAMETER><REPLACEABLE>offset</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pwrite64</FUNCTION> shall write <PARAMETER>count</PARAMETER> 
bytes from <PARAMETER>buf</PARAMETER> to the file associated with the
open file descriptor <PARAMETER>fd</PARAMETER>, at the 
position specified by <PARAMETER>offset</PARAMETER>, without changing 
the file position.
</PARA>
<PARA>
<FUNCTION>pwrite64</FUNCTION> is a large-file version of
the <FUNCTION>pwrite</FUNCTION> function as defined in
<XREF LINKEND=STD.SUSv3>.
It differs from <function>pwrite</function>
in that the <parameter>offset</parameter> parameter is an
<type>off64_t</type> instead of an <type>off_t</type>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <FUNCTION>pwrite64</FUNCTION> shall return the number 
of bytes actually written. Otherwise <function>pwrite</function>
shall return <RETURNVALUE>-1</RETURNVALUE> and
set <VARNAME>errno</VARNAME> to indicate the error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
See <function>pwrite</function> for possible error values.
</PARA>
</REFSECT1>
</REFENTRY>


</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libgcc-s>
<TITLE>Interfaces for libgcc_s</TITLE>
<PARA>
<XREF LINKEND="lib-libgcc-s-def"> defines the library name and shared object name
for the libgcc_s library
</PARA>
<TABLE id="lib-libgcc-s-def">
<TITLE>libgcc_s Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libgcc_s</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libgcc_s.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
</PARA>
<!-- debug: database interface name Unwind Library -->
<SECT2>
<!--libgroup-->
<TITLE>Unwind Library</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Unwind Library</TITLE>
<PARA>
No external functions are defined for libgcc_s - Unwind Library
in this part of the specification. See also the relevant architecture specific part of this specification.
</PARA>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libgcc-s-ddefs>
<TITLE>Data Definitions for libgcc_s</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libgcc_s.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>unwind.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef unsigned int _Unwind_Ptr __attribute__ ((__mode__(__pointer__)));
typedef unsigned int _Unwind_Word __attribute__ ((__mode__(__word__)));
typedef unsigned int _Unwind_Exception_Class
    __attribute__ ((__mode__(__DI__)));

typedef enum {
    _URC_NO_REASON = 0,
    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
    _URC_FATAL_PHASE2_ERROR = 2,
    _URC_FATAL_PHASE1_ERROR = 3,
    _URC_NORMAL_STOP = 4,
    _URC_END_OF_STACK = 5,
    _URC_HANDLER_FOUND = 6,
    _URC_INSTALL_CONTEXT = 7,
    _URC_CONTINUE_UNWIND = 8
} _Unwind_Reason_Code;

typedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,
					      struct _Unwind_Exception *);

struct _Unwind_Exception {
    _Unwind_Exception_Class exception_class;
    _Unwind_Exception_Cleanup_Fn exception_cleanup;
    _Unwind_Word private_1;
    _Unwind_Word private_2;
} __attribute__ ((__aligned__));

#define _UA_SEARCH_PHASE	1
#define _UA_END_OF_STACK	16
#define _UA_CLEANUP_PHASE	2
#define _UA_HANDLER_FRAME	4
#define _UA_FORCE_UNWIND	8

typedef int _Unwind_Action;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libdl>
<TITLE>Interfaces for libdl</TITLE>
<PARA>
<XREF LINKEND="lib-libdl-def"> defines the library name and shared object name
for the libdl library
</PARA>
<TABLE id="lib-libdl-def">
<TITLE>libdl Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libdl</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libdl.so.2</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libdl.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
<MEMBER ID='REFSTD.libdl.2'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Dynamic Loader -->
<SECT2>
<!--libgroup-->
<TITLE>Dynamic Loader</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Dynamic Loader</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Dynamic Loader specified in <XREF linkend="tbl-libdl-dynam-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libdl-dynam-ints">
<TITLE>libdl - Dynamic Loader Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>dladdr</primary></indexterm>dladdr <LINK LINKEND="REFSTD.libdl.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>dlclose</primary></indexterm>dlclose <LINK LINKEND="REFSTD.libdl.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>dlerror</primary></indexterm>dlerror <LINK LINKEND="REFSTD.libdl.2">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>dlopen</primary></indexterm>dlopen <LINK LINKEND="REFSTD.libdl.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>dlsym</primary></indexterm>dlsym <LINK LINKEND="REFSTD.libdl.1">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libdl-ddefs>
<TITLE>Data Definitions for libdl</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libdl.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>dlfcn.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define RTLD_NEXT	((void *) -1l)
#define RTLD_DEFAULT	((void *) 0)
#define RTLD_LOCAL	0
#define RTLD_LAZY	0x00001
#define RTLD_NOW	0x00002
#define RTLD_GLOBAL	0x00100

typedef struct {
    char *dli_fname;
    void *dli_fbase;
    char *dli_sname;
    void *dli_saddr;
} Dl_info;
extern int dladdr(const void *, Dl_info *);
extern int dlclose(void *);
extern char *dlerror(void);
extern void *dlopen(const char *, int);
extern void *dlsym(void *, const char *);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libdlman>
<TITLE>Interface Definitions for libdl</TITLE>
<PARA>
The interfaces defined on the following pages are included in libdl and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libdl> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="baselib-dladdr-3"> <REFMETA>
<REFENTRYTITLE>dladdr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dladdr
</REFNAME>
<REFPURPOSE>
find the shared object containing a given address
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dlfcn.h&gt;

typedef struct {
             const char  <STRUCTFIELD>*dli_fname</STRUCTFIELD>;
             void        <STRUCTFIELD>*dli_fbase</STRUCTFIELD>;
             const char  <STRUCTFIELD>*dli_sname</STRUCTFIELD>;
             void        <STRUCTFIELD>*dli_saddr</STRUCTFIELD>;
} <STRUCTNAME>Dl_info</STRUCTNAME>;
</SYNOPSIS>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>dladdr</FUNCTION></FUNCDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>addr</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>Dl_info *
  <PARAMETER>dlip</PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>dladdr</FUNCTION> function shall query the dynamic
linker for information about the shared object containing the 
address <PARAMETER>addr</PARAMETER>. The information shall be returned
in the user supplied data structure referenced by <PARAMETER>dlip</PARAMETER>.
</PARA>
<PARA>
The structure shall contain at least the following members:
<VARIABLELIST>
<VARLISTENTRY>
<TERM><structfield>dli_fname</structfield></TERM>
<LISTITEM><PARA>
The pathname of the shared object containing the address
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><structfield>dli_fbase</structfield></TERM>
<LISTITEM><PARA>
The base address at which the shared object is
mapped into the address space of the calling process.
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><structfield>dli_sname</structfield></TERM>
<LISTITEM><PARA>
The name of the nearest runtime symbol with  value
less than or equal to <PARAMETER>addr</PARAMETER>.
Where possible, the symbol name shall be returned as it
would appear in C source code.
</PARA><PARA>
If no symbol with a suitable value is found,
both this field and <structfield>dli_saddr</structfield>
shall be set to <LITERAL>NULL</LITERAL>.
</PARA></LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><structfield>dli_saddr</structfield></TERM>
<LISTITEM><PARA>
The address of the symbol returned in
<structfield>dli_sname</structfield>. This address has type 
"pointer to <replaceable>type</replaceable>", where
<replaceable>type</replaceable> is the type of the symbol
<structfield>dli_sname</structfield>.
<NOTE><TITLE>Example</TITLE><PARA>
If the symbol in <structfield>dli_sname</structfield> is a function,
then the type of <structfield>dli_saddr</structfield> is of type
"pointer to function".
</PARA></NOTE>
</PARA></LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>
<PARA>
The behavior of <function>dladdr</function> is only
specified in dynamically linked programs.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <function>dladdr</function> shall return non-zero, and
the structure referenced by <parameter>dlip</parameter> shall be filled in
as described. Otherwise, <function>dladdr</function> shall return zero,
and the cause of the error can be fetched with <function>dlerror</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>
See <function>dlerror</function>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
Environment
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
<LITERAL>LD_LIBRARY_PATH</LITERAL>
</TERM>
<LISTITEM>
<PARA>
directory search-path for object files
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--      BSDI BSD/OS                    February 9, 1998    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<refentry id="baselib-dlopen-1"> <refmeta>
<refentrytitle>dlopen</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>
<refnamediv>
<refname>dlopen
</refname>
<refpurpose>open dynamic object
</refpurpose>
<indexterm id="ix-baselib-dlopen-1"><primary>dlopen</primary></indexterm>
</refnamediv>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 July  2004</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dlfcn.h&gt;
</SYNOPSIS>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>void * 
  <FUNCTION>dlopen</FUNCTION></FUNCDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>filename</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int
  <PARAMETER><REPLACEABLE>flag</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<refsect1>
<title>Description</title>

<para>
The <function>dlopen</function> function shall behave as specified in 
<XREF LINKEND="STD.SUSv3">, but with additional behaviors listed below.
</para>

<para>
If the file argument does not contain a slash character, then the
system shall look for a library of that name in at least the following
directories, and use the first one which is found:

<itemizedlist>

<listitem><para>The directories specified by the 
<CONSTANT>DT_RPATH</CONSTANT> dynamic entry.
</para></listitem>

<listitem><para>The directories specified in the 
<constant>LD_LIBRARY_PATH</constant>
environment variable (which is a colon separated list of pathnames).
This step shall be skipped for setuid
and setgid executables.</para></listitem>

<listitem><para>A set of directories sufficient to contain the
libraries specified in this standard.

<note><para>Traditionally, <filename>/lib</filename> and
<filename>/usr/lib</filename>.  This case would also cover cases in
which the system used the mechanism of
<filename>/etc/ld.so.conf</filename> and
<filename>/etc/ld.so.cache</filename> to provide access.
</para>

<para>Example: An application which is not linked against libm may
choose to dlopen libm.</para></note>

</para></listitem>

</itemizedlist>

</para>

</refsect1>
</refentry>

<refentry id="baselib-dlsym-1">

<refmeta>
<refentrytitle>dlsym</refentrytitle>
<refmiscinfo>Base Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>dlsym</refname>
<refpurpose>obtain the address of a symbol from a dlopen object</refpurpose>
<indexterm id="ix-baselib-dlsym-1">
  <primary>dlsym</primary></indexterm>
</refnamediv>

<refsect1>
<title>Description</title>

<para>
<function>dlsym</function> is as specified in the
<XREF LINKEND="std.SUSv3">, but with differences as listed below.
</para>

<refsect2>
<title>RTLD_NEXT, RTLD_DEFAULT Required</title>
<para>
The values <constant>RTLD_NEXT</constant> and
<constant>RTLD_DEFAULT</constant>, described as
reserved for future use in <XREF LINKEND="std.SUSv3">,
are required, with behavior as described in <XREF LINKEND="std.SUSv3">.
</para>
</refsect2>

</refsect1>
</refentry>

</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=librt>
<TITLE>Interfaces for librt</TITLE>
<PARA>
<XREF LINKEND="lib-librt-def"> defines the library name and shared object name
for the librt library
</PARA>
<TABLE id="lib-librt-def">
<TITLE>librt Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>librt</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>librt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.librt.1'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Shared Memory Objects -->
<SECT2>
<!--libgroup-->
<TITLE>Shared Memory Objects</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Shared Memory Objects</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Shared Memory Objects specified in <XREF linkend="tbl-librt-share-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-librt-share-ints">
<TITLE>librt - Shared Memory Objects Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>shm_open</primary></indexterm>shm_open <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>shm_unlink</primary></indexterm>shm_unlink <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Clock -->
<SECT2>
<!--libgroup-->
<TITLE>Clock</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Clock</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Clock specified in <XREF linkend="tbl-librt-clock-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-librt-clock-ints">
<TITLE>librt - Clock Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>clock_getcpuclockid</primary></indexterm>clock_getcpuclockid <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clock_getres</primary></indexterm>clock_getres <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clock_gettime</primary></indexterm>clock_gettime <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>clock_nanosleep</primary></indexterm>clock_nanosleep <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clock_settime</primary></indexterm>clock_settime <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Timers -->
<SECT2>
<!--libgroup-->
<TITLE>Timers</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Timers</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Timers specified in <XREF linkend="tbl-librt-timer-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-librt-timer-ints">
<TITLE>librt - Timers Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>timer_create</primary></indexterm>timer_create <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>timer_delete</primary></indexterm>timer_delete <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>timer_getoverrun</primary></indexterm>timer_getoverrun <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>timer_gettime</primary></indexterm>timer_gettime <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>timer_settime</primary></indexterm>timer_settime <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
<!-- debug: database interface name Message Queues -->
<SECT2>
<!--libgroup-->
<TITLE>Message Queues</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Message Queues</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Message Queues specified in <XREF linkend="tbl-librt-messa-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-librt-messa-ints">
<TITLE>librt - Message Queues Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>mq_close</primary></indexterm>mq_close(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_getattr</primary></indexterm>mq_getattr(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_notify</primary></indexterm>mq_notify(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_open</primary></indexterm>mq_open(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mq_receive</primary></indexterm>mq_receive(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_send</primary></indexterm>mq_send(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_setattr</primary></indexterm>mq_setattr(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_timedreceive</primary></indexterm>mq_timedreceive(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mq_timedsend</primary></indexterm>mq_timedsend(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>mq_unlink</primary></indexterm>mq_unlink(GLIBC_2.3.4) <LINK LINKEND="REFSTD.librt.1">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=librt-ddefs>
<TITLE>Data Definitions for librt</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in librt.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>mqueue.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef int mqd_t;
struct mq_attr {
    long int mq_flags;
    long int mq_maxmsg;
    long int mq_msgsize;
    long int mq_curmsgs;
    long int __pad[4];
};
extern int mq_close(mqd_t);
extern int mq_getattr(mqd_t, struct mq_attr *);
extern int mq_notify(mqd_t, const struct sigevent *);
extern mqd_t mq_open(const char *, int, ...);
extern ssize_t mq_receive(mqd_t, char *, size_t, unsigned int *);
extern int mq_send(mqd_t, const char *, size_t, unsigned int);
extern int mq_setattr(mqd_t, const struct mq_attr *, struct mq_attr *);
extern ssize_t mq_timedreceive(mqd_t, char *, size_t, unsigned int *,
			       const struct timespec *);
extern int mq_timedsend(mqd_t, const char *, size_t, unsigned int,
			const struct timespec *);
extern int mq_unlink(const char *);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libcrypt>
<TITLE>Interfaces for libcrypt</TITLE>
<PARA>
<XREF LINKEND="lib-libcrypt-def"> defines the library name and shared object name
for the libcrypt library
</PARA>
<TABLE id="lib-libcrypt-def">
<TITLE>libcrypt Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libcrypt</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libcrypt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libcrypt.1'>
[SUSv3] <XREF LINKEND="std.SUSv3">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Encryption -->
<SECT2>
<!--libgroup-->
<TITLE>Encryption</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Encryption</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Encryption specified in <XREF linkend="tbl-libcrypt-encry-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libcrypt-encry-ints">
<TITLE>libcrypt - Encryption Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>crypt</primary></indexterm>crypt <LINK LINKEND="REFSTD.libcrypt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>encrypt</primary></indexterm>encrypt <LINK LINKEND="REFSTD.libcrypt.1">[SUSv3]</LINK></ENTRY>
<ENTRY><indexterm><primary>setkey</primary></indexterm>setkey <LINK LINKEND="REFSTD.libcrypt.1">[SUSv3]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<!-- empty header file All/crypt.h -->
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libpam>
<TITLE>Interfaces for libpam</TITLE>
<PARA>
<XREF LINKEND="lib-libpam-def"> defines the library name and shared object name
for the libpam library
</PARA>
<TABLE id="lib-libpam-def">
<TITLE>libpam Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libpam</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libpam.so.0</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The Pluggable Authentication Module (PAM) interfaces allow
applications to request authentication via a system administrator
defined mechanism, known as a <FIRSTTERM>service</FIRSTTERM>.
</PARA>
<PARA>
A single service name, <VARNAME>other</VARNAME>, shall always be present.
The behavior of this service shall be determined by the system administrator.
Additional service names may also exist.
<NOTE>
<PARA>
Future versions of this specification might define additional
service names.
</PARA>
</NOTE>
</PARA>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libpam.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Pluggable Authentication API -->
<SECT2>
<!--libgroup-->
<TITLE>Pluggable Authentication API</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Pluggable Authentication API</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Pluggable Authentication API specified in <XREF linkend="tbl-libpam-plugg-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libpam-plugg-ints">
<TITLE>libpam - Pluggable Authentication API Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>pam_acct_mgmt</primary></indexterm>pam_acct_mgmt <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_authenticate</primary></indexterm>pam_authenticate <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_chauthtok</primary></indexterm>pam_chauthtok <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_close_session</primary></indexterm>pam_close_session <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pam_end</primary></indexterm>pam_end <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_fail_delay</primary></indexterm>pam_fail_delay <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_get_item</primary></indexterm>pam_get_item <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_getenv</primary></indexterm>pam_getenv <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pam_getenvlist</primary></indexterm>pam_getenvlist <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_open_session</primary></indexterm>pam_open_session <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_putenv</primary></indexterm>pam_putenv <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_set_item</primary></indexterm>pam_set_item <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pam_setcred</primary></indexterm>pam_setcred <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_start</primary></indexterm>pam_start <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pam_strerror</primary></indexterm>pam_strerror <LINK LINKEND="REFSTD.libpam.1">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libpam-ddefs>
<TITLE>Data Definitions for libpam</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libpam.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>security/pam_appl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef struct pam_handle pam_handle_t;
struct pam_message {
    int msg_style;
    const char *msg;
};
struct pam_response {
    char *resp;
    int resp_retcode;
};

struct pam_conv {
    int (*conv) (int num_msg, const struct pam_message * *msg,
		 struct pam_response * *resp, void *appdata_ptr);
    void *appdata_ptr;
};

#define PAM_PROMPT_ECHO_OFF	1
#define PAM_PROMPT_ECHO_ON	2
#define PAM_ERROR_MSG	3
#define PAM_TEXT_INFO	4

#define PAM_SERVICE	1	/* The service name */
#define PAM_USER	2	/* The user name */
#define PAM_TTY	3		/* The tty name */
#define PAM_RHOST	4	/* The remote host name */
#define PAM_CONV	5	/* The pam_conv structure */
#define PAM_RUSER	8	/* The remote user name */
#define PAM_USER_PROMPT	9	/* the prompt for getting a username */

#define PAM_SUCCESS	0	/* Successful function return */
#define PAM_OPEN_ERR	1	/* dlopen() failure */
#define PAM_USER_UNKNOWN	10	/* User not known to the underlying authenticaiton module */
#define PAM_MAXTRIES	11	/* An authentication service has maintained a retry count which */
#define PAM_NEW_AUTHTOK_REQD	12	/* New authentication token required */
#define PAM_ACCT_EXPIRED	13	/* User account has expired */
#define PAM_SESSION_ERR	14	/* Can not make/remove an entry for  the specified session */
#define PAM_CRED_UNAVAIL	15	/* Underlying authentication service can not retrieve user cred */
#define PAM_CRED_EXPIRED	16	/* User credentials expired */
#define PAM_CRED_ERR	17	/* Failure setting user credentials */
#define PAM_CONV_ERR	19	/* Conversation error */
#define PAM_SYMBOL_ERR	2	/* Symbol not found */
#define PAM_AUTHTOK_ERR	20	/* Authentication token manipulation error */
#define PAM_AUTHTOK_RECOVER_ERR	21	/* Authentication information cannot be recovered */
#define PAM_AUTHTOK_LOCK_BUSY	22	/* Authentication token lock busy */
#define PAM_AUTHTOK_DISABLE_AGING	23	/* Authentication token aging disabled */
#define PAM_TRY_AGAIN	24	/* Preliminary check by password service */
#define PAM_ABORT	26	/* Critical error (?module fail now request) */
#define PAM_AUTHTOK_EXPIRED	27	/* user's authentication token has expired */
#define PAM_BAD_ITEM	29	/* Bad item passed to pam_*_item() */
#define PAM_SERVICE_ERR	3	/* Error in service module */
#define PAM_SYSTEM_ERR	4	/* System error */
#define PAM_BUF_ERR	5	/* Memory buffer error */
#define PAM_PERM_DENIED	6	/* Permission denied */
#define PAM_AUTH_ERR	7	/* Authentication failure */
#define PAM_CRED_INSUFFICIENT	8	/* Can not access authentication data due to insufficient crede */
#define PAM_AUTHINFO_UNAVAIL	9	/* Underlying authentication service can not retrieve authentic */

#define PAM_DISALLOW_NULL_AUTHTOK	0x0001U
#define PAM_ESTABLISH_CRED	0x0002U	/* Set user credentials for an authentication service */
#define PAM_DELETE_CRED	0x0004U	/* Delete user credentials associated with an authentication se */
#define PAM_REINITIALIZE_CRED	0x0008U	/* Reinitialize user credentials */
#define PAM_REFRESH_CRED	0x0010U	/* Extend lifetime of user credentials */
#define PAM_CHANGE_EXPIRED_AUTHTOK	0x0020U	/* Extend lifetime of user credentials */
#define PAM_SILENT	0x8000U	/* Authentication service should not generate any messages */

extern int pam_set_item(pam_handle_t *, int, const void *);
extern int pam_get_item(const pam_handle_t *, int, const void **);
extern const char *pam_strerror(pam_handle_t *, int);
extern char **pam_getenvlist(pam_handle_t *);
extern int pam_fail_delay(pam_handle_t *, unsigned int);
extern int pam_start(const char *, const char *, const struct pam_conv *,
		     pam_handle_t * *);
extern int pam_end(pam_handle_t *, int);
extern int pam_authenticate(pam_handle_t *, int);
extern int pam_setcred(pam_handle_t *, int);
extern int pam_acct_mgmt(pam_handle_t *, int);
extern int pam_open_session(pam_handle_t *, int);
extern int pam_close_session(pam_handle_t *, int);
extern int pam_chauthtok(pam_handle_t *, int);
extern const char *pam_getenv(pam_handle_t *, const char *);
extern int pam_putenv(pam_handle_t *, const char *);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libpamman>
<TITLE>Interface Definitions for libpam</TITLE>
<PARA>
The interfaces defined on the following pages are included in libpam and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libpam> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="baselib-pam-acct-mgmt"> <REFMETA>
<REFENTRYTITLE>pam_acct_mgmt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_acct_mgmt</REFNAME>
<REFPURPOSE>
establish the status of a user's account
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_acct_mgmt</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_acct_mgmt</FUNCTION> establishes the account's usability 
and the user's accessibility to the system. It is typically called 
after the user has been authenticated.
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> may be specified as any valid flag (namely, 
one of those applicable to the <PARAMETER>flags</PARAMETER> argument of 
<FUNCTION>pam_authenticate</FUNCTION>). Additionally, the value of 
<PARAMETER>flags</PARAMETER> may be logically or'd 
with <CONSTANT>PAM_SILENT</CONSTANT>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_NEW_AUTHTOK_REQD
</TERM>
<LISTITEM>
<PARA>
User is valid, but user's authentication token has expired.
The correct response to this return-value is to require that the
user satisfy the <FUNCTION>pam_chauthtok</FUNCTION> function before 
obtaining service. It may not be possible for an application to do 
this. In such a case, the user should be denied access until the
account password is updated.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_ACCT_EXPIRED
</TERM>
<LISTITEM>
<PARA>
User is no longer permitted access to the system.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTH_ERR
</TERM>
<LISTITEM>
<PARA>
Authentication error.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_PERM_DENIED
</TERM>
<LISTITEM>
<PARA>
User is not permitted to gain access at this time.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER_UNKNOWN
</TERM>
<LISTITEM>
<PARA>
User is not known to a module's account management component.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-authenticate"> <REFMETA>
<REFENTRYTITLE>pam_authenticate</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_authenticate</REFNAME>
<REFPURPOSE>
authenticate the user
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_authenticate</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_authenticate</FUNCTION> serves as an interface to the 
authentication mechanisms of the loaded modules. 
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> is an optional parameter that may
be specified by the following value:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_DISALLOW_NULL_AUTHTOK
</TERM>
<LISTITEM>
<PARA>
Instruct the authentication modules to return <CONSTANT>PAM_AUTH_ERR</CONSTANT>
if the user does not have a registered authorization token.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Additionally, the value of <PARAMETER>flags</PARAMETER> may be 
logically or'd with <CONSTANT>PAM_SILENT</CONSTANT>.
</PARA>

<PARA>The process may need to be privileged in order to successfully
call this function.</PARA>

</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTH_ERR
</TERM>
<LISTITEM>
<PARA>
User was not authenticated or process did not have sufficient privileges
to perform authentication.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_CRED_INSUFFICIENT
</TERM>
<LISTITEM>
<PARA>
Application does not have sufficient credentials to
authenticate the user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTHINFO_UNAVAIL
</TERM>
<LISTITEM>
<PARA>
Modules were not able to access the authentication information. This
might be due to a network or hardware failure, etc.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER_UNKNOWN
</TERM>
<LISTITEM>
<PARA>
Supplied username is not known to the authentication service.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_MAXTRIES
</TERM>
<LISTITEM>
<PARA>
One or more authentication modules has reached its limit of tries
authenticating the user. Do not try again.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_ABORT
</TERM>
<LISTITEM>
<PARA>
One or more authentication modules failed to load.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-chauthtok"> <REFMETA>
<REFENTRYTITLE>pam_chauthtok</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_chauthtok</REFNAME>
<REFPURPOSE>
change the authentication token for a given user
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_chauthtok</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_chauthtok</FUNCTION> is used to change the 
authentication token for a given user as indicated by the state 
associated with the handle <PARAMETER>pamh</PARAMETER>.
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> is an optional parameter that may
be specified by the following value:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_CHANGE_EXPIRED_AUTHTOK
</TERM>
<LISTITEM>
<PARA>
User's authentication token should only be changed if it has expired.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Additionally, the value of <PARAMETER>flags</PARAMETER> may be 
logically or'd with <CONSTANT>PAM_SILENT</CONSTANT>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>RETURN VALUE</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTHTOK_ERR
</TERM>
<LISTITEM>
<PARA>
A module was unable to obtain the new authentication token.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTHTOK_RECOVER_ERR
</TERM>
<LISTITEM>
<PARA>
A module was unable to obtain the old authentication token.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTHTOK_LOCK_BUSY
</TERM>
<LISTITEM>
<PARA>
One or more modules were unable to change the authentication token
since it is currently locked.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_AUTHTOK_DISABLE_AGING
</TERM>
<LISTITEM>
<PARA>
Authentication token aging has been disabled for at least one of the modules.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_PERM_DENIED
</TERM>
<LISTITEM>
<PARA>
Permission denied.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_TRY_AGAIN
</TERM>
<LISTITEM>
<PARA>
Not all modules were in a position to update the authentication
token(s). In such a case, none of the user's authentication tokens 
are updated.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER_UNKNOWN
</TERM>
<LISTITEM>
<PARA>
User is not known to the authentication token changing service.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-close-session"> <REFMETA>
<REFENTRYTITLE>pam_close_session</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_close_session</REFNAME>
<REFPURPOSE>
indicate that an authenticated session has ended
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_close_session</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_close_session</FUNCTION> is used to indicate that 
an authenticated session has ended. It is used to inform the module 
that the user is exiting a session. It should be possible for the 
PAM library to open a session and close the same session from 
different applications.
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> may have the value
<CONSTANT>PAM_SILENT</CONSTANT> to indicate that no output 
should be generated as a result of this function call.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_SESSION_ERR
</TERM>
<LISTITEM>
<PARA>
One of the required loaded modules was unable to close a session for the user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-end"> <REFMETA>
<REFENTRYTITLE>pam_end</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_end</REFNAME>
<REFPURPOSE>
terminate the use of the PAM library
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_end</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>pam_status</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_end</FUNCTION> terminates use of the PAM library.
On success, the contents of <PARAMETER>*pamh</PARAMETER> are no 
longer valid, and all memory associated with it is invalid.
</PARA>
<PARA>
Normally, <PARAMETER>pam_status</PARAMETER> is passed the value 
<CONSTANT>PAM_SUCCESS</CONSTANT>, but in the event of an
unsuccessful service application, the appropriate PAM error 
return value should be used.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-fail-delay"> <REFMETA>
<REFENTRYTITLE>pam_fail_delay</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_fail_delay</REFNAME>
<REFPURPOSE>
specify delay time to use on authentication error
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_fail_delay</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>unsigned int 
  <PARAMETER><REPLACEABLE>micro_sec</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_fail_delay</FUNCTION> specifies the minimum delay for the 
PAM library to use when an authentication error occurs. The actual delay 
can vary by as much at 25%. If this function is called multiple times, 
the longest time specified by any of the call will be used.
</PARA>
<PARA>
The delay is invoked if an authentication error occurs during the
<FUNCTION>pam_authenticate</FUNCTION> or <FUNCTION>pam_chauthtok</FUNCTION>
function calls.
</PARA>
<PARA>
Independent of the success of
<FUNCTION>pam_authenticate</FUNCTION> or <FUNCTION>pam_chauthtok</FUNCTION>,
the delay time is reset to its default value of 0 when the PAM library returns 
control to the application from these two functions.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-get-item"> <REFMETA>
<REFENTRYTITLE>pam_get_item</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_get_item</REFNAME>
<REFPURPOSE>
obtain the value of the indicated item.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_get_item</FUNCTION></FUNCDEF>
 <PARAMDEF>const pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>item_type</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const void * *
  <PARAMETER><REPLACEABLE>item</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_get_item</FUNCTION> obtains the value of the indicated
<PARAMETER>item_type</PARAMETER>. The possible values of
<PARAMETER>item_type</PARAMETER> are the same as listed for
<FUNCTION>pam_set_item</FUNCTION>.
</PARA>
<PARA>
On success, <PARAMETER>item</PARAMETER> contains a pointer to the
value of the corresponding item. Note that this is a pointer to the 
actual data and should not be <FUNCTION>free</FUNCTION>'d or over-written.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_PERM_DENIED
</TERM>
<LISTITEM>
<PARA>
Application passed a <CONSTANT>NULL</CONSTANT> pointer for
<VARNAME>item</VARNAME>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_BAD_ITEM
</TERM>
<LISTITEM>
<PARA>
Application attempted to get an undefined item.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-getenv"> <REFMETA>
<REFENTRYTITLE>pam_getenv</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_getenv</REFNAME>
<REFPURPOSE>
get a PAM environment variable
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;security/pam_appl.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>const char *
<function>pam_getenv</function>
</funcdef>
<paramdef>const pam_handle_t *
<parameter>pamh</parameter>
</paramdef>
<paramdef>const char *
<parameter>name</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 August 2007</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The
<FUNCTION>pam_getenv</FUNCTION> function shall search the environment
associated with the PAM handle <parameter>pamh</parameter> for the
environment variable <parameter>name</parameter>. 
If the specified environment variable cannot be found, a null pointer shall
be returned. The application shall ensure that it does not modify the string pointed to by the
<function>pam_getenv</function> function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, <function>pam_getenv</function> returns a pointer to a string of the form
<systemitem>name=value</systemitem>.
</PARA>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-getenvlist"> <REFMETA>
<REFENTRYTITLE>pam_getenvlist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_getenvlist</REFNAME>
<REFPURPOSE>
returns a pointer to the complete PAM environment.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>char * const *
  <FUNCTION>pam_getenvlist</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_getenvlist</FUNCTION> returns a pointer to the complete 
PAM environment. This pointer points to an array of pointers to
<CONSTANT>NUL</CONSTANT>-terminated strings and must be terminated by a
<CONSTANT>NULL</CONSTANT> pointer. Each string has the form "name=value".
</PARA>
<PARA>
The PAM library module allocates memory for the returned value and the
associated strings. The calling application is responsible for freeing this
memory. 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
<FUNCTION>pam_getenvlist</FUNCTION> returns an array of string pointers 
containing the PAM environment. On error, <CONSTANT>NULL</CONSTANT> 
is returned.
</PARA>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-open-session"> <REFMETA>
<REFENTRYTITLE>pam_open_session</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_open_session</REFNAME>
<REFPURPOSE>
indicate session has started
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_open_session</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>pam_open_session</FUNCTION> function is used to indicate that an 
authenticated session has begun, after the user has been
identified (see <function>pam_authenticate</function>) and,
if necessary, granted credentials (see <function>pam_setcred</function>).
It is used to inform the module that 
the user is currently in a session. It should be possible for the PAM 
library to open a session and close the same session from different 
applications.
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> may have the value
<CONSTANT>PAM_SILENT</CONSTANT> to indicate that no output be
generated as a result of this function call.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_SESSION_ERR
</TERM>
<LISTITEM>
<PARA>
One of the loaded modules was unable to open a session for the user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-putenv"> <REFMETA>
<REFENTRYTITLE>pam_putenv</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_putenv</REFNAME>
<REFPURPOSE>
Add, replace or delete a PAM environment variable
</REFPURPOSE>
</REFNAMEDIV>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;security/pam_appl.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>pam_putenv</function>
</funcdef>
<paramdef>const pam_handle_t *
<parameter>pamh</parameter>
</paramdef>
<paramdef>const char *
<parameter>name_value</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 August, 2007</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The
<FUNCTION>pam_putenv</FUNCTION> function 
shall modify the environment list associated with
<parameter>pamh</parameter>. If <parameter>name_value</parameter> contains
an <literal>'='</literal> character, the characters to the left of the first
<literal>'='</literal> character represent the <parameter>name</parameter>, and the remaining
characters after the <literal>'='</literal> represent the <parameter>value</parameter>.
</PARA>
<para>
If the <parameter>name</parameter> environment variable exists in the environment associated with
<parameter>pamh</parameter>, it shall be modified to have the value <parameter>value</parameter>.
Otherwise, the <parameter>name</parameter> shall be added to the environment associated
with <parameter>pamh</parameter> with the value <parameter>value</parameter>.
</para>
<para>
If there is no <literal>'='</literal> character in <parameter>name_value</parameter>, the variable
in the environment associated with <parameter>pamh</parameter> named <parameter>name_value</parameter>
shall be deleted.
</para>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, the <function>pam_putenv</function> function shall return <returnvalue>PAM_SUCCESS</returnvalue>.
Otherwise the return value indicates the error:
<variablelist>
<varlistentry>
<term>PAM_PERM_DENIED</term>
<listitem><para>The <parameter>name_value</parameter> argument is a null pointer.</para></listitem>
</varlistentry>
<varlistentry>
<term>PAM_BAD_ITEM</term>
<listitem><para>The PAM environment varable named <parameter>name_value</parameter> does not exist and therefore cannot be deleted.</para></listitem>
</varlistentry>
<varlistentry>
<term>PAM_ABORT</term>
<listitem><para>The PAM handle identifed by <parameter>pamh</parameter> is corrupt.</para></listitem>
</varlistentry>
<varlistentry>
<term>PAM_BUF_ERR</term>
<listitem><para>Memory buffer error.</para></listitem>
</varlistentry>
</variablelist>
</PARA>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-set-item"> <REFMETA>
<REFENTRYTITLE>pam_set_item</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_set_item</REFNAME>
<REFPURPOSE>
(re)set the value of an item.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_set_item</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>item_type</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const void *
  <PARAMETER><REPLACEABLE>item</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_set_item</FUNCTION> (re)sets the value of one of the 
following item_types:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SERVICE
</TERM>
<LISTITEM>
<PARA>
service name
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER
</TERM>
<LISTITEM>
<PARA>
user name
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_TTY
</TERM>
<LISTITEM>
<PARA>
terminal name
</PARA>
<PARA>
The value for a device file should include the <FILENAME>/dev/</FILENAME> 
prefix. The value for graphical, X-based, applications should be the 
<VARNAME>$DISPLAY</VARNAME> variable.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_RHOST
</TERM>
<LISTITEM>
<PARA>
remote host name
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_CONV
</TERM>
<LISTITEM>
<PARA>
conversation structure
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_RUSER
</TERM>
<LISTITEM>
<PARA>
remote user name
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER_PROMPT
</TERM>
<LISTITEM>
<PARA>
string to be used when prompting for a user's name
</PARA>
<PARA>
The default value for this string is <LITERAL>Please enter 
username: </LITERAL>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
For all <PARAMETER>item_types</PARAMETER> other than
<CONSTANT>PAM_CONV</CONSTANT>, <PARAMETER>item</PARAMETER> is a pointer 
to a <CONSTANT>NULL</CONSTANT>-terminated character string. In the case 
of <CONSTANT>PAM_CONV</CONSTANT>, <PARAMETER>item</PARAMETER> points to
an initialized <STRUCTNAME>pam_conv</STRUCTNAME> structure.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_PERM_DENIED
</TERM>
<LISTITEM>
<PARA>
An attempt was made to replace the conversation structure with a
<CONSTANT>NULL</CONSTANT> value.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_BUF_ERR
</TERM>
<LISTITEM>
<PARA>
Function ran out of memory making a copy of the item.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_BAD_ITEM
</TERM>
<LISTITEM>
<PARA>
Application attempted to set an undefined item.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-setcred"> <REFMETA>
<REFENTRYTITLE>pam_setcred</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_setcred</REFNAME>
<REFPURPOSE>
set the module-specific credentials of the user
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>extern int 
  <FUNCTION>pam_setcred</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>flags</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_setcred</FUNCTION> sets the module-specific credentials of 
the user. It is usually called after the user has been authenticated,
after the account management function has been called and after a
session has been opened for the user.
</PARA>
<PARA>
<PARAMETER>flags</PARAMETER> maybe specified from among the following 
values:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_ESTABLISH_CRED
</TERM>
<LISTITEM>
<PARA>
set credentials for the authentication service
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_DELETE_CRED
</TERM>
<LISTITEM>
<PARA>
delete credentials associated with the authentication service
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_REINITIALIZE_CRED
</TERM>
<LISTITEM>
<PARA>
reinitialize the user credentials
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_REFRESH_CRED
</TERM>
<LISTITEM>
<PARA>
extend lifetime of the user credentials
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Additionally, the value of <PARAMETER>flags</PARAMETER> may be 
logically or'd with <CONSTANT>PAM_SILENT</CONSTANT>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_CRED_UNAVAIL
</TERM>
<LISTITEM>
<PARA>
Module cannot retrieve the user's credentials.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_CRED_EXPIRED
</TERM>
<LISTITEM>
<PARA>
User's credentials have expired.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_USER_UNKNOWN
</TERM>
<LISTITEM>
<PARA>
User is not known to an authentication module.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_CRED_ERR
</TERM>
<LISTITEM>
<PARA>
Module was unable to set the credentials of the user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<NOTE>
<PARA>
Errors may be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</NOTE>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-start"> <REFMETA>
<REFENTRYTITLE>pam_start</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_start</REFNAME>
<REFPURPOSE>
initialize the PAM library
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>int 
  <FUNCTION>pam_start</FUNCTION></FUNCDEF>
 <PARAMDEF>const char * 
  <PARAMETER><REPLACEABLE>service_name</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const char *
  <PARAMETER><REPLACEABLE>user</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>const struct pam_conv *
  <PARAMETER>pam_conversation</PARAMETER></PARAMDEF>
 <PARAMDEF>pam_handle_t * *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_start</FUNCTION> is used to initialize the PAM 
library. It must be called prior to any other usage of the PAM 
library. On success, <PARAMETER>*pamh</PARAMETER> becomes a handle 
that provides continuity for successive calls to the PAM library. 
<FUNCTION>pam_start</FUNCTION> expects arguments as follows: the 
<PARAMETER>service_name</PARAMETER> of the program, the 
<PARAMETER>username</PARAMETER> of the individual to be
authenticated, a pointer to an application-supplied
<STRUCTNAME>pam_conv</STRUCTNAME> structure, and a pointer to a
<PARAMETER>pam_handle_t</PARAMETER> pointer.
</PARA>
<PARA>
An application must provide the <EMPHASIS>conversation function</EMPHASIS> 
used for direct communication between a loaded module and the application. 
The application also typically provides a means for the module to prompt 
the user for a password, etc.
</PARA>
<PARA>
The structure, pam_conv, is defined to be,
<SYNOPSIS>
  struct pam_conv {
               int (*conv) (int num_msg,
                            const struct pam_message * *msg,
                            struct pam_response * *resp,
                            void *appdata_ptr);
               void *appdata_ptr;
  };
</SYNOPSIS>
It is initialized by the application before it is passed to the
library. The contents of this structure are attached to the
<PARAMETER>*pamh</PARAMETER> handle. The point of this argument is to
provide a mechanism for any loaded module to interact directly with the
application program; this is why it is called a conversation structure.
</PARA>
<PARA>
When a module calls the referenced <FUNCTION>conv</FUNCTION> function, 
<PARAMETER>appdata_ptr</PARAMETER> is set to the second element of this
structure.
</PARA>
<PARA>
The other arguments of a call to <FUNCTION>conv</FUNCTION> 
concern the information exchanged by module and application. 
<PARAMETER>num_msg</PARAMETER> holds the length of the array of
pointers passed via <PARAMETER>msg</PARAMETER>. On success,
the pointer <PARAMETER>resp</PARAMETER> points to an array of
<PARAMETER>num_msg</PARAMETER> <STRUCTNAME>pam_response</STRUCTNAME>
structures, holding the application-supplied text. Note that 
<PARAMETER>resp</PARAMETER> is a struct 
<STRUCTNAME>pam_response</STRUCTNAME> array and not an array of 
pointers.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
PAM_SUCCESS
</TERM>
<LISTITEM>
<PARA>
Success.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_BUF_ERR
</TERM>
<LISTITEM>
<PARA>
Memory allocation error.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
PAM_ABORT
</TERM>
<LISTITEM>
<PARA>
Internal failure.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS</TITLE>
<PARA>
May be translated to text with <FUNCTION>pam_strerror</FUNCTION>.
</PARA>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


<REFENTRY ID="baselib-pam-strerror"> <REFMETA>
<REFENTRYTITLE>pam_strerror</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>pam_strerror</REFNAME>
<REFPURPOSE>
returns a string describing the PAM error
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>27 September 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;security/pam_appl.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
 <FUNCDEF>const char *
  <FUNCTION>pam_strerror</FUNCTION></FUNCDEF>
 <PARAMDEF>pam_handle_t *
  <PARAMETER><REPLACEABLE>pamh</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>int 
  <PARAMETER><REPLACEABLE>errnum</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>27 September 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>pam_strerror</FUNCTION> returns a string describing the PAM 
error associated with <PARAMETER>errnum</PARAMETER>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>
On success, this function returns a description of the indicated error.
The application 
should not free or modify this string. 
Otherwise, a string
indicating that the error is unknown shall be returned.
It is unspecified whether or not the string returned is translated according to
the setting of <envar>LC_MESSAGES</envar>.
</PARA>
</REFSECT1>
</REFENTRY>

<!--
Portions taken from the Linux-PAM Application Guide which contains
the following Copyright message.

    Copyright (C) Andrew G. Morgan 1996-9.  All rights reserved.

Redistribution and use in source (sgml) and binary (derived) forms,
with or without modification, are permitted provided that the
following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, and the entire permission notice in its entirety,
   including the disclaimer of warranties.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior
   written permission.

ALTERNATIVELY, this product may be distributed under the terms of the
GNU General Public License, in which case the provisions of the GNU
GPL are required INSTEAD OF the above restrictions.  (This clause is
necessary due to a potential bad interaction between the GNU GPL and
the restrictions contained in a BSD-style copyright.)

THIS SOFTWARE IS PROVIDED `AS IS' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

 -->


</SECT1>
<!-- End of text generated from database -->


</CHAPTER>

</PART>
