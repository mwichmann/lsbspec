<PART ID="tocutillib">
<TITLE>Utility Libraries</TITLE>

<CHAPTER id=utillib>
<TITLE>Utility Libraries</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
An LSB-conforming implementation shall also support the following
utility libraries which are built on top of the interfaces provided
by the base libraries. These libraries implement common functionality,
and hide additional system dependent information such as file formats
and device names.

<itemizedlist>
<listitem><para>libz</para></listitem>
<listitem><para>libncurses</para></listitem>
<listitem><para>libncursesw</para></listitem>
<listitem><para>libutil</para></listitem>
</itemizedlist>
</PARA>
<PARA>
The structure of the definitions for these libraries follows the
same model as used for <XREF LINKEND=baselib>.
</PARA>
</SECT1>
<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libz>
<TITLE>Interfaces for libz</TITLE>
<PARA>
<XREF LINKEND="lib-libz-def"> defines the library name and shared object name
for the libz library
</PARA>
<TABLE id="lib-libz-def">
<TITLE>libz Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libz</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libz.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libz.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Compression Library -->
<SECT2>
<!--libgroup-->
<TITLE>Compression Library</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Compression Library</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Compression Library specified in <XREF linkend="tbl-libz-compr-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libz-compr-ints">
<TITLE>libz - Compression Library Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>adler32</primary></indexterm>adler32 <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>compress</primary></indexterm>compress <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>compress2</primary></indexterm>compress2 <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>compressBound</primary></indexterm>compressBound(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>crc32</primary></indexterm>crc32 <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflate</primary></indexterm>deflate <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateBound</primary></indexterm>deflateBound(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateCopy</primary></indexterm>deflateCopy <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflateEnd</primary></indexterm>deflateEnd <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateInit2_</primary></indexterm>deflateInit2_ <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateInit_</primary></indexterm>deflateInit_ <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateParams</primary></indexterm>deflateParams <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflatePrime</primary></indexterm>deflatePrime(ZLIB_1.2.0.8) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateReset</primary></indexterm>deflateReset <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateSetDictionary</primary></indexterm>deflateSetDictionary <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>get_crc_table</primary></indexterm>get_crc_table <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gzclearerr</primary></indexterm>gzclearerr(ZLIB_1.2.0.2) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzclose</primary></indexterm>gzclose <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzdopen</primary></indexterm>gzdopen <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzeof</primary></indexterm>gzeof <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gzerror</primary></indexterm>gzerror <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzflush</primary></indexterm>gzflush <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzgetc</primary></indexterm>gzgetc <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzgets</primary></indexterm>gzgets <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gzopen</primary></indexterm>gzopen <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzprintf</primary></indexterm>gzprintf <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzputc</primary></indexterm>gzputc <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzputs</primary></indexterm>gzputs <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gzread</primary></indexterm>gzread <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzrewind</primary></indexterm>gzrewind <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzseek</primary></indexterm>gzseek <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzsetparams</primary></indexterm>gzsetparams <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>gztell</primary></indexterm>gztell <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzwrite</primary></indexterm>gzwrite <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflate</primary></indexterm>inflate <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateBack</primary></indexterm>inflateBack(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>inflateBackEnd</primary></indexterm>inflateBackEnd(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateBackInit_</primary></indexterm>inflateBackInit_(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateCopy</primary></indexterm>inflateCopy(ZLIB_1.2.0) <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateEnd</primary></indexterm>inflateEnd <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>inflateInit2_</primary></indexterm>inflateInit2_ <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateInit_</primary></indexterm>inflateInit_ <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateReset</primary></indexterm>inflateReset <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateSetDictionary</primary></indexterm>inflateSetDictionary <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>inflateSync</primary></indexterm>inflateSync <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateSyncPoint</primary></indexterm>inflateSyncPoint <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>uncompress</primary></indexterm>uncompress <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>zError</primary></indexterm>zError <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>zlibVersion</primary></indexterm>zlibVersion <LINK LINKEND="REFSTD.libz.1">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libz-ddefs>
<TITLE>Data Definitions for libz</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libz.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>zconf.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ZEXPORT
#define ZEXPORTVA
#define OF(args)	args
#define ZEXTERN	extern
</SCREEN>
</SECT2>
<SECT2>
<TITLE>zlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ZLIB_VERSION	"1.2.2"
#define Z_NULL	0
#define MAX_WBITS	15	/* 32K LZ77 window */
#define MAX_MEM_LEVEL	9	/* Maximum value for memLevel in deflateInit2 */
#define deflateInit2(strm,level,method,windowBits,memLevel,strategy)	\
	deflateInit2_((strm),(level),(method),(windowBits),(memLevel),(strategy),ZLIB_VERSION,sizeof(z_stream))
#define deflateInit(strm,level)	\
	deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm,windowBits)	\
	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm)	\
	inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define inflateBackInit(strm, windowBits, window)	\
        inflateBackInit_((strm), (windowBits), (window), \
                                            ZLIB_VERSION, sizeof(z_stream))

typedef char charf;
typedef int intf;

typedef void *voidpf;
typedef unsigned int uInt;
typedef unsigned long int uLong;
typedef uLong uLongf;
typedef void *voidp;
typedef unsigned char Byte;
typedef off_t z_off_t;
typedef void *const voidpc;

typedef voidpf(*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);
struct internal_state {
    int dummy;
};
typedef Byte Bytef;
typedef uInt uIntf;
typedef unsigned int (*in_func) (void *, unsigned char **);
typedef int (*out_func) (void *, unsigned char *, unsigned int);

typedef struct z_stream_s {
    Bytef *next_in;		/* next input byte */
    uInt avail_in;		/* number of bytes available at next_in */
    uLong total_in;		/* total nb of input bytes read so far */
    Bytef *next_out;		/* next output byte should be put there */
    uInt avail_out;		/* remaining free space at next_out */
    uLong total_out;		/* total nb of bytes output so far */
    char *msg;			/* last error message, NULL if no error */
    struct internal_state *state;	/* not visible by applications */
    alloc_func zalloc;		/* used to allocate the internal state */
    free_func zfree;		/* used to free the internal state */
    voidpf opaque;		/* private data object passed to zalloc and zfree */
    int data_type;		/* best guess about the data type: ascii or binary */
    uLong adler;		/* adler32 value of the uncompressed data */
    uLong reserved;		/* reserved for future use */
} z_stream;

typedef z_stream *z_streamp;
typedef voidp gzFile;

#define Z_NO_FLUSH	0
#define Z_PARTIAL_FLUSH	1
#define Z_SYNC_FLUSH	2
#define Z_FULL_FLUSH	3
#define Z_FINISH	4
#define Z_BLOCK	5

#define Z_ERRNO	(-1)
#define Z_STREAM_ERROR	(-2)
#define Z_DATA_ERROR	(-3)
#define Z_MEM_ERROR	(-4)
#define Z_BUF_ERROR	(-5)
#define Z_VERSION_ERROR	(-6)
#define Z_OK	0
#define Z_STREAM_END	1
#define Z_NEED_DICT	2

#define Z_DEFAULT_COMPRESSION	(-1)
#define Z_NO_COMPRESSION	0
#define Z_BEST_SPEED	1
#define Z_BEST_COMPRESSION	9

#define Z_DEFAULT_STRATEGY	0
#define Z_FILTERED	1
#define Z_HUFFMAN_ONLY	2

#define Z_BINARY	0
#define Z_ASCII	1
#define Z_UNKNOWN	2

#define Z_DEFLATED	8

extern uLong adler32(uLong adler, const Bytef * buf, uInt len);
extern int compress(Bytef * dest, uLongf * destLen, const Bytef * source,
		    uLong sourceLen);
extern int compress2(Bytef * dest, uLongf * destLen, const Bytef * source,
		     uLong sourceLen, int level);
extern uLong compressBound(uLong sourceLen);
extern uLong crc32(uLong crc, const Bytef * buf, uInt len);
extern int deflate(z_streamp strm, int flush);
extern uLong deflateBound(z_streamp strm, uLong sourceLen);
extern int deflateCopy(z_streamp dest, z_streamp source);
extern int deflateEnd(z_streamp strm);
extern int deflateInit2_(z_streamp strm, int level, int method,
			 int windowBits, int memLevel, int strategy,
			 const char *version, int stream_size);
extern int deflateInit_(z_streamp strm, int level, const char *version,
			int stream_size);
extern int deflateParams(z_streamp strm, int level, int strategy);
extern int deflatePrime(z_streamp strm, int bits, int value);
extern int deflateReset(z_streamp strm);
extern int deflateSetDictionary(z_streamp strm, const Bytef * dictionary,
				uInt dictLength);
extern const uLongf *get_crc_table(void);
extern void gzclearerr(gzFile file);
extern int gzclose(gzFile file);
extern gzFile gzdopen(int fd, const char *mode);
extern int gzeof(gzFile file);
extern const char *gzerror(gzFile file, int *errnum);
extern int gzflush(gzFile file, int flush);
extern int gzgetc(gzFile file);
extern char *gzgets(gzFile file, char *buf, int len);
extern gzFile gzopen(const char *path, const char *mode);
extern int gzprintf(gzFile file, const char *format, ...);
extern int gzputc(gzFile file, int c);
extern int gzputs(gzFile file, const char *s);
extern int gzread(gzFile file, voidp buf, unsigned int len);
extern int gzrewind(gzFile file);
extern z_off_t gzseek(gzFile file, z_off_t offset, int whence);
extern int gzsetparams(gzFile file, int level, int strategy);
extern z_off_t gztell(gzFile file);
extern int gzwrite(gzFile file, voidpc buf, unsigned int len);
extern int inflate(z_streamp strm, int flush);
extern int inflateBack(z_streamp strm, in_func in, void *in_desc,
		       out_func out, void *out_desc);
extern int inflateBackEnd(z_streamp strm);
extern int inflateBackInit_(z_streamp strm, int windowBits,
			    unsigned char *window, const char *version,
			    int stream_size);
extern int inflateCopy(z_streamp dest, z_streamp source);
extern int inflateEnd(z_streamp strm);
extern int inflateInit2_(z_streamp strm, int windowBits,
			 const char *version, int stream_size);
extern int inflateInit_(z_streamp strm, const char *version,
			int stream_size);
extern int inflateReset(z_streamp strm);
extern int inflateSetDictionary(z_streamp strm, const Bytef * dictionary,
				uInt dictLength);
extern int inflateSync(z_streamp strm);
extern int inflateSyncPoint(z_streamp z);
extern int uncompress(Bytef * dest, uLongf * destLen, const Bytef * source,
		      uLong sourceLen);
extern const char *zError(int);
extern const char *zlibVersion(void);
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libzman>
<TITLE>Interface Definitions for libz</TITLE>
<PARA>
The interfaces defined on the following pages are included in libz and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libz> shall behave as described
in the referenced base document.
</PARA>
<refentry id="zlib-adler32-1">

<refmeta>
<refentrytitle>adler32</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>adler32</refname>
<refpurpose>compute Adler 32 Checksum</refpurpose>
<indexterm id="ix-utillib-adler32-1">
  <primary>adler32</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>uLong
<function>adler32</function>
</funcdef>
<paramdef>uLong
<parameter>adler</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>buf</parameter>
</paramdef>
<paramdef>uInt
<parameter>len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>adler32</function> function shall compute a running
Adler-32 checksum (as described in <xref linkend="std.rfc1950">).
On entry, <parameter>adler</parameter> is the previous value for the
checksum, and <parameter>buf</parameter> shall point to an array of
<parameter>len</parameter> bytes of data to be added to this checksum.
The <function>adler32</function> function shall return the new checksum.
</para>
<para>
If <parameter>buf</parameter> is <constant>NULL</constant> (or 
<constant>Z_NULL</constant>), <function>adler32</function>
shall return the initial checksum.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>adler32</function> function shall return  
the new checksum value.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The following code fragment demonstrates typical usage of
the <function>adler32</function> function:
<programlisting>
     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
</programlisting>
</para>
</refsect1>
</refentry>



<refentry id="zlib-compress-1">

<refmeta>
<refentrytitle>compress</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compress</refname>
<refpurpose>compress data</refpurpose>
<indexterm id="ix-utillib-compress-1">
  <primary>compress</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compress</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compress</function> function shall attempt to compress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>. 
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value
be at least 
<inlineequation>
  <alt>(sourceLen &times; 1.001) &plus; 12</alt>
  <graphic>
</inlineequation>.
<!-- NB, above equation needs special stylesheet considerations ...
     it does not actually contain a graphic (well, the graphic element
     does not contain a fileref), and only the ALT element has anything
     of interest-->
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of compressed data in
<parameter>dest</parameter>.
</para>
<para>
The <function>compress</function> function is equivalent to 
<function>compress2</function> with a <parameter>level</parameter> of
<constant>Z_DEFAULT_COMPRESSION</constant>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>compress</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>compress</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>compress</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
compressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-compress2-1">

<refmeta>
<refentrytitle>compress2</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compress2</refname>
<refpurpose>compress data at a specified level</refpurpose>
<indexterm id="ix-utillib-compress2-1">
  <primary>compress2</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compress2</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compress2</function> function shall attempt to compress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>, at the level described by 
<parameter>level</parameter>. 
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value
be at least 
<inlineequation>
  <alt>(sourceLen &times; 1.001) &plus; 12</alt>
  <graphic>
</inlineequation>.
<!-- NB, above equation needs special stylesheet considerations ...
     it does not actually contain a graphic (well, the graphic element
     does not contain a fileref), and only the ALT element has anything
     of interest-->
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of compressed data in
<parameter>dest</parameter>.
</para>
<para>
The <function>compress</function> function is equivalent to 
<function>compress2</function> with a <parameter>level</parameter> of
<constant>Z_DEFAULT_COMPRESSION</constant>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>compress2</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>compress2</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>compress2</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
compressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The <parameter>level</parameter> was not <constant>Z_DEFAULT_COMPRESSION</constant>,
or was not between 0 and 9.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-compressBound-1">

<refmeta>
<refentrytitle>compressBound</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compressBound</refname>
<refpurpose>compute compressed data size</refpurpose>
<indexterm id="ix-utillib-compressBound-1">
  <primary>compressBound</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compressBound</function>
</funcdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compressBound</function> function shall estimate the size
of buffer required to compress <parameter>sourceLen</parameter>
bytes of data using the <function>compress</function>
or <function>compress2</function> functions.
If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<parameter>sourceLen</parameter> bytes of data, using the
parameters stored in <parameter>stream</parameter>, 
in a single
call to <function>compress</function> or 
<function>compress2</function>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>compressBound</function> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <function>compress</function>
or <function>compress2</function>.
This function may return a conservative value that may be larger than 
<parameter>sourceLen</parameter>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<refentry id="zlib-crc32-1">

<refmeta>
<refentrytitle>crc32</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>crc32</refname>
<refpurpose>compute CRC-32 Checksum</refpurpose>
<indexterm id="ix-utillib-crc32-1">
  <primary>crc32</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>uLong
<function>crc32</function>
</funcdef>
<paramdef>uLong
<parameter>crc</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>buf</parameter>
</paramdef>
<paramdef>uInt
<parameter>len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>crc32</function> function shall compute a running
Cyclic Redundancy Check checksum, as defined in <xref linkend="std.ituv42">.
On entry, <parameter>crc</parameter> is the previous value for the
checksum, and <parameter>buf</parameter> shall point to an array of
<parameter>len</parameter> bytes of data to be added to this checksum.
The <function>crc32</function> function shall return the new checksum.
</para>
<para>
If <parameter>buf</parameter> is <constant>NULL</constant> (or 
<constant>Z_NULL</constant>), <function>crc32</function>
shall return the initial checksum.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>crc32</function> function shall return  
the new checksum value.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The following code fragment demonstrates typical usage of
the <function>crc32</function> function:
<programlisting>
     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
</programlisting>
</para>
</refsect1>
</refentry>



<refentry id="zlib-deflate-1">

<refmeta>
<refentrytitle>deflate</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflate</refname>
<refpurpose>compress data</refpurpose>
<indexterm id="ix-utillib-deflate-1">
  <primary>deflate</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflate</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflate</function> function shall attempt to compress
data until either the input buffer is empty or the output buffer is full.
The <parameter>stream</parameter> references a
<structname>z_stream</structname> structure. Before the first call to
<function>deflate</function>, this structure
should have been initialized by a call to 
<function>deflateInit2_</function>.
<note><para>
<function>deflateInit2_</function> is only in the binary standard; source
level applications should initialize <parameter>stream</parameter>
via a call to <function>deflateInit</function> or 
<function>deflateInit2</function>.
</para></note>
In addition, the <parameter>stream</parameter> input and output buffers
should have been initialized as follows:
<variablelist>
<varlistentry>
<term><structfield>next_in</structfield></term>
<listitem><para>
should point to the data to be compressed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_in</structfield></term>
<listitem><para>
should contain the number of bytes of data in the
buffer referenced by <structfield>next_in</structfield>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>next_out</structfield></term>
<listitem><para>
should point to a buffer where compressed data may be placed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_out</structfield></term>
<listitem><para>
should contain the size in bytes of the
buffer referenced by <structfield>next_out</structfield>
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>deflate</function> function
shall perform one or both of the following actions:
<orderedlist>
<listitem><para>
Compress input data from <structfield>next_in</structfield>
and update <structfield>next_in</structfield>,
<structfield>avail_in</structfield> and
<structfield>total_in</structfield> to reflect the data that has been 
compressed.
</para></listitem>
<listitem><para>
Fill the output buffer referenced by <structfield>next_out</structfield>,
and update <structfield>next_out</structfield>,
<structfield>avail_out</structfield> and
<structfield>total_out</structfield> to reflect the compressed data that 
has been placed there. If <parameter>flush</parameter> is not
<constant>Z_NO_FLUSH</constant>, and
<structfield>avail_out</structfield> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).
</para></listitem>
</orderedlist>
</para>
<para>
The <function>deflate</function> function shall return when either
<structfield>avail_in</structfield> reaches zero (indicating that all the input
data has been compressed), or <structfield>avail_out</structfield> reaches
zero (indicating that the output buffer is full).
</para>
<para>
On success, the <function>deflate</function> function shall set the
<structfield>adler</structfield> field of the <parameter>stream</parameter>
to the <function>adler32</function> checksum of all the input data compressed
so far (represented by <structfield>total_in</structfield>).
</para>
<para>
If the <function>deflate</function> function shall attempt to determine
the type of input data, and set field <structfield>data_type</structfield>
in <parameter>stream</parameter> to <constant>Z_ASCII</constant> if the
majority of the data bytes fall within the ASCII (ISO 646) printable
character range. Otherwise, it shall set <structfield>data_type</structfield>
to <constant>Z_BINARY</constant>.
This data type is informational only, and does not affect the compression
algorithm.
<note><para>
Future versions of the LSB may remove this requirement, since it is based
on an outdated character set that does not support Internationalization,
and does not affect the algorithm. It is included for information
only at this release. Applications should not depend on this field.
</para></note>
</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines when compressed bits 
are added to the output buffer in <structfield>next_out</structfield>.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>deflate</function>
may return with some data pending output, and not yet added to the 
output buffer.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>deflate</function> shall flush all pending output to
<structfield>next_out</structfield> and align the output to a byte 
boundary. A synchronization point is generated in  the output.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_FULL_FLUSH</constant>,
all output shall be flushed, as for <constant>Z_SYNC_FLUSH</constant>,
and the compression state shall be reset. 
A synchronization point is generated in  the output.
<note><title>Rationale</title>
<para>
<constant>Z_SYNC_FLUSH</constant> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <constant>Z_FULL_FLUSH</constant>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.
</para>
</note>
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all pending input shall be processed and <function>deflate</function>
shall return with <returnvalue>Z_STREAM_END</returnvalue> if there is
sufficient space in the output buffer at <structfield>next_out</structfield>,
as indicated by <structfield>avail_out</structfield>. If
<function>deflate</function> is called with <parameter>flush</parameter>
set to <constant>Z_FINISH</constant> and there is insufficient space to store
the compressed data, and no other error has occurred during compression,
<function>deflate</function> shall return <returnvalue>Z_OK</returnvalue>,
and the application should call <function>deflate</function> again with
<parameter>flush</parameter> unchanged, and having updated <structfield>
next_out</structfield> and <structfield>avail_out</structfield>.
</para>
<para>
If all the compression is to be done in a single step, 
<function>deflate</function>
may be called with <parameter>flush</parameter> set to 
<constant>Z_FINISH</constant> immediately after the stream
has been initialized if <structfield>avail_out</structfield>
is set to at least the value returned by <function>deflateBound</function>.
</para>

</refsect2>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflate</function> shall return  
<returnvalue>Z_OK</returnvalue>, unless <parameter>flush</parameter> was set 
to <constant>Z_FINISH</constant> and there was sufficient space in the output buffer
to compress all of the input data. In this case, <function>deflate</function>
shall return <returnvalue>Z_STREAM_END</returnvalue>.
On error, <function>deflate</function> shall return a value to indicate
the error.
<note><para>
If <function>deflate</function> returns <returnvalue>Z_OK</returnvalue>
and has set <structfield>avail_out</structfield> to zero, the function should
be called again with the same value for <parameter>flush</parameter>, and with
updated <structfield>next_out</structfield> and 
<structfield>avail_out</structfield> until <function>deflate</function>
returns with <returnvalue>Z_OK</returnvalue> (or <returnvalue>Z_STREAM_END</returnvalue>
if <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>) and a non-zero 
<structfield>avail_out</structfield>.
</para>
</note>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflate</function> shall return a value as described 
below, and set the <structfield>msg</structfield> field of 
<parameter>stream</parameter> to point to a string describing the error:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
No progress is possible; either <structfield>avail_in</structfield>
or <structfield>avail_out</structfield> was zero.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-deflateBound-1">

<refmeta>
<refentrytitle>deflateBound</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateBound</refname>
<refpurpose>compute compressed data size</refpurpose>
<indexterm id="ix-utillib-deflateBound-1">
  <primary>deflateBound</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateBound</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateBound</function> function shall estimate the size
of buffer required to compress <parameter>sourceLen</parameter>
bytes of data. If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<parameter>sourceLen</parameter> bytes of data, using the
parameters stored in <parameter>stream</parameter>, 
in a single
call to <function>deflate</function> with flush set to
<constant>Z_FINISH</constant>.
</para>
<para>
On entry, <parameter>stream</parameter> 
should
have been initialized via a call to <function>deflateInit_</function>
or <function>deflateInit2_</function>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>deflateBound</function> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <function>deflate</function>.
If the <parameter>stream</parameter> is not correctly initialized,
or is <constant>NULL</constant>, then <function>deflateBound</function>
may return a conservative value that may be larger than 
<parameter>sourceLen</parameter>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateCopy-1">

<refmeta>
<refentrytitle>deflateCopy</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateCopy</refname>
<refpurpose>copy compression stream</refpurpose>
<indexterm id="ix-utillib-deflateCopy-1">
  <primary>deflateCopy</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateCopy</function>
</funcdef>
<paramdef>z_streamp
<parameter>dest</parameter>
</paramdef>
<paramdef>z_streamp
<parameter>source</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateCopy</function> function shall copy the compression state
information in <parameter>source</parameter> to the uninitialized
<structname>z_stream</structname> structure referenced by 
<parameter>dest</parameter>.
</para>
<para>
On successful return, <parameter>dest</parameter> will be an exact copy
of the stream referenced by <parameter>source</parameter>. The input and
output buffer pointers in <structfield>next_in</structfield> and
<structfield>next_out</structfield> will reference the same data.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateCopy</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return a value less than zero to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateCopy</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>source</parameter> is inconsistent, or
either <parameter>source</parameter> or
<parameter>dest</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
This function can be useful when several compression strategies will
be tried, for example when there are several ways of pre-processing the
input data with a filter. The streams that will be discarded should then
be freed by calling <function>deflateEnd</function>. Note that 
<function>deflateCopy</function> duplicates the
internal compression state which can be quite large, so this strategy
may be slow and can consume lots of memory.
</para>
</refsect1>
</refentry>



<refentry id="zlib-deflateEnd-1">

<refmeta>
<refentrytitle>deflateEnd</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateEnd</refname>
<refpurpose>free compression stream state</refpurpose>
<indexterm id="ix-utillib-deflateEnd-1">
  <primary>deflateEnd</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateEnd</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateEnd</function> function shall free all allocated
state information referenced by <parameter>stream</parameter>.
All pending output is discarded, and unprocessed input is ignored.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateEnd</function> shall return  
<returnvalue>Z_OK</returnvalue>, or <returnvalue>Z_DATA_ERROR</returnvalue>
if there was pending output discarded or input unprocessed.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateEnd</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-deflateInit2" xreflabel="deflateInit2.">

<refmeta>
<refentrytitle>deflateInit2_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateInit2_</refname>
<refpurpose>initialize compression system</refpurpose>
<indexterm id="ix-utillib-deflateInit2-1">
  <primary>deflateInit2_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>deflateInit2_</function>
  </funcdef>
  <paramdef>z_streamp <parameter>strm</parameter></paramdef>
  <paramdef>int <parameter>level</parameter></paramdef>
  <paramdef>int <parameter>method</parameter></paramdef>
  <paramdef>int <parameter>windowBits</parameter></paramdef>
  <paramdef>int <parameter>memLevel</parameter></paramdef>
  <paramdef>int <parameter>strategy</parameter></paramdef>
  <paramdef>char * <parameter>version</parameter></paramdef>
  <paramdef>int <parameter>stream_size</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateInit2_</function> function shall initialize the compression
system.
On entry, <parameter>strm</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>deflateInit2_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
The <parameter>method</parameter> selects the compression algorithm to use. LSB
conforming implementation shall support the <constant>Z_DEFLATED</constant> method,
and may support other implementation defined methods.
</para>
<para>
The <parameter>windowBits</parameter> parameter shall be a base 2 logarithm of the window 
size to use, and shall be a value between <constant>8</constant> and <constant>15</constant>.
A smaller value will use less memory, but will result in a poorer compression ratio, 
while a higher value will
give better compression but utilize more memory.
</para>
<para>
The <parameter>memLevel</parameter> parameter specifies how much memory to use for the 
internal state. The value of <parameter>memLevel</parameter> shall be between
<constant>1</constant> and <constant>MAX_MEM_LEVEL</constant>. Smaller values
use less memory but are slower, while higher values use more memory to gain compression speed.
</para>
<para>
The <parameter>strategy</parameter> parameter selects the compression strategy to use:
<variablelist>
<varlistentry>
<term><constant>Z_DEFAULT_STRATEGY</constant></term>
<listitem><para>
use the system default compression strategy. <constant>Z_DEFAULT_STRATEGY</constant>
is particularly appropriate for text data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_FILTERED</constant></term>
<listitem><para>
use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <constant>Z_FILTERED</constant> uses more Huffman encoding
and less string matching than <constant>Z_DEFAULT_STRATEGY</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_HUFFMAN_ONLY</constant></term>
<listitem><para>
force Huffman encoding only, with no string match.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>deflateInit2_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>deflateInit2</function> macro.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateInit2_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateInit2_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateInit2_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateInit" xreflabel="deflateInit.">

<refmeta>
<refentrytitle>deflateInit_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateInit_</refname>
<refpurpose>initialize compression system</refpurpose>
<indexterm id="ix-utillib-deflateInit-1">
  <primary>deflateInit_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateInit_</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>const char *
<parameter>version</parameter>
</paramdef>
<paramdef>int
<parameter>stream_size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateInit_</function> function shall initialize 
the compression
system.
On entry, <parameter>stream</parameter> shall refer to a user 
supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). 
The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory
allocated by the
<structfield>zalloc</structfield> function. If this is
<constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data
that will be passed to the
<structfield>alloc_func</structfield> and
<structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with
the version implemented, or if the size of the
<structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size
in the library
implementation, <function>deflateInit_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a
<parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
The <function>deflateInit_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>deflateInit</function> macro.
</para>
<para>
The <function>deflateInit_</function> function is equivalent to
<programlisting>
 deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, MAX_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
</programlisting>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateInit_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateInit_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateInit_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the 
<parameter>stream</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateParams-1">

<refmeta>
<refentrytitle>deflateParams</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateParams</refname>
<refpurpose>set compression parameters</refpurpose>
<indexterm id="ix-utillib-deflateParams-1">
  <primary>deflateParams</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateParams</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>int
<parameter>strategy</parameter>
</paramdef>
 
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateParams</function> function shall dynamically
alter the compression parameters for the compression stream object
<parameter>stream</parameter>.
On entry, <parameter>stream</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure), already initialized
via a call to <function>deflateInit_</function> or
<function>deflateInit2_</function>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
If the compression level is altered by <function>deflateParams</function>,
and some data has already been compressed with this <parameter>stream</parameter>
(i.e. <structfield>total_in</structfield> is not zero),
and the new <parameter>level</parameter> requires a different
underlying compression method, then <parameter>stream</parameter>
shall be flushed by a call to <function>deflate</function>.
</para>
<para>
The <parameter>strategy</parameter> parameter selects the compression strategy to use:
<variablelist>
<varlistentry>
<term><constant>Z_DEFAULT_STRATEGY</constant></term>
<listitem><para>
use the system default compression strategy. <constant>Z_DEFAULT_STRATEGY</constant>
is particularly appropriate for text data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_FILTERED</constant></term>
<listitem><para>
use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <constant>Z_FILTERED</constant> uses more Huffman encoding
and less string matching than <constant>Z_DEFAULT_STRATEGY</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_HUFFMAN_ONLY</constant></term>
<listitem><para>
force Huffman encoding only, with no string match.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateParams</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateParams</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateParams</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
Insufficient space in <parameter>stream</parameter> 
to flush the current output.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
<refsect1>
<title>Application Usage (Informative)</title>
<para>
Applications should ensure that the <parameter>stream</parameter> is flushed,
e.g. by a call to <userinput>deflate(stream, Z_SYNC_FLUSH)</userinput>
before calling <function>deflateParams</function>, or ensure that there is
sufficient space in <structfield>next_out</structfield> (as identified by
<structfield>avail_out</structfield>) to ensure that all pending output and
all uncompressed input can be flushed in a single call to
<function>deflate</function>.
<note><title>Rationale</title>
<para>
Although the <function>deflateParams</function> function should flush pending output
and compress all pending input, the result is unspecified if there is insufficient
space in the output buffer. Applications should only call <function>deflateParams</function>
when the <parameter>stream</parameter> is effectively empty (flushed).
</para>
<para>
The <function>deflateParams</function> can be used to switch between
compression and straight copy of the
input data, or to switch to a different kind of input data requiring a
different strategy.
</para>
</note>
</para>
</refsect1>
</refentry>
<!--
 Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented ; you
   must not claim that you wrote the original software. If you use this
   software in a product, an acknowledgment in the product documentation
   would be appreciated but is not required.  2. Altered source versions
   must be plainly marked as such, and must not be misrepresented as
   being the original software.  3. This notice may not be removed or
   altered from any source distribution.

Jean-loup Gailly
    jloup@gzip.org
Mark Adler
    madler@alumni.caltech.edu  
-->


<!-- MISSING DEFINITION FOR deflatePrime -->
<!-- Lets just hope nobody notices -->
<refentry id="zlib-deflateReset-1">

<refmeta>
<refentrytitle>deflateReset</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateReset</refname>
<refpurpose>reset compression stream state</refpurpose>
<indexterm id="ix-utillib-deflateReset-1">
  <primary>deflateReset</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateReset</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateReset</function> function shall reset all state
associated with <parameter>stream</parameter>.
All pending output shall be discarded, and the counts of processed
bytes (<structfield>total_in</structfield> and 
<structfield>total_out</structfield>) shall be reset to zero.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateReset</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateReset</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-deflateSetDictionary-1">

<refmeta>
<refentrytitle>deflateSetDictionary</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateSetDictionary</refname>
<refpurpose>initialize compression dictionary</refpurpose>
<indexterm id="ix-utillib-deflateSetDictionary-1">
  <primary>deflateSetDictionary</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateSetDictionary</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>dictionary</parameter>
</paramdef>
<paramdef>uInt
<parameter>dictlen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateSetDictionary</function> function shall initialize the
compression dictionary associated with <parameter>stream</parameter>
using the <parameter>dictlen</parameter> bytes referenced by
<parameter>dictionary</parameter>.
</para>
<para>
The implementation may silently use a subset of the provided dictionary
if the dictionary cannot fit in the current window associated with
<parameter>stream</parameter> (see <function>deflateInit2_</function>).
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
If the dictionary is successfully set, the Adler32 checksum of the entire
provided dictionary
shall be stored in the <structfield>adler</structfield> member of 
<parameter>stream</parameter>. This value may be used by the decompression
system to select the correct dictionary. The compression and decompression 
systems must use the same dictionary.
</para>
<para>
<parameter>stream</parameter> shall reference an initialized compression
stream, with <structfield>total_in</structfield> zero (i.e. no data
has been compressed since the stream was initialized).
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateSetDictionary</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate an error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateSetDictionary</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent, or
<parameter>stream</parameter> 
was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.
</para>
</refsect1>
</refentry>



<refentry id="zlib-get-crc-table-1">

<refmeta>
<refentrytitle>get_crc_table</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>get_crc_table</refname>
<refpurpose>generate a table for crc calculations</refpurpose>
<indexterm id="ix-utillib-get-crc-table-1">
  <primary>get_crc_table</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>const uLongf *
<function>get_crc_table</function>
</funcdef>
<void>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
Generate tables for a byte-wise 32-bit CRC calculation based on the polynomial:
<literal>x<superscript>32</superscript>+x<superscript>26</superscript>+x<superscript>23</superscript>+x<superscript>22</superscript>+x<superscript>16</superscript>+x<superscript>12</superscript>+x<superscript>11</superscript>+x<superscript>10</superscript>+x<superscript>8</superscript>+x<superscript>7</superscript>+x<superscript>5</superscript>+x<superscript>4</superscript>+x<superscript>2</superscript>+x+1</literal>
</para>
<para>
In a multi-threaded application, <function>get_crc_table</function>
should be called by one thread to initialize the tables before any other
thread calls any <literal>libz</literal> function.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>get_crc_table</function> function shall return a
pointer to the first of a set of tables used internally to calculate
CRC-32 values (see <function>crc32</function>).
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<!-- MISSING DEFINITION FOR gzclearerr -->
<!-- Lets just hope nobody notices -->
<refentry id="zlib-gzclose-1">

<refmeta>
<refentrytitle>gzclose</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzclose</refname>
<refpurpose>close a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzclose-1">
  <primary>gzclose</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzclose</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzclose</function> function shall close the compressed file stream
<parameter>file</parameter>.
If <parameter>file</parameter> was open for writing, <function>gzclose</function>
shall first flush any pending output. Any state information allocated shall
be freed.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzclose</function> shall return 
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>gzclose</function> shall return an error value as described below.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzclose</function> may set
the global variable <varname>errno</varname>
to indicate the error.
The <function>gzclose</function> shall return a value other than <constant>Z_OK</constant>
on error.
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem>
<para>
<parameter>file</parameter> was <constant>NULL</constant> (or <constant>Z_NULL</constant>),
or did not refer to an open compressed file stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An error occurred in the underlying base libraries, and the application should check
<varname>errno</varname> for further information.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible during buffer flush (see <function>deflate</function>).
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzdopen-1">

<refmeta>
<refentrytitle>gzdopen</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzdopen</refname>
<refpurpose>open a compressed file</refpurpose>
<indexterm id="ix-utillib-gzdopen-1">
  <primary>gzdopen</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   gzFile <function>gzdopen</function>
  </funcdef>
  <paramdef> int <parameter>fd</parameter></paramdef>
  <paramdef> const char *<parameter>mode</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzdopen</function> function shall attempt to associate
the open file
referenced by <parameter>fd</parameter> with a <type>gzFile</type>
object.
The <parameter>mode</parameter> argument is based on that of 
<function>fopen</function>, but the 
<parameter>mode</parameter> parameter may also contain the following characters:
<variablelist>
<varlistentry>
<term><replaceable>digit</replaceable></term>
<listitem>
<para>
set the compression level to <replaceable>digit</replaceable>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <function>deflateInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><replaceable>[fhR]</replaceable></term>
<listitem>
<para>
set the compression strategy to <replaceable>[fhR]</replaceable>.
The letter <literal>f</literal> corresponds to filtered data, 
the letter <literal>h</literal>
corresponds to Huffman only compression, and 
the letter <literal>R</literal>
corresponds to Run Length Encoding.
See <function>deflateInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>

<para>
If <parameter>fd</parameter> refers to an uncompressed file, and 
<parameter>mode</parameter> refers to a read mode, 
<function>gzdopen</function> shall attempt to open the file and return
a <type>gzFile</type> object suitable for reading directly from the file
without any decompression.
</para>
<para>
If <parameter>mode</parameter>
is <literal>NULL</literal>, or if <parameter>mode</parameter> does not contain
one of <simplelist type=inline>
<member><literal>r</literal></member>
<member><literal>w</literal></member>
<member>or <literal>a</literal></member>
</simplelist>,
<function>gzdopen</function> shall return <constant>Z_NULL</constant>,
and need not set any other error condition.
</para>
</refsect1>
<refsect1>
<title>Example</title>
<para>
<synopsis>
gzdopen(fileno(stdin), "r");
</synopsis>
Attempt to associate the standard input with a <type>gzFile</type> object.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzdopen</function> shall return a 
<type>gzFile</type> object. On failure, 
<function>gzdopen</function> shall return <constant>Z_NULL</constant> and
may set <varname>errno</varname> accordingly.
<NOTE><para>
At version 1.2.2, <varname>zlib</varname>
does not set <varname>errno</varname> for several
error conditions. Applications may not be able to
determine the cause of an error.
</para></NOTE>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzdopen</function> may set
the global variable <varname>errno</varname>
to indicate the error.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzeof-1">

<refmeta>
<refentrytitle>gzeof</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzeof</refname>
<refpurpose>check for end-of-file on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzeof-1">
  <primary>gzeof</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzeof</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzeof</function> function shall test the compressed file stream
<parameter>file</parameter> for end of file.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
If <parameter>file</parameter> was open for reading
and end of file has been reached, <function>gzeof</function> shall return 
<returnvalue>1</returnvalue>.
Otherwise, <function>gzeof</function> shall return <returnvalue>0</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzerror-1">

<refmeta>
<refentrytitle>gzerror</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzerror</refname>
<refpurpose>decode an error on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzerror-1">
  <primary>gzerror</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   const char * <function>gzerror</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int * <parameter>errnum</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzerror</function> function shall return a string describing
the last error to have occurred associated with the open compressed file stream
referred to by <parameter>file</parameter>.
It shall also set the location referenced by
<parameter>errnum</parameter> to an integer value that further identifies the
error.

</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>gzerror</function> function shall return a string that
describes the last error associated with the given
<parameter>file</parameter> compressed file stream.
This string shall have the format
<literal>"%s: %s"</literal>, with the name of the file, followed by a colon,
a space, and the description of the error. If the compressed file stream
was opened by a call to <function>gzdopen</function>, the format of the
filename is unspecified.
<NOTE><TITLE>Rationale</TITLE>
<para>Although in all current implementations of libz file descriptors
are named <literal>"&lt;fd:%d&gt;"</literal>, the code suggests that this
is for debugging purposes only, and may change in a future release.
</para>
</NOTE>
</para>
<para>
It is unspecified if the string returned is determined by the setting
of the <constant>LC_MESSAGES</constant> category in the current locale.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzflush-1">

<refmeta>
<refentrytitle>gzflush</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzflush</refname>
<refpurpose>flush a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzflush-1">
  <primary>gzflush</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>gzflush</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzflush</function> function shall flush pending
output to the compressed file stream identified by
<parameter>file</parameter>, which must be open for writing.

</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines which compressed bits 
are added to the output file.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>gzflush</function>
may return with some data pending output, and not yet written to the file.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>gzflush</function> shall flush all pending output to
<parameter>file</parameter> and align the output to a byte 
boundary.
There may still be data pending compression that is not flushed.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_FULL_FLUSH</constant>,
all output shall be flushed, as for <constant>Z_SYNC_FLUSH</constant>,
and the compression state shall be reset.
There may still be data pending compression that is not flushed.
<note><title>Rationale</title>
<para>
<constant>Z_SYNC_FLUSH</constant> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <constant>Z_FULL_FLUSH</constant>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.
</para>
</note>
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all pending uncompressed data shall be compressed
and all output shall be flushed.
</para>

</refsect2>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzflush</function> shall return the value
<returnvalue>Z_OK</returnvalue>.
Otherwise <function>gzflush</function> shall return
a value to indicate the error, and may set the error number
associated with the compressed file stream 
<parameter>file</parameter>.
<note><para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>
and the flush operation is successful, <function>gzflush</function>
will return <returnvalue>Z_OK</returnvalue>, but the compressed
file stream error value may be set to <constant>Z_STREAM_END</constant>.
</para></note>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzflush</function> shall return an error
value, and may set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications may use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzgetc-1">

<refmeta>
<refentrytitle>gzgetc</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzgetc</refname>
<refpurpose>read a character from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzgetc-1">
  <primary>gzgetc</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzgetc</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzgetc</function> function shall read the next single
character from the compressed file stream
referenced by <parameter>file</parameter>, which shall have been opened
in a read mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzgetc</function> shall return the uncompressed
character read,
otherwise, on end of file or error, <function>gzgetc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On end of file or error, <function>gzgetc</function> shall return
<returnvalue>-1</returnvalue>. Further information can be found
by calling <function>gzerror</function> with a pointer to the 
compressed file stream.
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzgets-1">

<refmeta>
<refentrytitle>gzgets</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzgets</refname>
<refpurpose>read a string from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzgets-1">
  <primary>gzgets</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   char * <function>gzgets</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>char * <parameter>buf</parameter></paramdef>
  <paramdef>int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzgets</function> function shall attempt to read
data from the compressed file stream <parameter>file</parameter>,
uncompressing it into <parameter>buf</parameter> until
either <parameter>len</parameter><literal>-1</literal> bytes
have been inserted into <parameter>buf</parameter>, or until
a newline character has been uncompressed into <parameter>buf</parameter>.
A null byte shall be appended to the uncompressed data. The
<parameter>file</parameter> shall have been opened
in for reading (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzgets</function> shall return a pointer to 
<parameter>buf</parameter>. Otherwise, <function>gzgets</function>
shall return <returnvalue>Z_NULL</returnvalue>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzgets</function> shall 
return <returnvalue>Z_NULL</returnvalue>. The following conditions shall
always be treated as an error:
<simplelist>
<member><parameter>file</parameter> is <constant>NULL</constant>,
or does not refer to a file open for reading;</member>
<member><parameter>buf</parameter> is <constant>NULL</constant>;</member>
<member><parameter>len</parameter> is less than or equal to zero.</member>
</simplelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzopen-1">

<refmeta>
<refentrytitle>gzopen</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzopen</refname>
<refpurpose>open a compressed file</refpurpose>
<indexterm id="ix-utillib-gzopen-1">
  <primary>gzopen</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   gzFile <function>gzopen</function>
  </funcdef>
  <paramdef>const char *<parameter>path</parameter> </paramdef>
  <paramdef>const char *<parameter>mode</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzopen</function> function shall open the compressed file
named by <parameter>path</parameter>.
The <parameter>mode</parameter> argument is based on that of 
<function>fopen</function>, but the 
<parameter>mode</parameter> parameter may also contain the following characters:
<variablelist>
<varlistentry>
<term><replaceable>digit</replaceable></term>
<listitem>
<para>
set the compression level to <replaceable>digit</replaceable>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <function>deflateInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><replaceable>[fhR]</replaceable></term>
<listitem>
<para>
set the compression strategy to <replaceable>[fhR]</replaceable>.
The letter <literal>f</literal> corresponds to filtered data, 
the letter <literal>h</literal>
corresponds to Huffman only compression, and 
the letter <literal>R</literal>
corresponds to Run Length Encoding.
See <function>deflateInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>

<para>
If <parameter>path</parameter> refers to an uncompressed file, and 
<parameter>mode</parameter> refers to a read mode, 
<function>gzopen</function> shall attempt to open the file and return
a <type>gzFile</type> object suitable for reading directly from the file
without any decompression.
</para>
<para>
If <parameter>path</parameter> or <parameter>mode</parameter>
is <literal>NULL</literal>, or if <parameter>mode</parameter> does not contain
one of <simplelist type=inline>
<member><literal>r</literal></member>
<member><literal>w</literal></member>
<member>or <literal>a</literal></member>
</simplelist>,
<function>gzopen</function> shall return <constant>Z_NULL</constant>,
and need not set any other error condition.
</para>
<para>
The <type>gzFile</type> object is also referred to as a compressed file stream.
</para>
</refsect1>
<refsect1>
<title>Example</title>
<para>
<programlisting>
gzopen("file.gz", "w6h");
</programlisting>
Attempt to create a new compressed file, <filename>file.gz</filename>,
at compression level 6 using Huffman only compression.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzopen</function> shall return a 
<type>gzFile</type> object (also known as a <emphasis>compressed
file stream</emphasis>). On failure, 
<function>gzopen</function> shall return <constant>Z_NULL</constant> and
may set <varname>errno</varname> accordingly.
<NOTE><para>
At version 1.2.2, <varname>zlib</varname>
does not set <varname>errno</varname> for several
error conditions. Applications may not be able to
determine the cause of an error.
</para></NOTE>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzopen</function> may set
the global variable <varname>errno</varname>
to indicate the error.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzprintf-1">

<refmeta>
<refentrytitle>gzprintf</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzprintf</refname>
<refpurpose>format data and compress</refpurpose>
<indexterm id="ix-utillib-gzprintf-1">
  <primary>gzprintf</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzprintf</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>const char * <parameter>fmt</parameter></paramdef>
  <varargs>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzprintf</function> function shall format data as for
<function>fprintf</function>, and write the resulting string to the compressed
file stream <parameter>file</parameter>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>gzprintf</function> function
shall return the number of uncompressed bytes
actually written, or a value less than or equal to 
<constant>0</constant> in the event of an error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
If <parameter>file</parameter> is <constant>NULL</constant>, or refers to a 
compressed file stream that has not been opened for writing,
<function>gzprintf</function> shall return <literal>Z_STREAM_ERROR</literal>.
Otherwise, errors are as for <function>gzwrite</function>.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzputc-1">

<refmeta>
<refentrytitle>gzputc</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzputc</refname>
<refpurpose>write character to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzputc-1">
  <primary>gzputc</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzputc</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int <parameter>c</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzputc</function> function shall write the single
character <parameter>c</parameter>, converted from integer to unsigned
character, to the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzputc</function> shall return the value
written, otherwise <function>gzputc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzputc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzputs-1">

<refmeta>
<refentrytitle>gzputs</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzputs</refname>
<refpurpose>string write to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzputs-1">
  <primary>gzputs</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzputs</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>const char * <parameter>s</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzputs</function> function shall write the null terminated
string <parameter>s</parameter> to
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
The terminating null character shall not be written.
The <function>gzputs</function> function shall return the number of 
uncompressed bytes actually written.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzputs</function> shall return the number of uncompressed
bytes actually written to <parameter>file</parameter>.
On error <function>gzputs</function> shall return a value
less than or equal to <constant>0</constant>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzputs</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
If <parameter>file</parameter> is <constant>NULL</constant>, 
<function>gzputs</function> shall return <constant>Z_STREAM_ERR</constant>.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzread-1">

<refmeta>
<refentrytitle>gzread</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzread</refname>
<refpurpose>read from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzread-1">
  <primary>gzread</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzread</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>voidp <parameter>buf</parameter></paramdef>
  <paramdef>unsigned int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzread</function> function shall read data from
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a read mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
The <function>gzread</function> function shall read data from
<parameter>file</parameter>, and uncompress it into 
<parameter>buf</parameter>. At most, <parameter>len</parameter>
bytes of uncompressed data shall be copied to <parameter>buf</parameter>.
If the file is not compressed, <function>gzread</function> shall simply
copy data from <parameter>file</parameter> to <parameter>buf</parameter>
without alteration.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzread</function> shall return the number of bytes
decompressed into <parameter>buf</parameter>.
If <function>gzread</function> returns <constant>0</constant>,
either the end-of-file has been reached
or an underlying read error has occurred. Applications
should use <function>gzerror</function> or <function>gzeof</function>
to determine which occurred.
On other errors, 
<function>gzread</function> shall return a value less than 
<constant>0</constant> and applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzread</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_END</constant></term>
<listitem><para>
End of file has been reached on input.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
A CRC error occurred when reading data; the file is corrupt.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_NEED_DICT</constant></term>
<listitem><para>
A dictionary is needed (see <function>inflateSetDictionary</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to decompress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-gzrewind-1">

<refmeta>
<refentrytitle>gzrewind</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzrewind</refname>
<refpurpose>reset the file-position indicator on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzrewind-1">
  <primary>gzrewind</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>gzrewind</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzrewind</function> function shall set the starting position
for the next read
on compressed file stream <parameter>file</parameter> to the beginning
of file. <parameter>file</parameter> must be open for reading.
</para>
<para>
<function>gzrewind</function> is equivalent to 
<programlisting>(int)gzseek(file, 0L, SEEK_SET)</programlisting>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzrewind</function> shall return 
<returnvalue>0</returnvalue>.
On error, <function>gzrewind</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzrewind</function> shall return <constant>-1</constant>,
indicating that <parameter>file</parameter> is 
<constant>NULL</constant>, or does not represent
an open compressed file stream, or represents a compressed file stream
that is open for writing and is not currently at the beginning of file.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzseek-1">

<refmeta>
<refentrytitle>gzseek</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzseek</refname>
<refpurpose>reposition a file-position indicator in a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzseek-1">
  <primary>gzseek</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>z_off_t
<function>gzseek</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>
<paramdef>z_off_t
<parameter>offset</parameter>
</paramdef>
<paramdef>int
<parameter>whence</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzseek</function> function shall set the file-position
indicator for the compressed file stream <parameter>file</parameter>.
The file-position indicator controls where the next
read or write operation on the compressed file stream shall take place.
The <parameter>offset</parameter> indicates a byte offset in the
uncompressed data. The <parameter>whence</parameter> parameter
may be one of:
<variablelist>
<varlistentry>
<term><constant>SEEK_SET</constant></term>
<listitem><para>
the offset is relative to the start of the uncompressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>SEEK_CUR</constant></term>
<listitem><para>
the offset is relative to the current positition in the uncompressed data.
</para></listitem>
</varlistentry>
</variablelist>
<note><para>
The value <constant>SEEK_END</constant> need not be supported.
</para></note>
</para>
<para>
If the <parameter>file</parameter> is open for writing, the new offset
must be greater than or equal to the current offset. In this case, 
<function>gzseek</function> shall compress a sequence of null bytes
to fill the gap from the previous offset to the new offset.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzseek</function> shall return the resulting
offset in the file expressed
as a byte position in the <emphasis>uncompressed</emphasis> data stream.
On error, <function>gzseek</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzseek</function> shall return 
<returnvalue>-1</returnvalue>.
The following conditions shall always result in an error:
<itemizedlist>
<listitem><para>
<parameter>file</parameter> is <constant>NULL</constant>
</para></listitem>
<listitem><para>
<parameter>file</parameter> does not represent
an open compressed file stream.
</para></listitem>
<listitem><para>
<parameter>file</parameter> refers to a compressed file stream that is open
for writing, and the newly computed offset is less than the current offset.
</para></listitem>
<listitem><para>
The newly computed offset is less than zero.
</para></listitem>
<listitem><para>
<parameter>whence</parameter> is not one of the supported values.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
If <parameter>file</parameter> is open for reading, the implementation
may still need to uncompress all of the data up to the new offset.
As a result, <function>gzseek</function> may be extremely slow
in some circumstances.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzsetparams-1">

<refmeta>
<refentrytitle>gzsetparams</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzsetparams</refname>
<refpurpose>dynamically set compression parameters</refpurpose>
<indexterm id="ix-utillib-gzsetparams-1">
  <primary>gzsetparams</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzsetparams</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int <parameter>level</parameter></paramdef>
  <paramdef>int <parameter>strategy</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzsetparams</function> function shall set the compression level and
compression strategy on the compressed file stream referenced by
<parameter>file</parameter>. The compressed file stream shall have been opened
in a write mode.
The <parameter>level</parameter> and <parameter>strategy</parameter> are as defined
in <XREF Linkend=zlib-deflateinit2>.
If there is any data pending writing, it shall be flushed before the parameters are
updated.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>gzsetparams</function> function shall return 
<constant>Z_OK</constant>. 
<!--
Otherwise, <function>gzsetparams</function> shall return
<constant>Z_STREAM_ERROR</constant>.
-->
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzsetparams</function> shall return one of the
following error indications:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter, or <parameter>file</parameter> not open for writing.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
An internal inconsistency was detected while flushing the previous buffer.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gztell-1">

<refmeta>
<refentrytitle>gztell</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gztell</refname>
<refpurpose>find position on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gztell-1">
  <primary>gztell</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   z_off_t <function>gztell</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gztell</function> function shall return the starting position
for the next read or write operation
on compressed file stream <parameter>file</parameter>. This position represents
the number of bytes from the beginning of file in the uncompressed data.
</para>
<para>
<function>gztell</function> is equivalent to 
<programlisting>gzseek(file, 0L, SEEK_CUR)</programlisting>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
<function>gztell</function> shall return the current offset in the file expressed
as a byte position in the <emphasis>uncompressed</emphasis> data stream.
On error, <function>gztell</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gztell</function> shall return <constant>-1</constant>,
indicating that <parameter>file</parameter> is 
<constant>NULL</constant>, or does not represent
an open compressed file stream.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzwrite-1">

<refmeta>
<refentrytitle>gzwrite</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzwrite</refname>
<refpurpose>write to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzwrite-1">
  <primary>gzwrite</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzwrite</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>voidpc <parameter>buf</parameter></paramdef>
  <paramdef>unsigned int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzwrite</function> function shall write data to
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
On entry, <parameter>buf</parameter> shall point to a buffer containing
<parameter>len</parameter> bytes of uncompressed data.
The <function>gzwrite</function> function shall compress this data and
write it to
<parameter>file</parameter>.
The <function>gzwrite</function> function shall return the number of 
uncompressed bytes actually written.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzwrite</function> shall return the number of 
uncompressed bytes actually written to <parameter>file</parameter>.
On error <function>gzwrite</function> shall return a value
less than or equal to <constant>0</constant>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzwrite</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-inflate-1">

<refmeta>
<refentrytitle>inflate</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflate</refname>
<refpurpose>decompress data</refpurpose>
<indexterm id="ix-utillib-inflate-1">
  <primary>inflate</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflate</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflate</function> function shall attempt to decompress
data until either the input buffer is empty or the output buffer is full.
The <parameter>stream</parameter> references a
<structname>z_stream</structname> structure. Before the first call to
<function>inflate</function>, this structure
should have been initialized by a call to 
<function>inflateInit2_</function>.
<note><para>
<function>inflateInit2_</function> is only in the binary standard; source
level applications should initialize <parameter>stream</parameter>
via a call to <function>inflateInit</function> or 
<function>inflateInit2</function>.
</para></note>
In addition, the <parameter>stream</parameter> input and output buffers
should have been initialized as follows:
<variablelist>
<varlistentry>
<term><structfield>next_in</structfield></term>
<listitem><para>
should point to the data to be decompressed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_in</structfield></term>
<listitem><para>
should contain the number of bytes of data in the
buffer referenced by <structfield>next_in</structfield>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>next_out</structfield></term>
<listitem><para>
should point to a buffer where decompressed data may be placed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_out</structfield></term>
<listitem><para>
should contain the size in bytes of the
buffer referenced by <structfield>next_out</structfield>
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>inflate</function> function
shall perform one or both of the following actions:
<orderedlist>
<listitem><para>
Decompress input data from <structfield>next_in</structfield>
and update <structfield>next_in</structfield>,
<structfield>avail_in</structfield> and
<structfield>total_in</structfield> to reflect the data that has been 
decompressed.
</para></listitem>
<listitem><para>
Fill the output buffer referenced by <structfield>next_out</structfield>,
and update <structfield>next_out</structfield>,
<structfield>avail_out</structfield>, and
<structfield>total_out</structfield> to reflect the decompressed data that 
has been placed there. If <parameter>flush</parameter> is not
<constant>Z_NO_FLUSH</constant>, and
<structfield>avail_out</structfield> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).
</para></listitem>
</orderedlist>
</para>
<para>
The <function>inflate</function> function shall return when either
<structfield>avail_in</structfield> reaches zero (indicating that all the input
data has been compressed), or <structfield>avail_out</structfield> reaches
zero (indicating that the output buffer is full).
</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines when uncompressed bytes
are added to the output buffer in <structfield>next_out</structfield>.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>inflate</function>
may return with some data pending output, and not yet added to the 
output buffer.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>inflate</function> shall flush all pending output to
<structfield>next_out</structfield>, and update 
<structfield>next_out</structfield>
and <structfield>avail_out</structfield> accordingly.
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_BLOCK</constant>,
<function>inflate</function> shall stop adding data to the output
buffer if and when the next compressed block boundary is reached
(see <xref linkend="std.rfc1951">).
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all of the compressed input shall be decompressed and added to
the output. If there is insufficient output space (i.e. the compressed
input data uncompresses to more than <structfield>avail_out</structfield>
bytes), then <function>inflate</function> shall fail and return
<returnvalue>Z_BUF_ERROR</returnvalue>.
</para>
</refsect2>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflate</function> shall return  
<returnvalue>Z_OK</returnvalue> if decompression progress has been made,
or <returnvalue>Z_STREAM_END</returnvalue> if all of the input data
has been decompressed and there was sufficient space in the output
buffer to store the uncompressed result.

On error, <function>inflate</function> shall return a value to indicate
the error.
<note><para>
If <function>inflate</function> returns <returnvalue>Z_OK</returnvalue>
and has set <structfield>avail_out</structfield> to zero, the function should
be called again with the same value for <parameter>flush</parameter>, and with
updated <structfield>next_out</structfield> and 
<structfield>avail_out</structfield> until <function>inflate</function>
returns with either <returnvalue>Z_OK</returnvalue> 
or <returnvalue>Z_STREAM_END</returnvalue>
and a non-zero 
<structfield>avail_out</structfield>.
</para>
</note>
</para>
<para>
On success, <function>inflate</function> shall set the 
<structfield>adler</structfield> to the Adler-32 checksum of
the output produced so far (i.e. <structfield>total_out</structfield>
bytes).
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflate</function> shall return a value as described 
below, and may set the <structfield>msg</structfield> field of 
<parameter>stream</parameter> to point to a string describing the error:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
No progress is possible; either <structfield>avail_in</structfield>
or <structfield>avail_out</structfield> was zero.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_NEED_DICT</constant></term>
<listitem><para>
A preset dictionary is required. The <structfield>adler</structfield>
field shall be set to the Adler-32 checksum of the dictionary chosen
by the compressor.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>



<!-- MISSING DEFINITION FOR inflateBack -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR inflateBackEnd -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR inflateBackInit_ -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR inflateCopy -->
<!-- Lets just hope nobody notices -->
<refentry id="zlib-inflateEnd-1">

<refmeta>
<refentrytitle>inflateEnd</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateEnd</refname>
<refpurpose>free decompression stream state</refpurpose>
<indexterm id="ix-utillib-inflateEnd-1">
  <primary>inflateEnd</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateEnd</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateEnd</function> function shall free all allocated
state information referenced by <parameter>stream</parameter>.
All pending output is discarded, and unprocessed input is ignored.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateEnd</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateEnd</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
<listitem><para>
The <structfield>zfree</structfield> function pointer is
<constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-inflateInit2" xreflabel="inflateInit2.">

<refmeta>
<refentrytitle>inflateInit2_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateInit2_</refname>
<refpurpose>initialize decompression system</refpurpose>
<indexterm id="ix-utillib-inflateInit2-1">
  <primary>inflateInit2_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>inflateInit2_</function>
  </funcdef>
  <paramdef>z_streamp <parameter>strm</parameter></paramdef>
  <paramdef>int <parameter>windowBits</parameter></paramdef>
  <paramdef>char * <parameter>version</parameter></paramdef>
  <paramdef>int <parameter>stream_size</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateInit2_</function> function shall initialize the decompression
system.
On entry, <parameter>strm</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>inflateInit2_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>windowBits</parameter> parameter shall be a base 2 logarithm of the maximum
window 
size to use, and shall be a value between <constant>8</constant> and <constant>15</constant>.
If the input data was compressed with a larger window size, subsequent attempts to
decompress this data will fail with <constant>Z_DATA_ERROR</constant>, rather than try to
allocate a larger window.
</para>
<para>
The <function>inflateInit2_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>inflateInit2</function> macro.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>inflateInit2_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>inflateInit2_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateInit2_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateInit" xreflabel="inflateInit.">

<refmeta>
<refentrytitle>inflateInit_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateInit_</refname>
<refpurpose>initialize decompression system</refpurpose>
<indexterm id="ix-utillib-inflateInit-1">
  <primary>inflateInit_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateInit_</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const char *
<parameter>version</parameter>
</paramdef>
<paramdef>int
<parameter>stream_size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateInit_</function> function shall initialize the
decompression system.
On entry, <parameter>stream</parameter> shall refer to a user supplied
<type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>inflateInit_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <function>inflateInit_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>inflateInit</function> macro.
</para>
<para>
The <function>inflateInit_</function> shall be equivalent to 
<programlisting>
inflateInit2_(strm, MAX_WBITS, version, stream_size);
</programlisting>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>inflateInit_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>inflateInit_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateInit_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateReset-1">

<refmeta>
<refentrytitle>inflateReset</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateReset</refname>
<refpurpose>reset decompression stream state</refpurpose>
<indexterm id="ix-utillib-inflateReset-1">
  <primary>inflateReset</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateReset</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateReset</function> function shall reset all state
associated with <parameter>stream</parameter>.
All pending output shall be discarded, and the counts of processed
bytes (<structfield>total_in</structfield> and 
<structfield>total_out</structfield>) shall be reset to zero.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateReset</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateReset</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-inflateSetDictionary-1">

<refmeta>
<refentrytitle>inflateSetDictionary</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSetDictionary</refname>
<refpurpose>initialize decompression dictionary</refpurpose>
<indexterm id="ix-utillib-inflateSetDictionary-1">
  <primary>inflateSetDictionary</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSetDictionary</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>dictionary</parameter>
</paramdef>
<paramdef>uInt
<parameter>dictlen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSetDictionary</function> function shall initialize the
decompression dictionary associated with <parameter>stream</parameter>
using the <parameter>dictlen</parameter> bytes referenced by
<parameter>dictionary</parameter>.
</para>
<para>
The <function>inflateSetDictionary</function> function should be called
immediately after a call to <function>inflate</function> has failed
with return value <returnvalue>Z_NEED_DICT</returnvalue>. The 
<parameter>dictionary</parameter> must have the same Adler-32
checksum as the dictionary used for
the compression (see <function>deflateSetDictionary</function>).
</para>
<para>
<parameter>stream</parameter> shall reference an initialized decompression
stream, with <structfield>total_in</structfield> zero (i.e. no data
has been decompressed since the stream was initialized).
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateSetDictionary</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return a value as indicated below.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSetDictionary</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent, or
<parameter>stream</parameter> 
was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
The Adler-32 checksum of the supplied dictionary does not match that used
for the compression.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.
</para>
</refsect1>
</refentry>



<refentry id="zlib-inflateSync-1">

<refmeta>
<refentrytitle>inflateSync</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSync</refname>
<refpurpose>advance compression stream to next sync point</refpurpose>
<indexterm id="ix-utillib-inflateSync-1">
  <primary>inflateSync</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSync</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSync</function> function shall advance through the
compressed data in <parameter>stream</parameter>, skipping any invalid
compressed data, until the next full flush point is reached, or all
input is exhausted. See the
description for <function>deflate</function> with flush level
<constant>Z_FULL_FLUSH</constant>.
No output is placed in <structfield>next_out</structfield>.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateSync</function> shall return  
<returnvalue>Z_OK</returnvalue>, and update the
<structfield>next_in</structfield>,
<structfield>avail_in</structfield>, and
<structfield>total_in</structfield>
fields of <parameter>stream</parameter> to reflect the number
of bytes of compressed data that have been skipped.
Otherwise, <function>inflateSync</function>
shall return a value as described below to indicate the
error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSync</function> shall return a value
as described below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
There is no data available to skip over.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
No sync point was found.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-inflateSyncPoint-1">

<refmeta>
<refentrytitle>inflateSyncPoint</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSyncPoint</refname>
<refpurpose>test for synchronization point</refpurpose>
<indexterm id="ix-utillib-inflateSyncPoint-1">
  <primary>inflateSyncPoint</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSyncPoint</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSyncPoint</function> function shall return a non-zero
value if the compressed data stream referenced by
<parameter>stream</parameter> is at a synchronization point. 
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
If the compressed data in <parameter>stream</parameter> is at 
a synchronization point (see <function>deflate</function>
with a flush level of <constant>Z_SYNC_FLUSH</constant> or
<constant>Z_FULL_FLUSH</constant>), <function>inflateSyncPoint</function> 
shall return  a non-zero value, other than <constant>Z_STREAM_ERROR</constant>. 
Otherwise, if the <parameter>stream</parameter> is valid,
<function>inflateSyncPoint</function> shall return 0.
If <parameter>stream</parameter> is invalid, or in an invalid state,
<function>inflateSyncPoint</function> shall return
<returnvalue>Z_STREAM_ERROR</returnvalue> to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSyncPoint</function> shall return a value
as described below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>



<refentry id="zlib-uncompress-1">

<refmeta>
<refentrytitle>uncompress</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>uncompress</refname>
<refpurpose>uncompress data</refpurpose>
<indexterm id="ix-utillib-uncompress-1">
  <primary>uncompress</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>uncompress</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>uncompress</function> function shall attempt to uncompress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>. 
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value is large enough to hold
the entire uncompressed data.
<note><para>
The LSB does not describe any mechanism by which a compressor can
communicate the size required to the uncompressor. 
</para></note>
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of uncompressed data in
<parameter>dest</parameter>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>uncompress</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>uncompress</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>uncompress</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
uncompressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
The compressed data (referenced by <parameter>source</parameter>) was corrupted.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-zError-1">

<refmeta>
<refentrytitle>zError</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>zError</refname>
<refpurpose>translate error number to string</refpurpose>
<indexterm id="ix-utillib-zError-1">
  <primary>zError</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>const char *
<function>zError</function>
</funcdef>
<paramdef>int
<parameter>err</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>zError</function> function shall return the string
identifying the error associated with <parameter>err</parameter>.
This allows for conversion from error code to string for functions
such as <function>compress</function> and <function>uncompress</function>,
that do not always set the string version of an error.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>zError</function> function shall return a 
the string identifying the error associated with 
<parameter>err</parameter>, or <returnvalue>NULL</returnvalue> if
<parameter>err</parameter> is not a valid error code.
</para>
<para>
It is unspecified if the string returned is determined by the setting
of the <constant>LC_MESSAGES</constant> category in the current locale.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


<refentry id="zlib-zlibVersion-1">

<refmeta>
<refentrytitle>zlibVersion</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>zlibVersion</refname>
<refpurpose>discover library version at run time</refpurpose>
<indexterm id="ix-utillib-zlibVersion-1">
  <primary>zlibVersion</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   const char * <function>zlibVersion</function>
  </funcdef>
  <void>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>zlibVersion</function> function shall return the string
identifying the interface version at the time the library was built.
</para>
<para>
Applications should compare the value returned from 
<function>zlibVersion</function> with the macro constant 
<constant>ZLIB_VERSION</constant> for compatibility.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>zlibVersion</function> function shall return a 
the string identifying the version of the library currently implemented.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>


</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libncurses>
<TITLE>Interfaces for libncurses</TITLE>
<PARA>
<XREF LINKEND="lib-libncurses-def"> defines the library name and shared object name
for the libncurses library
</PARA>
<TABLE id="lib-libncurses-def">
<TITLE>libncurses Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libncurses</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libncurses.so.5</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The parameters or return types of the following interfaces 
have had the const qualifier added as shown here, as 
compared to the specification in <xref linkend="std.SUS.CURSES">.
</PARA>
<SCREEN>
<!-- all bug keyname and unctrl are addressed in the next Curses spec -->
extern const char *keyname (int);
extern SCREEN *newterm (const char *, FILE *, FILE *);
extern const char *unctrl (chtype);

extern int mvprintw (int, int, const char *, ...);
extern int mvwprintw (WINDOW *, int, int, const char *, ...);
extern int printw (const char *, ...);
extern int vwprintw (WINDOW *, const char *, va_list);
extern int vw_printw (WINDOW *, const char *, va_list);
extern int wprintw (WINDOW *, const char *, ...);

extern int mvscanw (int, int, const char *, ...);
extern int mvwscanw (WINDOW *, int, int, const char *, ...);
extern int scanw (const char *, ...);
extern int vwscanw (WINDOW *, const char *, va_list);
extern int vw_scanw (WINDOW *, const char *, va_list);
extern int wscanw (WINDOW *, const char *, ...);
</SCREEN>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libncurses.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
<MEMBER ID='REFSTD.libncurses.2'>
[SUS-CURSES] <XREF LINKEND="std.SUS.CURSES">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Curses -->
<SECT2>
<!--libgroup-->
<TITLE>Curses</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Curses</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Curses specified in <XREF linkend="tbl-libncurses-curse-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libncurses-curse-ints">
<TITLE>libncurses - Curses Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>addch</primary></indexterm>addch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>addchnstr</primary></indexterm>addchnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>addchstr</primary></indexterm>addchstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>addnstr</primary></indexterm>addnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addstr</primary></indexterm>addstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_get</primary></indexterm>attr_get <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_off</primary></indexterm>attr_off <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_on</primary></indexterm>attr_on <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_set</primary></indexterm>attr_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attroff</primary></indexterm>attroff <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attron</primary></indexterm>attron <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>attrset</primary></indexterm>attrset <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>baudrate</primary></indexterm>baudrate <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>beep</primary></indexterm>beep <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>bkgd</primary></indexterm>bkgd <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>bkgdset</primary></indexterm>bkgdset <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>border</primary></indexterm>border <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>box</primary></indexterm>box <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>can_change_color</primary></indexterm>can_change_color <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>cbreak</primary></indexterm>cbreak <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>chgat</primary></indexterm>chgat <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>clear</primary></indexterm>clear <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>clearok</primary></indexterm>clearok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>clrtobot</primary></indexterm>clrtobot <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clrtoeol</primary></indexterm>clrtoeol <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>color_content</primary></indexterm>color_content <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>color_set</primary></indexterm>color_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>copywin</primary></indexterm>copywin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>curs_set</primary></indexterm>curs_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>def_prog_mode</primary></indexterm>def_prog_mode <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>def_shell_mode</primary></indexterm>def_shell_mode <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>del_curterm</primary></indexterm>del_curterm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delay_output</primary></indexterm>delay_output <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>delch</primary></indexterm>delch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>deleteln</primary></indexterm>deleteln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>delscreen</primary></indexterm>delscreen <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delwin</primary></indexterm>delwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>derwin</primary></indexterm>derwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>doupdate</primary></indexterm>doupdate <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>dupwin</primary></indexterm>dupwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>echo</primary></indexterm>echo <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>echochar</primary></indexterm>echochar <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>endwin</primary></indexterm>endwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>erase</primary></indexterm>erase <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erasechar</primary></indexterm>erasechar <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>filter</primary></indexterm>filter <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>flash</primary></indexterm>flash <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>flushinp</primary></indexterm>flushinp <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getbkgd</primary></indexterm>getbkgd <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>getch</primary></indexterm>getch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>getnstr</primary></indexterm>getnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>getstr</primary></indexterm>getstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getwin</primary></indexterm>getwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>halfdelay</primary></indexterm>halfdelay <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_colors</primary></indexterm>has_colors <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_ic</primary></indexterm>has_ic <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>has_il</primary></indexterm>has_il <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>hline</primary></indexterm>hline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>idcok</primary></indexterm>idcok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>idlok</primary></indexterm>idlok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>immedok</primary></indexterm>immedok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>inch</primary></indexterm>inch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>inchnstr</primary></indexterm>inchnstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inchstr</primary></indexterm>inchstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>init_color</primary></indexterm>init_color <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>init_pair</primary></indexterm>init_pair <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>initscr</primary></indexterm>initscr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>innstr</primary></indexterm>innstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>insch</primary></indexterm>insch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>insdelln</primary></indexterm>insdelln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>insertln</primary></indexterm>insertln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>insnstr</primary></indexterm>insnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>insstr</primary></indexterm>insstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>instr</primary></indexterm>instr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>intrflush</primary></indexterm>intrflush <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>is_linetouched</primary></indexterm>is_linetouched <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>is_wintouched</primary></indexterm>is_wintouched <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>isendwin</primary></indexterm>isendwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>keyname</primary></indexterm>keyname <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>keypad</primary></indexterm>keypad <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>killchar</primary></indexterm>killchar <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>leaveok</primary></indexterm>leaveok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>longname</primary></indexterm>longname <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>meta</primary></indexterm>meta <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>move</primary></indexterm>move <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddch</primary></indexterm>mvaddch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddchnstr</primary></indexterm>mvaddchnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddchstr</primary></indexterm>mvaddchstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvaddnstr</primary></indexterm>mvaddnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddstr</primary></indexterm>mvaddstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvchgat</primary></indexterm>mvchgat <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvcur</primary></indexterm>mvcur <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvdelch</primary></indexterm>mvdelch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvderwin</primary></indexterm>mvderwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetch</primary></indexterm>mvgetch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetnstr</primary></indexterm>mvgetnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvgetstr</primary></indexterm>mvgetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvhline</primary></indexterm>mvhline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinch</primary></indexterm>mvinch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinchnstr</primary></indexterm>mvinchnstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvinchstr</primary></indexterm>mvinchstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinnstr</primary></indexterm>mvinnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsch</primary></indexterm>mvinsch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsnstr</primary></indexterm>mvinsnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvinsstr</primary></indexterm>mvinsstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinstr</primary></indexterm>mvinstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvprintw</primary></indexterm>mvprintw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvscanw</primary></indexterm>mvscanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvvline</primary></indexterm>mvvline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddch</primary></indexterm>mvwaddch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchnstr</primary></indexterm>mvwaddchnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchstr</primary></indexterm>mvwaddchstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwaddnstr</primary></indexterm>mvwaddnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddstr</primary></indexterm>mvwaddstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwchgat</primary></indexterm>mvwchgat <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwdelch</primary></indexterm>mvwdelch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwgetch</primary></indexterm>mvwgetch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetnstr</primary></indexterm>mvwgetnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetstr</primary></indexterm>mvwgetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwhline</primary></indexterm>mvwhline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwin</primary></indexterm>mvwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinch</primary></indexterm>mvwinch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinchnstr</primary></indexterm>mvwinchnstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinchstr</primary></indexterm>mvwinchstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwinnstr</primary></indexterm>mvwinnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsch</primary></indexterm>mvwinsch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsnstr</primary></indexterm>mvwinsnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsstr</primary></indexterm>mvwinsstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwinstr</primary></indexterm>mvwinstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwprintw</primary></indexterm>mvwprintw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwscanw</primary></indexterm>mvwscanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwvline</primary></indexterm>mvwvline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>napms</primary></indexterm>napms <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>newpad</primary></indexterm>newpad <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>newterm</primary></indexterm>newterm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>newwin</primary></indexterm>newwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nl</primary></indexterm>nl <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>nocbreak</primary></indexterm>nocbreak <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>nodelay</primary></indexterm>nodelay <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>noecho</primary></indexterm>noecho <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nonl</primary></indexterm>nonl <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>noqiflush</primary></indexterm>noqiflush <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>noraw</primary></indexterm>noraw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>notimeout</primary></indexterm>notimeout <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>overlay</primary></indexterm>overlay <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>overwrite</primary></indexterm>overwrite <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>pair_content</primary></indexterm>pair_content <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>pechochar</primary></indexterm>pechochar <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pnoutrefresh</primary></indexterm>pnoutrefresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>prefresh</primary></indexterm>prefresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>printw</primary></indexterm>printw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>putp</primary></indexterm>putp <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>putwin</primary></indexterm>putwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>qiflush</primary></indexterm>qiflush <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>raw</primary></indexterm>raw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>redrawwin</primary></indexterm>redrawwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>refresh</primary></indexterm>refresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_prog_mode</primary></indexterm>reset_prog_mode <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_shell_mode</primary></indexterm>reset_shell_mode <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>resetty</primary></indexterm>resetty <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>restartterm</primary></indexterm>restartterm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>ripoffline</primary></indexterm>ripoffline <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>savetty</primary></indexterm>savetty <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scanw</primary></indexterm>scanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scr_dump</primary></indexterm>scr_dump <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_init</primary></indexterm>scr_init <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_restore</primary></indexterm>scr_restore <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_set</primary></indexterm>scr_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scrl</primary></indexterm>scrl <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scroll</primary></indexterm>scroll <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>scrollok</primary></indexterm>scrollok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>set_curterm</primary></indexterm>set_curterm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>set_term</primary></indexterm>set_term <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>setscrreg</primary></indexterm>setscrreg <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>setupterm</primary></indexterm>setupterm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attr_set</primary></indexterm>slk_attr_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_attroff</primary></indexterm>slk_attroff <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attron</primary></indexterm>slk_attron <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attrset</primary></indexterm>slk_attrset <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_clear</primary></indexterm>slk_clear <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_color</primary></indexterm>slk_color <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_init</primary></indexterm>slk_init <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_label</primary></indexterm>slk_label <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_noutrefresh</primary></indexterm>slk_noutrefresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_refresh</primary></indexterm>slk_refresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_restore</primary></indexterm>slk_restore <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_set</primary></indexterm>slk_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_touch</primary></indexterm>slk_touch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>standend</primary></indexterm>standend <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>standout</primary></indexterm>standout <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>start_color</primary></indexterm>start_color <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>subpad</primary></indexterm>subpad <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>subwin</primary></indexterm>subwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>syncok</primary></indexterm>syncok <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>termattrs</primary></indexterm>termattrs <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>termname</primary></indexterm>termname <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgetent</primary></indexterm>tgetent <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetflag</primary></indexterm>tgetflag <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetnum</primary></indexterm>tgetnum <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetstr</primary></indexterm>tgetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgoto</primary></indexterm>tgoto <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetflag</primary></indexterm>tigetflag <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetnum</primary></indexterm>tigetnum <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetstr</primary></indexterm>tigetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>timeout</primary></indexterm>timeout <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>touchline</primary></indexterm>touchline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>touchwin</primary></indexterm>touchwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tparm</primary></indexterm>tparm <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tputs</primary></indexterm>tputs <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>typeahead</primary></indexterm>typeahead <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>unctrl</primary></indexterm>unctrl <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetch</primary></indexterm>ungetch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>untouchwin</primary></indexterm>untouchwin <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>use_env</primary></indexterm>use_env <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidattr</primary></indexterm>vidattr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidputs</primary></indexterm>vidputs <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vline</primary></indexterm>vline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_printw</primary></indexterm>vw_printw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_scanw</primary></indexterm>vw_scanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwprintw</primary></indexterm>vwprintw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vwscanw</primary></indexterm>vwscanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddch</primary></indexterm>waddch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchnstr</primary></indexterm>waddchnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchstr</primary></indexterm>waddchstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>waddnstr</primary></indexterm>waddnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddstr</primary></indexterm>waddstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_get</primary></indexterm>wattr_get <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_off</primary></indexterm>wattr_off <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wattr_on</primary></indexterm>wattr_on <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_set</primary></indexterm>wattr_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattroff</primary></indexterm>wattroff <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattron</primary></indexterm>wattron <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wattrset</primary></indexterm>wattrset <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgd</primary></indexterm>wbkgd <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgdset</primary></indexterm>wbkgdset <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wborder</primary></indexterm>wborder <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wchgat</primary></indexterm>wchgat <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclear</primary></indexterm>wclear <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclrtobot</primary></indexterm>wclrtobot <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclrtoeol</primary></indexterm>wclrtoeol <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wcolor_set</primary></indexterm>wcolor_set <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcursyncup</primary></indexterm>wcursyncup <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wdelch</primary></indexterm>wdelch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wdeleteln</primary></indexterm>wdeleteln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wechochar</primary></indexterm>wechochar <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>werase</primary></indexterm>werase <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetch</primary></indexterm>wgetch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetnstr</primary></indexterm>wgetnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wgetstr</primary></indexterm>wgetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>whline</primary></indexterm>whline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winch</primary></indexterm>winch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winchnstr</primary></indexterm>winchnstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>winchstr</primary></indexterm>winchstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>winnstr</primary></indexterm>winnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsch</primary></indexterm>winsch <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsdelln</primary></indexterm>winsdelln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>winsertln</primary></indexterm>winsertln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsnstr</primary></indexterm>winsnstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsstr</primary></indexterm>winsstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>winstr</primary></indexterm>winstr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wmove</primary></indexterm>wmove <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wnoutrefresh</primary></indexterm>wnoutrefresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wprintw</primary></indexterm>wprintw <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wredrawln</primary></indexterm>wredrawln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wrefresh</primary></indexterm>wrefresh <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscanw</primary></indexterm>wscanw <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscrl</primary></indexterm>wscrl <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsetscrreg</primary></indexterm>wsetscrreg <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wstandend</primary></indexterm>wstandend <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wstandout</primary></indexterm>wstandout <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsyncdown</primary></indexterm>wsyncdown <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsyncup</primary></indexterm>wsyncup <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wtimeout</primary></indexterm>wtimeout <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wtouchln</primary></indexterm>wtouchln <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>wvline</primary></indexterm>wvline <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Curses specified in <XREF linkend="tbl-libncurses-curse-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libncurses-curse-depints">
<TITLE>libncurses - Curses Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>tgetent</primary></indexterm>tgetent <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetflag</primary></indexterm>tgetflag <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetnum</primary></indexterm>tgetnum <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetstr</primary></indexterm>tgetstr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgoto</primary></indexterm>tgoto <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Curses specified in <XREF linkend="tbl-libncurses-curse-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libncurses-curse-data">
<TITLE>libncurses - Curses Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>COLORS</primary></indexterm>COLORS <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>COLOR_PAIRS</primary></indexterm>COLOR_PAIRS <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>COLS</primary></indexterm>COLS <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>LINES</primary></indexterm>LINES <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>acs_map</primary></indexterm>acs_map <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>cur_term</primary></indexterm>cur_term <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>curscr</primary></indexterm>curscr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>newscr</primary></indexterm>newscr <LINK LINKEND="REFSTD.libncurses.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>stdscr</primary></indexterm>stdscr <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY><indexterm><primary>ttytype</primary></indexterm>ttytype <LINK LINKEND="REFSTD.libncurses.2">[SUS-CURSES]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libncurses-ddefs>
<TITLE>Data Definitions for libncurses</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libncurses.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>curses.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define getattrs(win)	((win)?(win)->_attrs:A_NORMAL)
#define ERR	(-1)
#define OK	(0)
#define ACS_RARROW	(acs_map['+'])
#define ACS_LARROW	(acs_map[','])
#define ACS_UARROW	(acs_map['-'])
#define ACS_DARROW	(acs_map['.'])
#define ACS_BLOCK	(acs_map['0'])
#define ACS_CKBOARD	(acs_map['a'])
#define ACS_DEGREE	(acs_map['f'])
#define ACS_PLMINUS	(acs_map['g'])
#define ACS_BOARD	(acs_map['h'])
#define ACS_LANTERN	(acs_map['i'])
#define ACS_LRCORNER	(acs_map['j'])
#define ACS_URCORNER	(acs_map['k'])
#define ACS_ULCORNER	(acs_map['l'])
#define ACS_LLCORNER	(acs_map['m'])
#define ACS_PLUS	(acs_map['n'])
#define ACS_S1	(acs_map['o'])
#define ACS_HLINE	(acs_map['q'])
#define ACS_S9	(acs_map['s'])
#define ACS_LTEE	(acs_map['t'])
#define ACS_RTEE	(acs_map['u'])
#define ACS_BTEE	(acs_map['v'])
#define ACS_TTEE	(acs_map['w'])
#define ACS_VLINE	(acs_map['x'])
#define ACS_DIAMOND	(acs_map['`'])
#define ACS_BULLET	(acs_map['~'])
#define setsyx(y,x)	do{if((y)==-1&amp;&amp;(x)==-1)newscr->_leaveok=TRUE;else{newscr->_leaveok=FALSE;wmove(newscr,(y),(x));}}while(0)
#define getsyx(y,x)	do{if(newscr->_leaveok)(y)=(x)=-1;elsegetyx(newscr,(y),(x));}while(0)
#define getmaxyx(win,y,x)	\
	(y=(win)?((win)->_maxy+1):ERR,x=(win)?((win)->_maxx+1):ERR)
#define getbegyx(win,y,x)	\
	(y=(win)?(win)->_begy:ERR,x=(win)?(win)->_begx:ERR)
#define getyx(win,y,x)	\
	(y=(win)?(win)->_cury:ERR,x=(win)?(win)->_curx:ERR)
#define getparyx(win,y,x)	\
	(y=(win)?(win)->_pary:ERR,x=(win)?(win)->_parx:ERR)

#define __NCURSES_H	1
#define NCURSES_EXPORT(type)	type
#define NCURSES_EXPORT_VAR(type)	type

#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_BLINK	A_BLINK
#define WA_BOLD	A_BOLD
#define WA_DIM	A_DIM
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_INVIS	A_INVIS
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_NORMAL	A_NORMAL
#define WA_PROTECT	A_PROTECT
#define WA_REVERSE	A_REVERSE
#define WA_RIGHT	A_RIGHT
#define WA_STANDOUT	A_STANDOUT
#define WA_TOP	A_TOP
#define WA_UNDERLINE	A_UNDERLINE
#define WA_VERTICAL	A_VERTICAL
#define A_REVERSE	NCURSES_BITS(1UL,10)

#define COLOR_BLACK	0
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7

#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _SCROLLWIN	0x08
#define _ISPAD	0x10
#define _HASMOVED	0x20

typedef unsigned char bool;

typedef unsigned long int chtype;
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef struct {
    attr_t attr;
    wchar_t chars[5];
} cchar_t;
struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};

struct _win_st {
    short _cury;		/* current cursor position */
    short _curx;
    short _maxy;		/* maximums of x and y, NOT window size */
    short _maxx;
    short _begy;		/* screen coords of upper-left-hand corner */
    short _begx;
    short _flags;		/* window state flags */
    attr_t _attrs;		/* current attribute for non-space character */
    chtype _bkgd;		/* current background char/attribute pair */
    bool _notimeout;		/* no time out on function-key entry? */
    bool _clear;		/* consider all data in the window invalid? */
    bool _leaveok;		/* OK to not reset cursor on exit? */
    bool _scroll;		/* OK to scroll this window? */
    bool _idlok;		/* OK to use insert/delete line? */
    bool _idcok;		/* OK to use insert/delete char? */
    bool _immed;		/* window in immed mode? (not yet used) */
    bool _sync;			/* window in sync mode? */
    bool _use_keypad;		/* process function keys into KEY_ symbols? */
    int _delay;			/* 0 = nodelay, &lt;0 = blocking, >0 = delay */
    struct ldat *_line;		/* the actual line data */
    short _regtop;		/* top line of scrolling region */
    short _regbottom;		/* bottom line of scrolling region */
    int _parx;			/* x coordinate of this window in parent */
    int _pary;			/* y coordinate of this window in parent */
    WINDOW *_parent;		/* pointer to parent if a sub-window */
    struct pdat _pad;
    short _yoffset;		/* real begy is _begy + _yoffset */
    cchar_t _bkgrnd;		/* current background char/attribute pair */
};

#define KEY_F(n)	(KEY_F0+(n))
#define KEY_CODE_YES	0400
#define KEY_BREAK	0401
#define KEY_MIN	0401
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_MAX	0777

#define PAIR_NUMBER(a)	(((a)&amp;A_COLOR)>>8)
#define NCURSES_BITS(mask,shift)	((mask)&lt;&lt;((shift)+8))
#define A_CHARTEXT	(NCURSES_BITS(1UL,0)-1UL)
#define A_NORMAL	0L
#define NCURSES_ATTR_SHIFT	8
#define A_COLOR	NCURSES_BITS(((1UL)&lt;&lt;8)-1UL,0)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define COLOR_PAIR(n)	NCURSES_BITS(n,0)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL-1UL),0)

extern int COLORS;
extern int COLOR_PAIRS;
extern int COLS;
extern int LINES;
extern chtype acs_map[];
extern int addch(const chtype);
extern int addchnstr(const chtype *, int);
extern int addchstr(const chtype *);
extern int addnstr(const char *, int);
extern int addstr(const char *);
extern int attr_get(attr_t *, short *, void *);
extern int attr_off(attr_t, void *);
extern int attr_on(attr_t, void *);
extern int attr_set(attr_t, short, void *);
extern int attroff(int);
extern int attron(int);
extern int attrset(int);
extern int baudrate(void);
extern int beep(void);
extern int bkgd(chtype);
extern void bkgdset(chtype);
extern int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype,
		  chtype);
extern int box(WINDOW *, chtype, chtype);
extern bool can_change_color(void);
extern int cbreak(void);
extern int chgat(int, attr_t, short, const void *);
extern int clear(void);
extern int clearok(WINDOW *, bool);
extern int clrtobot(void);
extern int clrtoeol(void);
extern int color_content(short, short *, short *, short *);
extern int color_set(short, void *);
extern int copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int,
		   int);
extern int curs_set(int);
extern WINDOW *curscr;
extern int def_prog_mode(void);
extern int def_shell_mode(void);
extern int delay_output(int);
extern int delch(void);
extern int deleteln(void);
extern void delscreen(SCREEN *);
extern int delwin(WINDOW *);
extern WINDOW *derwin(WINDOW *, int, int, int, int);
extern int doupdate(void);
extern WINDOW *dupwin(WINDOW *);
extern int echo(void);
extern int echochar(const chtype);
extern int endwin(void);
extern int erase(void);
extern char erasechar(void);
extern void filter(void);
extern int flash(void);
extern int flushinp(void);
extern chtype getbkgd(WINDOW *);
extern int getch(void);
extern int getnstr(char *, int);
extern int getstr(char *);
extern WINDOW *getwin(FILE *);
extern int halfdelay(int);
extern bool has_colors(void);
extern bool has_ic(void);
extern bool has_il(void);
extern int hline(chtype, int);
extern void idcok(WINDOW *, bool);
extern int idlok(WINDOW *, bool);
extern void immedok(WINDOW *, bool);
extern chtype inch(void);
extern int inchnstr(chtype *, int);
extern int inchstr(chtype *);
extern int init_color(short, short, short, short);
extern int init_pair(short, short, short);
extern WINDOW *initscr(void);
extern int innstr(char *, int);
extern int insch(chtype);
extern int insdelln(int);
extern int insertln(void);
extern int insnstr(const char *, int);
extern int insstr(const char *);
extern int instr(char *);
extern int intrflush(WINDOW *, bool);
extern bool is_linetouched(WINDOW *, int);
extern bool is_wintouched(WINDOW *);
extern bool isendwin(void);
extern const char *keyname(int);
extern int keypad(WINDOW *, bool);
extern char killchar(void);
extern int leaveok(WINDOW *, bool);
extern char *longname(void);
extern int meta(WINDOW *, bool);
extern int move(int, int);
extern int mvaddch(int, int, const chtype);
extern int mvaddchnstr(int, int, const chtype *, int);
extern int mvaddchstr(int, int, const chtype *);
extern int mvaddnstr(int, int, const char *, int);
extern int mvaddstr(int, int, const char *);
extern int mvchgat(int, int, int, attr_t, short, const void *);
extern int mvcur(int, int, int, int);
extern int mvdelch(int, int);
extern int mvderwin(WINDOW *, int, int);
extern int mvgetch(int, int);
extern int mvgetnstr(int, int, char *, int);
extern int mvgetstr(int, int, char *);
extern int mvhline(int, int, chtype, int);
extern chtype mvinch(int, int);
extern int mvinchnstr(int, int, chtype *, int);
extern int mvinchstr(int, int, chtype *);
extern int mvinnstr(int, int, char *, int);
extern int mvinsch(int, int, chtype);
extern int mvinsnstr(int, int, const char *, int);
extern int mvinsstr(int, int, const char *);
extern int mvinstr(int, int, char *);
extern int mvprintw(int, int, const char *, ...);
extern int mvscanw(int, int, const char *, ...);
extern int mvvline(int, int, chtype, int);
extern int mvwaddch(WINDOW *, int, int, const chtype);
extern int mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr(WINDOW *, int, int, const chtype *);
extern int mvwaddnstr(WINDOW *, int, int, const char *, int);
extern int mvwaddstr(WINDOW *, int, int, const char *);
extern int mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch(WINDOW *, int, int);
extern int mvwgetch(WINDOW *, int, int);
extern int mvwgetnstr(WINDOW *, int, int, char *, int);
extern int mvwgetstr(WINDOW *, int, int, char *);
extern int mvwhline(WINDOW *, int, int, chtype, int);
extern int mvwin(WINDOW *, int, int);
extern chtype mvwinch(WINDOW *, int, int);
extern int mvwinchnstr(WINDOW *, int, int, chtype *, int);
extern int mvwinchstr(WINDOW *, int, int, chtype *);
extern int mvwinnstr(WINDOW *, int, int, char *, int);
extern int mvwinsch(WINDOW *, int, int, chtype);
extern int mvwinsnstr(WINDOW *, int, int, const char *, int);
extern int mvwinsstr(WINDOW *, int, int, const char *);
extern int mvwinstr(WINDOW *, int, int, char *);
extern int mvwprintw(WINDOW *, int, int, const char *, ...);
extern int mvwscanw(WINDOW *, int, int, const char *, ...);
extern int mvwvline(WINDOW *, int, int, chtype, int);
extern int napms(int);
extern WINDOW *newpad(int, int);
extern WINDOW *newscr;
extern SCREEN *newterm(const char *, FILE *, FILE *);
extern WINDOW *newwin(int, int, int, int);
extern int nl(void);
extern int nocbreak(void);
extern int nodelay(WINDOW *, bool);
extern int noecho(void);
extern int nonl(void);
extern void noqiflush(void);
extern int noraw(void);
extern int notimeout(WINDOW *, bool);
extern int overlay(const WINDOW *, WINDOW *);
extern int overwrite(const WINDOW *, WINDOW *);
extern int pair_content(short, short *, short *);
extern int pechochar(WINDOW *, chtype);
extern int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
extern int prefresh(WINDOW *, int, int, int, int, int, int);
extern int printw(const char *, ...);
extern int putwin(WINDOW *, FILE *);
extern void qiflush(void);
extern int raw(void);
extern int redrawwin(WINDOW *);
extern int refresh(void);
extern int reset_prog_mode(void);
extern int reset_shell_mode(void);
extern int resetty(void);
extern int ripoffline(int, int (*)(WINDOW *, int));
extern int savetty(void);
extern int scanw(const char *, ...);
extern int scr_dump(const char *);
extern int scr_init(const char *);
extern int scr_restore(const char *);
extern int scr_set(const char *);
extern int scrl(int);
extern int scroll(WINDOW *);
extern int scrollok(WINDOW *, bool);
extern SCREEN *set_term(SCREEN *);
extern int setscrreg(int, int);
extern int slk_attr_set(const attr_t, short, void *);
extern int slk_attroff(const chtype);
extern int slk_attron(const chtype);
extern int slk_attrset(const chtype);
extern int slk_clear(void);
extern int slk_color(short);
extern int slk_init(int);
extern char *slk_label(int);
extern int slk_noutrefresh(void);
extern int slk_refresh(void);
extern int slk_restore(void);
extern int slk_set(int, const char *, int);
extern int slk_touch(void);
extern int standend(void);
extern int standout(void);
extern int start_color(void);
extern WINDOW *stdscr;
extern WINDOW *subpad(WINDOW *, int, int, int, int);
extern WINDOW *subwin(WINDOW *, int, int, int, int);
extern int syncok(WINDOW *, bool);
extern chtype termattrs(void);
extern char *termname(void);
extern void timeout(int);
extern int touchline(WINDOW *, int, int);
extern int touchwin(WINDOW *);
extern int typeahead(int);
extern const char *unctrl(chtype);
extern int ungetch(int);
extern int untouchwin(WINDOW *);
extern void use_env(bool);
extern int vidattr(chtype);
extern int vidputs(chtype, int (*)(int));
extern int vline(chtype, int);
extern int vw_printw(WINDOW *, const char *, va_list);
extern int vw_scanw(WINDOW *, const char *, va_list);
extern int vwprintw(WINDOW *, const char *, va_list);
extern int vwscanw(WINDOW *, const char *, va_list);
extern int waddch(WINDOW *, const chtype);
extern int waddchnstr(WINDOW *, const chtype *, int);
extern int waddchstr(WINDOW *, const chtype *);
extern int waddnstr(WINDOW *, const char *, int);
extern int waddstr(WINDOW *, const char *);
extern int wattr_get(WINDOW *, attr_t *, short *, void *);
extern int wattr_off(WINDOW *, attr_t, void *);
extern int wattr_on(WINDOW *, attr_t, void *);
extern int wattr_set(WINDOW *, attr_t, short, void *);
extern int wattroff(WINDOW *, int);
extern int wattron(WINDOW *, int);
extern int wattrset(WINDOW *, int);
extern int wbkgd(WINDOW *, chtype);
extern void wbkgdset(WINDOW *, chtype);
extern int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype,
		   chtype, chtype, chtype);
extern int wchgat(WINDOW *, int, attr_t, short, const void *);
extern int wclear(WINDOW *);
extern int wclrtobot(WINDOW *);
extern int wclrtoeol(WINDOW *);
extern int wcolor_set(WINDOW *, short, void *);
extern void wcursyncup(WINDOW *);
extern int wdelch(WINDOW *);
extern int wdeleteln(WINDOW *);
extern int wechochar(WINDOW *, const chtype);
extern int werase(WINDOW *);
extern int wgetch(WINDOW *);
extern int wgetnstr(WINDOW *, char *, int);
extern int wgetstr(WINDOW *, char *);
extern int whline(WINDOW *, chtype, int);
extern chtype winch(WINDOW *);
extern int winchnstr(WINDOW *, chtype *, int);
extern int winchstr(WINDOW *, chtype *);
extern int winnstr(WINDOW *, char *, int);
extern int winsch(WINDOW *, chtype);
extern int winsdelln(WINDOW *, int);
extern int winsertln(WINDOW *);
extern int winsnstr(WINDOW *, const char *, int);
extern int winsstr(WINDOW *, const char *);
extern int winstr(WINDOW *, char *);
extern int wmove(WINDOW *, int, int);
extern int wnoutrefresh(WINDOW *);
extern int wprintw(WINDOW *, const char *, ...);
extern int wredrawln(WINDOW *, int, int);
extern int wrefresh(WINDOW *);
extern int wscanw(WINDOW *, const char *, ...);
extern int wscrl(WINDOW *, int);
extern int wsetscrreg(WINDOW *, int, int);
extern int wstandend(WINDOW *);
extern int wstandout(WINDOW *);
extern void wsyncdown(WINDOW *);
extern void wsyncup(WINDOW *);
extern void wtimeout(WINDOW *, int);
extern int wtouchln(WINDOW *, int, int, int);
extern int wvline(WINDOW *, chtype, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>term.h</TITLE>
<PARA>
</PARA>
<SCREEN>

extern TERMINAL *cur_term;
extern int del_curterm(TERMINAL *);
extern int putp(const char *);
extern int restartterm(char *, int, int *);
extern TERMINAL *set_curterm(TERMINAL *);
extern int setupterm(char *, int, int *);
extern int tgetent(char *, const char *);
extern int tgetflag(char *);
extern int tgetnum(char *);
extern char *tgetstr(char *, char **);
extern char *tgoto(const char *, int, int);
extern int tigetflag(const char *);
extern int tigetnum(const char *);
extern char *tigetstr(const char *);
extern char *tparm(const char *, ...);
extern int tputs(const char *, int, int (*)(int));
extern char ttytype[];
</SCREEN>
</SECT2>
<!-- empty header file All/unctrl.h -->
</SECT1>
<SECT1 ID=libncursesman>
<TITLE>Interface Definitions for libncurses</TITLE>
<PARA>
The interfaces defined on the following pages are included in libncurses and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libncurses> shall behave as described
in the referenced base document.
</PARA>
<refentry id="curses-inchnstr-1">

<refmeta>
<refentrytitle>inchnstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inchnstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-inchnstr-1">
	<primary>inchnstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inchnstr</function>
</funcdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>
<paramdef>int
<parameter>n</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>inchnstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>inchnstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-inchstr-1">

<refmeta>
<refentrytitle>inchstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inchstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-inchstr-1">
	<primary>inchstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inchstr</function>
</funcdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>inchstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>inchstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-instr-1">

<refmeta>
<refentrytitle>instr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>instr</refname>
<refpurpose>obtain a string of characters from a curses window</refpurpose>
<indexterm id="ix-curses-instr-1">
	<primary>instr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>instr</function>
</funcdef>
<paramdef>char *
<parameter>str</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>instr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>instr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="libncurses-mvcur-1">

<refmeta>
<refentrytitle>mvcur</refentrytitle>
<refmiscinfo>libncurses</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvcur</refname>
<refpurpose>send cursor movement commands to terminal</refpurpose>
<indexterm id="ix-libncurses-mvcur-1">
	<primary>mvcur</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvcur</function>
</funcdef>
<paramdef>int
<parameter>oldrow</parameter>
</paramdef>
<paramdef>int
<parameter>oldcol</parameter>
</paramdef>
<paramdef>int
<parameter>newrow</parameter>
</paramdef>
<paramdef>int
<parameter>newcol</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>The interface <function>mvcur</function> shall behave
as described in <xref linkend="std.SUS.CURSES">,
except that if (<parameter>newrow</parameter>, 
<parameter>newcol</parameter>) is not a valid
address for the terminal in use, the results of the 
<function>mvcur</function> function are
unspecified.
</para>
</refsect1>

</REFENTRY>



<refentry id="curses-mvinchnstr-1">

<refmeta>
<refentrytitle>mvinchnstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvinchnstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-mvinchnstr-1">
	<primary>mvinchnstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvinchnstr</function>
</funcdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>
<paramdef>int
<parameter>n</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvinchnstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvinchnstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvinchstr-1">

<refmeta>
<refentrytitle>mvinchstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvinchstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-mvinchstr-1">
	<primary>mvinchstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvinchstr</function>
</funcdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvinchstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvinchstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvinstr-1">

<refmeta>
<refentrytitle>mvinstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvinstr</refname>
<refpurpose>obtain a string of characters from a curses window</refpurpose>
<indexterm id="ix-curses-mvinstr-1">
	<primary>mvinstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvinstr</function>
</funcdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>char *
<parameter>str</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvinstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvinstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvscanw-1">

<refmeta>
<refentrytitle>mvscanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>mvscanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-mvscanw-1">
	<primary>mvscanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>mvscanw</function>
</funcdef>
<paramdef>int <parameter>y</parameter></paramdef>
<paramdef>int <parameter>x</parameter></paramdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef><parameter>...</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




<refentry id="curses-mvwinchnstr-1">

<refmeta>
<refentrytitle>mvwinchnstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvwinchnstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-mvwinchnstr-1">
	<primary>mvwinchnstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvwinchnstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>
<paramdef>int
<parameter>n</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvwinchnstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvwinchnstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvwinchstr-1">

<refmeta>
<refentrytitle>mvwinchstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvwinchstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-mvwinchstr-1">
	<primary>mvwinchstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvwinchstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvwinchstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvwinchstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvwinstr-1">

<refmeta>
<refentrytitle>mvwinstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>mvwinstr</refname>
<refpurpose>obtain a string of characters from a curses window</refpurpose>
<indexterm id="ix-curses-mvwinstr-1">
	<primary>mvwinstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>mvwinstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>int
<parameter>y</parameter>
</paramdef>
<paramdef>int
<parameter>x</parameter>
</paramdef>
<paramdef>char *
<parameter>str</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>mvwinstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>mvwinstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-mvwscanw-1">

<refmeta>
<refentrytitle>mvwscanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>mvwscanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-mvwscanw-1">
	<primary>mvwscanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>mvwscanw</function>
</funcdef>
<paramdef>WINDOW *<parameter>win</parameter></paramdef>
<paramdef>int <parameter>y</parameter></paramdef>
<paramdef>int <parameter>x</parameter></paramdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef><parameter>...</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




<!-- MISSING DEFINITION FOR newscr -->
<!-- Lets just hope nobody notices -->
<refentry id="curses-ripoffline-1">

<refmeta>
<refentrytitle>ripoffline</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ripoffline</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-ripoffline">
	<primary>ripoffline</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
  <funcdef>int <function>ripoffline</function></funcdef>
    <paramdef>int <parameter>line</parameter></paramdef>
    <paramdef>int 
      (*<parameter>init</parameter>) <funcparams>WINDOW *, int</funcparams></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>ripoffline</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>ripoffline</function> shall
return <literal>-1</literal> if the number of lines that
were ripped off exceeds five.
</para>
</refsect1>
</refentry>


<refentry id="curses-scanw-1">

<refmeta>
<refentrytitle>scanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>scanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-scanw-1">
	<primary>scanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>scanw</function>
</funcdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef><parameter>...</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




<refentry id="curses-vw_scanw-1">

<refmeta>
<refentrytitle>vw_scanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>vw_scanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-vw_scanw-1">
	<primary>vw_scanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>vw_scanw</function>
</funcdef>
<paramdef>WINDOW *<parameter>win</parameter></paramdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef>va_list <parameter>vararglist</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




<refentry id="curses-vwscanw-1">

<refmeta>
<refentrytitle>vwscanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>vwscanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-vwscanw-1">
	<primary>vwscanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>vw_scanw</function>
</funcdef>
<paramdef>WINDOW *<parameter>win</parameter></paramdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef>va_list <parameter>vararglist</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




<refentry id="curses-winchnstr-1">

<refmeta>
<refentrytitle>winchnstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>winchnstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-winchnstr-1">
	<primary>winchnstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>winchnstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>
<paramdef>int
<parameter>n</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>winchnstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>winchnstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-winchstr-1">

<refmeta>
<refentrytitle>winchstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>winchstr</refname>
<refpurpose>obtain a string of characters and their attributes from a curses window</refpurpose>
<indexterm id="ix-curses-winchstr-1">
	<primary>winchstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>winchstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>chtype *
<parameter>chstr</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>winchstr</function> shall behave
as specified in <XREF LINKEND=STD.SUS.CURSES>,
except that <function>winchstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-winstr-1">

<refmeta>
<refentrytitle>winstr</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>winstr</refname>
<refpurpose>obtain a string of characters from a curses window</refpurpose>
<indexterm id="ix-curses-winstr-1">
	<primary>winstr</primary></indexterm>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>winstr</function>
</funcdef>
<paramdef>WINDOW *
<parameter>win</parameter>
</paramdef>
<paramdef>char *
<parameter>str</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
The interface <function>winstr</function> shall behave
as specified in <XREF LINKEND=STD.SUSv4>,
except that <function>winstr</function> shall
return the number of characters that were read.
</para>
</refsect1>
</refentry>


<refentry id="curses-wscanw-1">

<refmeta>
<refentrytitle>wscanw</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta> 

<refnamediv>
<refname>wscanw</refname>
<refpurpose>
convert formatted input from a curses window
</refpurpose>
<indexterm id="ix-curses-wscanw-1">
	<primary>wscanw</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;curses.h&gt;
</funcsynopsisinfo>
<funcprototype>
<funcdef>int
<function>wscanw</function>
</funcdef>
<paramdef>WINDOW *<parameter>win</parameter></paramdef>
<paramdef>const char *<parameter>fmt</parameter></paramdef>
<paramdef><parameter>...</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The scanw family of functions shall behave as
described in <xref linkend="std.SUS.CURSES">,
except as noted below.
</para>
</refsect1>

<refsect1>
<title>Differences</title>
<para>
This function returns <constant>ERR</constant> on failure.
On success it returns the number of successfully matched
and assigned input items.  
This differs from <xref linkend="std.SUS.CURSES">, which
indicates this function returns <constant>OK</constant>
on success.
</para>
</refsect1>
</refentry>




</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libncursesw>
<TITLE>Interfaces for libncursesw</TITLE>
<PARA>
<XREF LINKEND="lib-libncursesw-def"> defines the library name and shared object name
for the libncursesw library
</PARA>
<TABLE id="lib-libncursesw-def">
<TITLE>libncursesw Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libncursesw</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libncursesw.so.5</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libncursesw.1'>
[Libncursesw] <XREF LINKEND="std.Libncursesw">
</MEMBER>
<MEMBER ID='REFSTD.libncursesw.2'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Curses Wide -->
<SECT2>
<!--libgroup-->
<TITLE>Curses Wide</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Curses Wide</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Curses Wide specified in <XREF linkend="tbl-libncursesw-curse-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libncursesw-curse-ints">
<TITLE>libncursesw - Curses Wide Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>add_wch</primary></indexterm>add_wch <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>add_wchnstr</primary></indexterm>add_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>add_wchstr</primary></indexterm>add_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>addch</primary></indexterm>addch <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addchnstr</primary></indexterm>addchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>addchstr</primary></indexterm>addchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>addnstr</primary></indexterm>addnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>addnwstr</primary></indexterm>addnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addstr</primary></indexterm>addstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>addwstr</primary></indexterm>addwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>assume_default_colors</primary></indexterm>assume_default_colors <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_get</primary></indexterm>attr_get <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_off</primary></indexterm>attr_off <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_on</primary></indexterm>attr_on <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>attr_set</primary></indexterm>attr_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>attroff</primary></indexterm>attroff <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attron</primary></indexterm>attron <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>attrset</primary></indexterm>attrset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>baudrate</primary></indexterm>baudrate <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>beep</primary></indexterm>beep <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bkgd</primary></indexterm>bkgd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>bkgdset</primary></indexterm>bkgdset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>bkgrnd</primary></indexterm>bkgrnd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>bkgrndset</primary></indexterm>bkgrndset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>border</primary></indexterm>border <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>border_set</primary></indexterm>border_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>box</primary></indexterm>box <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>box_set</primary></indexterm>box_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>can_change_color</primary></indexterm>can_change_color <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>cbreak</primary></indexterm>cbreak <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>chgat</primary></indexterm>chgat <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>clear</primary></indexterm>clear <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clearok</primary></indexterm>clearok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>clrtobot</primary></indexterm>clrtobot <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>clrtoeol</primary></indexterm>clrtoeol <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>color_content</primary></indexterm>color_content <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>color_set</primary></indexterm>color_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>copywin</primary></indexterm>copywin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>curs_set</primary></indexterm>curs_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>curses_version</primary></indexterm>curses_version <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>def_prog_mode</primary></indexterm>def_prog_mode <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>def_shell_mode</primary></indexterm>def_shell_mode <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>define_key</primary></indexterm>define_key <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>del_curterm</primary></indexterm>del_curterm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delay_output</primary></indexterm>delay_output <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>delch</primary></indexterm>delch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>deleteln</primary></indexterm>deleteln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>delscreen</primary></indexterm>delscreen <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delwin</primary></indexterm>delwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>derwin</primary></indexterm>derwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>doupdate</primary></indexterm>doupdate <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>dupwin</primary></indexterm>dupwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>echo</primary></indexterm>echo <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>echo_wchar</primary></indexterm>echo_wchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>echochar</primary></indexterm>echochar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>endwin</primary></indexterm>endwin <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erase</primary></indexterm>erase <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>erasechar</primary></indexterm>erasechar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>erasewchar</primary></indexterm>erasewchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>filter</primary></indexterm>filter <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>flash</primary></indexterm>flash <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>flushinp</primary></indexterm>flushinp <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>get_wch</primary></indexterm>get_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>get_wstr</primary></indexterm>get_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getbkgd</primary></indexterm>getbkgd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getbkgrnd</primary></indexterm>getbkgrnd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getcchar</primary></indexterm>getcchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getch</primary></indexterm>getch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getmouse</primary></indexterm>getmouse <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getn_wstr</primary></indexterm>getn_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getnstr</primary></indexterm>getnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>getstr</primary></indexterm>getstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getwin</primary></indexterm>getwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>halfdelay</primary></indexterm>halfdelay <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_colors</primary></indexterm>has_colors <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_ic</primary></indexterm>has_ic <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>has_il</primary></indexterm>has_il <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_key</primary></indexterm>has_key <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_mouse</primary></indexterm>has_mouse <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>hline</primary></indexterm>hline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>hline_set</primary></indexterm>hline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>idcok</primary></indexterm>idcok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>idlok</primary></indexterm>idlok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>immedok</primary></indexterm>immedok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>in_wch</primary></indexterm>in_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>in_wchnstr</primary></indexterm>in_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>in_wchstr</primary></indexterm>in_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>inch</primary></indexterm>inch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>inchnstr</primary></indexterm>inchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>inchstr</primary></indexterm>inchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>init_color</primary></indexterm>init_color <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>init_pair</primary></indexterm>init_pair <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>initscr</primary></indexterm>initscr <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>innstr</primary></indexterm>innstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>innwstr</primary></indexterm>innwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>ins_nwstr</primary></indexterm>ins_nwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>ins_wch</primary></indexterm>ins_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>ins_wstr</primary></indexterm>ins_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>insch</primary></indexterm>insch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>insdelln</primary></indexterm>insdelln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>insertln</primary></indexterm>insertln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>insnstr</primary></indexterm>insnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>insstr</primary></indexterm>insstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>instr</primary></indexterm>instr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>intrflush</primary></indexterm>intrflush <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>inwstr</primary></indexterm>inwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>is_linetouched</primary></indexterm>is_linetouched <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>is_wintouched</primary></indexterm>is_wintouched <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>isendwin</primary></indexterm>isendwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>key_name</primary></indexterm>key_name <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>keybound</primary></indexterm>keybound <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>keyname</primary></indexterm>keyname <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>keyok</primary></indexterm>keyok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>keypad</primary></indexterm>keypad <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>killchar</primary></indexterm>killchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>killwchar</primary></indexterm>killwchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>leaveok</primary></indexterm>leaveok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>longname</primary></indexterm>longname <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mcprint</primary></indexterm>mcprint <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>meta</primary></indexterm>meta <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mouse_trafo</primary></indexterm>mouse_trafo <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mouseinterval</primary></indexterm>mouseinterval <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mousemask</primary></indexterm>mousemask <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>move</primary></indexterm>move <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvadd_wch</primary></indexterm>mvadd_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvadd_wchnstr</primary></indexterm>mvadd_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvadd_wchstr</primary></indexterm>mvadd_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddch</primary></indexterm>mvaddch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvaddchnstr</primary></indexterm>mvaddchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddchstr</primary></indexterm>mvaddchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddnstr</primary></indexterm>mvaddnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddnwstr</primary></indexterm>mvaddnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvaddstr</primary></indexterm>mvaddstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddwstr</primary></indexterm>mvaddwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvchgat</primary></indexterm>mvchgat <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvcur</primary></indexterm>mvcur <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvdelch</primary></indexterm>mvdelch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvderwin</primary></indexterm>mvderwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvget_wch</primary></indexterm>mvget_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvget_wstr</primary></indexterm>mvget_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvgetch</primary></indexterm>mvgetch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetn_wstr</primary></indexterm>mvgetn_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetnstr</primary></indexterm>mvgetnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetstr</primary></indexterm>mvgetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvhline</primary></indexterm>mvhline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvhline_set</primary></indexterm>mvhline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvin_wch</primary></indexterm>mvin_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvin_wchnstr</primary></indexterm>mvin_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvin_wchstr</primary></indexterm>mvin_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinch</primary></indexterm>mvinch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinchnstr</primary></indexterm>mvinchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinchstr</primary></indexterm>mvinchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvinnstr</primary></indexterm>mvinnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinnwstr</primary></indexterm>mvinnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvins_nwstr</primary></indexterm>mvins_nwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvins_wch</primary></indexterm>mvins_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvins_wstr</primary></indexterm>mvins_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsch</primary></indexterm>mvinsch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsnstr</primary></indexterm>mvinsnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsstr</primary></indexterm>mvinsstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvinstr</primary></indexterm>mvinstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinwstr</primary></indexterm>mvinwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvprintw</primary></indexterm>mvprintw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvscanw</primary></indexterm>mvscanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvvline</primary></indexterm>mvvline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvvline_set</primary></indexterm>mvvline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwadd_wch</primary></indexterm>mvwadd_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwadd_wchnstr</primary></indexterm>mvwadd_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwadd_wchstr</primary></indexterm>mvwadd_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddch</primary></indexterm>mvwaddch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchnstr</primary></indexterm>mvwaddchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchstr</primary></indexterm>mvwaddchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwaddnstr</primary></indexterm>mvwaddnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddnwstr</primary></indexterm>mvwaddnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddstr</primary></indexterm>mvwaddstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddwstr</primary></indexterm>mvwaddwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwchgat</primary></indexterm>mvwchgat <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwdelch</primary></indexterm>mvwdelch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwget_wch</primary></indexterm>mvwget_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwget_wstr</primary></indexterm>mvwget_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwgetch</primary></indexterm>mvwgetch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetn_wstr</primary></indexterm>mvwgetn_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetnstr</primary></indexterm>mvwgetnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetstr</primary></indexterm>mvwgetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwhline</primary></indexterm>mvwhline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwhline_set</primary></indexterm>mvwhline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwin</primary></indexterm>mvwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwin_wch</primary></indexterm>mvwin_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwin_wchnstr</primary></indexterm>mvwin_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwin_wchstr</primary></indexterm>mvwin_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinch</primary></indexterm>mvwinch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinchnstr</primary></indexterm>mvwinchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwinchstr</primary></indexterm>mvwinchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinnstr</primary></indexterm>mvwinnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinnwstr</primary></indexterm>mvwinnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwins_nwstr</primary></indexterm>mvwins_nwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwins_wch</primary></indexterm>mvwins_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwins_wstr</primary></indexterm>mvwins_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsch</primary></indexterm>mvwinsch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsnstr</primary></indexterm>mvwinsnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwinsstr</primary></indexterm>mvwinsstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinstr</primary></indexterm>mvwinstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinwstr</primary></indexterm>mvwinwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwprintw</primary></indexterm>mvwprintw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>mvwscanw</primary></indexterm>mvwscanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwvline</primary></indexterm>mvwvline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwvline_set</primary></indexterm>mvwvline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>napms</primary></indexterm>napms <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>newpad</primary></indexterm>newpad <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>newterm</primary></indexterm>newterm <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>newwin</primary></indexterm>newwin <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>nl</primary></indexterm>nl <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>nocbreak</primary></indexterm>nocbreak <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>nodelay</primary></indexterm>nodelay <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>noecho</primary></indexterm>noecho <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>nonl</primary></indexterm>nonl <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>noqiflush</primary></indexterm>noqiflush <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>noraw</primary></indexterm>noraw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>notimeout</primary></indexterm>notimeout <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>overlay</primary></indexterm>overlay <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>overwrite</primary></indexterm>overwrite <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>pair_content</primary></indexterm>pair_content <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>pecho_wchar</primary></indexterm>pecho_wchar <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>pechochar</primary></indexterm>pechochar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>pnoutrefresh</primary></indexterm>pnoutrefresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>prefresh</primary></indexterm>prefresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>printw</primary></indexterm>printw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>putp</primary></indexterm>putp <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>putwin</primary></indexterm>putwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>qiflush</primary></indexterm>qiflush <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>raw</primary></indexterm>raw <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>redrawwin</primary></indexterm>redrawwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>refresh</primary></indexterm>refresh <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_prog_mode</primary></indexterm>reset_prog_mode <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_shell_mode</primary></indexterm>reset_shell_mode <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>resetty</primary></indexterm>resetty <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>resizeterm</primary></indexterm>resizeterm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>restartterm</primary></indexterm>restartterm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>ripoffline</primary></indexterm>ripoffline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>savetty</primary></indexterm>savetty <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scanw</primary></indexterm>scanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_dump</primary></indexterm>scr_dump <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_init</primary></indexterm>scr_init <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_restore</primary></indexterm>scr_restore <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>scr_set</primary></indexterm>scr_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scrl</primary></indexterm>scrl <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scroll</primary></indexterm>scroll <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>scrollok</primary></indexterm>scrollok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>set_curterm</primary></indexterm>set_curterm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>set_term</primary></indexterm>set_term <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>setcchar</primary></indexterm>setcchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>setscrreg</primary></indexterm>setscrreg <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>setupterm</primary></indexterm>setupterm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attr</primary></indexterm>slk_attr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attr_off</primary></indexterm>slk_attr_off <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attr_on</primary></indexterm>slk_attr_on <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_attroff</primary></indexterm>slk_attroff <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attron</primary></indexterm>slk_attron <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attrset</primary></indexterm>slk_attrset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_clear</primary></indexterm>slk_clear <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_color</primary></indexterm>slk_color <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_init</primary></indexterm>slk_init <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_label</primary></indexterm>slk_label <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_noutrefresh</primary></indexterm>slk_noutrefresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_refresh</primary></indexterm>slk_refresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_restore</primary></indexterm>slk_restore <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_set</primary></indexterm>slk_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_touch</primary></indexterm>slk_touch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>slk_wset</primary></indexterm>slk_wset <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>standend</primary></indexterm>standend <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>standout</primary></indexterm>standout <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>start_color</primary></indexterm>start_color <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>subpad</primary></indexterm>subpad <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>subwin</primary></indexterm>subwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>syncok</primary></indexterm>syncok <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>term_attrs</primary></indexterm>term_attrs <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>termattrs</primary></indexterm>termattrs <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>termname</primary></indexterm>termname <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetent</primary></indexterm>tgetent <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetflag</primary></indexterm>tgetflag <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgetnum</primary></indexterm>tgetnum <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetstr</primary></indexterm>tgetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgoto</primary></indexterm>tgoto <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetflag</primary></indexterm>tigetflag <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tigetnum</primary></indexterm>tigetnum <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetstr</primary></indexterm>tigetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>timeout</primary></indexterm>timeout <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>touchline</primary></indexterm>touchline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>touchwin</primary></indexterm>touchwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tparm</primary></indexterm>tparm <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tputs</primary></indexterm>tputs <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>typeahead</primary></indexterm>typeahead <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>unctrl</primary></indexterm>unctrl <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>unget_wch</primary></indexterm>unget_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetch</primary></indexterm>ungetch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetmouse</primary></indexterm>ungetmouse <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>untouchwin</primary></indexterm>untouchwin <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>use_default_colors</primary></indexterm>use_default_colors <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>use_env</primary></indexterm>use_env <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>use_extended_names</primary></indexterm>use_extended_names <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vid_attr</primary></indexterm>vid_attr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vid_puts</primary></indexterm>vid_puts <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidattr</primary></indexterm>vidattr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidputs</primary></indexterm>vidputs <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vline</primary></indexterm>vline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vline_set</primary></indexterm>vline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_printw</primary></indexterm>vw_printw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_scanw</primary></indexterm>vw_scanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>vwprintw</primary></indexterm>vwprintw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwscanw</primary></indexterm>vwscanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wadd_wch</primary></indexterm>wadd_wch <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>wadd_wchnstr</primary></indexterm>wadd_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wadd_wchstr</primary></indexterm>wadd_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddch</primary></indexterm>waddch <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchnstr</primary></indexterm>waddchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchstr</primary></indexterm>waddchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>waddnstr</primary></indexterm>waddnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddnwstr</primary></indexterm>waddnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddstr</primary></indexterm>waddstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddwstr</primary></indexterm>waddwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wattr_get</primary></indexterm>wattr_get <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_off</primary></indexterm>wattr_off <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_on</primary></indexterm>wattr_on <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_set</primary></indexterm>wattr_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wattroff</primary></indexterm>wattroff <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattron</primary></indexterm>wattron <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattrset</primary></indexterm>wattrset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgd</primary></indexterm>wbkgd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wbkgdset</primary></indexterm>wbkgdset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgrnd</primary></indexterm>wbkgrnd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgrndset</primary></indexterm>wbkgrndset <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wborder</primary></indexterm>wborder <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wborder_set</primary></indexterm>wborder_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wchgat</primary></indexterm>wchgat <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclear</primary></indexterm>wclear <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclrtobot</primary></indexterm>wclrtobot <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wclrtoeol</primary></indexterm>wclrtoeol <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcolor_set</primary></indexterm>wcolor_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcursyncup</primary></indexterm>wcursyncup <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wdelch</primary></indexterm>wdelch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wdeleteln</primary></indexterm>wdeleteln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wecho_wchar</primary></indexterm>wecho_wchar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wechochar</primary></indexterm>wechochar <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wenclose</primary></indexterm>wenclose <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>werase</primary></indexterm>werase <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wget_wch</primary></indexterm>wget_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wget_wstr</primary></indexterm>wget_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetbkgrnd</primary></indexterm>wgetbkgrnd <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wgetch</primary></indexterm>wgetch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetn_wstr</primary></indexterm>wgetn_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetnstr</primary></indexterm>wgetnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetstr</primary></indexterm>wgetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>whline</primary></indexterm>whline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>whline_set</primary></indexterm>whline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>win_wch</primary></indexterm>win_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>win_wchnstr</primary></indexterm>win_wchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>win_wchstr</primary></indexterm>win_wchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winch</primary></indexterm>winch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winchnstr</primary></indexterm>winchnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winchstr</primary></indexterm>winchstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>winnstr</primary></indexterm>winnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winnwstr</primary></indexterm>winnwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wins_nwstr</primary></indexterm>wins_nwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wins_wch</primary></indexterm>wins_wch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wins_wstr</primary></indexterm>wins_wstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsch</primary></indexterm>winsch <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsdelln</primary></indexterm>winsdelln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsertln</primary></indexterm>winsertln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>winsnstr</primary></indexterm>winsnstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsstr</primary></indexterm>winsstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winstr</primary></indexterm>winstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>winwstr</primary></indexterm>winwstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wmouse_trafo</primary></indexterm>wmouse_trafo <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmove</primary></indexterm>wmove <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wnoutrefresh</primary></indexterm>wnoutrefresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wprintw</primary></indexterm>wprintw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wredrawln</primary></indexterm>wredrawln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wrefresh</primary></indexterm>wrefresh <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wresize</primary></indexterm>wresize <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscanw</primary></indexterm>wscanw <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wscrl</primary></indexterm>wscrl <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsetscrreg</primary></indexterm>wsetscrreg <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wstandend</primary></indexterm>wstandend <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wstandout</primary></indexterm>wstandout <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wsyncdown</primary></indexterm>wsyncdown <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsyncup</primary></indexterm>wsyncup <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wtimeout</primary></indexterm>wtimeout <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wtouchln</primary></indexterm>wtouchln <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>wunctrl</primary></indexterm>wunctrl <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wvline</primary></indexterm>wvline <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>wvline_set</primary></indexterm>wvline_set <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic deprecated functions
for Curses Wide specified in <XREF linkend="tbl-libncursesw-curse-depints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<NOTE><PARA>These interfaces are deprecated, and applications
should avoid using them.
These interfaces may be withdrawn
in future releases of this specification.
</PARA></NOTE>
<!--libgroupdepints-->
<TABLE id="tbl-libncursesw-curse-depints">
<TITLE>libncursesw - Curses Wide Deprecated Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>tgetent</primary></indexterm>tgetent <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetflag</primary></indexterm>tgetflag <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetnum</primary></indexterm>tgetnum <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetstr</primary></indexterm>tgetstr <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>tgoto</primary></indexterm>tgoto <LINK LINKEND="REFSTD.libncursesw.1">[Libncursesw]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Curses Wide specified in <XREF linkend="tbl-libncursesw-curse-data">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libncursesw-curse-data">
<TITLE>libncursesw - Curses Wide Data Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>COLORS</primary></indexterm>COLORS <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>COLOR_PAIRS</primary></indexterm>COLOR_PAIRS <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>COLS</primary></indexterm>COLS <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ESCDELAY</primary></indexterm>ESCDELAY <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>LINES</primary></indexterm>LINES <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>TABSIZE</primary></indexterm>TABSIZE <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>acs_map</primary></indexterm>acs_map <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>cur_term</primary></indexterm>cur_term <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>curscr</primary></indexterm>curscr <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>newscr</primary></indexterm>newscr <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>stdscr</primary></indexterm>stdscr <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>ttytype</primary></indexterm>ttytype <LINK LINKEND="REFSTD.libncursesw.2">[LSB]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libncursesw-ddefs>
<TITLE>Data Definitions for libncursesw</TITLE>
<PARA>
This section defines global identifiers and their values that are associated
with interfaces contained in libncursesw.
These definitions are organized into groups that
correspond to system headers. This convention is used as a
convenience for the reader, and does not imply the existence
of these headers, or their content.
Where an interface is defined as requiring a particular system header file
all of the data definitions for that system header file presented here shall be in effect.
</PARA>
<PARA>
This section gives data definitions to promote binary application
portability, not to repeat source interface definitions available
elsewhere. System providers and application developers should use this ABI
to supplement - not to replace - source interface definition specifications.
</PARA>
<PARA>
This specification uses the <XREF LINKEND='std.ISOC99'> C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>ncursesw/curses.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define CURSES	1
#define setsyx(y,x)	do { if (newscr) { \
				 if ((y) == -1 &amp;&amp; (x) == -1) \
					 leaveok(newscr, TRUE); \
				 else { \
					 leaveok(newscr, FALSE); \
					 wmove(newscr, (y), (x)); \
				} \
			 } \
		  } while(0)
#define getsyx(y,x)	do { if (newscr) { \
				 if (is_leaveok(newscr)) \
					 (y) = (x) = -1; \
				 else \
					 getyx(newscr,(y), (x)); \
			 } \
		 } while(0)
#define CURSES_H	1
#define NCURSES_VERSION_MAJOR	5
#define NCURSES_VERSION_MINOR	9
#define NCURSES_VERSION_PATCH	20110404
#define NCURSES_VERSION	"5.9"
#define NCURSES_MOUSE_VERSION	1
#define NCURSES_ENABLE_STDBOOL_H	1
#define NCURSES_ATTR_T	int
#define NCURSES_INLINE	inline
#define NCURSES_COLOR_T	short
#define NCURSES_SIZE_T	short
#define NCURSES_TPARM_VARARGS	1
#define NCURSES_CH_T	cchar_t
#ifndef TRUE
#define TRUE	1
#endif
#define NCURSES_BOOL	bool
#ifdef __cplusplus
#  define NCURSES_CAST(type,value)        static_cast&lt;type>(value)
#else
#  define NCURSES_CAST(type,value)        (type)(value)
#endif
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_NORMAL	A_NORMAL
#define WA_STANDOUT	A_STANDOUT
#define WA_UNDERLINE	A_UNDERLINE
#define WA_REVERSE	A_REVERSE
#define WA_BLINK	A_BLINK
#define WA_DIM	A_DIM
#define WA_BOLD	A_BOLD
#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_INVIS	A_INVIS
#define WA_PROTECT	A_PROTECT
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_RIGHT	A_RIGHT
#define WA_TOP	A_TOP
#define WA_VERTICAL	A_VERTICAL
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7
#define NCURSES_ACS(c)	(acs_map[NCURSES_CAST(unsigned char,c)])
#define ACS_ULCORNER	NCURSES_ACS('l')
#define ACS_LLCORNER	NCURSES_ACS('m')
#define ACS_URCORNER	NCURSES_ACS('k')
#define ACS_LRCORNER	NCURSES_ACS('j')
#define ACS_LTEE	NCURSES_ACS('t')
#define ACS_RTEE	NCURSES_ACS('u')
#define ACS_BTEE	NCURSES_ACS('v')
#define ACS_TTEE	NCURSES_ACS('w')
#define ACS_HLINE	NCURSES_ACS('q')
#define ACS_VLINE	NCURSES_ACS('x')
#define ACS_PLUS	NCURSES_ACS('n')
#define ACS_S1	NCURSES_ACS('o')
#define ACS_S9	NCURSES_ACS('s')
#define ACS_DIAMOND	NCURSES_ACS('`')
#define ACS_CKBOARD	NCURSES_ACS('a')
#define ACS_DEGREE	NCURSES_ACS('f')
#define ACS_PLMINUS	NCURSES_ACS('g')
#define ACS_BULLET	NCURSES_ACS('~')
#define ACS_LARROW	NCURSES_ACS(',')
#define ACS_RARROW	NCURSES_ACS('+')
#define ACS_DARROW	NCURSES_ACS('.')
#define ACS_UARROW	NCURSES_ACS('-')
#define ACS_BOARD	NCURSES_ACS('h')
#define ACS_LANTERN	NCURSES_ACS('i')
#define ACS_BLOCK	NCURSES_ACS('0')
#define ACS_S3	NCURSES_ACS('p')
#define ACS_S7	NCURSES_ACS('r')
#define ACS_LEQUAL	NCURSES_ACS('y')
#define ACS_GEQUAL	NCURSES_ACS('z')
#define ACS_PI	NCURSES_ACS('{')
#define ACS_NEQUAL	NCURSES_ACS('|')
#define ACS_STERLING	NCURSES_ACS('}')
#define ACS_BSSB	ACS_ULCORNER
#define ACS_SSBB	ACS_LLCORNER
#define ACS_BBSS	ACS_URCORNER
#define ACS_SBBS	ACS_LRCORNER
#define ACS_SBSS	ACS_RTEE
#define ACS_SSSB	ACS_LTEE
#define ACS_SSBS	ACS_BTEE
#define ACS_BSSS	ACS_TTEE
#define ACS_BSBS	ACS_HLINE
#define ACS_SBSB	ACS_VLINE
#define ACS_SSSS	ACS_PLUS
#define ERR	(-1)
#define OK	(0)
#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _SCROLLWIN	0x08
#define _ISPAD	0x10
#define _HASMOVED	0x20
#define _WRAPPED	0x40
#define _NOCHANGE	-1
#define _NEWINDEX	-1
#define CCHARW_MAX	5
#define NCURSES_EXT_COLORS	20110404
#define GCC_PRINTFLIKE(fmt,var)	__attribute__((format(printf,fmt,var)))
#define GCC_SCANFLIKE(fmt,var)	__attribute__((format(scanf,fmt,var)))
#define vid_attr(a,pair,opts)	vidattr(a)
#define NCURSES_EXT_FUNCS	20110404
#define curses_version()	NCURSES_VERSION
#define NCURSES_SP_FUNCS	20110404
#define NCURSES_SP_OUTC	NCURSES_SP_NAME(NCURSES_OUTC)
#define NCURSES_SP_NAME(name)	name
#define NCURSES_ATTR_SHIFT	8
#define NCURSES_BITS(mask,shift)	((mask) &lt;&lt; ((shift) + NCURSES_ATTR_SHIFT))
#define A_NORMAL	(1UL - 1UL)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL - 1UL),0)
#define A_CHARTEXT	(NCURSES_BITS(1UL,0) - 1UL)
#define A_COLOR	NCURSES_BITS(((1UL) &lt;&lt; 8) - 1UL,0)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define A_REVERSE	NCURSES_BITS(1UL,10)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define getyx(win,y,x)	(y = getcury(win), x = getcurx(win))
#define getbegyx(win,y,x)	(y = getbegy(win), x = getbegx(win))
#define getmaxyx(win,y,x)	(y = getmaxy(win), x = getmaxx(win))
#define getparyx(win,y,x)	(y = getpary(win), x = getparx(win))
#define wgetstr(w, s)	wgetnstr(w, s, -1)
#define getnstr(s, n)	wgetnstr(stdscr, s, n)
#define setterm(term)	setupterm(term, 1, (int *)0)
#define fixterm()	reset_prog_mode()
#define resetterm()	reset_shell_mode()
#define saveterm()	def_prog_mode()
#define crmode()	cbreak()
#define nocrmode()	nocbreak()
#define getattrs(win)	NCURSES_CAST(int, (win) ? (win)->_attrs : A_NORMAL)
#define getcurx(win)	((win) ? (win)->_curx : ERR)
#define getcury(win)	((win) ? (win)->_cury : ERR)
#define getbegx(win)	((win) ? (win)->_begx : ERR)
#define getbegy(win)	((win) ? (win)->_begy : ERR)
#define getmaxx(win)	((win) ? ((win)->_maxx + 1) : ERR)
#define getmaxy(win)	((win) ? ((win)->_maxy + 1) : ERR)
#define getparx(win)	((win) ? (win)->_parx : ERR)
#define getpary(win)	((win) ? (win)->_pary : ERR)
#define wstandout(win)	(wattrset(win,A_STANDOUT))
#define wstandend(win)	(wattrset(win,A_NORMAL))
#define wattron(win,at)	wattr_on(win, NCURSES_CAST(attr_t, at), NULL)
#define wattroff(win,at)	wattr_off(win, NCURSES_CAST(attr_t, at), NULL)
#define scroll(win)	wscrl(win,1)
#define touchwin(win)	wtouchln((win), 0, getmaxy(win), 1)
#define touchline(win, s, c)	wtouchln((win), s, c, 1)
#define untouchwin(win)	wtouchln((win), 0, getmaxy(win), 0)
#define box(win, v, h)	wborder(win, v, v, h, h, 0, 0, 0, 0)
#define border(ls, rs, ts, bs, tl, tr, bl, br)	wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)
#define hline(ch, n)	whline(stdscr, ch, n)
#define vline(ch, n)	wvline(stdscr, ch, n)
#define winstr(w, s)	winnstr(w, s, -1)
#define winchstr(w, s)	winchnstr(w, s, -1)
#define winsstr(w, s)	winsnstr(w, s, -1)
#define redrawwin(win)	wredrawln(win, 0, (win)->_maxy+1)
#define waddstr(win,str)	waddnstr(win,str,-1)
#define waddchstr(win,str)	waddchnstr(win,str,-1)
#define COLOR_PAIR(n)	NCURSES_BITS(n, 0)
#define PAIR_NUMBER(a)	(NCURSES_CAST(int,((NCURSES_CAST(unsigned long,a) &amp; A_COLOR) >> NCURSES_ATTR_SHIFT)))
#define addch(ch)	waddch(stdscr,ch)
#define addchnstr(str,n)	waddchnstr(stdscr,str,n)
#define addchstr(str)	waddchstr(stdscr,str)
#define addnstr(str,n)	waddnstr(stdscr,str,n)
#define addstr(str)	waddnstr(stdscr,str,-1)
#define attroff(at)	wattroff(stdscr,at)
#define attron(at)	wattron(stdscr,at)
#define attrset(at)	wattrset(stdscr,at)
#define attr_get(ap,cp,o)	wattr_get(stdscr,ap,cp,o)
#define attr_off(a,o)	wattr_off(stdscr,a,o)
#define attr_on(a,o)	wattr_on(stdscr,a,o)
#define attr_set(a,c,o)	wattr_set(stdscr,a,c,o)
#define bkgd(ch)	wbkgd(stdscr,ch)
#define bkgdset(ch)	wbkgdset(stdscr,ch)
#define chgat(n,a,c,o)	wchgat(stdscr,n,a,c,o)
#define clear()	wclear(stdscr)
#define clrtobot()	wclrtobot(stdscr)
#define clrtoeol()	wclrtoeol(stdscr)
#define color_set(c,o)	wcolor_set(stdscr,c,o)
#define delch()	wdelch(stdscr)
#define deleteln()	winsdelln(stdscr,-1)
#define echochar(c)	wechochar(stdscr,c)
#define erase()	werase(stdscr)
#define getch()	wgetch(stdscr)
#define getstr(str)	wgetstr(stdscr,str)
#define inch()	winch(stdscr)
#define inchnstr(s,n)	winchnstr(stdscr,s,n)
#define inchstr(s)	winchstr(stdscr,s)
#define innstr(s,n)	winnstr(stdscr,s,n)
#define insch(c)	winsch(stdscr,c)
#define insdelln(n)	winsdelln(stdscr,n)
#define insertln()	winsdelln(stdscr,1)
#define insnstr(s,n)	winsnstr(stdscr,s,n)
#define insstr(s)	winsstr(stdscr,s)
#define instr(s)	winstr(stdscr,s)
#define move(y,x)	wmove(stdscr,y,x)
#define refresh()	wrefresh(stdscr)
#define scrl(n)	wscrl(stdscr,n)
#define setscrreg(t,b)	wsetscrreg(stdscr,t,b)
#define standend()	wstandend(stdscr)
#define standout()	wstandout(stdscr)
#define timeout(delay)	wtimeout(stdscr,delay)
#define wdeleteln(win)	winsdelln(win,-1)
#define winsertln(win)	winsdelln(win,1)
#define mvwaddch(win,y,x,ch)	(wmove(win,y,x) == ERR ? ERR : waddch(win,ch))
#define mvwaddchnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))
#define mvwaddchstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))
#define mvwaddnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,n))
#define mvwaddstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,-1))
#define mvwdelch(win,y,x)	(wmove(win,y,x) == ERR ? ERR : wdelch(win))
#define mvwchgat(win,y,x,n,a,c,o)	(wmove(win,y,x) == ERR ? ERR : wchgat(win,n,a,c,o))
#define mvwgetch(win,y,x)	(wmove(win,y,x) == ERR ? ERR : wgetch(win))
#define mvwgetnstr(win,y,x,str,n)	(wmove(win,y,x) == ERR ? ERR : wgetnstr(win,str,n))
#define mvwgetstr(win,y,x,str)	(wmove(win,y,x) == ERR ? ERR : wgetstr(win,str))
#define mvwhline(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : whline(win,c,n))
#define mvwinch(win,y,x)	(wmove(win,y,x) == ERR ? NCURSES_CAST(chtype, ERR) : winch(win))
#define mvwinchnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))
#define mvwinchstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winchstr(win,s))
#define mvwinnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))
#define mvwinsch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : winsch(win,c))
#define mvwinsnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : winsnstr(win,s,n))
#define mvwinsstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winsstr(win,s))
#define mvwinstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : winstr(win,s))
#define mvwvline(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : wvline(win,c,n))
#define mvaddch(y,x,ch)	mvwaddch(stdscr,y,x,ch)
#define mvaddchnstr(y,x,str,n)	mvwaddchnstr(stdscr,y,x,str,n)
#define mvaddchstr(y,x,str)	mvwaddchstr(stdscr,y,x,str)
#define mvaddnstr(y,x,str,n)	mvwaddnstr(stdscr,y,x,str,n)
#define mvaddstr(y,x,str)	mvwaddstr(stdscr,y,x,str)
#define mvchgat(y,x,n,a,c,o)	mvwchgat(stdscr,y,x,n,a,c,o)
#define mvdelch(y,x)	mvwdelch(stdscr,y,x)
#define mvgetch(y,x)	mvwgetch(stdscr,y,x)
#define mvgetnstr(y,x,str,n)	mvwgetnstr(stdscr,y,x,str,n)
#define mvgetstr(y,x,str)	mvwgetstr(stdscr,y,x,str)
#define mvhline(y,x,c,n)	mvwhline(stdscr,y,x,c,n)
#define mvinch(y,x)	mvwinch(stdscr,y,x)
#define mvinchnstr(y,x,s,n)	mvwinchnstr(stdscr,y,x,s,n)
#define mvinchstr(y,x,s)	mvwinchstr(stdscr,y,x,s)
#define mvinnstr(y,x,s,n)	mvwinnstr(stdscr,y,x,s,n)
#define mvinsch(y,x,c)	mvwinsch(stdscr,y,x,c)
#define mvinsnstr(y,x,s,n)	mvwinsnstr(stdscr,y,x,s,n)
#define mvinsstr(y,x,s)	mvwinsstr(stdscr,y,x,s)
#define mvinstr(y,x,s)	mvwinstr(stdscr,y,x,s)
#define mvvline(y,x,c,n)	mvwvline(stdscr,y,x,c,n)
#define getbkgd(win)	((win)->_bkgd)
#define slk_attr_off(a,v)	((v) ? ERR : slk_attroff(a))
#define slk_attr_on(a,v)	((v) ? ERR : slk_attron(a))
#define wattr_set(win,a,p,opts)	((win)->_attrs = (((a) &amp; ~A_COLOR) | (attr_t)COLOR_PAIR(p)), OK)
#define vw_printw	vwprintw
#define vw_scanw	vwscanw
#define vsscanf(a,b,c)	_nc_vsscanf(a,b,c)
#define is_cleared(win)	((win) ? (win)->_clear : FALSE)
#define is_idcok(win)	((win) ? (win)->_idcok : FALSE)
#define is_idlok(win)	((win) ? (win)->_idlok : FALSE)
#define is_immedok(win)	((win) ? (win)->_immed : FALSE)
#define is_keypad(win)	((win) ? (win)->_use_keypad : FALSE)
#define is_leaveok(win)	((win) ? (win)->_leaveok : FALSE)
#define is_nodelay(win)	((win) ? ((win)->_delay == 0) : FALSE)
#define is_notimeout(win)	((win) ? (win)->_notimeout : FALSE)
#define is_pad(win)	((win) ? ((win)->_flags &amp; _ISPAD) != 0 : FALSE)
#define is_scrollok(win)	((win) ? (win)->_scroll : FALSE)
#define is_subwin(win)	((win) ? ((win)->_flags &amp; _SUBWIN) != 0 : FALSE)
#define is_syncok(win)	((win) ? (win)->_sync : FALSE)
#define wgetparent(win)	((win) ? (win)->_parent : 0)
#define wgetscrreg(win,t,b)	((win) ? (*(t) = (win)->_regtop, *(b) = (win)->_regbottom, OK) : ERR)
#define KEY_CODE_YES	0400
#define KEY_MIN	0401
#define KEY_BREAK	0401
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_F(n)	(KEY_F0+(n))
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_EVENT	0633
#define KEY_MAX	0777
#define _XOPEN_CURSES	1
#define NCURSES_WACS(c)	(&amp;_nc_wacs[(unsigned char)c])
#define WACS_BSSB	NCURSES_WACS('l')
#define WACS_SSBB	NCURSES_WACS('m')
#define WACS_BBSS	NCURSES_WACS('k')
#define WACS_SBBS	NCURSES_WACS('j')
#define WACS_SBSS	NCURSES_WACS('u')
#define WACS_SSSB	NCURSES_WACS('t')
#define WACS_SSBS	NCURSES_WACS('v')
#define WACS_BSSS	NCURSES_WACS('w')
#define WACS_BSBS	NCURSES_WACS('q')
#define WACS_SBSB	NCURSES_WACS('x')
#define WACS_SSSS	NCURSES_WACS('n')
#define WACS_ULCORNER	WACS_BSSB
#define WACS_LLCORNER	WACS_SSBB
#define WACS_URCORNER	WACS_BBSS
#define WACS_LRCORNER	WACS_SBBS
#define WACS_RTEE	WACS_SBSS
#define WACS_LTEE	WACS_SSSB
#define WACS_BTEE	WACS_SSBS
#define WACS_TTEE	WACS_BSSS
#define WACS_HLINE	WACS_BSBS
#define WACS_VLINE	WACS_SBSB
#define WACS_PLUS	WACS_SSSS
#define WACS_S1	NCURSES_WACS('o')
#define WACS_S9	NCURSES_WACS('s')
#define WACS_DIAMOND	NCURSES_WACS('`')
#define WACS_CKBOARD	NCURSES_WACS('a')
#define WACS_DEGREE	NCURSES_WACS('f')
#define WACS_PLMINUS	NCURSES_WACS('g')
#define WACS_BULLET	NCURSES_WACS('~')
#define WACS_LARROW	NCURSES_WACS(',')
#define WACS_RARROW	NCURSES_WACS('+')
#define WACS_DARROW	NCURSES_WACS('.')
#define WACS_UARROW	NCURSES_WACS('-')
#define WACS_BOARD	NCURSES_WACS('h')
#define WACS_LANTERN	NCURSES_WACS('i')
#define WACS_BLOCK	NCURSES_WACS('0')
#define WACS_S3	NCURSES_WACS('p')
#define WACS_S7	NCURSES_WACS('r')
#define WACS_LEQUAL	NCURSES_WACS('y')
#define WACS_GEQUAL	NCURSES_WACS('z')
#define WACS_PI	NCURSES_WACS('{')
#define WACS_NEQUAL	NCURSES_WACS('|')
#define WACS_STERLING	NCURSES_WACS('}')
#define WACS_BDDB	NCURSES_WACS('C')
#define WACS_DDBB	NCURSES_WACS('D')
#define WACS_BBDD	NCURSES_WACS('B')
#define WACS_DBBD	NCURSES_WACS('A')
#define WACS_DBDD	NCURSES_WACS('G')
#define WACS_DDDB	NCURSES_WACS('F')
#define WACS_DDBD	NCURSES_WACS('H')
#define WACS_BDDD	NCURSES_WACS('I')
#define WACS_BDBD	NCURSES_WACS('R')
#define WACS_DBDB	NCURSES_WACS('Y')
#define WACS_DDDD	NCURSES_WACS('E')
#define WACS_D_ULCORNER	WACS_BDDB
#define WACS_D_LLCORNER	WACS_DDBB
#define WACS_D_URCORNER	WACS_BBDD
#define WACS_D_LRCORNER	WACS_DBBD
#define WACS_D_RTEE	WACS_DBDD
#define WACS_D_LTEE	WACS_DDDB
#define WACS_D_BTEE	WACS_DDBD
#define WACS_D_TTEE	WACS_BDDD
#define WACS_D_HLINE	WACS_BDBD
#define WACS_D_VLINE	WACS_DBDB
#define WACS_D_PLUS	WACS_DDDD
#define WACS_BTTB	NCURSES_WACS('L')
#define WACS_TTBB	NCURSES_WACS('M')
#define WACS_BBTT	NCURSES_WACS('K')
#define WACS_TBBT	NCURSES_WACS('J')
#define WACS_TBTT	NCURSES_WACS('U')
#define WACS_TTTB	NCURSES_WACS('T')
#define WACS_TTBT	NCURSES_WACS('V')
#define WACS_BTTT	NCURSES_WACS('W')
#define WACS_BTBT	NCURSES_WACS('Q')
#define WACS_TBTB	NCURSES_WACS('X')
#define WACS_TTTT	NCURSES_WACS('N')
#define WACS_T_ULCORNER	WACS_BTTB
#define WACS_T_LLCORNER	WACS_TTBB
#define WACS_T_URCORNER	WACS_BBTT
#define WACS_T_LRCORNER	WACS_TBBT
#define WACS_T_RTEE	WACS_TBTT
#define WACS_T_LTEE	WACS_TTTB
#define WACS_T_BTEE	WACS_TTBT
#define WACS_T_TTEE	WACS_BTTT
#define WACS_T_HLINE	WACS_BTBT
#define WACS_T_VLINE	WACS_TBTB
#define WACS_T_PLUS	WACS_TTTT
#define add_wch(c)	wadd_wch(stdscr,c)
#define add_wchnstr(str,n)	wadd_wchnstr(stdscr,str,n)
#define add_wchstr(str)	wadd_wchstr(stdscr,str)
#define addnwstr(wstr,n)	waddnwstr(stdscr,wstr,n)
#define addwstr(wstr)	waddwstr(stdscr,wstr)
#define bkgrnd(c)	wbkgrnd(stdscr,c)
#define bkgrndset(c)	wbkgrndset(stdscr,c)
#define border_set(l,r,t,b,tl,tr,bl,br)	wborder_set(stdscr,l,r,t,b,tl,tr,bl,br)
#define box_set(w,v,h)	wborder_set(w,v,v,h,h,0,0,0,0)
#define echo_wchar(c)	wecho_wchar(stdscr,c)
#define get_wch(c)	wget_wch(stdscr,c)
#define get_wstr(t)	wget_wstr(stdscr,t)
#define getbkgrnd(wch)	wgetbkgrnd(stdscr,wch)
#define getn_wstr(t,n)	wgetn_wstr(stdscr,t,n)
#define hline_set(c,n)	whline_set(stdscr,c,n)
#define in_wch(c)	win_wch(stdscr,c)
#define in_wchnstr(c,n)	win_wchnstr(stdscr,c,n)
#define in_wchstr(c)	win_wchstr(stdscr,c)
#define innwstr(c,n)	winnwstr(stdscr,c,n)
#define ins_nwstr(t,n)	wins_nwstr(stdscr,t,n)
#define ins_wch(c)	wins_wch(stdscr,c)
#define ins_wstr(t)	wins_wstr(stdscr,t)
#define inwstr(c)	winwstr(stdscr,c)
#define vline_set(c,n)	wvline_set(stdscr,c,n)
#define wadd_wchstr(win,str)	wadd_wchnstr(win,str,-1)
#define waddwstr(win,wstr)	waddnwstr(win,wstr,-1)
#define wget_wstr(w,t)	wgetn_wstr(w,t,-1)
#define win_wchstr(w,c)	win_wchnstr(w,c,-1)
#define wins_wstr(w,t)	wins_nwstr(w,t,-1)
#define wgetbkgrnd(win,wch)	(*wch = win->_bkgrnd, OK)
#define mvadd_wch(y,x,c)	mvwadd_wch(stdscr,y,x,c)
#define mvadd_wchnstr(y,x,s,n)	mvwadd_wchnstr(stdscr,y,x,s,n)
#define mvadd_wchstr(y,x,s)	mvwadd_wchstr(stdscr,y,x,s)
#define mvaddnwstr(y,x,wstr,n)	mvwaddnwstr(stdscr,y,x,wstr,n)
#define mvaddwstr(y,x,wstr)	mvwaddwstr(stdscr,y,x,wstr)
#define mvget_wch(y,x,c)	mvwget_wch(stdscr,y,x,c)
#define mvget_wstr(y,x,t)	mvwget_wstr(stdscr,y,x,t)
#define mvgetn_wstr(y,x,t,n)	mvwgetn_wstr(stdscr,y,x,t,n)
#define mvhline_set(y,x,c,n)	mvwhline_set(stdscr,y,x,c,n)
#define mvin_wch(y,x,c)	mvwin_wch(stdscr,y,x,c)
#define mvin_wchnstr(y,x,c,n)	mvwin_wchnstr(stdscr,y,x,c,n)
#define mvin_wchstr(y,x,c)	mvwin_wchstr(stdscr,y,x,c)
#define mvinnwstr(y,x,c,n)	mvwinnwstr(stdscr,y,x,c,n)
#define mvins_nwstr(y,x,t,n)	mvwins_nwstr(stdscr,y,x,t,n)
#define mvins_wch(y,x,c)	mvwins_wch(stdscr,y,x,c)
#define mvins_wstr(y,x,t)	mvwins_wstr(stdscr,y,x,t)
#define mvinwstr(y,x,c)	mvwinwstr(stdscr,y,x,c)
#define mvvline_set(y,x,c,n)	mvwvline_set(stdscr,y,x,c,n)
#define mvwadd_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wadd_wch(win,c))
#define mvwadd_wchnstr(win,y,x,s,n)	(wmove(win,y,x) == ERR ? ERR : wadd_wchnstr(win,s,n))
#define mvwadd_wchstr(win,y,x,s)	(wmove(win,y,x) == ERR ? ERR : wadd_wchstr(win,s))
#define mvwaddnwstr(win,y,x,wstr,n)	(wmove(win,y,x) == ERR ? ERR : waddnwstr(win,wstr,n))
#define mvwaddwstr(win,y,x,wstr)	(wmove(win,y,x) == ERR ? ERR : waddwstr(win,wstr))
#define mvwget_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wget_wch(win,c))
#define mvwget_wstr(win,y,x,t)	(wmove(win,y,x) == ERR ? ERR : wget_wstr(win,t))
#define mvwgetn_wstr(win,y,x,t,n)	(wmove(win,y,x) == ERR ? ERR : wgetn_wstr(win,t,n))
#define mvwhline_set(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : whline_set(win,c,n))
#define mvwin_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : win_wch(win,c))
#define mvwin_wchnstr(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : win_wchnstr(win,c,n))
#define mvwin_wchstr(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : win_wchstr(win,c))
#define mvwinnwstr(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : winnwstr(win,c,n))
#define mvwins_nwstr(win,y,x,t,n)	(wmove(win,y,x) == ERR ? ERR : wins_nwstr(win,t,n))
#define mvwins_wch(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : wins_wch(win,c))
#define mvwins_wstr(win,y,x,t)	(wmove(win,y,x) == ERR ? ERR : wins_wstr(win,t))
#define mvwinwstr(win,y,x,c)	(wmove(win,y,x) == ERR ? ERR : winwstr(win,c))
#define mvwvline_set(win,y,x,c,n)	(wmove(win,y,x) == ERR ? ERR : wvline_set(win,c,n))
#define NCURSES_MOUSE_MASK(b,m)	((m) &lt;&lt; (((b) - 1) * 6))
#define NCURSES_BUTTON_RELEASED	001L
#define NCURSES_BUTTON_PRESSED	002L
#define NCURSES_BUTTON_CLICKED	004L
#define NCURSES_DOUBLE_CLICKED	010L
#define NCURSES_TRIPLE_CLICKED	020L
#define NCURSES_RESERVED_EVENT	040L
#define BUTTON1_RELEASED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)
#define BUTTON1_PRESSED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_PRESSED)
#define BUTTON1_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_CLICKED)
#define BUTTON1_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_DOUBLE_CLICKED)
#define BUTTON1_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(1, NCURSES_TRIPLE_CLICKED)
#define BUTTON2_RELEASED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_RELEASED)
#define BUTTON2_PRESSED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_PRESSED)
#define BUTTON2_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_CLICKED)
#define BUTTON2_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_DOUBLE_CLICKED)
#define BUTTON2_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(2, NCURSES_TRIPLE_CLICKED)
#define BUTTON3_RELEASED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_RELEASED)
#define BUTTON3_PRESSED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_PRESSED)
#define BUTTON3_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_CLICKED)
#define BUTTON3_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_DOUBLE_CLICKED)
#define BUTTON3_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(3, NCURSES_TRIPLE_CLICKED)
#define BUTTON4_RELEASED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_RELEASED)
#define BUTTON4_PRESSED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_PRESSED)
#define BUTTON4_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_CLICKED)
#define BUTTON4_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_DOUBLE_CLICKED)
#define BUTTON4_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(4, NCURSES_TRIPLE_CLICKED)
#define BUTTON5_RELEASED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_RELEASED)
#define BUTTON5_PRESSED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_PRESSED)
#define BUTTON5_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_BUTTON_CLICKED)
#define BUTTON5_DOUBLE_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_DOUBLE_CLICKED)
#define BUTTON5_TRIPLE_CLICKED	NCURSES_MOUSE_MASK(5, NCURSES_TRIPLE_CLICKED)
#define BUTTON_CTRL	NCURSES_MOUSE_MASK(6, 0001L)
#define BUTTON_SHIFT	NCURSES_MOUSE_MASK(6, 0002L)
#define BUTTON_ALT	NCURSES_MOUSE_MASK(6, 0004L)
#define REPORT_MOUSE_POSITION	NCURSES_MOUSE_MASK(6, 0010L)
#define BUTTON1_RESERVED_EVENT	NCURSES_MOUSE_MASK(1, NCURSES_RESERVED_EVENT)
#define BUTTON2_RESERVED_EVENT	NCURSES_MOUSE_MASK(2, NCURSES_RESERVED_EVENT)
#define BUTTON3_RESERVED_EVENT	NCURSES_MOUSE_MASK(3, NCURSES_RESERVED_EVENT)
#define BUTTON4_RESERVED_EVENT	NCURSES_MOUSE_MASK(4, NCURSES_RESERVED_EVENT)
#define ALL_MOUSE_EVENTS	(REPORT_MOUSE_POSITION - 1)
#define BUTTON_RELEASE(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 001))
#define BUTTON_PRESS(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 002))
#define BUTTON_CLICK(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 004))
#define BUTTON_DOUBLE_CLICK(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 010))
#define BUTTON_TRIPLE_CLICK(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 020))
#define BUTTON_RESERVED_EVENT(e,	x) ((e) &amp; NCURSES_MOUSE_MASK(x, 040))
#define mouse_trafo(y,x,to_screen)	wmouse_trafo(stdscr,y,x,to_screen)
#define _tracech_t	_tracecchar_t
#define _tracech_t2	_tracecchar_t2
#define TRACE_DISABLE	0x0000
#define TRACE_TIMES	0x0001
#define TRACE_TPUTS	0x0002
#define TRACE_UPDATE	0x0004
#define TRACE_MOVE	0x0008
#define TRACE_CHARPUT	0x0010
#define TRACE_ORDINARY	0x001F
#define TRACE_CALLS	0x0020
#define TRACE_VIRTPUT	0x0040
#define TRACE_IEVENT	0x0080
#define TRACE_BITS	0x0100
#define TRACE_ICALLS	0x0200
#define TRACE_CCALLS	0x0400
#define TRACE_DATABASE	0x0800
#define TRACE_ATTRS	0x1000
#define TRACE_SHIFT	13
#define TRACE_MAXIMUM	((1 &lt;&lt; TRACE_SHIFT) - 1)
#define OPTIMIZE_MVCUR	0x01
#define OPTIMIZE_HASHMAP	0x02
#define OPTIMIZE_SCROLL	0x04
#define OPTIMIZE_ALL	0xff

typedef unsigned long int chtype;
typedef chtype attr_t;

struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef unsigned long int mmask_t;
typedef unsigned char bool;

typedef unsigned char NCURSES_BOOL;
typedef int (*NCURSES_OUTC) (int);
typedef int (*NCURSES_WINDOW_CB) (WINDOW *, void *);
typedef int (*NCURSES_SCREEN_CB) (SCREEN *, void *);
struct _win_st {
    short _cury;		/* current cursor position */
    short _curx;
    short _maxy;		/* maximums of x and y, NOT window size */
    short _maxx;
    short _begy;		/* screen coords of upper-left-hand corner */
    short _begx;
    short _flags;		/* window state flags */
    attr_t _attrs;		/* current attribute for non-space character */
    chtype _bkgd;		/* current background char/attribute pair */
    bool _notimeout;		/* no time out on function-key entry? */
    bool _clear;		/* consider all data in the window invalid? */
    bool _leaveok;		/* OK to not reset cursor on exit? */
    bool _scroll;		/* OK to scroll this window? */
    bool _idlok;		/* OK to use insert/delete line? */
    bool _idcok;		/* OK to use insert/delete char? */
    bool _immed;		/* window in immed mode? (not yet used) */
    bool _sync;			/* window in sync mode? */
    bool _use_keypad;		/* process function keys into KEY_ symbols? */
    int _delay;			/* 0 = nodelay, &lt;0 = blocking, >0 = delay */
    struct ldat *_line;		/* the actual line data */
    short _regtop;		/* top line of scrolling region */
    short _regbottom;		/* bottom line of scrolling region */
    int _parx;			/* x coordinate of this window in parent */
    int _pary;			/* y coordinate of this window in parent */
    WINDOW *_parent;		/* pointer to parent if a sub-window */
    struct pdat _pad;
    short _yoffset;		/* real begy is _begy + _yoffset */
    cchar_t _bkgrnd;		/* current background char/attribute pair */
};
int (*_bkgrnd) (WINDOW *, int);
struct ldat;
extern int COLORS;
extern int COLOR_PAIRS;
extern int COLS;
extern int ESCDELAY;
extern int LINES;
extern int TABSIZE;
extern chtype acs_map[];
extern int add_wch(cchar_t *);
extern int add_wchnstr(cchar_t *, int);
extern int add_wchstr(cchar_t *);
extern int addch(const chtype);
extern int addchnstr(const chtype *, int);
extern int addchstr(const chtype *);
extern int addnstr(const char *, int);
extern int addnwstr(wchar_t *, int);
extern int addstr(const char *);
extern int addwstr(wchar_t *);
extern int assume_default_colors(int, int);
extern int attr_get(attr_t *, short *, void *);
extern int attr_off(attr_t, void *);
extern int attr_on(attr_t, void *);
extern int attr_set(attr_t, short, void *);
extern int attroff(int);
extern int attron(int);
extern int attrset(int);
extern int baudrate(void);
extern int beep(void);
extern int bkgd(chtype);
extern void bkgdset(chtype);
extern int bkgrnd(cchar_t *);
extern void bkgrndset(cchar_t *);
extern int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype,
		  chtype);
extern int border_set(cchar_t *, cchar_t *, cchar_t *, cchar_t *,
		      cchar_t *, cchar_t *, cchar_t *, cchar_t *);
extern int box(WINDOW *, chtype, chtype);
extern int box_set(WINDOW *, cchar_t *, cchar_t *);
extern unsigned char can_change_color(void);
extern int cbreak(void);
extern int chgat(int, attr_t, short, const void *);
extern int clear(void);
extern int clearok(WINDOW *, unsigned char);
extern int clrtobot(void);
extern int clrtoeol(void);
extern int color_content(short, short *, short *, short *);
extern int color_set(short, void *);
extern int copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int,
		   int);
extern int curs_set(int);
extern WINDOW *curscr;
extern const char *curses_version(void);
extern int def_prog_mode(void);
extern int def_shell_mode(void);
extern int define_key(const char *, int);
extern int delay_output(int);
extern int delch(void);
extern int deleteln(void);
extern void delscreen(SCREEN *);
extern int delwin(WINDOW *);
extern WINDOW *derwin(WINDOW *, int, int, int, int);
extern int doupdate(void);
extern WINDOW *dupwin(WINDOW *);
extern int echo(void);
extern int echo_wchar(cchar_t *);
extern int echochar(const chtype);
extern int endwin(void);
extern int erase(void);
extern char erasechar(void);
extern int erasewchar(wchar_t *);
extern void filter(void);
extern int flash(void);
extern int flushinp(void);
extern int get_wch(wint_t *);
extern int get_wstr(wint_t *);
extern chtype getbkgd(WINDOW *);
extern int getbkgrnd(cchar_t *);
extern int getcchar(cchar_t *, wchar_t *, attr_t *, short *, void *);
extern int getch(void);
extern int getmouse(MEVENT *);
extern int getn_wstr(wint_t *, int);
extern int getnstr(char *, int);
extern int getstr(char *);
extern WINDOW *getwin(FILE *);
extern int halfdelay(int);
extern unsigned char has_colors(void);
extern unsigned char has_ic(void);
extern unsigned char has_il(void);
extern int has_key(void);
extern bool has_mouse(void);
extern int hline(chtype, int);
extern int hline_set(cchar_t *, int);
extern void idcok(WINDOW *, unsigned char);
extern int idlok(WINDOW *, unsigned char);
extern void immedok(WINDOW *, unsigned char);
extern int in_wch(cchar_t *);
extern int in_wchnstr(cchar_t *, int);
extern int in_wchstr(cchar_t *);
extern chtype inch(void);
extern int inchnstr(chtype *, int);
extern int inchstr(chtype *);
extern int init_color(short, short, short, short);
extern int init_pair(short, short, short);
extern WINDOW *initscr(void);
extern int innstr(char *, int);
extern int innwstr(wchar_t *, int);
extern int ins_nwstr(wchar_t *, int);
extern int ins_wch(cchar_t *);
extern int ins_wstr(wchar_t *);
extern int insch(chtype);
extern int insdelln(int);
extern int insertln(void);
extern int insnstr(const char *, int);
extern int insstr(const char *);
extern int instr(char *);
extern int intrflush(WINDOW *, unsigned char);
extern int inwstr(wchar_t *);
extern unsigned char is_linetouched(WINDOW *, int);
extern unsigned char is_wintouched(WINDOW *);
extern unsigned char isendwin(void);
extern char *key_name(wchar_t);
extern char *keybound(int, int);
extern char *keyname(int);
extern int keyok(int, unsigned char);
extern int keypad(WINDOW *, unsigned char);
extern char killchar(void);
extern int killwchar(wchar_t *);
extern int leaveok(WINDOW *, unsigned char);
extern char *longname(void);
extern int mcprint(void);
extern int meta(WINDOW *, unsigned char);
extern bool mouse_trafo(int *, int *, bool);
extern int mouseinterval(int);
extern mmask_t mousemask(mmask_t, mmask_t *);
extern int move(int, int);
extern int mvadd_wch(int, int, cchar_t *);
extern int mvadd_wchnstr(int, int, cchar_t *, int);
extern int mvadd_wchstr(int, int, cchar_t *);
extern int mvaddch(const chtype, const chtype, const chtype);
extern int mvaddchnstr(int, int, const chtype *, int);
extern int mvaddchstr(int, int, const chtype *);
extern int mvaddnstr(int, int, const char *, int);
extern int mvaddnwstr(int, int, wchar_t *, int);
extern int mvaddstr(int, int, const char *);
extern int mvaddwstr(int, int, wchar_t *);
extern int mvchgat(int, int, int, attr_t, short, const void *);
extern int mvcur(int, int, int, int);
extern int mvdelch(int, int);
extern int mvderwin(WINDOW *, int, int);
extern int mvget_wch(int, int, wint_t *);
extern int mvget_wstr(int, int, wint_t *);
extern int mvgetch(int, int);
extern int mvgetn_wstr(int, int, wint_t *, int);
extern int mvgetnstr(int, int, char *, int);
extern int mvgetstr(int, int, char *);
extern int mvhline(int, int, chtype, int);
extern int mvhline_set(int, int, cchar_t *, int);
extern int mvin_wch(int, int, cchar_t *);
extern int mvin_wchnstr(int, int, cchar_t *, int);
extern int mvin_wchstr(int, int, cchar_t *);
extern chtype mvinch(int, int);
extern int mvinchnstr(int, int, chtype *, int);
extern int mvinchstr(int, int, chtype *);
extern int mvinnstr(int, int, char *, int);
extern int mvinnwstr(int, int, wchar_t *, int);
extern int mvins_nwstr(int, int, wchar_t *, int);
extern int mvins_wch(int, int, cchar_t *);
extern int mvins_wstr(int, int, wchar_t *);
extern int mvinsch(int, int, chtype);
extern int mvinsnstr(int, int, const char *, int);
extern int mvinsstr(int, int, const char *);
extern int mvinstr(int, int, char *);
extern int mvinwstr(int, int, wchar_t *);
extern int mvprintw(int, int, const char *, ...);
extern int mvscanw(int, int, char *, ...);
extern int mvvline(int, int, chtype, int);
extern int mvvline_set(int, int, cchar_t *, int);
extern int mvwadd_wch(WINDOW *, int, int, cchar_t *);
extern int mvwadd_wchnstr(WINDOW *, int, int, cchar_t *, int);
extern int mvwadd_wchstr(WINDOW *, int, int, cchar_t *);
extern int mvwaddch(const chtype, const chtype, const chtype,
		    const chtype);
extern int mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr(WINDOW *, int, int, const chtype *);
extern int mvwaddnstr(WINDOW *, int, int, const char *, int);
extern int mvwaddnwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwaddstr(WINDOW *, int, int, const char *);
extern int mvwaddwstr(WINDOW *, int, int, wchar_t *);
extern int mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch(WINDOW *, int, int);
extern int mvwget_wch(WINDOW *, int, int, wint_t *);
extern int mvwget_wstr(WINDOW *, int, int, wint_t *);
extern int mvwgetch(WINDOW *, int, int);
extern int mvwgetn_wstr(WINDOW *, int, int, wint_t *, int);
extern int mvwgetnstr(WINDOW *, int, int, char *, int);
extern int mvwgetstr(WINDOW *, int, int, char *);
extern int mvwhline(WINDOW *, int, int, chtype, int);
extern int mvwhline_set(WINDOW *, int, int, cchar_t *, int);
extern int mvwin(WINDOW *, int, int);
extern int mvwin_wch(WINDOW *, int, int, cchar_t *);
extern int mvwin_wchnstr(WINDOW *, int, int, cchar_t *, int);
extern int mvwin_wchstr(WINDOW *, int, int, cchar_t *);
extern chtype mvwinch(WINDOW *, int, int);
extern int mvwinchnstr(WINDOW *, int, int, chtype *, int);
extern int mvwinchstr(WINDOW *, int, int, chtype *);
extern int mvwinnstr(WINDOW *, int, int, char *, int);
extern int mvwinnwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwins_nwstr(WINDOW *, int, int, wchar_t *, int);
extern int mvwins_wch(WINDOW *, int, int, cchar_t *);
extern int mvwins_wstr(WINDOW *, int, int, wchar_t *);
extern int mvwinsch(WINDOW *, int, int, chtype);
extern int mvwinsnstr(WINDOW *, int, int, const char *, int);
extern int mvwinsstr(WINDOW *, int, int, const char *);
extern int mvwinstr(WINDOW *, int, int, char *);
extern int mvwinwstr(WINDOW *, int, int, wchar_t *);
extern int mvwprintw(WINDOW *, int, int, const char *, ...);
extern int mvwscanw(WINDOW *, int, int, char *, ...);
extern int mvwvline(WINDOW *, int, int, chtype, int);
extern int mvwvline_set(WINDOW *, int, int, cchar_t *, int);
extern int napms(int);
extern WINDOW *newpad(int, int);
extern WINDOW *newscr;
extern SCREEN *newterm(char *, FILE *, FILE *);
extern WINDOW *newwin(int, int, int, int);
extern int nl(void);
extern int nocbreak(void);
extern int nodelay(WINDOW *, unsigned char);
extern int noecho(void);
extern int nonl(void);
extern void noqiflush(void);
extern int noraw(void);
extern int notimeout(WINDOW *, unsigned char);
extern int overlay(const WINDOW *, WINDOW *);
extern int overwrite(const WINDOW *, WINDOW *);
extern int pair_content(short, short *, short *);
extern int pecho_wchar(WINDOW *, cchar_t *);
extern int pechochar(const chtype, const chtype);
extern int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
extern int prefresh(WINDOW *, int, int, int, int, int, int);
extern int printw(const char *, ...);
extern int putwin(WINDOW *, FILE *);
extern void qiflush(void);
extern int raw(void);
extern int redrawwin(WINDOW *);
extern int refresh(void);
extern int reset_prog_mode(void);
extern int reset_shell_mode(void);
extern int resetty(void);
extern int resizeterm(int, int);
extern int ripoffline(int, int (*)(WINDOW *, int));
extern int savetty(void);
extern int scanw(char *, ...);
extern int scr_dump(const char *);
extern int scr_init(const char *);
extern int scr_restore(const char *);
extern int scr_set(const char *);
extern int scrl(int);
extern int scroll(WINDOW *);
extern int scrollok(WINDOW *, unsigned char);
extern SCREEN *set_term(SCREEN *);
extern int setcchar(cchar_t *, wchar_t *, attr_t, short, void *);
extern int setscrreg(int, int);
extern attr_t slk_attr(void);
extern int slk_attr_off(attr_t, void *);
extern int slk_attr_on(attr_t, void *);
extern int slk_attroff(const chtype);
extern int slk_attron(const chtype);
extern int slk_attrset(const chtype);
extern int slk_clear(void);
extern int slk_color(short);
extern int slk_init(int);
extern char *slk_label(int);
extern int slk_noutrefresh(void);
extern int slk_refresh(void);
extern int slk_restore(void);
extern int slk_set(int, const char *, int);
extern int slk_touch(void);
extern int slk_wset(int, const wchar_t *, int);
extern int standend(void);
extern int standout(void);
extern int start_color(void);
extern WINDOW *stdscr;
extern WINDOW *subpad(WINDOW *, int, int, int, int);
extern WINDOW *subwin(WINDOW *, int, int, int, int);
extern int syncok(WINDOW *, unsigned char);
extern attr_t term_attrs(void);
extern chtype termattrs(void);
extern char *termname(void);
extern void timeout(int);
extern int touchline(WINDOW *, int, int);
extern int touchwin(WINDOW *);
extern int typeahead(int);
extern char *unctrl(chtype);
extern int unget_wch(wchar_t);
extern int ungetch(int);
extern int ungetmouse(MEVENT *);
extern int untouchwin(WINDOW *);
extern int use_default_colors(void);
extern void use_env(unsigned char);
extern int use_extended_names(unsigned char);
extern int vid_attr(attr_t, short, void *);
extern int vid_puts(attr_t, short, void *, int);
extern int vidattr(chtype);
extern int vidputs(chtype, NCURSES_OUTC);
extern int vline(chtype, int);
extern int vline_set(cchar_t *, int);
extern int vw_printw(WINDOW *, const char *, va_list);
extern int vw_scanw(WINDOW *, char *, va_list);
extern int vwprintw(WINDOW *, const char *, va_list);
extern int vwscanw(WINDOW *, char *, va_list);
extern int wadd_wch(WINDOW *, cchar_t *);
extern int wadd_wchnstr(WINDOW *, cchar_t *, int);
extern int wadd_wchstr(WINDOW *, cchar_t *);
extern int waddch(WINDOW *, chtype);
extern int waddchnstr(WINDOW *, const chtype *, int);
extern int waddchstr(WINDOW *, const chtype *);
extern int waddnstr(WINDOW *, const char *, int);
extern int waddnwstr(WINDOW *, wchar_t *, int);
extern int waddstr(WINDOW *, const char *);
extern int waddwstr(WINDOW *, wchar_t *);
extern int wattr_get(WINDOW *, attr_t *, short *, void *);
extern int wattr_off(WINDOW *, attr_t, void *);
extern int wattr_on(WINDOW *, attr_t, void *);
extern int wattr_set(WINDOW *, attr_t, short, void *);
extern int wattroff(WINDOW *, int);
extern int wattron(WINDOW *, int);
extern int wattrset(WINDOW *, int);
extern int wbkgd(WINDOW *, chtype);
extern void wbkgdset(WINDOW *, chtype);
extern int wbkgrnd(WINDOW *, cchar_t *);
extern void wbkgrndset(WINDOW *, cchar_t *);
extern int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype,
		   chtype, chtype, chtype);
extern int wborder_set(WINDOW *, cchar_t *, cchar_t *, cchar_t *,
		       cchar_t *, cchar_t *, cchar_t *, cchar_t *,
		       cchar_t *);
extern int wchgat(WINDOW *, int, attr_t, short, const void *);
extern int wclear(WINDOW *);
extern int wclrtobot(WINDOW *);
extern int wclrtoeol(WINDOW *);
extern int wcolor_set(WINDOW *, short, void *);
extern void wcursyncup(WINDOW *);
extern int wdelch(WINDOW *);
extern int wdeleteln(WINDOW *);
extern int wecho_wchar(WINDOW *, cchar_t *);
extern int wechochar(const chtype, const chtype);
extern unsigned char wenclose(WINDOW *, int, int);
extern int werase(WINDOW *);
extern int wget_wch(WINDOW *, wint_t *);
extern int wget_wstr(WINDOW *, wint_t *);
extern int wgetbkgrnd(WINDOW *, cchar_t *);
extern int wgetch(WINDOW *);
extern int wgetn_wstr(WINDOW *, wint_t *, int);
extern int wgetnstr(WINDOW *, char *, int);
extern int wgetstr(WINDOW *, char *);
extern int whline(WINDOW *, chtype, int);
extern int whline_set(WINDOW *, cchar_t *, int);
extern int win_wch(WINDOW *, cchar_t *);
extern int win_wchnstr(WINDOW *, cchar_t *, int);
extern int win_wchstr(WINDOW *, cchar_t *);
extern chtype winch(WINDOW *);
extern int winchnstr(WINDOW *, chtype *, int);
extern int winchstr(WINDOW *, chtype *);
extern int winnstr(WINDOW *, char *, int);
extern int winnwstr(WINDOW *, wchar_t *, int);
extern int wins_nwstr(WINDOW *, wchar_t *, int);
extern int wins_wch(WINDOW *, cchar_t *);
extern int wins_wstr(WINDOW *, wchar_t *);
extern int winsch(WINDOW *, chtype);
extern int winsdelln(WINDOW *, int);
extern int winsertln(WINDOW *);
extern int winsnstr(WINDOW *, const char *, int);
extern int winsstr(WINDOW *, const char *);
extern int winstr(WINDOW *, char *);
extern int winwstr(WINDOW *, wchar_t *);
extern unsigned char wmouse_trafo(const WINDOW *, int *, int *, bool);
extern int wmove(WINDOW *, int, int);
extern int wnoutrefresh(WINDOW *);
extern int wprintw(WINDOW *, const char *, ...);
extern int wredrawln(WINDOW *, int, int);
extern int wrefresh(WINDOW *);
extern int wresize(WINDOW *, int, int);
extern int wscanw(WINDOW *, char *, ...);
extern int wscrl(WINDOW *, int);
extern int wsetscrreg(WINDOW *, int, int);
extern int wstandend(WINDOW *);
extern int wstandout(WINDOW *);
extern void wsyncdown(WINDOW *);
extern void wsyncup(WINDOW *);
extern void wtimeout(WINDOW *, int);
extern int wtouchln(WINDOW *, int, int, int);
extern wchar_t *wunctrl(cchar_t *);
extern int wvline(WINDOW *, chtype, int);
extern int wvline_set(WINDOW *, cchar_t *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ncursesw/ncurses_dll.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NCURSES_API
#define NCURSES_IMPEXP
#define NCURSES_STATIC
#define NCURSES_WRAPPED_VAR(type,name)	extern type NCURSES_PUBLIC_VAR(name)(void)
#define NCURSES_PUBLIC_VAR(name)	_nc_ ##name
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ncursesw/term.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NCURSES_TERM_H_incl	1
#define NCURSES_VERSION	"5.9"
#define NCURSES_SBOOL	char
#define NCURSES_XNAMES	1
#define TERMIOS	1
#define TTY	struct termios
#define TCSANOW	TCSETA
#define TCSADRAIN	TCSETAW
#define TCSAFLUSH	TCSETAF
#define tcsetattr(fd, cmd, arg)	ioctl(fd, cmd, arg)
#define tcgetattr(fd, arg)	ioctl(fd, TCGETA, arg)
#define cfgetospeed(t)	((t)->c_cflag &amp; CBAUD)
#define TCOFLUSH	1
#define TCIOFLUSH	2
#define tcflush(fd, arg)	ioctl(fd, TCFLSH, arg)
#define GET_TTY(fd, buf)	tcgetattr(fd, buf)
#define SET_TTY(fd, buf)	tcsetattr(fd, TCSADRAIN, buf)
#define NAMESIZE	256
#define CUR	cur_term->type.
#define auto_left_margin	CUR Booleans[0]
#define auto_right_margin	CUR Booleans[1]
#define no_esc_ctlc	CUR Booleans[2]
#define ceol_standout_glitch	CUR Booleans[3]
#define eat_newline_glitch	CUR Booleans[4]
#define erase_overstrike	CUR Booleans[5]
#define generic_type	CUR Booleans[6]
#define hard_copy	CUR Booleans[7]
#define has_meta_key	CUR Booleans[8]
#define has_status_line	CUR Booleans[9]
#define insert_null_glitch	CUR Booleans[10]
#define memory_above	CUR Booleans[11]
#define memory_below	CUR Booleans[12]
#define move_insert_mode	CUR Booleans[13]
#define move_standout_mode	CUR Booleans[14]
#define over_strike	CUR Booleans[15]
#define status_line_esc_ok	CUR Booleans[16]
#define dest_tabs_magic_smso	CUR Booleans[17]
#define tilde_glitch	CUR Booleans[18]
#define transparent_underline	CUR Booleans[19]
#define xon_xoff	CUR Booleans[20]
#define needs_xon_xoff	CUR Booleans[21]
#define prtr_silent	CUR Booleans[22]
#define hard_cursor	CUR Booleans[23]
#define non_rev_rmcup	CUR Booleans[24]
#define no_pad_char	CUR Booleans[25]
#define non_dest_scroll_region	CUR Booleans[26]
#define can_change	CUR Booleans[27]
#define back_color_erase	CUR Booleans[28]
#define hue_lightness_saturation	CUR Booleans[29]
#define col_addr_glitch	CUR Booleans[30]
#define cr_cancels_micro_mode	CUR Booleans[31]
#define has_print_wheel	CUR Booleans[32]
#define row_addr_glitch	CUR Booleans[33]
#define semi_auto_right_margin	CUR Booleans[34]
#define cpi_changes_res	CUR Booleans[35]
#define lpi_changes_res	CUR Booleans[36]
#define columns	CUR Numbers[0]
#define init_tabs	CUR Numbers[1]
#define lines	CUR Numbers[2]
#define lines_of_memory	CUR Numbers[3]
#define magic_cookie_glitch	CUR Numbers[4]
#define padding_baud_rate	CUR Numbers[5]
#define virtual_terminal	CUR Numbers[6]
#define width_status_line	CUR Numbers[7]
#define num_labels	CUR Numbers[8]
#define label_height	CUR Numbers[9]
#define label_width	CUR Numbers[10]
#define max_attributes	CUR Numbers[11]
#define maximum_windows	CUR Numbers[12]
#define max_colors	CUR Numbers[13]
#define max_pairs	CUR Numbers[14]
#define no_color_video	CUR Numbers[15]
#define buffer_capacity	CUR Numbers[16]
#define dot_vert_spacing	CUR Numbers[17]
#define dot_horz_spacing	CUR Numbers[18]
#define max_micro_address	CUR Numbers[19]
#define max_micro_jump	CUR Numbers[20]
#define micro_col_size	CUR Numbers[21]
#define micro_line_size	CUR Numbers[22]
#define number_of_pins	CUR Numbers[23]
#define output_res_char	CUR Numbers[24]
#define output_res_line	CUR Numbers[25]
#define output_res_horz_inch	CUR Numbers[26]
#define output_res_vert_inch	CUR Numbers[27]
#define print_rate	CUR Numbers[28]
#define wide_char_size	CUR Numbers[29]
#define buttons	CUR Numbers[30]
#define bit_image_entwining	CUR Numbers[31]
#define bit_image_type	CUR Numbers[32]
#define back_tab	CUR Strings[0]
#define bell	CUR Strings[1]
#define carriage_return	CUR Strings[2]
#define change_scroll_region	CUR Strings[3]
#define clear_all_tabs	CUR Strings[4]
#define clear_screen	CUR Strings[5]
#define clr_eol	CUR Strings[6]
#define clr_eos	CUR Strings[7]
#define column_address	CUR Strings[8]
#define command_character	CUR Strings[9]
#define cursor_address	CUR Strings[10]
#define cursor_down	CUR Strings[11]
#define cursor_home	CUR Strings[12]
#define cursor_invisible	CUR Strings[13]
#define cursor_left	CUR Strings[14]
#define cursor_mem_address	CUR Strings[15]
#define cursor_normal	CUR Strings[16]
#define cursor_right	CUR Strings[17]
#define cursor_to_ll	CUR Strings[18]
#define cursor_up	CUR Strings[19]
#define cursor_visible	CUR Strings[20]
#define delete_character	CUR Strings[21]
#define delete_line	CUR Strings[22]
#define dis_status_line	CUR Strings[23]
#define down_half_line	CUR Strings[24]
#define enter_alt_charset_mode	CUR Strings[25]
#define enter_blink_mode	CUR Strings[26]
#define enter_bold_mode	CUR Strings[27]
#define enter_ca_mode	CUR Strings[28]
#define enter_delete_mode	CUR Strings[29]
#define enter_dim_mode	CUR Strings[30]
#define enter_insert_mode	CUR Strings[31]
#define enter_secure_mode	CUR Strings[32]
#define enter_protected_mode	CUR Strings[33]
#define enter_reverse_mode	CUR Strings[34]
#define enter_standout_mode	CUR Strings[35]
#define enter_underline_mode	CUR Strings[36]
#define erase_chars	CUR Strings[37]
#define exit_alt_charset_mode	CUR Strings[38]
#define exit_attribute_mode	CUR Strings[39]
#define exit_ca_mode	CUR Strings[40]
#define exit_delete_mode	CUR Strings[41]
#define exit_insert_mode	CUR Strings[42]
#define exit_standout_mode	CUR Strings[43]
#define exit_underline_mode	CUR Strings[44]
#define flash_screen	CUR Strings[45]
#define form_feed	CUR Strings[46]
#define from_status_line	CUR Strings[47]
#define init_1string	CUR Strings[48]
#define init_2string	CUR Strings[49]
#define init_3string	CUR Strings[50]
#define init_file	CUR Strings[51]
#define insert_character	CUR Strings[52]
#define insert_line	CUR Strings[53]
#define insert_padding	CUR Strings[54]
#define key_backspace	CUR Strings[55]
#define key_catab	CUR Strings[56]
#define key_clear	CUR Strings[57]
#define key_ctab	CUR Strings[58]
#define key_dc	CUR Strings[59]
#define key_dl	CUR Strings[60]
#define key_down	CUR Strings[61]
#define key_eic	CUR Strings[62]
#define key_eol	CUR Strings[63]
#define key_eos	CUR Strings[64]
#define key_f0	CUR Strings[65]
#define key_f1	CUR Strings[66]
#define key_f10	CUR Strings[67]
#define key_f2	CUR Strings[68]
#define key_f3	CUR Strings[69]
#define key_f4	CUR Strings[70]
#define key_f5	CUR Strings[71]
#define key_f6	CUR Strings[72]
#define key_f7	CUR Strings[73]
#define key_f8	CUR Strings[74]
#define key_f9	CUR Strings[75]
#define key_home	CUR Strings[76]
#define key_ic	CUR Strings[77]
#define key_il	CUR Strings[78]
#define key_left	CUR Strings[79]
#define key_ll	CUR Strings[80]
#define key_npage	CUR Strings[81]
#define key_ppage	CUR Strings[82]
#define key_right	CUR Strings[83]
#define key_sf	CUR Strings[84]
#define key_sr	CUR Strings[85]
#define key_stab	CUR Strings[86]
#define key_up	CUR Strings[87]
#define keypad_local	CUR Strings[88]
#define keypad_xmit	CUR Strings[89]
#define lab_f0	CUR Strings[90]
#define lab_f1	CUR Strings[91]
#define lab_f10	CUR Strings[92]
#define lab_f2	CUR Strings[93]
#define lab_f3	CUR Strings[94]
#define lab_f4	CUR Strings[95]
#define lab_f5	CUR Strings[96]
#define lab_f6	CUR Strings[97]
#define lab_f7	CUR Strings[98]
#define lab_f8	CUR Strings[99]
#define lab_f9	CUR Strings[100]
#define meta_off	CUR Strings[101]
#define meta_on	CUR Strings[102]
#define newline	CUR Strings[103]
#define pad_char	CUR Strings[104]
#define parm_dch	CUR Strings[105]
#define parm_delete_line	CUR Strings[106]
#define parm_down_cursor	CUR Strings[107]
#define parm_ich	CUR Strings[108]
#define parm_index	CUR Strings[109]
#define parm_insert_line	CUR Strings[110]
#define parm_left_cursor	CUR Strings[111]
#define parm_right_cursor	CUR Strings[112]
#define parm_rindex	CUR Strings[113]
#define parm_up_cursor	CUR Strings[114]
#define pkey_key	CUR Strings[115]
#define pkey_local	CUR Strings[116]
#define pkey_xmit	CUR Strings[117]
#define print_screen	CUR Strings[118]
#define prtr_off	CUR Strings[119]
#define prtr_on	CUR Strings[120]
#define repeat_char	CUR Strings[121]
#define reset_1string	CUR Strings[122]
#define reset_2string	CUR Strings[123]
#define reset_3string	CUR Strings[124]
#define reset_file	CUR Strings[125]
#define restore_cursor	CUR Strings[126]
#define row_address	CUR Strings[127]
#define save_cursor	CUR Strings[128]
#define scroll_forward	CUR Strings[129]
#define scroll_reverse	CUR Strings[130]
#define set_attributes	CUR Strings[131]
#define set_tab	CUR Strings[132]
#define set_window	CUR Strings[133]
#define tab	CUR Strings[134]
#define to_status_line	CUR Strings[135]
#define underline_char	CUR Strings[136]
#define up_half_line	CUR Strings[137]
#define init_prog	CUR Strings[138]
#define key_a1	CUR Strings[139]
#define key_a3	CUR Strings[140]
#define key_b2	CUR Strings[141]
#define key_c1	CUR Strings[142]
#define key_c3	CUR Strings[143]
#define prtr_non	CUR Strings[144]
#define char_padding	CUR Strings[145]
#define acs_chars	CUR Strings[146]
#define plab_norm	CUR Strings[147]
#define key_btab	CUR Strings[148]
#define enter_xon_mode	CUR Strings[149]
#define exit_xon_mode	CUR Strings[150]
#define enter_am_mode	CUR Strings[151]
#define exit_am_mode	CUR Strings[152]
#define xon_character	CUR Strings[153]
#define xoff_character	CUR Strings[154]
#define ena_acs	CUR Strings[155]
#define label_on	CUR Strings[156]
#define label_off	CUR Strings[157]
#define key_beg	CUR Strings[158]
#define key_cancel	CUR Strings[159]
#define key_close	CUR Strings[160]
#define key_command	CUR Strings[161]
#define key_copy	CUR Strings[162]
#define key_create	CUR Strings[163]
#define key_end	CUR Strings[164]
#define key_enter	CUR Strings[165]
#define key_exit	CUR Strings[166]
#define key_find	CUR Strings[167]
#define key_help	CUR Strings[168]
#define key_mark	CUR Strings[169]
#define key_message	CUR Strings[170]
#define key_move	CUR Strings[171]
#define key_next	CUR Strings[172]
#define key_open	CUR Strings[173]
#define key_options	CUR Strings[174]
#define key_previous	CUR Strings[175]
#define key_print	CUR Strings[176]
#define key_redo	CUR Strings[177]
#define key_reference	CUR Strings[178]
#define key_refresh	CUR Strings[179]
#define key_replace	CUR Strings[180]
#define key_restart	CUR Strings[181]
#define key_resume	CUR Strings[182]
#define key_save	CUR Strings[183]
#define key_suspend	CUR Strings[184]
#define key_undo	CUR Strings[185]
#define key_sbeg	CUR Strings[186]
#define key_scancel	CUR Strings[187]
#define key_scommand	CUR Strings[188]
#define key_scopy	CUR Strings[189]
#define key_screate	CUR Strings[190]
#define key_sdc	CUR Strings[191]
#define key_sdl	CUR Strings[192]
#define key_select	CUR Strings[193]
#define key_send	CUR Strings[194]
#define key_seol	CUR Strings[195]
#define key_sexit	CUR Strings[196]
#define key_sfind	CUR Strings[197]
#define key_shelp	CUR Strings[198]
#define key_shome	CUR Strings[199]
#define key_sic	CUR Strings[200]
#define key_sleft	CUR Strings[201]
#define key_smessage	CUR Strings[202]
#define key_smove	CUR Strings[203]
#define key_snext	CUR Strings[204]
#define key_soptions	CUR Strings[205]
#define key_sprevious	CUR Strings[206]
#define key_sprint	CUR Strings[207]
#define key_sredo	CUR Strings[208]
#define key_sreplace	CUR Strings[209]
#define key_sright	CUR Strings[210]
#define key_srsume	CUR Strings[211]
#define key_ssave	CUR Strings[212]
#define key_ssuspend	CUR Strings[213]
#define key_sundo	CUR Strings[214]
#define req_for_input	CUR Strings[215]
#define key_f11	CUR Strings[216]
#define key_f12	CUR Strings[217]
#define key_f13	CUR Strings[218]
#define key_f14	CUR Strings[219]
#define key_f15	CUR Strings[220]
#define key_f16	CUR Strings[221]
#define key_f17	CUR Strings[222]
#define key_f18	CUR Strings[223]
#define key_f19	CUR Strings[224]
#define key_f20	CUR Strings[225]
#define key_f21	CUR Strings[226]
#define key_f22	CUR Strings[227]
#define key_f23	CUR Strings[228]
#define key_f24	CUR Strings[229]
#define key_f25	CUR Strings[230]
#define key_f26	CUR Strings[231]
#define key_f27	CUR Strings[232]
#define key_f28	CUR Strings[233]
#define key_f29	CUR Strings[234]
#define key_f30	CUR Strings[235]
#define key_f31	CUR Strings[236]
#define key_f32	CUR Strings[237]
#define key_f33	CUR Strings[238]
#define key_f34	CUR Strings[239]
#define key_f35	CUR Strings[240]
#define key_f36	CUR Strings[241]
#define key_f37	CUR Strings[242]
#define key_f38	CUR Strings[243]
#define key_f39	CUR Strings[244]
#define key_f40	CUR Strings[245]
#define key_f41	CUR Strings[246]
#define key_f42	CUR Strings[247]
#define key_f43	CUR Strings[248]
#define key_f44	CUR Strings[249]
#define key_f45	CUR Strings[250]
#define key_f46	CUR Strings[251]
#define key_f47	CUR Strings[252]
#define key_f48	CUR Strings[253]
#define key_f49	CUR Strings[254]
#define key_f50	CUR Strings[255]
#define key_f51	CUR Strings[256]
#define key_f52	CUR Strings[257]
#define key_f53	CUR Strings[258]
#define key_f54	CUR Strings[259]
#define key_f55	CUR Strings[260]
#define key_f56	CUR Strings[261]
#define key_f57	CUR Strings[262]
#define key_f58	CUR Strings[263]
#define key_f59	CUR Strings[264]
#define key_f60	CUR Strings[265]
#define key_f61	CUR Strings[266]
#define key_f62	CUR Strings[267]
#define key_f63	CUR Strings[268]
#define clr_bol	CUR Strings[269]
#define clear_margins	CUR Strings[270]
#define set_left_margin	CUR Strings[271]
#define set_right_margin	CUR Strings[272]
#define label_format	CUR Strings[273]
#define set_clock	CUR Strings[274]
#define display_clock	CUR Strings[275]
#define remove_clock	CUR Strings[276]
#define create_window	CUR Strings[277]
#define goto_window	CUR Strings[278]
#define hangup	CUR Strings[279]
#define dial_phone	CUR Strings[280]
#define quick_dial	CUR Strings[281]
#define tone	CUR Strings[282]
#define pulse	CUR Strings[283]
#define flash_hook	CUR Strings[284]
#define fixed_pause	CUR Strings[285]
#define wait_tone	CUR Strings[286]
#define user0	CUR Strings[287]
#define user1	CUR Strings[288]
#define user2	CUR Strings[289]
#define user3	CUR Strings[290]
#define user4	CUR Strings[291]
#define user5	CUR Strings[292]
#define user6	CUR Strings[293]
#define user7	CUR Strings[294]
#define user8	CUR Strings[295]
#define user9	CUR Strings[296]
#define orig_pair	CUR Strings[297]
#define orig_colors	CUR Strings[298]
#define initialize_color	CUR Strings[299]
#define initialize_pair	CUR Strings[300]
#define set_color_pair	CUR Strings[301]
#define set_foreground	CUR Strings[302]
#define set_background	CUR Strings[303]
#define change_char_pitch	CUR Strings[304]
#define change_line_pitch	CUR Strings[305]
#define change_res_horz	CUR Strings[306]
#define change_res_vert	CUR Strings[307]
#define define_char	CUR Strings[308]
#define enter_doublewide_mode	CUR Strings[309]
#define enter_draft_quality	CUR Strings[310]
#define enter_italics_mode	CUR Strings[311]
#define enter_leftward_mode	CUR Strings[312]
#define enter_micro_mode	CUR Strings[313]
#define enter_near_letter_quality	CUR Strings[314]
#define enter_normal_quality	CUR Strings[315]
#define enter_shadow_mode	CUR Strings[316]
#define enter_subscript_mode	CUR Strings[317]
#define enter_superscript_mode	CUR Strings[318]
#define enter_upward_mode	CUR Strings[319]
#define exit_doublewide_mode	CUR Strings[320]
#define exit_italics_mode	CUR Strings[321]
#define exit_leftward_mode	CUR Strings[322]
#define exit_micro_mode	CUR Strings[323]
#define exit_shadow_mode	CUR Strings[324]
#define exit_subscript_mode	CUR Strings[325]
#define exit_superscript_mode	CUR Strings[326]
#define exit_upward_mode	CUR Strings[327]
#define micro_column_address	CUR Strings[328]
#define micro_down	CUR Strings[329]
#define micro_left	CUR Strings[330]
#define micro_right	CUR Strings[331]
#define micro_row_address	CUR Strings[332]
#define micro_up	CUR Strings[333]
#define order_of_pins	CUR Strings[334]
#define parm_down_micro	CUR Strings[335]
#define parm_left_micro	CUR Strings[336]
#define parm_right_micro	CUR Strings[337]
#define parm_up_micro	CUR Strings[338]
#define select_char_set	CUR Strings[339]
#define set_bottom_margin	CUR Strings[340]
#define set_bottom_margin_parm	CUR Strings[341]
#define set_left_margin_parm	CUR Strings[342]
#define set_right_margin_parm	CUR Strings[343]
#define set_top_margin	CUR Strings[344]
#define set_top_margin_parm	CUR Strings[345]
#define start_bit_image	CUR Strings[346]
#define start_char_set_def	CUR Strings[347]
#define stop_bit_image	CUR Strings[348]
#define stop_char_set_def	CUR Strings[349]
#define subscript_characters	CUR Strings[350]
#define superscript_characters	CUR Strings[351]
#define these_cause_cr	CUR Strings[352]
#define zero_motion	CUR Strings[353]
#define char_set_names	CUR Strings[354]
#define key_mouse	CUR Strings[355]
#define mouse_info	CUR Strings[356]
#define req_mouse_pos	CUR Strings[357]
#define get_mouse	CUR Strings[358]
#define set_a_foreground	CUR Strings[359]
#define set_a_background	CUR Strings[360]
#define pkey_plab	CUR Strings[361]
#define device_type	CUR Strings[362]
#define code_set_init	CUR Strings[363]
#define set0_des_seq	CUR Strings[364]
#define set1_des_seq	CUR Strings[365]
#define set2_des_seq	CUR Strings[366]
#define set3_des_seq	CUR Strings[367]
#define set_lr_margin	CUR Strings[368]
#define set_tb_margin	CUR Strings[369]
#define bit_image_repeat	CUR Strings[370]
#define bit_image_newline	CUR Strings[371]
#define bit_image_carriage_return	CUR Strings[372]
#define color_names	CUR Strings[373]
#define define_bit_image_region	CUR Strings[374]
#define end_bit_image_region	CUR Strings[375]
#define set_color_band	CUR Strings[376]
#define set_page_length	CUR Strings[377]
#define display_pc_char	CUR Strings[378]
#define enter_pc_charset_mode	CUR Strings[379]
#define exit_pc_charset_mode	CUR Strings[380]
#define enter_scancode_mode	CUR Strings[381]
#define exit_scancode_mode	CUR Strings[382]
#define pc_term_options	CUR Strings[383]
#define scancode_escape	CUR Strings[384]
#define alt_scancode_esc	CUR Strings[385]
#define enter_horizontal_hl_mode	CUR Strings[386]
#define enter_left_hl_mode	CUR Strings[387]
#define enter_low_hl_mode	CUR Strings[388]
#define enter_right_hl_mode	CUR Strings[389]
#define enter_top_hl_mode	CUR Strings[390]
#define enter_vertical_hl_mode	CUR Strings[391]
#define set_a_attributes	CUR Strings[392]
#define set_pglen_inch	CUR Strings[393]
#define BOOLWRITE	37
#define NUMWRITE	33
#define STRWRITE	394
#define beehive_glitch	no_esc_ctlc
#define teleray_glitch	dest_tabs_magic_smso
#define micro_char_size	micro_col_size
#define termcap_init2	CUR Strings[394]
#define termcap_reset	CUR Strings[395]
#define magic_cookie_glitch_ul	CUR Numbers[33]
#define backspaces_with_bs	CUR Booleans[37]
#define crt_no_scrolling	CUR Booleans[38]
#define no_correctly_working_cr	CUR Booleans[39]
#define carriage_return_delay	CUR Numbers[34]
#define new_line_delay	CUR Numbers[35]
#define linefeed_if_not_lf	CUR Strings[396]
#define backspace_if_not_bs	CUR Strings[397]
#define gnu_has_meta_key	CUR Booleans[40]
#define linefeed_is_newline	CUR Booleans[41]
#define backspace_delay	CUR Numbers[36]
#define horizontal_tab_delay	CUR Numbers[37]
#define number_of_function_keys	CUR Numbers[38]
#define other_non_function_keys	CUR Strings[398]
#define arrow_key_map	CUR Strings[399]
#define has_hardware_tabs	CUR Booleans[42]
#define return_does_clr_eol	CUR Booleans[43]
#define acs_ulcorner	CUR Strings[400]
#define acs_llcorner	CUR Strings[401]
#define acs_urcorner	CUR Strings[402]
#define acs_lrcorner	CUR Strings[403]
#define acs_ltee	CUR Strings[404]
#define acs_rtee	CUR Strings[405]
#define acs_btee	CUR Strings[406]
#define acs_ttee	CUR Strings[407]
#define acs_hline	CUR Strings[408]
#define acs_vline	CUR Strings[409]
#define acs_plus	CUR Strings[410]
#define memory_lock	CUR Strings[411]
#define memory_unlock	CUR Strings[412]
#define box_chars_1	CUR Strings[413]
#define BOOLCOUNT	44
#define NUMCOUNT	39
#define STRCOUNT	414
#define acs_chars_index	146
#define cur_term	NCURSES_PUBLIC_VAR(cur_term())
#define boolnames	NCURSES_PUBLIC_VAR(boolnames())
#define boolcodes	NCURSES_PUBLIC_VAR(boolcodes())
#define boolfnames	NCURSES_PUBLIC_VAR(boolfnames())
#define numnames	NCURSES_PUBLIC_VAR(numnames())
#define numcodes	NCURSES_PUBLIC_VAR(numcodes())
#define numfnames	NCURSES_PUBLIC_VAR(numfnames())
#define strnames	NCURSES_PUBLIC_VAR(strnames())
#define strcodes	NCURSES_PUBLIC_VAR(strcodes())
#define strfnames	NCURSES_PUBLIC_VAR(strfnames())

typedef struct termtype {
    char *term_names;
    char *str_table;
    char *Booleans;
    short *Numbers;
    char **Strings;
    char *ext_str_table;
    char **ext_Names;
    unsigned short num_Booleans;
    unsigned short num_Numbers;
    unsigned short num_Strings;
    unsigned short ext_Booleans;
    unsigned short ext_Numbers;
    unsigned short ext_Strings;
} TERMTYPE;
typedef struct term {
    TERMTYPE type;
    short Filedes;
    struct termios Ottyb;
    struct termios Nttyb;
    int _baudrate;
    char *_termname;
} TERMINAL;
extern TERMINAL *cur_term;
extern int del_curterm(TERMINAL *);
extern int putp(const char *);
extern int restartterm(char *, int, int *);
extern TERMINAL *set_curterm(TERMINAL *);
extern int setupterm(char *, int, int *);
extern int tgetent(char *, const char *);
extern int tgetflag(char *);
extern int tgetnum(char *);
extern char *tgetstr(char *, char **);
extern char *tgoto(const char *, int, int);
extern int tigetflag(char *);
extern int tigetnum(char *);
extern char *tigetstr(char *);
extern char *tparm(char *, ...);
extern int tputs(const char *, int, int (*)(int));
extern char ttytype[];
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ncursesw/unctrl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define NCURSES_UNCTRL_H_incl	1
#define NCURSES_VERSION	"5.9"
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libncurseswman>
<TITLE>Interface Definitions for libncursesw</TITLE>
<PARA>
The interfaces defined on the following pages are included in libncursesw and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libncursesw> shall behave as described
in the referenced base document.
</PARA>
<!-- MISSING DEFINITION FOR COLORS -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR COLOR_PAIRS -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR COLS -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR ESCDELAY -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR LINES -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR TABSIZE -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR acs_map -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR add_wch -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR addch -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR cbreak -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR clear -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR cur_term -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR curscr -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR echo -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR endwin -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR has_mouse -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR initscr -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR intrflush -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR keypad -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR move -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR newscr -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR newterm -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR newwin -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR nl -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR noecho -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR nonl -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR pecho_wchar -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR raw -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR refresh -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR slk_wset -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR stdscr -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR ttytype -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR wadd_wch -->
<!-- Lets just hope nobody notices -->
<!-- MISSING DEFINITION FOR waddch -->
<!-- Lets just hope nobody notices -->
</SECT1>
<!-- End of text generated from database -->


<!-- Start of generated text - do not edit! -->
<!-- generated from the LSB specification database by mklibspec -->
<SECT1 ID=libutil>
<TITLE>Interfaces for libutil</TITLE>
<PARA>
<XREF LINKEND="lib-libutil-def"> defines the library name and shared object name
for the libutil library
</PARA>
<TABLE id="lib-libutil-def">
<TITLE>libutil Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libutil</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libutil.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER ID='REFSTD.libutil.1'>
[LSB] <XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Utility Functions -->
<SECT2>
<!--libgroup-->
<TITLE>Utility Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Utility Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Utility Functions specified in <XREF linkend="tbl-libutil-utili-ints">,
with the full mandatory functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libutil-utili-ints">
<TITLE>libutil - Utility Functions Function Interfaces</TITLE>
<TGROUP COLS=4>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>forkpty</primary></indexterm>forkpty <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>login</primary></indexterm>login <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>login_tty</primary></indexterm>login_tty <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>logout</primary></indexterm>logout <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>logwtmp</primary></indexterm>logwtmp <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
<ENTRY><indexterm><primary>openpty</primary></indexterm>openpty <LINK LINKEND="REFSTD.libutil.1">[LSB]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libutilman>
<TITLE>Interface Definitions for libutil</TITLE>
<PARA>
The interfaces defined on the following pages are included in libutil and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed in <XREF LINKEND=libutil> shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="libutil-forkpty-3"> <REFMETA>
<REFENTRYTITLE>forkpty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>forkpty
</REFNAME>
<REFPURPOSE>Create a new process attached to an available pseudo-terminal
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-forkpty-3"><PRIMARY>forkpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pty.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
<FUNCDEF>int
<FUNCTION>
forkpty
</FUNCTION>
</FUNCDEF>
  <PARAMDEF>int *
    <PARAMETER><REPLACEABLE>amaster</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>char *
    <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>const struct termios *
    <PARAMETER><REPLACEABLE>termp</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>const struct winsize *
    <PARAMETER><REPLACEABLE>winp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>forkpty</FUNCTION>
function shall find and open a pseudo-terminal device pair in the
same manner as the <FUNCTION>openpty</FUNCTION> function. 
If a pseudo-terminal is available,
<FUNCTION>forkpty</FUNCTION>
shall create a new process in the same manner as the <FUNCTION>fork</FUNCTION>
function, and prepares the new process for login in the same manner as 
<FUNCTION>login_tty</FUNCTION>.
</PARA>
<PARA>
If <PARAMETER>termp</PARAMETER> is not null, 
it shall refer to a <VARNAME>termios</VARNAME> structure that shall be used
to initialize the characteristics of the slave device. 
If <PARAMETER>winp</PARAMETER> is not null, it
shall refer to a <VARNAME>winsize</VARNAME> structure used to 
initialize the window size of the
slave device.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the parent process shall return the process id of the child, and the
child shall return 0. On error, no new process shall be created, -1 shall be
returned, and <VARNAME>errno</VARNAME> shall be set appropriately.
On success, the parent process shall receive the file descriptor of the master
side of the pseudo-terminal in the location referenced by 
<PARAMETER>amaster</PARAMETER>, and, if <PARAMETER>name</PARAMETER> is
not NULL, the filename of the slave device in 
<PARAMETER>name</PARAMETER>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EAGAIN
</TERM>
<LISTITEM>
<PARA>
Unable to create a new process.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
ENOENT
</TERM>
<LISTITEM>
<PARA>
There are no available pseudo-terminals.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="libutil-login-3"> <REFMETA>
<REFENTRYTITLE>login</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login
</REFNAME>
<REFPURPOSE>login utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-3"><PRIMARY>login</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
  <FUNCPROTOTYPE>
    <FUNCDEF>void
      <FUNCTION>login</FUNCTION>
    </FUNCDEF>
    <PARAMDEF>struct utmp *
      <PARAMETER><REPLACEABLE>ut</REPLACEABLE></PARAMETER>
    </PARAMDEF>
  </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>login</function> function shall update the user 
accounting databases.
The <parameter>ut</parameter> parameter shall reference a 
<STRUCTNAME>utmp</STRUCTNAME> structure 
for all fields except the following:
<ORDEREDLIST>
<LISTITEM>
<PARA>
The <STRUCTFIELD>ut_type</STRUCTFIELD> field shall be set to <constant>
USER_PROCESS</constant>.
</PARA></LISTITEM>
<LISTITEM><PARA>
The <STRUCTFIELD>ut_pid</STRUCTFIELD> field shall be set to the process identifier
for the current process.
</PARA></LISTITEM>
<LISTITEM><PARA>
The <STRUCTFIELD>ut_line</STRUCTFIELD> field shall be set to the name of the 
controlling terminal device.
The name shall be found by examining the device associated with the
standard input, output and error streams in sequence, until one associated with
a terminal device is found.
If none of these streams refers to a terminal device, the 
<STRUCTFIELD>ut_line</STRUCTFIELD> field shall be set to <constant>"???"</constant>.
If the terminal device is in the <filename>/dev</filename> directory
hierarchy, the <STRUCTFIELD>ut_line</STRUCTFIELD> field shall not contain the leading
<constant>"/dev/"</constant>, otherwise it shall be set to the final component
of the pathname of the device. 
If the user
accounting database imposes a limit on the size of the 
<structfield>ut_line</structfield> field, it shall
truncate the name, but any such limit shall not be smaller than 
<CONSTANT>UT_LINESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
</ORDEREDLIST>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>None</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="libutil-login-tty-3"> <REFMETA>
<REFENTRYTITLE>login_tty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login_tty
</REFNAME>
<REFPURPOSE>Prepare a terminal for login
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-tty-3"><PRIMARY>login_tty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
 <FUNCPROTOTYPE>
  <FUNCDEF>int
    <FUNCTION>login_tty</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>int <PARAMETER><replaceable>fdr</replaceable></PARAMETER></PARAMDEF>
 </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>login_tty</function> function
shall prepare the terminal device referenced by the file
descriptor <parameter>fdr</parameter>. 
This function shall create a new session, make the terminal 
the controlling terminal for the current process, and set the standard 
input, output, and error streams of the current process to the terminal.
If <parameter>fdr</parameter> is not the standard input, output or error stream,
then <function>login_tty</function> shall close <parameter>fdr</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <function>login_tty</function> shall return zero;
otherwise -1 is returned, and errno shall be set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<REFSECT1INFO><DATE>Aug 16 2004</DATE></REFSECT1INFO>
<TITLE>Errors</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOTTY
</TERM>
<LISTITEM>
<PARA>
<parameter>fdr</parameter> does not refer to a terminal device.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="libutil-logout-3"> <REFMETA>
<REFENTRYTITLE>logout</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logout
</REFNAME>
<REFPURPOSE>logout utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-logout-3"><PRIMARY>logout</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
  <FUNCPROTOTYPE>
    <FUNCDEF>int
      <FUNCTION>logout</FUNCTION>
    </FUNCDEF>
    <PARAMDEF>const char *
      <PARAMETER><REPLACEABLE>line</REPLACEABLE></PARAMETER>
    </PARAMDEF>
  </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Given the device <parameter>line</parameter>,
the <function>logout</function> function shall search
the user accounting database which is read by <function>getutent</function>
for an entry with the corresponding line,
and with the type of <CONSTANT>USER_PROCESS</CONSTANT>.
If a corresponding entry is located, it shall be updated as follows:
<ORDEREDLIST>
<LISTITEM><PARA>The <varname>ut_name</varname> field shall be set to zeroes
(<Constant>UT_NAMESIZE</constant> NUL bytes).</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_host</varname> field shall be set to zeroes
(<Constant>UT_HOSTSIZE</constant> NUL bytes).</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_tv</varname> shall be set to the current 
time of day.</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_type</varname> field shall be set to
<constant>DEAD_PROCESS</constant>.</PARA></LISTITEM>
</ORDEREDLIST>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>logout</function> function shall return non-zero.
Zero is returned if there was no entry to remove, or if the utmp file
could not be opened or updated.
</PARA>
</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-logwtmp-3"> <REFMETA>
<REFENTRYTITLE>logwtmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logwtmp
</REFNAME>
<REFPURPOSE>
append an entry to the wtmp file
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h>
</FUNCSYNOPSISINFO>
 <FUNCPROTOTYPE>
  <FUNCDEF>void
    <FUNCTION>logwtmp</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>line</REPLACEABLE></PARAMETER>
  </PARAMDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER>
  </PARAMDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>host</REPLACEABLE></PARAMETER>
  </PARAMDEF>
 </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If the process has permission to update the user accounting databases,
the <FUNCTION>logwtmp</FUNCTION> function
shall append a record to the user accounting database 
that records all logins and logouts. The record to be appended
shall be constructed as follows:
<ORDEREDLIST>
<LISTITEM><PARA>The <varname>ut_line</varname> field shall be initialized
from <parameter>line</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_line</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_LINESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_name</varname> field shall be initialized
from <parameter>name</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_name</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_NAMESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_host</varname> field shall be initialized
from <parameter>host</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_host</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_HOSTSIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>If the <parameter>name</parameter> parameter does not refer
to an empty string (i.e. <constant>""</constant>), 
the <varname>ut_type</varname> field shall be set to 
<constant>USER_PROCESS</constant>; otherwise the
<varname>ut_type</varname> field shall be set to 
<constant>DEAD_PROCESS</constant>.
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_id</varname> field shall be set to the 
process identifier for the current process.
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_tv</varname> field shall be set to the
current time of day.
</PARA></LISTITEM>
</ORDEREDLIST>
<NOTE><PARA>If a process does not have write access to the 
the user accounting database, the
<function>logwtmp</function> function will not update it. 
Since the function does not return
any value, an application has no way of knowing whether it succeeded or failed.
</PARA></NOTE>
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="libutil-openpty-3"> <REFMETA>
<REFENTRYTITLE>openpty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>openpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-terminal
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-openpty-3"><PRIMARY>openpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pty.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>int
    <FUNCTION>openpty</FUNCTION></FUNCDEF>
    <PARAMDEF>int *<parameter><replaceable>amaster</replaceable></parameter></PARAMDEF>
    <PARAMDEF>int *<parameter><replaceable>aslave</replaceable></parameter></PARAMDEF>
    <PARAMDEF>char *<parameter><replaceable>name</replaceable></parameter></PARAMDEF>
    <PARAMDEF>const struct termios *<parameter><replaceable>termp</replaceable></parameter></PARAMDEF>
    <PARAMDEF>const struct winsize *<parameter><replaceable>winp</replaceable></parameter></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>

</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>openpty</function>
function shall find an available pseudo-terminal
and return file descriptors for the master and slave devices in
the locations referenced by 
<parameter>amaster</parameter> and <parameter>aslave</parameter>
respectively. 
If <parameter>name</parameter> is not NULL,
the filename of the slave shall be placed in the user supplied buffer 
referenced by <parameter>name</parameter>.
If <parameter>termp</parameter> is not NULL, it shall
point to a <varname>termios</varname> structure used to initialize
the terminal parameters of the slave pseudo-terminal device.
If <parameter>winp</parameter> is not NULL, it shall
point to a <varname>winsize</varname> structure used to initialize
the window size parameters of the slave pseudo-terminal device.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOENT
</TERM>
<LISTITEM>
<PARA>
There are no available pseudo-terminals.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>


</SECT1>
<!-- End of text generated from database -->


</CHAPTER>

</PART>
