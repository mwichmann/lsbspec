<PART ID="tocutillib">
<TITLE>Utility Libraries</TITLE>

<CHAPTER id=utillib>
<TITLE>Utility Libraries</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
An LSB-conforming implementation shall also support the following utility
libraries which
are built on top of the interfaces provided by the base libraries. These
libraries implement common functionality, and hide additional system dependent
information such as file formats and device names.
<itemizedlist>
<listitem><para>libz</para></listitem>
<listitem><para>libcurses</para></listitem>
<listitem><para>libutil</para></listitem>
</itemizedlist>
</PARA>
</SECT1>
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->
<!--    at Fri Mar 11 21:39:05 2005 -->
<SECT1 ID=libz>
<TITLE>Interfaces for libz</TITLE>
<PARA>
<XREF LINKEND="lib-libz-def"> defines the library name and shared object name
for the libz library
</PARA>
<TABLE id="lib-libz-def">
<TITLE>libz Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libz</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libz.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER>
<XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Compression Library -->
<SECT2>
<!--libgroup-->
<TITLE>Compression Library</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Compression Library</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Compression Library specified in <XREF linkend="tbl-libz-com-ints">,
with the full functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libz-com-ints">
<TITLE>libz - Compression Library Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>adler32</primary></indexterm>adler32 <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateInit2_</primary></indexterm>deflateInit2_ <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzerror</primary></indexterm>gzerror <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzrewind</primary></indexterm>gzrewind <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateReset</primary></indexterm>inflateReset <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>compress</primary></indexterm>compress <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateInit_</primary></indexterm>deflateInit_ <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzflush</primary></indexterm>gzflush <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzseek</primary></indexterm>gzseek <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateSetDictionary</primary></indexterm>inflateSetDictionary <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>compress2</primary></indexterm>compress2 <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateParams</primary></indexterm>deflateParams <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzgetc</primary></indexterm>gzgetc <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzsetparams</primary></indexterm>gzsetparams <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateSync</primary></indexterm>inflateSync <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>compressBound</primary></indexterm>compressBound <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateReset</primary></indexterm>deflateReset <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzgets</primary></indexterm>gzgets <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gztell</primary></indexterm>gztell <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateSyncPoint</primary></indexterm>inflateSyncPoint <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>crc32</primary></indexterm>crc32 <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>deflateSetDictionary</primary></indexterm>deflateSetDictionary <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzopen</primary></indexterm>gzopen <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzwrite</primary></indexterm>gzwrite <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>uncompress</primary></indexterm>uncompress <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflate</primary></indexterm>deflate <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>get_crc_table</primary></indexterm>get_crc_table <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzprintf</primary></indexterm>gzprintf <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflate</primary></indexterm>inflate <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>zError</primary></indexterm>zError <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflateBound</primary></indexterm>deflateBound <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzclose</primary></indexterm>gzclose <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzputc</primary></indexterm>gzputc <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateEnd</primary></indexterm>inflateEnd <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>zlibVersion</primary></indexterm>zlibVersion <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflateCopy</primary></indexterm>deflateCopy <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzdopen</primary></indexterm>gzdopen <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzputs</primary></indexterm>gzputs <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateInit2_</primary></indexterm>inflateInit2_ <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deflateEnd</primary></indexterm>deflateEnd <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzeof</primary></indexterm>gzeof <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>gzread</primary></indexterm>gzread <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inflateInit_</primary></indexterm>inflateInit_ <LINK LINKEND="std-127-10-tbl-libz-com-ints">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>
<FORMALPARA><TITLE><ANCHOR id="std-127-10-tbl-libz-com-ints">[1]</TITLE><para><XREF LINKEND=std.LSB></para></FORMALPARA>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libz-ddefs>
<TITLE>Data Definitions for libz</TITLE>
<PARA>
This section defines global identifiers and their values that are associated with interfaces contained in libz.
These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
These definitions are intended to supplement those provided in the referenced underlying specifications.
</PARA>
<PARA>
This specification uses ISO/IEC 9899 C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>zlib.h</TITLE>
<PARA>
In addition to the values below, the <filename>zlib.h</filename> 
header shall define the
<constant>ZLIB_VERSION</constant> macro. This macro may be used
to check that the version of the library at run time matches that
at compile time.
</PARA>
<PARA>
See also the <FUNCTION>zlibVersion</FUNCTION> function, which returns
the library version at run time. The first character of the version 
at compile time should always match the first character at run time.
</PARA>
<SCREEN>

#define Z_NULL	0
#define MAX_WBITS	15
#define MAX_MEM_LEVEL	9
#define deflateInit2(strm,level,method,windowBits,memLevel,strategy)	deflateInit2_((strm),(level),(method),(windowBits),(memLevel),(strategy),ZLIB_VERSION,sizeof(z_stream))
#define deflateInit(strm,level)	deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm,windowBits)	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm)	inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))

typedef char charf;
typedef int intf;

typedef void *voidpf;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef uLong uLongf;
typedef void *voidp;
typedef unsigned char Byte;
typedef off_t z_off_t;
typedef void *const voidpc;

typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);
struct internal_state
{
  int dummy;
}
 ;
typedef Byte Bytef;
typedef uInt uIntf;

typedef struct z_stream_s
{
  Bytef *next_in;
  uInt avail_in;
  uLong total_in;
  Bytef *next_out;
  uInt avail_out;
  uLong total_out;
  char *msg;
  struct internal_state *state;
  alloc_func zalloc;
  free_func zfree;
  voidpf opaque;
  int data_type;
  uLong adler;
  uLong reserved;
}
z_stream;

typedef z_stream *z_streamp;
typedef voidp gzFile;
#define Z_NO_FLUSH	0
#define Z_PARTIAL_FLUSH	1
#define Z_SYNC_FLUSH	2
#define Z_FULL_FLUSH	3
#define Z_FINISH	4

#define Z_ERRNO	(-1)
#define Z_STREAM_ERROR	(-2)
#define Z_DATA_ERROR	(-3)
#define Z_MEM_ERROR	(-4)
#define Z_BUF_ERROR	(-5)
#define Z_VERSION_ERROR	(-6)
#define Z_OK	0
#define Z_STREAM_END	1
#define Z_NEED_DICT	2

#define Z_DEFAULT_COMPRESSION	(-1)
#define Z_NO_COMPRESSION	0
#define Z_BEST_SPEED	1
#define Z_BEST_COMPRESSION	9

#define Z_DEFAULT_STRATEGY	0
#define Z_FILTERED	1
#define Z_HUFFMAN_ONLY	2

#define Z_BINARY	0
#define Z_ASCII	1
#define Z_UNKNOWN	2

#define Z_DEFLATED	8
</SCREEN>
</SECT2>
</SECT1>
<SECT1 ID=libzman>
<TITLE>Interface Definitions for libz</TITLE>
<PARA>
The following interfaces are included in libz and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed above for libz shall behave as described
in the referenced base document.
</PARA>
<refentry id="zlib-adler32-1">

<refmeta>
<refentrytitle>adler32</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>adler32</refname>
<refpurpose>Compute Adler 32 Checksum</refpurpose>
<indexterm id="ix-utillib-adler32-1">
  <primary>adler32</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>uLong
<function>adler32</function>
</funcdef>
<paramdef>uLong
<parameter>adler</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>buf</parameter>
</paramdef>
<paramdef>uInt
<parameter>len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>adler32</function> function shall compute a running
Adler-32 checksum (as described in <xref linkend="std.rfc1950">).
On entry, <parameter>adler</parameter> is the previous value for the
checksum, and <parameter>buf</parameter> shall point to an array of
<parameter>len</parameter> bytes of data to be added to this checksum.
The <function>adler32</function> function shall return the new checksum.
</para>
<para>
If <parameter>buf</parameter> is <constant>NULL</constant> (or 
<constant>Z_NULL</constant>), <function>adler32</function>
shall return the initial checksum.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>adler32</function> function shall return  
the new checksum value.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The following code fragment demonstrates typical usage of
the <function>adler32</function> function:
<programlisting>
     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
</programlisting>
</para>
</refsect1>
</refentry>


<refentry id="zlib-compress-1">

<refmeta>
<refentrytitle>compress</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compress</refname>
<refpurpose>compress data</refpurpose>
<indexterm id="ix-utillib-compress-1">
  <primary>compress</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compress</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compress</function> function shall attempt to compress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>. 
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value
be at least 
<inlineequation>
  <alt>(sourceLen &times; 1.001) &plus; 12</alt>
  <graphic>
</inlineequation>.
<!-- NB, above equation needs special stylesheet considerations ...
     it does not actually contain a graphic (well, the graphic element
     does not contain a fileref), and only the ALT element has anything
     of interest-->
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of compressed data in
<parameter>dest</parameter>.
</para>
<para>
The <function>compress</function> function is equivalent to 
<function>compress2</function> with a <parameter>level</parameter> of
<constant>Z_DEFAULT_LEVEL</constant>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>compress</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>compress</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>compress</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
compressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="zlib-compress2-1">

<refmeta>
<refentrytitle>compress2</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compress2</refname>
<refpurpose>compress data at a specified level</refpurpose>
<indexterm id="ix-utillib-compress2-1">
  <primary>compress2</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compress2</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compress2</function> function shall attempt to compress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>, at the level described by 
<parameter>level</parameter>. 
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value
be at least 
<inlineequation>
  <alt>(sourceLen &times; 1.001) &plus; 12</alt>
  <graphic>
</inlineequation>.
<!-- NB, above equation needs special stylesheet considerations ...
     it does not actually contain a graphic (well, the graphic element
     does not contain a fileref), and only the ALT element has anything
     of interest-->
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of compressed data in
<parameter>dest</parameter>.
</para>
<para>
The <function>compress</function> function is equivalent to 
<function>compress2</function> with a <parameter>level</parameter> of
<constant>Z_DEFAULT_LEVEL</constant>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>compress2</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>compress2</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>compress2</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
compressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The <parameter>level</parameter> was not <constant>Z_DEFAULT_LEVEL</constant>,
or was not between 0 and 9.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="zlib-compressBound-1">

<refmeta>
<refentrytitle>compressBound</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>compressBound</refname>
<refpurpose>compute compressed data size</refpurpose>
<indexterm id="ix-utillib-compressBound-1">
  <primary>compressBound</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>compressBound</function>
</funcdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>compressBound</function> function shall estimate the size
of buffer required to compress <parameter>sourceLen</parameter>
bytes of data using the <function>compress</function>
or <function>compress2</function> functions.
If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<parameter>sourceLen</parameter> bytes of data, using the
parameters stored in <parameter>stream</parameter>, 
in a single
call to <function>compress</function> or 
<function>compress2</function>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>compressBound</function> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <function>compress</function>
or <function>compress2</function>.
This function may return a conservative value that may be larger than 
<parameter>sourceLen</parameter>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-crc32-1">

<refmeta>
<refentrytitle>crc32</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>crc32</refname>
<refpurpose>Compute CRC-32 Checksum</refpurpose>
<indexterm id="ix-utillib-crc32-1">
  <primary>crc32</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>uLong
<function>crc32</function>
</funcdef>
<paramdef>uLong
<parameter>crc</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>buf</parameter>
</paramdef>
<paramdef>uInt
<parameter>len</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>crc32</function> function shall compute a running
Cyclic Redundancy Check checksum, as defined in <xref linkend="std.ituv42">.
On entry, <parameter>crc</parameter> is the previous value for the
checksum, and <parameter>buf</parameter> shall point to an array of
<parameter>len</parameter> bytes of data to be added to this checksum.
The <function>crc32</function> function shall return the new checksum.
</para>
<para>
If <parameter>buf</parameter> is <constant>NULL</constant> (or 
<constant>Z_NULL</constant>), <function>crc32</function>
shall return the initial checksum.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>crc32</function> function shall return  
the new checksum value.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The following code fragment demonstrates typical usage of
the <function>crc32</function> function:
<programlisting>
     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
</programlisting>
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflate-1">

<refmeta>
<refentrytitle>deflate</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflate</refname>
<refpurpose>compress data</refpurpose>
<indexterm id="ix-utillib-deflate-1">
  <primary>deflate</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflate</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflate</function> function shall attempt to compress
data until either the input buffer is empty or the output buffer is full.
The <parameter>stream</parameter> references a
<structname>z_stream</structname> structure. Before the first call to
<function>deflate</function>, this structure
should have been initialized by a call to 
<function>deflateInit2_</function>.
<note><para>
<function>deflateInit2_</function> is only in the binary standard; source
level applications should initialize <parameter>stream</parameter>
via a call to <function>deflateInit</function> or 
<function>deflateInit2</function>.
</para></note>
In addition, the <parameter>stream</parameter> input and output buffers
should have been initialized as follows:
<variablelist>
<varlistentry>
<term><structfield>next_in</structfield></term>
<listitem><para>
should point to the data to be compressed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_in</structfield></term>
<listitem><para>
should contain the number of bytes of data in the
buffer referenced by <structfield>next_in</structfield>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>next_out</structfield></term>
<listitem><para>
should point to a buffer where compressed data may be placed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_out</structfield></term>
<listitem><para>
should contain the size in bytes of the
buffer referenced by <structfield>next_out</structfield>
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>deflate</function> function
shall perform one or both of the following actions:
<orderedlist>
<listitem><para>
Compress input data from <structfield>next_in</structfield>
and update <structfield>next_in</structfield>,
<structfield>avail_in</structfield> and
<structfield>total_in</structfield> to reflect the data that has been 
compressed.
</para></listitem>
<listitem><para>
Fill the output buffer referenced by <structfield>next_out</structfield>,
and update <structfield>next_out</structfield>,
<structfield>avail_out</structfield> and
<structfield>total_out</structfield> to reflect the compressed data that 
has been placed there. If <parameter>flush</parameter> is not
<constant>Z_NO_FLUSH</constant>, and
<structfield>avail_out</structfield> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).
</para></listitem>
</orderedlist>
</para>
<para>
The <function>deflate</function> function shall return when either
<structfield>avail_in</structfield> reaches zero (indicating that all the input
data has been compressed), or <structfield>avail_out</structfield> reaches
zero (indicating that the output buffer is full).
</para>
<para>
On success, the <function>deflate</function> function shall set the
<structfield>adler</structfield> field of the <parameter>stream</parameter>
to the <function>adler32</function> checksum of all the input data compressed
so far (represented by <structfield>total_in</structfield>).
</para>
<para>
If the <function>deflate</function> function shall attempt to determine
the type of input data, and set field <structfield>data_type</structfield>
in <parameter>stream</parameter> to <constant>Z_ASCII</constant> if the
majority of the data bytes fall within the ASCII (ISO 646) printable
character range. Otherwise, it shall set <structfield>data_type</structfield>
to <constant>Z_BINARY</constant>.
This data type is informational only, and does not affect the compression
algorithm.
<note><para>
Future versions of the LSB may remove this requirement, since it is based
on an outdated character set that does not support Internationalization,
and does not affect the algorithm. It is included for information
only at this release. Applications should not depend on this field.
</para></note>
</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines when compressed bits 
are added to the output buffer in <structfield>next_out</structfield>.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>deflate</function>
may return with some data pending output, and not yet added to the 
output buffer.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>deflate</function> shall flush all pending output to
<structfield>next_out</structfield> and align the output to a byte 
boundary. A synchronization point is generated in  the output.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_FULL_FLUSH</constant>,
all output shall be flushed, as for <constant>Z_SYNC_FLUSH</constant>,
and the compression state shall be reset. 
A synchronization point is generated in  the output.
<note><title>Rationale</title>
<para>
<constant>Z_SYNC_FLUSH</constant> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <constant>Z_FULL_FLUSH</constant>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.
</para>
</note>
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all pending input shall be processed and <function>deflate</function>
shall return with <returnvalue>Z_STREAM_END</returnvalue> if there is
sufficient space in the output buffer at <structfield>next_out</structfield>,
as indicated by <structfield>avail_out</structfield>. If
<function>deflate</function> is called with <parameter>flush</parameter>
set to <constant>Z_FINISH</constant> and there is insufficient space to store
the compressed data, and no other error has occurred during compression,
<function>deflate</function> shall return <returnvalue>Z_OK</returnvalue>,
and the application should call <function>deflate</function> again with
<parameter>flush</parameter> unchanged, and having updated <structfield>
next_out</structfield> and <structfield>avail_out</structfield>.
</para>
<para>
If all the compression is to be done in a single step, 
<function>deflate</function>
may be called with <parameter>flush</parameter> set to 
<constant>Z_FINISH</constant> immediately after the stream
has been initialized if <structfield>avail_out</structfield>
is set to at least the value returned by <function>deflateBound</function>.
</para>

</refsect2>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflate</function> shall return  
<returnvalue>Z_OK</returnvalue>, unless <parameter>flush</parameter> was set 
to <constant>Z_FINISH</constant> and there was sufficient space in the output buffer
to compress all of the input data. In this case, <function>deflate</function>
shall return <returnvalue>Z_STREAM_END</returnvalue>.
On error, <function>deflate</function> shall return a value to indicate
the error.
<note><para>
If <function>deflate</function> returns <returnvalue>Z_OK</returnvalue>
and has set <structfield>avail_out</structfield> to zero, the function should
be called again with the same value for <parameter>flush</parameter>, and with
updated <structfield>next_out</structfield> and 
<structfield>avail_out</structfield> until <function>deflate</function>
returns with <returnvalue>Z_OK</returnvalue> (or <returnvalue>Z_STREAM_END</returnvalue>
if <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>) and a non-zero 
<structfield>avail_out</structfield>.
</para>
</note>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflate</function> shall return a value as described 
below, and set the <structfield>msg</structfield> field of 
<parameter>stream</parameter> to point to a string describing the error:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
No progress is possible; either <structfield>avail_in</structfield>
or <structfield>avail_out</structfield> was zero.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateBound-1">

<refmeta>
<refentrytitle>deflateBound</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateBound</refname>
<refpurpose>compute compressed data size</refpurpose>
<indexterm id="ix-utillib-deflateBound-1">
  <primary>deflateBound</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateBound</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateBound</function> function shall estimate the size
of buffer required to compress <parameter>sourceLen</parameter>
bytes of data. If successful, the value returned shall be an upper
bound for the size of buffer required to compress 
<parameter>sourceLen</parameter> bytes of data, using the
parameters stored in <parameter>stream</parameter>, 
in a single
call to <function>deflate</function> with flush set to
<constant>Z_FINISH</constant>.
</para>
<para>
On entry, <parameter>stream</parameter> 
should
have been initialized via a call to <function>deflateInit_</function>
or <function>deflateInit2_</function>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>deflateBound</function> shall return a value
representing the upper bound of an array to allocate to hold
the compressed data in a single call to <function>deflate</function>.
If the <parameter>stream</parameter> is not correctly initialized,
or is <constant>NULL</constant>, then <function>deflateBound</function>
may return a conservative value that may be larger than 
<parameter>sourceLen</parameter>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-deflateCopy-1">

<refmeta>
<refentrytitle>deflateCopy</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateCopy</refname>
<refpurpose>copy compression stream</refpurpose>
<indexterm id="ix-utillib-deflateCopy-1">
  <primary>deflateCopy</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateCopy</function>
</funcdef>
<paramdef>z_streamp
<parameter>dest</parameter>
</paramdef>
<paramdef>z_streamp
<parameter>source</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateCopy</function> function shall copy the compression state
information in <parameter>source</parameter> to the uninitialized
<structname>z_stream</structname> structure referenced by 
<parameter>dest</parameter>.
</para>
<para>
On successful return, <parameter>dest</parameter> will be an exact copy
of the stream referenced by <parameter>source</parameter>. The input and
output buffer pointers in <structfield>next_in</structfield> and
<structfield>next_out</structfield> will reference the same data.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateCopy</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return a value less than zero to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateCopy</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>source</parameter> is inconsistent, or
either <parameter>source</parameter> or
<parameter>dest</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
This function can be useful when several compression strategies will
be tried, for example when there are several ways of pre-processing the
input data with a filter. The streams that will be discarded should then
be freed by calling <function>deflateEnd</function>. Note that 
<function>deflateCopy</function> duplicates the
internal compression state which can be quite large, so this strategy
may be slow and can consume lots of memory.
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateEnd-1">

<refmeta>
<refentrytitle>deflateEnd</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateEnd</refname>
<refpurpose>free compression stream state</refpurpose>
<indexterm id="ix-utillib-deflateEnd-1">
  <primary>deflateEnd</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateEnd</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateEnd</function> function shall free all allocated
state information referenced by <parameter>stream</parameter>.
All pending output is discarded, and unprocessed input is ignored.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateEnd</function> shall return  
<returnvalue>Z_OK</returnvalue>, or <returnvalue>Z_DATA_ERROR</returnvalue>
if there was pending output discarded or input unprocessed.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateEnd</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateInit2" xreflabel="deflateInit2_">

<refmeta>
<refentrytitle>deflateInit2_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateInit2_</refname>
<refpurpose>initialize compression system</refpurpose>
<indexterm id="ix-utillib-deflateInit2-1">
  <primary>deflateInit2_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>deflateInit2_</function>
  </funcdef>
  <paramdef>z_streamp <parameter>strm</parameter></paramdef>
  <paramdef>int <parameter>level</parameter></paramdef>
  <paramdef>int <parameter>method</parameter></paramdef>
  <paramdef>int <parameter>windowBits</parameter></paramdef>
  <paramdef>int <parameter>memLevel</parameter></paramdef>
  <paramdef>int <parameter>strategy</parameter></paramdef>
  <paramdef>char * <parameter>version</parameter></paramdef>
  <paramdef>int <parameter>stream_size</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateInit2_</function> function shall initialize the compression
system.
On entry, <parameter>strm</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>deflateInit2_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
The <parameter>method</parameter> selects the compression algorithm to use. LSB
conforming implementation shall support the <constant>Z_DEFLATED</constant> method,
and may support other implementation defined methods.
</para>
<para>
The <parameter>windowBits</parameter> parameter shall be a base 2 logarithm of the window 
size to use, and shall be a value between <constant>8</constant> and <constant>15</constant>.
A smaller value will use less memory, but will result in a poorer compression ratio, 
while a higher value will
give better compression but utilize more memory.
</para>
<para>
The <parameter>memLevel</parameter> parameter specifies how much memory to use for the 
internal state. The value of <parameter>memLevel</parameter> shall be between
<constant>1</constant> and <constant>MAX_MEM_LEVEL</constant>. Smaller values
use less memory but are slower, while higher values use more memory to gain compression speed.
</para>
<para>
The <parameter>strategy</parameter> parameter selects the compression strategy to use:
<variablelist>
<varlistentry>
<term><constant>Z_DEFAULT_STRATEGY</constant></term>
<listitem><para>
use the system default compression strategy. <constant>Z_DEFAULT_STRATEGY</constant>
is particularly appropriate for text data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_FILTERED</constant></term>
<listitem><para>
use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <constant>Z_FILTERED</constant> uses more Huffman encoding
and less string matching than <constant>Z_DEFAULT_STRATEGY</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_HUFFMAN_ONLY</constant></term>
<listitem><para>
force Huffman encoding only, with no string match.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>deflateInit2_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>deflateInit2</function> macro.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateInit2_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateInit2_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateInit2_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>

<refentry id="zlib-deflateInit" xreflabel="deflateInit_">

<refmeta>
<refentrytitle>deflateInit_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateInit_</refname>
<refpurpose>initialize compression system</refpurpose>
<indexterm id="ix-utillib-deflateInit-1">
  <primary>deflateInit_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateInit_</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>const char *
<parameter>version</parameter>
</paramdef>
<paramdef>int
<parameter>stream_size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateInit_</function> function shall initialize 
the compression
system.
On entry, <parameter>stream</parameter> shall refer to a user 
supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). 
The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory
allocated by the
<structfield>zalloc</structfield> function. If this is
<constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data
that will be passed to the
<structfield>alloc_func</structfield> and
<structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with
the version implemented, or if the size of the
<structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size
in the library
implementation, <function>deflateInit_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a
<parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
</para>
<para>
The <function>deflateInit_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>deflateInit</function> macro.
</para>
<para>
The <function>deflateInit_</function> function is equivalent to
<programlisting>
 deflateInit2_(stream, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
</programlisting>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateInit_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateInit_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateInit_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the 
<parameter>stream</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>

<refentry id="zlib-deflateParams-1">

<refmeta>
<refentrytitle>deflateParams</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateParams</refname>
<refpurpose>set compression parameters</refpurpose>
<indexterm id="ix-utillib-deflateParams-1">
  <primary>deflateParams</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateParams</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>level</parameter>
</paramdef>
<paramdef>int
<parameter>strategy</parameter>
</paramdef>
 
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateParams</function> function shall dynamically
alter the compression parameters for the compression stream object
<parameter>stream</parameter>.
On entry, <parameter>stream</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure), already initialized
via a call to <function>deflateInit_</function> or
<function>deflateInit2_</function>.
</para>
<para>
The <parameter>level</parameter> supplied shall be a value between
<constant>0</constant> and <constant>9</constant>, or the value
<constant>Z_DEFAULT_COMPRESSION</constant>. A <parameter>level</parameter>
of <constant>1</constant> requests the highest speed, while a <parameter>level</parameter>
of <constant>9</constant> requests the highest compression.
A <parameter>level</parameter> of <constant>0</constant> indicates that no
compression should be used, and the output shall be the same as the input.
If the compression level is altered by <function>deflateParams</function>,
and some data has already been compressed with this <parameter>stream</parameter>
(i.e. <structfield>total_in</structfield> is not zero),
and the new <parameter>level</parameter> requires a different
underlying compression method, then <parameter>stream</parameter>
shall be flushed by a call to <function>deflate</function>.
</para>
<para>
The <parameter>strategy</parameter> parameter selects the compression strategy to use:
<variablelist>
<varlistentry>
<term><constant>Z_DEFAULT_STRATEGY</constant></term>
<listitem><para>
use the system default compression strategy. <constant>Z_DEFAULT_STRATEGY</constant>
is particularly appropriate for text data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_FILTERED</constant></term>
<listitem><para>
use a compression strategy tuned for data consisting largely of small values with a
fairly random distribution. <constant>Z_FILTERED</constant> uses more Huffman encoding
and less string matching than <constant>Z_DEFAULT_STRATEGY</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_HUFFMAN_ONLY</constant></term>
<listitem><para>
force Huffman encoding only, with no string match.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>deflateParams</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>deflateParams</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateParams</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
Insufficient space in <parameter>stream</parameter> 
to flush the current output.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
<refsect1>
<title>Application Usage (Informative)</title>
<para>
Applications should ensure that the <parameter>stream</parameter> is flushed,
e.g. by a call to <userinput>deflate(stream, Z_SYNC_FLUSH)</userinput>
before calling <function>deflateParams</function>, or ensure that there is
sufficient space in <structfield>next_out</structfield> (as identified by
<structfield>avail_out</structfield>) to ensure that all pending output and
all uncompressed input can be flushed in a single call to
<function>deflate</function>.
<note><title>Rationale</title>
<para>
Although the <function>deflateParams</function> function should flush pending output
and compress all pending input, the result is unspecified if there is insufficient
space in the output buffer. Applications should only call <function>deflateParams</function>
when the <parameter>stream</parameter> is effectively empty (flushed).
</para>
<para>
The <function>deflateParams</function> can be used to switch between
compression and straight copy of the
input data, or to switch to a different kind of input data requiring a
different strategy.
</para>
</note>
</para>
</refsect1>
</refentry>
<!--
 Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented ; you
   must not claim that you wrote the original software. If you use this
   software in a product, an acknowledgment in the product documentation
   would be appreciated but is not required.  2. Altered source versions
   must be plainly marked as such, and must not be misrepresented as
   being the original software.  3. This notice may not be removed or
   altered from any source distribution.

Jean-loup Gailly
    jloup@gzip.org
Mark Adler
    madler@alumni.caltech.edu  
-->

<refentry id="zlib-deflateReset-1">

<refmeta>
<refentrytitle>deflateReset</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateReset</refname>
<refpurpose>reset compression stream state</refpurpose>
<indexterm id="ix-utillib-deflateReset-1">
  <primary>deflateReset</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateReset</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateReset</function> function shall reset all state
associated with <parameter>stream</parameter>.
All pending output shall be discarded, and the counts of processed
bytes (<structfield>total_in</structfield> and 
<structfield>total_out</structfield>) shall be reset to zero.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateReset</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateReset</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-deflateSetDictionary-1">

<refmeta>
<refentrytitle>deflateSetDictionary</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>deflateSetDictionary</refname>
<refpurpose>initialize compression dictionary</refpurpose>
<indexterm id="ix-utillib-deflateSetDictionary-1">
  <primary>deflateSetDictionary</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>deflateSetDictionary</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>dictionary</parameter>
</paramdef>
<paramdef>uInt
<parameter>dictlen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>deflateSetDictionary</function> function shall initialize the
compression dictionary associated with <parameter>stream</parameter>
using the <parameter>dictlen</parameter> bytes referenced by
<parameter>dictionary</parameter>.
</para>
<para>
The implementation may silently use a subset of the provided dictionary
if the dictionary cannot fit in the current window associated with
<parameter>stream</parameter> (see <function>deflateInit2_</function>).
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
If the dictionary is successfully set, the Adler32 checksum of the entire
provided dictionary
shall be stored in the <structfield>adler</structfield> member of 
<parameter>stream</parameter>. This value may be used by the decompression
system to select the correct dictionary. The compression and decompression 
systems must use the same dictionary.
</para>
<para>
<parameter>stream</parameter> shall reference an initialized compression
stream, with <structfield>total_in</structfield> zero (i.e. no data
has been compressed since the stream was initialized).
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>deflateSetDictionary</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate an error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>deflateSetDictionary</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent, or
<parameter>stream</parameter> 
was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.
</para>
</refsect1>
</refentry>


<refentry id="zlib-get-crc-table-1">

<refmeta>
<refentrytitle>get_crc_table</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>get_crc_table</refname>
<refpurpose>generate a table for crc calculations</refpurpose>
<indexterm id="ix-utillib-get-crc-table-1">
  <primary>get_crc_table</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>const uLongf *
<function>get_crc_table</function>
</funcdef>
<void>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
Generate tables for a byte-wise 32-bit CRC calculation based on the polynomial:
<literal>x<superscript>32</superscript>+x<superscript>26</superscript>+x<superscript>23</superscript>+x<superscript>22</superscript>+x<superscript>16</superscript>+x<superscript>12</superscript>+x<superscript>11</superscript>+x<superscript>10</superscript>+x<superscript>8</superscript>+x<superscript>7</superscript>+x<superscript>5</superscript>+x<superscript>4</superscript>+x<superscript>2</superscript>+x+1</literal>
</para>
<para>
In a multi-threaded application, <function>get_crc_table</function>
should be called by one thread to initialize the tables before any other
thread calls any <literal>libz</literal> function.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>get_crc_table</function> function shall return a
pointer to the first of a set of tables used internally to calculate
CRC-32 values (see <function>crc32</function>).
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzclose-1">

<refmeta>
<refentrytitle>gzclose</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzclose</refname>
<refpurpose>close a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzclose-1">
  <primary>gzclose</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzclose</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzclose</function> function shall close the compressed file stream
<parameter>file</parameter>.
If <parameter>file</parameter> was open for writing, <function>gzclose</function>
shall first flush any pending output. Any state information allocated shall
be freed.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzclose</function> shall return 
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>gzclose</function> shall return an error value as described below.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzclose</function> may set
the global variable <varname>errno</varname>
to indicate the error.
The <function>gzclose</function> shall return a value other than <constant>Z_OK</constant>
on error.
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem>
<para>
<parameter>file</parameter> was <constant>NULL</constant> (or <constant>Z_NULL</constant>),
or did not refer to an open compressed file stream.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An error occurred in the underlying base libraries, and the application should check
<varname>errno</varname> for further information.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible during buffer flush (see <function>deflate</function>).
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzdopen-1">

<refmeta>
<refentrytitle>gzdopen</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzdopen</refname>
<refpurpose>open a compressed file</refpurpose>
<indexterm id="ix-utillib-gzdopen-1">
  <primary>gzdopen</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   gzFile <function>gzdopen</function>
  </funcdef>
  <paramdef> int <parameter>fd</parameter></paramdef>
  <paramdef> const char *<parameter>mode</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzdopen</function> function shall attempt to associate
the open file
referenced by <parameter>fd</parameter> with a <type>gzFile</type>
object.
The <parameter>mode</parameter> argument is based on that of 
<function>fopen</function>, but the 
<parameter>mode</parameter> parameter may also contain the following characters:
<variablelist>
<varlistentry>
<term><replaceable>digit</replaceable></term>
<listitem>
<para>
set the compression level to <replaceable>digit</replaceable>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <function>defaultInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><replaceable>[fhR]</replaceable></term>
<listitem>
<para>
set the compression strategy to <replaceable>[fhR]</replaceable>.
The letter <literal>f</literal> corresponds to filtered data, 
the letter <literal>h</literal>
corresponds to Huffman only compression, and 
the letter <literal>R</literal>
corresponds to Run Length Encoding.
See <function>defaultInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>

<para>
If <parameter>fd</parameter> refers to an uncompressed file, and 
<parameter>mode</parameter> refers to a read mode, 
<function>gzdopen</function> shall attempt to open the file and return
a <type>gzFile</type> object suitable for reading directly from the file
without any decompression.
</para>
<para>
If <parameter>mode</parameter>
is <literal>NULL</literal>, or if <parameter>mode</parameter> does not contain
one of <simplelist type=inline>
<member><literal>r</literal></member>
<member><literal>w</literal></member>
<member>or <literal>a</literal></member>
</simplelist>,
<function>gzdopen</function> shall return <constant>Z_NULL</constant>,
and need not set any other error condition.
</para>
</refsect1>
<refsect1>
<title>Example</title>
<para>
<synopsis>
gzdopen(fileno(stdin), "r");
</synopsis>
Attempt to associate the standard input with a <type>gzFile</type> object.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzdopen</function> shall return a 
<type>gzFile</type> object. On failure, 
<function>gzdopen</function> shall return <constant>Z_NULL</constant> and
may set <varname>errno</varname> accordingly.
<NOTE><para>
At version 1.2.2, <varname>zlib</varname>
does not set <varname>errno</varname> for several
error conditions. Applications may not be able to
determine the cause of an error.
</para></NOTE>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzdopen</function> may set
the global variable <varname>errno</varname>
to indicate the error.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzeof-1">

<refmeta>
<refentrytitle>gzeof</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzeof</refname>
<refpurpose>check for end-of-file on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzeof-1">
  <primary>gzeof</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzeof</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzeof</function> function shall test the compressed file stream
<parameter>file</parameter> for end of file.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
If <parameter>file</parameter> was open for reading
and end of file has been reached, <function>gzeof</function> shall return 
<returnvalue>1</returnvalue>.
Otherwise, <function>gzeof</function> shall return <returnvalue>0</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzerror-1">

<refmeta>
<refentrytitle>gzerror</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzerror</refname>
<refpurpose>decode an error on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzerror-1">
  <primary>gzerror</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   const char * <function>gzerror</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int * <parameter>errnum</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzerror</function> function shall return a string describing
the last error to have occurred associated with the open compressed file stream
referred to by <parameter>file</parameter>.
It shall also set the location referenced by
<parameter>errnum</parameter> to an integer value that further identifies the
error.

</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>gzerror</function> function shall return a string that
describes the last error associated with the given
<parameter>file</parameter> compressed file stream.
This string shall have the format
<literal>"%s: %s"</literal>, with the name of the file, followed by a colon,
a space, and the description of the error. If the compressed file stream
was opened by a call to <function>gzdopen</function>, the format of the
filename is unspecified.
<NOTE><TITLE>Rationale</TITLE>
<para>Although in all current implementations of libz file descriptors
are named <literal>"&lt;fd:%d&gt;"</literal>, the code suggests that this
is for debugging purposes only, and may change in a future release.
</para>
</NOTE>
</para>
<para>
It is unspecified if the string returned is determined by the setting
of the <constant>LC_MESSAGES</constant> category in the current locale.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzflush-1">

<refmeta>
<refentrytitle>gzflush</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzflush</refname>
<refpurpose>flush a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzflush-1">
  <primary>gzflush</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>gzflush</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzflush</function> function shall flush pending
output to the compressed file stream identified by
<parameter>file</parameter>, which must be open for writing.

</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines which compressed bits 
are added to the output file.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>gzflush</function>
may return with some data pending output, and not yet written to the file.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>gzflush</function> shall flush all pending output to
<parameter>file</parameter> and align the output to a byte 
boundary.
There may still be data pending compression that is not flushed.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_FULL_FLUSH</constant>,
all output shall be flushed, as for <constant>Z_SYNC_FLUSH</constant>,
and the compression state shall be reset.
There may still be data pending compression that is not flushed.
<note><title>Rationale</title>
<para>
<constant>Z_SYNC_FLUSH</constant> is intended to ensure that the compressed
data contains all the data compressed so far, and allows a decompressor
to reconstruct all of the input data. <constant>Z_FULL_FLUSH</constant>
allows decompression to restart from this point if the previous compressed
data has been lost or damaged. Flushing is likely to degrade the
performance of the compression system, and should only be used where
necessary.
</para>
</note>
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all pending uncompressed data shall be compressed
and all output shall be flushed.
</para>

</refsect2>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzflush</function> shall return the value
<returnvalue>Z_OK</returnvalue>.
Otherwise <function>gzflush</function> shall return
a value to indicate the error, and may set the error number
associated with the compressed file stream 
<parameter>file</parameter>.
<note><para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>
and the flush operation is successful, <function>gzflush</function>
will return <returnvalue>Z_OK</returnvalue>, but the compressed
file stream error value may be set to <constant>Z_STREAM_END</constant>.
</para></note>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzwrite</function> shall return an error
value, and may set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications may use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzgetc-1">

<refmeta>
<refentrytitle>gzgetc</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzgetc</refname>
<refpurpose>read a character from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzgetc-1">
  <primary>gzgetc</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzgetc</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzgetc</function> function shall read the next single
character from the compressed file stream
referenced by <parameter>file</parameter>, which shall have been opened
in a read mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzgetc</function> shall return the uncompressed
character read,
otherwise, on end of file or error, <function>gzgetc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On end of file or error, <function>gzgetc</function> shall return
<returnvalue>-1</returnvalue>. Further information can be found
by calling <function>gzerror</function> with a pointer to the 
compressed file stream.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzgets-1">

<refmeta>
<refentrytitle>gzgets</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzgets</refname>
<refpurpose>read a string from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzgets-1">
  <primary>gzgets</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   char * <function>gzgets</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>char * <parameter>buf</parameter></paramdef>
  <paramdef>int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzgets</function> function shall attempt to read
data from the compressed file stream <parameter>file</parameter>,
uncompressing it into <parameter>buf</parameter> until
either <parameter>len</parameter><literal>-1</literal> bytes
have been inserted into <parameter>buf</parameter>, or until
a newline character has been uncompressed into <parameter>buf</parameter>.
A null byte shall be appended to the uncompressed data. The
<parameter>file</parameter> shall have been opened
in for reading (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzgets</function> shall return a pointer to 
<parameter>buf</parameter>. Otherwise, <function>gzgets</function>
shall return <returnvalue>Z_NULL</returnvalue>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzgets</function> shall 
return <returnvalue>Z_NULL</returnvalue>. The following conditions shall
always be treated as an error:
<simplelist>
<member><parameter>file</parameter> is <constant>NULL</constant>,
or does not refer to a file open for reading;</member>
<member><parameter>buf</parameter> is <constant>NULL</constant>;</member>
<member><parameter>len</parameter> is less than or equal to zero.</member>
</simplelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzopen-1">

<refmeta>
<refentrytitle>gzopen</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzopen</refname>
<refpurpose>open a compressed file</refpurpose>
<indexterm id="ix-utillib-gzopen-1">
  <primary>gzopen</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   gzFile <function>gzopen</function>
  </funcdef>
  <paramdef>const char *<parameter>path</parameter> </paramdef>
  <paramdef>const char *<parameter>mode</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzopen</function> function shall open the compressed file
named by <parameter>path</parameter>.
The <parameter>mode</parameter> argument is based on that of 
<function>fopen</function>, but the 
<parameter>mode</parameter> parameter may also contain the following characters:
<variablelist>
<varlistentry>
<term><replaceable>digit</replaceable></term>
<listitem>
<para>
set the compression level to <replaceable>digit</replaceable>.
A low value (e.g. 1) means high speed, while a high value (e.g. 9) means 
high compression. A compression level of 0 (zero) means no compression.
See <function>defaultInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><replaceable>[fhR]</replaceable></term>
<listitem>
<para>
set the compression strategy to <replaceable>[fhR]</replaceable>.
The letter <literal>f</literal> corresponds to filtered data, 
the letter <literal>h</literal>
corresponds to Huffman only compression, and 
the letter <literal>R</literal>
corresponds to Run Length Encoding.
See <function>defaultInit2_</function> for further details.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>

<para>
If <parameter>path</parameter> refers to an uncompressed file, and 
<parameter>mode</parameter> refers to a read mode, 
<function>gzopen</function> shall attempt to open the file and return
a <type>gzFile</type> object suitable for reading directly from the file
without any decompression.
</para>
<para>
If <parameter>path</parameter> or <parameter>mode</parameter>
is <literal>NULL</literal>, or if <parameter>mode</parameter> does not contain
one of <simplelist type=inline>
<member><literal>r</literal></member>
<member><literal>w</literal></member>
<member>or <literal>a</literal></member>
</simplelist>,
<function>gzopen</function> shall return <constant>Z_NULL</constant>,
and need not set any other error condition.
</para>
<para>
The <type>gzFile</type> object is also referred to as a compressed file stream.
</para>
</refsect1>
<refsect1>
<title>Example</title>
<para>
<programlisting>
gzopen("file.gz", "w6h");
</programlisting>
Attempt to create a new compressed file, <filename>file.gz</filename>,
at compression level 6 using Huffman only compression.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzopen</function> shall return a 
<type>gzFile</type> object (also known as a <emphasis>compressed
file stream</emphasis>). On failure, 
<function>gzopen</function> shall return <constant>Z_NULL</constant> and
may set <varname>errno</varname> accordingly.
<NOTE><para>
At version 1.2.2, <varname>zlib</varname>
does not set <varname>errno</varname> for several
error conditions. Applications may not be able to
determine the cause of an error.
</para></NOTE>
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzopen</function> may set
the global variable <varname>errno</varname>
to indicate the error.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzprintf-1">

<refmeta>
<refentrytitle>gzprintf</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzprintf</refname>
<refpurpose>format data and compress</refpurpose>
<indexterm id="ix-utillib-gzprintf-1">
  <primary>gzprintf</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzprintf</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>const char * <parameter>fmt</parameter></paramdef>
  <varargs>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzprintf</function> function shall format data as for
<function>fprintf</function>, and write the resulting string to the compressed
file stream <parameter>file</parameter>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>gzprintf</function> function
shall return the number of uncompressed bytes
actually written, or a value less than or equal to 
<constant>0</constant> in the event of an error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
If <parameter>file</parameter> is <constant>NULL</constant>, or refers to a 
compressed file stream that has not been opened for writing,
<function>gzprintf</function> shall return <literal>Z_STREAM_ERROR</literal>.
Otherwise, errors are as for <function>gzwrite</function>.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzputc-1">

<refmeta>
<refentrytitle>gzputc</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzputc</refname>
<refpurpose>write character to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzputc-1">
  <primary>gzputc</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzputc</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int <parameter>c</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzputc</function> function shall write the single
character <parameter>c</parameter>, converted from integer to unsigned
character, to the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzputc</function> shall return the value
written, otherwise <function>gzputc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzputc</function> shall return
<returnvalue>-1</returnvalue>.
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzputs-1">

<refmeta>
<refentrytitle>gzputs</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzputs</refname>
<refpurpose>string write to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzputs-1">
  <primary>gzputs</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzputs</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>const char * <parameter>s</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzputs</function> function shall write the null terminated
string <parameter>s</parameter> to
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
The terminating null character shall not be written.
The <function>gzputs</function> function shall return the number of 
uncompressed bytes actually written.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzputs</function> shall return the number of uncompressed
bytes actually written to <parameter>file</parameter>.
On error <function>gzputs</function> shall return a value
less than or equal to <constant>0</constant>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzputs</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
If <parameter>file</parameter> is <constant>NULL</constant>, 
<function>gzputs</function> shall return <constant>Z_STREAM_ERR</constant>.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzread-1">

<refmeta>
<refentrytitle>gzread</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzread</refname>
<refpurpose>read from a compressed file</refpurpose>
<indexterm id="ix-utillib-gzread-1">
  <primary>gzread</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzread</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>voidp <parameter>buf</parameter></paramdef>
  <paramdef>unsigned int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzread</function> function shall read data from
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a read mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
The <function>gzread</function> function shall read data from
<parameter>file</parameter>, and uncompress it into 
<parameter>buf</parameter>. At most, <parameter>len</parameter>
bytes of uncompressed data shall be copied to <parameter>buf</parameter>.
If the file is not compressed, <function>gzread</function> shall simply
copy data from <parameter>file</parameter> to <parameter>buf</parameter>
without alteration.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzread</function> shall return the number of bytes
decompressed into <parameter>buf</parameter>.
If <function>gzread</function> returns <constant>0</constant>,
either the end-of-file has been reached
or an underlying read error has occurred. Applications
should use <function>gzerror</function> or <function>gzeof</function>
to determine which occurred.
On other errors, 
<function>gzread</function> shall return a value less than 
<constant>0</constant> and
and applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzread</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_END</constant></term>
<listitem><para>
End of file has been reached on input.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
A CRC error occurred when reading data; the file is corrupt.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_NEED_DICT</constant></term>
<listitem><para>
A dictionary is needed (see <function>inflateSetDictionary</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to decompress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-gzrewind-1">

<refmeta>
<refentrytitle>gzrewind</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzrewind</refname>
<refpurpose>reset the file-position indicator on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzrewind-1">
  <primary>gzrewind</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>gzrewind</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzrewind</function> function shall set the starting position
for the next read
on compressed file stream <parameter>file</parameter> to the beginning
of file. <parameter>file</parameter> must be open for reading.
</para>
<para>
<function>gzrewind</function> is equivalent to 
<programlisting>(int)gzseek(file, 0L, SEEK_SET)</programlisting>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzrewind</function> shall return 
<returnvalue>0</returnvalue>.
On error, <function>gzrewind</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzrewind</function> shall return <constant>-1</constant>,
indicating that <parameter>file</parameter> is 
<constant>NULL</constant>, or does not represent
an open compressed file stream, or represents a compressed file stream
that is open for writing and is not currently at the beginning of file.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzseek-1">

<refmeta>
<refentrytitle>gzseek</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzseek</refname>
<refpurpose>reposition a file-position indicator in a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gzseek-1">
  <primary>gzseek</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>z_off_t
<function>gzseek</function>
</funcdef>
<paramdef>gzFile
<parameter>file</parameter>
</paramdef>
<paramdef>z_off_t
<parameter>offset</parameter>
</paramdef>
<paramdef>int
<parameter>whence</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzseek</function> function shall set the file-position
indicator for the compressed file stream <parameter>file</parameter>.
The file-position indicator controls where the next
read or write operation on the compressed file stream shall take place.
The <parameter>offset</parameter> indicates a byte offset in the
uncompressed data. The <parameter>whence</parameter> parameter
may be one of:
<variablelist>
<varlistentry>
<term><constant>SEEK_SET</constant></term>
<listitem><para>
the offset is relative to the start of the uncompressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>SEEK_CUR</constant></term>
<listitem><para>
the offset is relative to the current positition in the uncompressed data.
</para></listitem>
</varlistentry>
</variablelist>
<note><para>
The value <constant>SEEK_END</constant> need not be supported.
</para></note>
</para>
<para>
If the <parameter>file</parameter> is open for writing, the new offset
must be greater than or equal to the current offset. In this case, 
<function>gzseek</function> shall compress a sequence of null bytes
to fill the gap from the previous offset to the new offset.
</para>

</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzseek</function> shall return the resulting
offset in the file expressed
as a byte position in the <emphasis>uncompressed</emphasis> data stream.
On error, <function>gzseek</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzseek</function> shall return 
<returnvalue>-1</returnvalue>.
The following conditions shall always result in an error:
<itemizedlist>
<listitem><para>
<parameter>file</parameter> is <constant>NULL</constant>
</para></listitem>
<listitem><para>
<parameter>file</parameter> does not represent
an open compressed file stream.
</para></listitem>
<listitem><para>
<parameter>file</parameter> refers to a compressed file stream that is open
for writing, and the newly computed offset is less than the current offset.
</para></listitem>
<listitem><para>
The newly computed offset is less than zero.
</para></listitem>
<listitem><para>
<parameter>whence</parameter> is not one of the supported values.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
If <parameter>file</parameter> is open for reading, the implementation
may still need to uncompress all of the data up to the new offset.
As a result, <function>gzseek</function> may be extremely slow
in some circumstances.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzsetparams-1">

<refmeta>
<refentrytitle>gzsetparams</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzsetparams</refname>
<refpurpose>dynamically set compression parameters</refpurpose>
<indexterm id="ix-utillib-gzsetparams-1">
  <primary>gzsetparams</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzsetparams</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>int <parameter>level</parameter></paramdef>
  <paramdef>int <parameter>strategy</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzsetparams</function> function shall set the compression level and
compression strategy on the compressed file stream referenced by
<parameter>file</parameter>. The compressed file stream shall have been opened
in a write mode.
The <parameter>level</parameter> and <parameter>strategy</parameter> are as defined
in <XREF Linkend=zlib-deflateinit2>.
If there is any data pending writing, it shall be flushed before the parameters are
updated.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>gzsetparams</function> function shall return 
<constant>Z_OK</constant>. 
<!--
Otherwise, <function>gzsetparams</function> shall return
<constant>Z_STREAM_ERROR</constant>.
-->
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzsetparams</function> shall return one of the
following error indications:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter, or <parameter>file</parameter> not open for writing.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
An internal inconsistency was detected while flushing the previous buffer.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="zlib-gztell-1">

<refmeta>
<refentrytitle>gztell</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gztell</refname>
<refpurpose>find position on a compressed file stream</refpurpose>
<indexterm id="ix-utillib-gztell-1">
  <primary>gztell</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   z_off_t <function>gztell</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter> </paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gztell</function> function shall return the starting position
for the next read or write operation
on compressed file stream <parameter>file</parameter>. This position represents
the number of bytes from the beginning of file in the uncompressed data.
</para>
<para>
<function>gztell</function> is equivalent to 
<programlisting>gzseek(file, 0L, SEEK_SET)</programlisting>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
<function>gztell</function> shall return the current offset in the file expressed
as a byte position in the <emphasis>uncompressed</emphasis> data stream.
On error, <function>gztell</function> shall return -1, and
may set the error value for <parameter>file</parameter> accordingly.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gztell</function> shall return <constant>-1</constant>,
indicating that <parameter>file</parameter> is 
<constant>NULL</constant>, or does not represent
an open compressed file stream.
</para>
</refsect1>
</refentry>

<refentry id="zlib-gzwrite-1">

<refmeta>
<refentrytitle>gzwrite</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>gzwrite</refname>
<refpurpose>write to a compressed file</refpurpose>
<indexterm id="ix-utillib-gzwrite-1">
  <primary>gzwrite</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>gzwrite</function>
  </funcdef>
  <paramdef>gzFile <parameter>file</parameter></paramdef>
  <paramdef>voidpc <parameter>buf</parameter></paramdef>
  <paramdef>unsigned int <parameter>len</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>gzwrite</function> function shall write data to
the compressed file
referenced by <parameter>file</parameter>, which shall have been opened
in a write mode (see <function>gzopen</function> and 
<function>gzdopen</function>).
On entry, <parameter>buf</parameter> shall point to a buffer containing
<parameter>len</parameter>bytes of uncompressed data.
The <function>gzwrite</function> function shall compress this data and
write it to
<parameter>file</parameter>.
The <function>gzwrite</function> function shall return the number of 
uncompressed bytes actually written.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>gzwrite</function> shall return the number of 
uncompressed bytes actually written to <parameter>file</parameter>.
On error <function>gzwrite</function> shall return a value
less than or equal to <constant>0</constant>.
Applications may examine the cause using <function>gzerror</function>.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>gzwrite</function> shall set
the error number associated with the stream identified by 
<parameter>file</parameter>
to indicate the error. Applications should use <function>gzerror</function>
to access this error value.
</para>
<para>
<variablelist>
<varlistentry>
<term><constant>Z_ERRNO</constant></term>
<listitem><para>
An underlying base library function has indicated an error.
The global variable <varname>errno</varname> may be examined 
for further information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The stream is invalid, is not open for writing, or is in an invalid state.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
no compression progress is possible (see <function>deflate</function>).
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available to compress.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflate-1">

<refmeta>
<refentrytitle>inflate</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflate</refname>
<refpurpose>decompress data</refpurpose>
<indexterm id="ix-utillib-inflate-1">
  <primary>inflate</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflate</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>int
<parameter>flush</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflate</function> function shall attempt to decompress
data until either the input buffer is empty or the output buffer is full.
The <parameter>stream</parameter> references a
<structname>z_stream</structname> structure. Before the first call to
<function>inflate</function>, this structure
should have been initialized by a call to 
<function>inflateInit2_</function>.
<note><para>
<function>inflateInit2_</function> is only in the binary standard; source
level applications should initialize <parameter>stream</parameter>
via a call to <function>inflateInit</function> or 
<function>inflateInit2</function>.
</para></note>
In addition, the <parameter>stream</parameter> input and output buffers
should have been initialized as follows:
<variablelist>
<varlistentry>
<term><structfield>next_in</structfield></term>
<listitem><para>
should point to the data to be decompressed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_in</structfield></term>
<listitem><para>
should contain the number of bytes of data in the
buffer referenced by <structfield>next_in</structfield>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>next_out</structfield></term>
<listitem><para>
should point to a buffer where decompressed data may be placed.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>avail_out</structfield></term>
<listitem><para>
should contain the size in bytes of the
buffer referenced by <structfield>next_out</structfield>
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
The <function>inflate</function> function
shall perform one or both of the following actions:
<orderedlist>
<listitem><para>
Decompress input data from <structfield>next_in</structfield>
and update <structfield>next_in</structfield>,
<structfield>avail_in</structfield> and
<structfield>total_in</structfield> to reflect the data that has been 
decompressed.
</para></listitem>
<listitem><para>
Fill the output buffer referenced by <structfield>next_out</structfield>,
and update <structfield>next_out</structfield>,
<structfield>avail_out</structfield>, and
<structfield>total_out</structfield> to reflect the decompressed data that 
has been placed there. If <parameter>flush</parameter> is not
<constant>Z_NO_FLUSH</constant>, and
<structfield>avail_out</structfield> indicates that there is still space in
output buffer, this action shall always occur (see below for further details).
</para></listitem>
</orderedlist>
</para>
<para>
The <function>inflate</function> function shall return when either
<structfield>avail_in</structfield> reaches zero (indicating that all the input
data has been compressed), or <structfield>avail_out</structfield> reaches
zero (indicating that the output buffer is full).
</para>
<para>
On success, the <function>inflate</function> function shall set the
<structfield>adler</structfield> field of the <parameter>stream</parameter>
to the Adler-32 checksum of all the input data compressed
so far (represented by <structfield>total_in</structfield>).
</para>
<refsect2>
<title>Flush Operation</title>
<para>
The parameter <parameter>flush</parameter> determines when uncompressed bytes
are added to the output buffer in <structfield>next_out</structfield>.
If <parameter>flush</parameter> is <constant>Z_NO_FLUSH</constant>,
<function>inflate</function>
may return with some data pending output, and not yet added to the 
output buffer.
</para>
<para>
If <parameter>flush</parameter> is <constant>Z_SYNC_FLUSH</constant>,
<function>inflate</function> shall flush all pending output to
<structfield>next_out</structfield>, and update 
<structfield>next_out</structfield>
and <structfield>avail_out</structfield> accordingly.
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_BLOCK</constant>,
<function>inflate</function> shall stop adding data to the output
buffer if and when the next compressed block boundary is reached
(see <xref linkend="std.rfc1951">).
</para>
<para>
If <parameter>flush</parameter> is set to <constant>Z_FINISH</constant>,
all of the compressed input shall be decompressed and added to
the output. If there is insufficient output space (i.e. the compressed
input data uncompresses to more than <structfield>avail_out</structfield>
bytes), then <function>inflate</function> shall fail and return
<returnvalue>Z_BUF_ERROR</returnvalue>.
</para>
</refsect2>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflate</function> shall return  
<returnvalue>Z_OK</returnvalue> if decompression progress has been made,
or <returnvalue>Z_STREAM_END</returnvalue> if all of the input data
has been decompressed and there was sufficient space in the output
buffer to store the uncompressed result.

On error, <function>inflate</function> shall return a value to indicate
the error.
<note><para>
If <function>inflate</function> returns <returnvalue>Z_OK</returnvalue>
and has set <structfield>avail_out</structfield> to zero, the function should
be called again with the same value for <parameter>flush</parameter>, and with
updated <structfield>next_out</structfield> and 
<structfield>avail_out</structfield> until <function>inflate</function>
returns with either <returnvalue>Z_OK</returnvalue> 
or <returnvalue>Z_STREAM_END</returnvalue>
and a non-zero 
<structfield>avail_out</structfield>.
</para>
</note>
</para>
<para>
On success, <function>inflate</function> shall set the 
<structfield>adler</structfield> to the Adler-32 checksum of
the output produced so far (i.e. <structfield>total_out</structfield>
bytes).
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflate</function> shall return a value as described 
below, and may set the <structfield>msg</structfield> field of 
<parameter>stream</parameter> to point to a string describing the error:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
No progress is possible; either <structfield>avail_in</structfield>
or <structfield>avail_out</structfield> was zero.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_NEED_DICT</constant></term>
<listitem><para>
A preset dictionary is required. The <structfield>adler</structfield>
field shall be set to the Adler-32 checksum of the dictionary chosen
by the compressor.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateEnd-1">

<refmeta>
<refentrytitle>inflateEnd</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateEnd</refname>
<refpurpose>free decompression stream state</refpurpose>
<indexterm id="ix-utillib-inflateEnd-1">
  <primary>inflateEnd</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateEnd</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateEnd</function> function shall free all allocated
state information referenced by <parameter>stream</parameter>.
All pending output is discarded, and unprocessed input is ignored.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateEnd</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateEnd</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
<listitem><para>
The <structfield>zfree</structfield> function pointer is
<constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateInit2" xreflabel="inflateInit2_">

<refmeta>
<refentrytitle>inflateInit2_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateInit2_</refname>
<refpurpose>initialize decompression system</refpurpose>
<indexterm id="ix-utillib-inflateInit2-1">
  <primary>inflateInit2_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   int <function>inflateInit2_</function>
  </funcdef>
  <paramdef>z_streamp <parameter>strm</parameter></paramdef>
  <paramdef>int <parameter>windowBits</parameter></paramdef>
  <paramdef>char * <parameter>version</parameter></paramdef>
  <paramdef>int <parameter>stream_size</parameter></paramdef>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateInit2_</function> function shall initialize the decompression
system.
On entry, <parameter>strm</parameter> shall refer to a user supplied <type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>inflateInit2_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <parameter>windowBits</parameter> parameter shall be a base 2 logarithm of the maximum
window 
size to use, and shall be a value between <constant>8</constant> and <constant>15</constant>.
If the input data was compressed with a larger window size, subsequent attempts to
decompress this data will fail with <constant>Z_DATA_ERROR</constant>, rather than try to
allocate a larger window.
</para>
<para>
The <function>inflateInit2_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>inflateInit2</function> macro.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>inflateInit2_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>inflateInit2_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateInit2_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>

<refentry id="zlib-inflateInit" xreflabel="inflateInit_">

<refmeta>
<refentrytitle>inflateInit_</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateInit_</refname>
<refpurpose>initialize decompression system</refpurpose>
<indexterm id="ix-utillib-inflateInit-1">
  <primary>inflateInit_</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateInit_</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const char *
<parameter>version</parameter>
</paramdef>
<paramdef>int
<parameter>stream_size</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateInit_</function> function shall initialize the
decompression system.
On entry, <parameter>stream</parameter> shall refer to a user supplied
<type>z_stream</type>
object (a <structname>z_stream_s</structname> structure). The following fields shall be
set on entry:
<variablelist>
<varlistentry>
<term><structfield>zalloc</structfield></term>
<listitem><para>
a pointer to an <type>alloc_func</type> function, used to allocate state information.
If this is <constant>NULL</constant>, a default allocation function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>zfree</structfield></term>
<listitem><para>
a pointer to a <type>free_func</type> function, used to free memory allocated by the
<structfield>zalloc</structfield> function. If this is <constant>NULL</constant>
a default free function will be used.
</para></listitem>
</varlistentry>
<varlistentry>
<term><structfield>opaque</structfield></term>
<listitem><para>
If <structfield>alloc_func</structfield> is not <constant>NULL</constant>,
<structfield>opaque</structfield> is a user supplied pointer to data that will be passed to the
<structfield>alloc_func</structfield> and <structfield>free_func</structfield> functions.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
If the <parameter>version</parameter> requested is not compatible with the version
implemented, or if the size of the <structname>z_stream_s</structname> structure
provided in <parameter>stream_size</parameter> does not match the size in the library 
implementation, <function>inflateInit_</function> shall fail, and return
<constant>Z_VERSION_ERROR</constant>.
</para>
<para>
The <function>inflateInit_</function> function is not in the source standard;
it is only in the binary standard. Source applications should use the
<function>inflateInit</function> macro.
</para>
<para>
The <function>inflateInit_</function> shall be equivalent to 
<programlisting>
inflateInit2_(strm, DEF_WBITS, version, stream_size);
</programlisting>
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, the <function>inflateInit_</function> function shall return 
<constant>Z_OK</constant>. 
Otherwise, <function>inflateInit_</function> shall return
a value as described below to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateInit_</function> shall return one
of the following error indicators:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
Invalid parameter.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory available.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_VERSION_ERROR</constant></term>
<listitem><para>
The version requested is not compatible with the library version,
or the <type>z_stream</type> size differs from that used by the library.
</para></listitem>
</varlistentry>
</variablelist>
</para>
<para>
In addition, the <structfield>msg</structfield> field of the <parameter>strm</parameter>
may be set to an error message.
</para>
</refsect1>
</refentry>

<refentry id="zlib-inflateReset-1">

<refmeta>
<refentrytitle>inflateReset</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateReset</refname>
<refpurpose>reset decompression stream state</refpurpose>
<indexterm id="ix-utillib-inflateReset-1">
  <primary>inflateReset</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateReset</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateReset</function> function shall reset all state
associated with <parameter>stream</parameter>.
All pending output shall be discarded, and the counts of processed
bytes (<structfield>total_in</structfield> and 
<structfield>total_out</structfield>) shall be reset to zero.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateReset</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return <returnvalue>Z_STREAM_ERROR</returnvalue>
to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateReset</function> shall return 
<returnvalue>Z_STREAM_ERROR</returnvalue>. The following conditions
shall be treated as an error:
<itemizedlist>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent or inappropriate.
</para></listitem>
<listitem><para>
<parameter>stream</parameter> 
is <constant>NULL</constant>.
</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateSetDictionary-1">

<refmeta>
<refentrytitle>inflateSetDictionary</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSetDictionary</refname>
<refpurpose>initialize decompression dictionary</refpurpose>
<indexterm id="ix-utillib-inflateSetDictionary-1">
  <primary>inflateSetDictionary</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSetDictionary</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>dictionary</parameter>
</paramdef>
<paramdef>uInt
<parameter>dictlen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSetDictionary</function> function shall initialize the
decompression dictionary associated with <parameter>stream</parameter>
using the <parameter>dictlen</parameter> bytes referenced by
<parameter>dictionary</parameter>.
</para>
<para>
The <function>inflateSetDictionary</function> function should be called
immediately after a call to <function>inflate</function> has failed
with return value <returnvalue>Z_NEED_DICT</returnvalue>. The 
<parameter>dictionary</parameter> must have the same Adler-32
checksum as the dictionary used for
the compression (see <function>deflateSetDictionary</function>).
</para>
<para>
<parameter>stream</parameter> shall reference an initialized decompression
stream, with <structfield>total_in</structfield> zero (i.e. no data
has been decompressed since the stream was initialized).
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateSetDictionary</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise it shall return a value as indicated below.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSetDictionary</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state in <parameter>stream</parameter> is inconsistent, or
<parameter>stream</parameter> 
was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
The Adler-32 checksum of the supplied dictionary does not match that used
for the compression.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
<refsect1>
<title>Application Usage (informative)</title>
<para>
The application should provide a dictionary consisting of strings
{{{ed note: do we really mean "strings"? Null terminated?}}}
that are likely to be encountered in the data to be compressed.
The application should ensure that the dictionary is sorted such that
the most commonly used strings occur at the end of the dictionary.
</para>
<para>
The use of a dictionary is optional; however if the data
to be compressed is relatively short and has a predictable structure,
the use of a dictionary can substantially improve the compression
ratio.
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateSync-1">

<refmeta>
<refentrytitle>inflateSync</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSync</refname>
<refpurpose>advance compression stream to next sync point</refpurpose>
<indexterm id="ix-utillib-inflateSync-1">
  <primary>inflateSync</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSync</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSync</function> function shall advance through the
compressed data in <parameter>stream</parameter>, skipping any invalid
compressed data, until the next full flush point is reached, or all
input is exhausted. See the
description for <function>deflate</function> with flush level
<constant>Z_FULL_FLUSH</constant>.
No output is placed in <structfield>next_out</structfield>.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
On success, <function>inflateSync</function> shall return  
<returnvalue>Z_OK</returnvalue>, and update the
<simplelist type=inline>
<member><structfield>next_in</structfield>,</member>
<member><structfield>avail_in</structfield>, and</member>
<member><structfield>total_in</structfield></member>
</simplelist>
fields of <parameter>stream</parameter> to reflect the number
of bytes of compressed data that have been skipped.
Otherwise, <function>inflateSync</function>
shall return a value as described below to indicate the
error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSync</function> shall return a value
as described below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
There is no data available to skip over.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
No sync point was found.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-inflateSyncPoint-1">

<refmeta>
<refentrytitle>inflateSyncPoint</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>inflateSyncPoint</refname>
<refpurpose>test for synchronization point</refpurpose>
<indexterm id="ix-utillib-inflateSyncPoint-1">
  <primary>inflateSyncPoint</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>inflateSyncPoint</function>
</funcdef>
<paramdef>z_streamp
<parameter>stream</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>inflateSyncPoint</function> function shall return a non-zero
calue if the compressed data stream referenced by
<parameter>stream</parameter> is at a synchronization point. 
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
If the compressed data in <parameter>stream</parameter> is at 
a synchronization point (see <function>deflate</function>
with a flush level of <constant>Z_SYNC_FLUSH</constant> or
<constant>Z_FULL_FLUSH</constant>), <function>inflateSyncPoint</function> 
shall return  a non-zero value, other than <constant>Z_STREAM_ERROR</constant>. 
Otherwise, if the <parameter>stream</parameter> is valid,
<function>inflateSyncPoint</function> shall return 0.
If <parameter>stream</parameter> is invalid, or in an invalid state,
<function>inflateSyncPoint</function> shall return
<returnvalue>Z_STREAM_ERROR</returnvalue> to indicate the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>inflateSyncPoint</function> shall return a value
as described below:
<variablelist>
<varlistentry>
<term><constant>Z_STREAM_ERROR</constant></term>
<listitem><para>
The state (as represented in <parameter>stream</parameter>) is inconsistent, or
<parameter>stream</parameter> was <constant>NULL</constant>.
</para></listitem>
</varlistentry>
</variablelist>
</para>
</refsect1>
</refentry>


<refentry id="zlib-uncompress-1">

<refmeta>
<refentrytitle>uncompress</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>uncompress</refname>
<refpurpose>uncompress data</refpurpose>
<indexterm id="ix-utillib-uncompress-1">
  <primary>uncompress</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>int
<function>uncompress</function>
</funcdef>
<paramdef>Bytef *
<parameter>dest</parameter>
</paramdef>
<paramdef>uLongf *
<parameter>destLen</parameter>
</paramdef>
<paramdef>const Bytef *
<parameter>source</parameter>
</paramdef>
<paramdef>uLong
<parameter>sourceLen</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>uncompress</function> function shall attempt to uncompress
<parameter>sourceLen</parameter> bytes of data in the buffer 
<parameter>source</parameter>, placing the result in the buffer
<parameter>dest</parameter>. 
</para>
<para>
On entry, <parameter>destLen</parameter> should point to a value describing
the size of the <parameter>dest</parameter> buffer. 
The application should ensure that this value is large enough to hold
the entire uncompressed data.
<note><para>
The LSB does not describe any mechanism by which a compressor can
communicate the size required to the uncompressor. 
</para></note>
On successful exit, the variable referenced by <parameter>destLen</parameter>
shall be updated to hold the length of uncompressed data in
<parameter>dest</parameter>.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
On success, <function>uncompress</function> shall return  
<returnvalue>Z_OK</returnvalue>.
Otherwise, <function>uncompress</function> shall return a value to indicate
the error.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
On error, <function>uncompress</function> shall return a value as described 
below:
<variablelist>
<varlistentry>
<term><constant>Z_BUF_ERROR</constant></term>
<listitem><para>
The buffer <parameter>dest</parameter> was not large enough to hold the
uncompressed data.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_MEM_ERROR</constant></term>
<listitem><para>
Insufficient memory.
</para></listitem>
</varlistentry>
<varlistentry>
<term><constant>Z_DATA_ERROR</constant></term>
<listitem><para>
The compressed data (referenced by <parameter>source</parameter>) was corrupted.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</refsect1>
</refentry>

<refentry id="zlib-zError-1">

<refmeta>
<refentrytitle>zError</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>zError</refname>
<refpurpose>translate error number to string</refpurpose>
<indexterm id="ix-utillib-zError-1">
  <primary>zError</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo><funcprototype>
<funcdef>const char *
<function>zError</function>
</funcdef>
<paramdef>int
<parameter>err</parameter>
</paramdef>

</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>zError</function> function shall return the string
identifying the error associated with <parameter>err</parameter>.
This allows for conversion from error code to string for functions
such as <function>compress</function> and <function>uncompress</function>,
that do not always set the string version of an error.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>zError</function> function shall return a 
the string identifying the error associated with 
<parameter>err</parameter>, or <returnvalue>NULL</returnvalue> if
<parameter>err</parameter> is not a valid error code.
</para>
<para>
It is unspecified if the string returned is determined by the setting
of the <constant>LC_MESSAGES</constant> category in the current locale.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

<refentry id="zlib-zlibVersion-1">

<refmeta>
<refentrytitle>zlibVersion</refentrytitle>
<refmiscinfo>Utility Libraries</refmiscinfo>
</refmeta>

<refnamediv>
<refname>zlibVersion</refname>
<refpurpose>discover library version at run time</refpurpose>
<indexterm id="ix-utillib-zlibVersion-1">
  <primary>zlibVersion</primary></indexterm>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;zlib.h&gt;
</funcsynopsisinfo>
 <funcprototype>
  <funcdef>
   const char * <function>zlibVersion</function>
  </funcdef>
  <void>
 </funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
The <function>zlibVersion</function> function shall return the string
identifying the interface version at the time the library was built.
</para>
<para>
Applications should compare the value returned from 
<function>zlibVersion</function> with the macro constant 
<constant>ZLIB_VERSION</constant> for compatibility.
</para>
</refsect1>
<refsect1>
<title>Return Value</title>
<para>
The <function>zlibVersion</function> function shall return a 
the string identifying the version of the library currently implemented.
</para>
</refsect1>
<refsect1>
<title>Errors</title>
<para>
None defined.
</para>
</refsect1>
</refentry>

</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->
<!--    at Fri Mar 11 21:39:05 2005 -->
<SECT1 ID=libncurses>
<TITLE>Interfaces for libncurses</TITLE>
<PARA>
<XREF LINKEND="lib-libncurses-def"> defines the library name and shared object name
for the libncurses library
</PARA>
<TABLE id="lib-libncurses-def">
<TITLE>libncurses Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libncurses</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libncurses.so.5</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER>
<XREF LINKEND="std.SUS.CURSES">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Curses -->
<SECT2>
<!--libgroup-->
<TITLE>Curses</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Curses</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Curses specified in <XREF linkend="tbl-libncurses-cur-ints">,
with the full functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libncurses-cur-ints">
<TITLE>libncurses - Curses Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>addch</primary></indexterm>addch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_ic</primary></indexterm>has_ic <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchnstr</primary></indexterm>mvwaddchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_init</primary></indexterm>scr_init <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwscanw</primary></indexterm>vwscanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addchnstr</primary></indexterm>addchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>has_il</primary></indexterm>has_il <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddchstr</primary></indexterm>mvwaddchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_restore</primary></indexterm>scr_restore <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddch</primary></indexterm>waddch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addchstr</primary></indexterm>addchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>hline</primary></indexterm>hline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddnstr</primary></indexterm>mvwaddnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_set</primary></indexterm>scr_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchnstr</primary></indexterm>waddchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addnstr</primary></indexterm>addnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>idcok</primary></indexterm>idcok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddstr</primary></indexterm>mvwaddstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scrl</primary></indexterm>scrl <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddchstr</primary></indexterm>waddchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>addstr</primary></indexterm>addstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>idlok</primary></indexterm>idlok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwchgat</primary></indexterm>mvwchgat <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scroll</primary></indexterm>scroll <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddnstr</primary></indexterm>waddnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_get</primary></indexterm>attr_get <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>immedok</primary></indexterm>immedok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwdelch</primary></indexterm>mvwdelch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scrollok</primary></indexterm>scrollok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>waddstr</primary></indexterm>waddstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_off</primary></indexterm>attr_off <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inch</primary></indexterm>inch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetch</primary></indexterm>mvwgetch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>set_curterm</primary></indexterm>set_curterm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_get</primary></indexterm>wattr_get <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_on</primary></indexterm>attr_on <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inchnstr</primary></indexterm>inchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetnstr</primary></indexterm>mvwgetnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>set_term</primary></indexterm>set_term <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_off</primary></indexterm>wattr_off <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attr_set</primary></indexterm>attr_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>inchstr</primary></indexterm>inchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwgetstr</primary></indexterm>mvwgetstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>setscrreg</primary></indexterm>setscrreg <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_on</primary></indexterm>wattr_on <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attroff</primary></indexterm>attroff <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>init_color</primary></indexterm>init_color <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwhline</primary></indexterm>mvwhline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>setupterm</primary></indexterm>setupterm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattr_set</primary></indexterm>wattr_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attron</primary></indexterm>attron <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>init_pair</primary></indexterm>init_pair <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwin</primary></indexterm>mvwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attr_set</primary></indexterm>slk_attr_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattroff</primary></indexterm>wattroff <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>attrset</primary></indexterm>attrset <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>initscr</primary></indexterm>initscr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinch</primary></indexterm>mvwinch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attroff</primary></indexterm>slk_attroff <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattron</primary></indexterm>wattron <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>baudrate</primary></indexterm>baudrate <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>innstr</primary></indexterm>innstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinchnstr</primary></indexterm>mvwinchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attron</primary></indexterm>slk_attron <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wattrset</primary></indexterm>wattrset <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>beep</primary></indexterm>beep <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>insch</primary></indexterm>insch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinchstr</primary></indexterm>mvwinchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_attrset</primary></indexterm>slk_attrset <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgd</primary></indexterm>wbkgd <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bkgd</primary></indexterm>bkgd <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>insdelln</primary></indexterm>insdelln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinnstr</primary></indexterm>mvwinnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_clear</primary></indexterm>slk_clear <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wbkgdset</primary></indexterm>wbkgdset <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>bkgdset</primary></indexterm>bkgdset <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>insertln</primary></indexterm>insertln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsch</primary></indexterm>mvwinsch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_color</primary></indexterm>slk_color <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wborder</primary></indexterm>wborder <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>border</primary></indexterm>border <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>insnstr</primary></indexterm>insnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsnstr</primary></indexterm>mvwinsnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_init</primary></indexterm>slk_init <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wchgat</primary></indexterm>wchgat <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>box</primary></indexterm>box <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>insstr</primary></indexterm>insstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinsstr</primary></indexterm>mvwinsstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_label</primary></indexterm>slk_label <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclear</primary></indexterm>wclear <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>can_change_color</primary></indexterm>can_change_color <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>instr</primary></indexterm>instr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwinstr</primary></indexterm>mvwinstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_noutrefresh</primary></indexterm>slk_noutrefresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclrtobot</primary></indexterm>wclrtobot <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>cbreak</primary></indexterm>cbreak <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>intrflush</primary></indexterm>intrflush <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwprintw</primary></indexterm>mvwprintw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_refresh</primary></indexterm>slk_refresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wclrtoeol</primary></indexterm>wclrtoeol <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>chgat</primary></indexterm>chgat <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>is_linetouched</primary></indexterm>is_linetouched <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwscanw</primary></indexterm>mvwscanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_restore</primary></indexterm>slk_restore <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcolor_set</primary></indexterm>wcolor_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clear</primary></indexterm>clear <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>is_wintouched</primary></indexterm>is_wintouched <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwvline</primary></indexterm>mvwvline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_set</primary></indexterm>slk_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wcursyncup</primary></indexterm>wcursyncup <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clearok</primary></indexterm>clearok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>isendwin</primary></indexterm>isendwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>napms</primary></indexterm>napms <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>slk_touch</primary></indexterm>slk_touch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wdelch</primary></indexterm>wdelch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clrtobot</primary></indexterm>clrtobot <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>keyname</primary></indexterm>keyname <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>newpad</primary></indexterm>newpad <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>standend</primary></indexterm>standend <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wdeleteln</primary></indexterm>wdeleteln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>clrtoeol</primary></indexterm>clrtoeol <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>keypad</primary></indexterm>keypad <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>newterm</primary></indexterm>newterm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>standout</primary></indexterm>standout <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wechochar</primary></indexterm>wechochar <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>color_content</primary></indexterm>color_content <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>killchar</primary></indexterm>killchar <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>newwin</primary></indexterm>newwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>start_color</primary></indexterm>start_color <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>werase</primary></indexterm>werase <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>color_set</primary></indexterm>color_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>leaveok</primary></indexterm>leaveok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>nl</primary></indexterm>nl <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>subpad</primary></indexterm>subpad <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetch</primary></indexterm>wgetch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>copywin</primary></indexterm>copywin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>longname</primary></indexterm>longname <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>nocbreak</primary></indexterm>nocbreak <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>subwin</primary></indexterm>subwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetnstr</primary></indexterm>wgetnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>curs_set</primary></indexterm>curs_set <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>meta</primary></indexterm>meta <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>nodelay</primary></indexterm>nodelay <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>syncok</primary></indexterm>syncok <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wgetstr</primary></indexterm>wgetstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>def_prog_mode</primary></indexterm>def_prog_mode <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>move</primary></indexterm>move <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>noecho</primary></indexterm>noecho <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>termattrs</primary></indexterm>termattrs <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>whline</primary></indexterm>whline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>def_shell_mode</primary></indexterm>def_shell_mode <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddch</primary></indexterm>mvaddch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>nonl</primary></indexterm>nonl <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>termname</primary></indexterm>termname <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winch</primary></indexterm>winch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>del_curterm</primary></indexterm>del_curterm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddchnstr</primary></indexterm>mvaddchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>noqiflush</primary></indexterm>noqiflush <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetent</primary></indexterm>tgetent <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winchnstr</primary></indexterm>winchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delay_output</primary></indexterm>delay_output <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddchstr</primary></indexterm>mvaddchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>noraw</primary></indexterm>noraw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetflag</primary></indexterm>tgetflag <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winchstr</primary></indexterm>winchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delch</primary></indexterm>delch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddnstr</primary></indexterm>mvaddnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>notimeout</primary></indexterm>notimeout <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetnum</primary></indexterm>tgetnum <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winnstr</primary></indexterm>winnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>deleteln</primary></indexterm>deleteln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvaddstr</primary></indexterm>mvaddstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>overlay</primary></indexterm>overlay <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgetstr</primary></indexterm>tgetstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsch</primary></indexterm>winsch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delscreen</primary></indexterm>delscreen <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvchgat</primary></indexterm>mvchgat <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>overwrite</primary></indexterm>overwrite <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tgoto</primary></indexterm>tgoto <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsdelln</primary></indexterm>winsdelln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>delwin</primary></indexterm>delwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvcur</primary></indexterm>mvcur <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>pair_content</primary></indexterm>pair_content <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetflag</primary></indexterm>tigetflag <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsertln</primary></indexterm>winsertln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>derwin</primary></indexterm>derwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvdelch</primary></indexterm>mvdelch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>pechochar</primary></indexterm>pechochar <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetnum</primary></indexterm>tigetnum <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsnstr</primary></indexterm>winsnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>doupdate</primary></indexterm>doupdate <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvderwin</primary></indexterm>mvderwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>pnoutrefresh</primary></indexterm>pnoutrefresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tigetstr</primary></indexterm>tigetstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winsstr</primary></indexterm>winsstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>dupwin</primary></indexterm>dupwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetch</primary></indexterm>mvgetch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>prefresh</primary></indexterm>prefresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>timeout</primary></indexterm>timeout <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>winstr</primary></indexterm>winstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>echo</primary></indexterm>echo <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetnstr</primary></indexterm>mvgetnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>printw</primary></indexterm>printw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>touchline</primary></indexterm>touchline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wmove</primary></indexterm>wmove <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>echochar</primary></indexterm>echochar <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvgetstr</primary></indexterm>mvgetstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>putp</primary></indexterm>putp <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>touchwin</primary></indexterm>touchwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wnoutrefresh</primary></indexterm>wnoutrefresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>endwin</primary></indexterm>endwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvhline</primary></indexterm>mvhline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>putwin</primary></indexterm>putwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tparm</primary></indexterm>tparm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wprintw</primary></indexterm>wprintw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erase</primary></indexterm>erase <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinch</primary></indexterm>mvinch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>qiflush</primary></indexterm>qiflush <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>tputs</primary></indexterm>tputs <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wredrawln</primary></indexterm>wredrawln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>erasechar</primary></indexterm>erasechar <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinchnstr</primary></indexterm>mvinchnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>raw</primary></indexterm>raw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>typeahead</primary></indexterm>typeahead <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wrefresh</primary></indexterm>wrefresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>filter</primary></indexterm>filter <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinchstr</primary></indexterm>mvinchstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>redrawwin</primary></indexterm>redrawwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>unctrl</primary></indexterm>unctrl <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscanw</primary></indexterm>wscanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>flash</primary></indexterm>flash <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinnstr</primary></indexterm>mvinnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>refresh</primary></indexterm>refresh <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>ungetch</primary></indexterm>ungetch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wscrl</primary></indexterm>wscrl <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>flushinp</primary></indexterm>flushinp <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsch</primary></indexterm>mvinsch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_prog_mode</primary></indexterm>reset_prog_mode <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>untouchwin</primary></indexterm>untouchwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsetscrreg</primary></indexterm>wsetscrreg <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getbkgd</primary></indexterm>getbkgd <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsnstr</primary></indexterm>mvinsnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>reset_shell_mode</primary></indexterm>reset_shell_mode <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>use_env</primary></indexterm>use_env <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wstandend</primary></indexterm>wstandend <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getch</primary></indexterm>getch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinsstr</primary></indexterm>mvinsstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>resetty</primary></indexterm>resetty <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidattr</primary></indexterm>vidattr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wstandout</primary></indexterm>wstandout <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getnstr</primary></indexterm>getnstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvinstr</primary></indexterm>mvinstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>restartterm</primary></indexterm>restartterm <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vidputs</primary></indexterm>vidputs <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsyncdown</primary></indexterm>wsyncdown <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getstr</primary></indexterm>getstr <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvprintw</primary></indexterm>mvprintw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>ripoffline</primary></indexterm>ripoffline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vline</primary></indexterm>vline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wsyncup</primary></indexterm>wsyncup <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>getwin</primary></indexterm>getwin <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvscanw</primary></indexterm>mvscanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>savetty</primary></indexterm>savetty <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_printw</primary></indexterm>vw_printw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wtimeout</primary></indexterm>wtimeout <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>halfdelay</primary></indexterm>halfdelay <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvvline</primary></indexterm>mvvline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scanw</primary></indexterm>scanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vw_scanw</primary></indexterm>vw_scanw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wtouchln</primary></indexterm>wtouchln <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>has_colors</primary></indexterm>has_colors <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>mvwaddch</primary></indexterm>mvwaddch <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>scr_dump</primary></indexterm>scr_dump <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>vwprintw</primary></indexterm>vwprintw <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>wvline</primary></indexterm>wvline <LINK LINKEND="std-128-28-tbl-libncurses-cur-ints">[1]</LINK></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>
<FORMALPARA><TITLE><ANCHOR id="std-128-28-tbl-libncurses-cur-ints">[1]</TITLE><para><XREF LINKEND=std.SUS.CURSES></para></FORMALPARA>
<PARA>
An LSB conforming implementation shall provide the generic data interfaces
for Curses specified in <XREF linkend="tbl-libncurses-cur-data">,
with the full functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupdata-->
<TABLE id="tbl-libncurses-cur-data">
<TITLE>libncurses - Curses Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>COLORS</primary></indexterm>COLORS <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>COLS</primary></indexterm>COLS <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>acs_map</primary></indexterm>acs_map <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>curscr</primary></indexterm>curscr <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>COLOR_PAIRS</primary></indexterm>COLOR_PAIRS <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>LINES</primary></indexterm>LINES <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>cur_term</primary></indexterm>cur_term <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>stdscr</primary></indexterm>stdscr <LINK LINKEND="std-128-28-tbl-libncurses-cur-data">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>
<FORMALPARA><TITLE><ANCHOR id="std-128-28-tbl-libncurses-cur-data">[1]</TITLE><para><XREF LINKEND=std.SUS.CURSES></para></FORMALPARA>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libncurses-ddefs>
<TITLE>Data Definitions for libncurses</TITLE>
<PARA>
This section defines global identifiers and their values that are associated with interfaces contained in libncurses.
These definitions are organized into groups that correspond to system headers. This convention is used as a convenience for the reader, and does not imply the existence of these headers, or their content.</PARA>
<PARA>
These definitions are intended to supplement those provided in the referenced underlying specifications.
</PARA>
<PARA>
This specification uses ISO/IEC 9899 C Language as the reference programming language, and data definitions are specified in ISO C format. The C language is used here as a convenient notation. Using a C language description of these data objects does not preclude their use by other programming languages.</PARA>
<SECT2>
<TITLE>curses.h</TITLE>
<PARA>
</PARA>
<SCREEN>

#define ERR	(-1)
#define OK	(0)
#define ACS_RARROW	(acs_map['+'])
#define ACS_LARROW	(acs_map[','])
#define ACS_UARROW	(acs_map['-'])
#define ACS_DARROW	(acs_map['.'])
#define ACS_BLOCK	(acs_map['0'])
#define ACS_CKBOARD	(acs_map['a'])
#define ACS_DEGREE	(acs_map['f'])
#define ACS_PLMINUS	(acs_map['g'])
#define ACS_BOARD	(acs_map['h'])
#define ACS_LANTERN	(acs_map['i'])
#define ACS_LRCORNER	(acs_map['j'])
#define ACS_URCORNER	(acs_map['k'])
#define ACS_ULCORNER	(acs_map['l'])
#define ACS_LLCORNER	(acs_map['m'])
#define ACS_PLUS	(acs_map['n'])
#define ACS_S1	(acs_map['o'])
#define ACS_HLINE	(acs_map['q'])
#define ACS_S9	(acs_map['s'])
#define ACS_LTEE	(acs_map['t'])
#define ACS_RTEE	(acs_map['u'])
#define ACS_BTEE	(acs_map['v'])
#define ACS_TTEE	(acs_map['w'])
#define ACS_VLINE	(acs_map['x'])
#define ACS_DIAMOND	(acs_map['`'])
#define ACS_BULLET	(acs_map['~'])
#define getmaxyx(win,y,x)	(y=(win)?((win)->_maxy+1):ERR,x=(win)?((win)->_maxx+1):ERR)
#define getbegyx(win,y,x)	(y=(win)?(win)->_begy:ERR,x=(win)?(win)->_begx:ERR)
#define getyx(win,y,x)	(y=(win)?(win)->_cury:ERR,x=(win)?(win)->_curx:ERR)
#define getparyx(win,y,x)	(y=(win)?(win)->_pary:ERR,x=(win)?(win)->_parx:ERR)

#define WA_ALTCHARSET	A_ALTCHARSET
#define WA_ATTRIBUTES	A_ATTRIBUTES
#define WA_BLINK	A_BLINK
#define WA_BOLD	A_BOLD
#define WA_DIM	A_DIM
#define WA_HORIZONTAL	A_HORIZONTAL
#define WA_INVIS	A_INVIS
#define WA_LEFT	A_LEFT
#define WA_LOW	A_LOW
#define WA_NORMAL	A_NORMAL
#define WA_PROTECT	A_PROTECT
#define WA_REVERSE	A_REVERSE
#define WA_RIGHT	A_RIGHT
#define WA_STANDOUT	A_STANDOUT
#define WA_TOP	A_TOP
#define WA_UNDERLINE	A_UNDERLINE
#define WA_VERTICAL	A_VERTICAL
#define A_REVERSE	NCURSES_BITS(1UL,10)

#define COLOR_BLACK	0
#define COLOR_RED	1
#define COLOR_GREEN	2
#define COLOR_YELLOW	3
#define COLOR_BLUE	4
#define COLOR_MAGENTA	5
#define COLOR_CYAN	6
#define COLOR_WHITE	7

#define _SUBWIN	0x01
#define _ENDLINE	0x02
#define _FULLWIN	0x04
#define _ISPAD	0x10
#define _HASMOVED	0x20

typedef unsigned char bool;

typedef unsigned long chtype;
typedef struct screen SCREEN;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef struct
{
  attr_t attr;
  wchar_t chars[5];
}
cchar_t;
struct pdat
{
  short _pad_y;
  short _pad_x;
  short _pad_top;
  short _pad_left;
  short _pad_bottom;
  short _pad_right;
}
 ;

struct _win_st
{
  short _cury;
  short _curx;
  short _maxy;
  short _maxx;
  short _begy;
  short _begx;
  short _flags;
  attr_t _attrs;
  chtype _bkgd;
  bool _notimeout;
  bool _clear;
  bool _leaveok;
  bool _scroll;
  bool _idlok;
  bool _idcok;
  bool _immed;
  bool _sync;
  bool _use_keypad;
  int _delay;
  struct ldat *_line;
  short _regtop;
  short _regbottom;
  int _parx;
  int _pary;
  WINDOW *_parent;
  struct pdat _pad;
  short _yoffset;
  cchar_t _bkgrnd;
}
 ;
#define KEY_CODE_YES	0400
#define KEY_BREAK	0401
#define KEY_MIN	0401
#define KEY_DOWN	0402
#define KEY_UP	0403
#define KEY_LEFT	0404
#define KEY_RIGHT	0405
#define KEY_HOME	0406
#define KEY_BACKSPACE	0407
#define KEY_F0	0410
#define KEY_DL	0510
#define KEY_IL	0511
#define KEY_DC	0512
#define KEY_IC	0513
#define KEY_EIC	0514
#define KEY_CLEAR	0515
#define KEY_EOS	0516
#define KEY_EOL	0517
#define KEY_SF	0520
#define KEY_SR	0521
#define KEY_NPAGE	0522
#define KEY_PPAGE	0523
#define KEY_STAB	0524
#define KEY_CTAB	0525
#define KEY_CATAB	0526
#define KEY_ENTER	0527
#define KEY_SRESET	0530
#define KEY_RESET	0531
#define KEY_PRINT	0532
#define KEY_LL	0533
#define KEY_A1	0534
#define KEY_A3	0535
#define KEY_B2	0536
#define KEY_C1	0537
#define KEY_C3	0540
#define KEY_BTAB	0541
#define KEY_BEG	0542
#define KEY_CANCEL	0543
#define KEY_CLOSE	0544
#define KEY_COMMAND	0545
#define KEY_COPY	0546
#define KEY_CREATE	0547
#define KEY_END	0550
#define KEY_EXIT	0551
#define KEY_FIND	0552
#define KEY_HELP	0553
#define KEY_MARK	0554
#define KEY_MESSAGE	0555
#define KEY_MOVE	0556
#define KEY_NEXT	0557
#define KEY_OPEN	0560
#define KEY_OPTIONS	0561
#define KEY_PREVIOUS	0562
#define KEY_REDO	0563
#define KEY_REFERENCE	0564
#define KEY_REFRESH	0565
#define KEY_REPLACE	0566
#define KEY_RESTART	0567
#define KEY_RESUME	0570
#define KEY_SAVE	0571
#define KEY_SBEG	0572
#define KEY_SCANCEL	0573
#define KEY_SCOMMAND	0574
#define KEY_SCOPY	0575
#define KEY_SCREATE	0576
#define KEY_SDC	0577
#define KEY_SDL	0600
#define KEY_SELECT	0601
#define KEY_SEND	0602
#define KEY_SEOL	0603
#define KEY_SEXIT	0604
#define KEY_SFIND	0605
#define KEY_SHELP	0606
#define KEY_SHOME	0607
#define KEY_SIC	0610
#define KEY_SLEFT	0611
#define KEY_SMESSAGE	0612
#define KEY_SMOVE	0613
#define KEY_SNEXT	0614
#define KEY_SOPTIONS	0615
#define KEY_SPREVIOUS	0616
#define KEY_SPRINT	0617
#define KEY_SREDO	0620
#define KEY_SREPLACE	0621
#define KEY_SRIGHT	0622
#define KEY_SRSUME	0623
#define KEY_SSAVE	0624
#define KEY_SSUSPEND	0625
#define KEY_SUNDO	0626
#define KEY_SUSPEND	0627
#define KEY_UNDO	0630
#define KEY_MOUSE	0631
#define KEY_RESIZE	0632
#define KEY_MAX	0777

#define PAIR_NUMBER(a)	(((a)&amp A_COLOR)>>8)
#define NCURSES_BITS(mask,shift)	((mask)&lt;&lt;((shift)+8))
#define A_CHARTEXT	(NCURSES_BITS(1UL,0)-1UL)
#define A_NORMAL	0L
#define NCURSES_ATTR_SHIFT	8
#define A_COLOR	NCURSES_BITS(((1UL)&lt;&lt;8)-1UL,0)
#define A_BLINK	NCURSES_BITS(1UL,11)
#define A_DIM	NCURSES_BITS(1UL,12)
#define A_BOLD	NCURSES_BITS(1UL,13)
#define A_ALTCHARSET	NCURSES_BITS(1UL,14)
#define A_INVIS	NCURSES_BITS(1UL,15)
#define A_PROTECT	NCURSES_BITS(1UL,16)
#define A_HORIZONTAL	NCURSES_BITS(1UL,17)
#define A_LEFT	NCURSES_BITS(1UL,18)
#define A_LOW	NCURSES_BITS(1UL,19)
#define A_RIGHT	NCURSES_BITS(1UL,20)
#define A_TOP	NCURSES_BITS(1UL,21)
#define A_VERTICAL	NCURSES_BITS(1UL,22)
#define A_STANDOUT	NCURSES_BITS(1UL,8)
#define A_UNDERLINE	NCURSES_BITS(1UL,9)
#define COLOR_PAIR(n)	NCURSES_BITS(n,0)
#define A_ATTRIBUTES	NCURSES_BITS(~(1UL-1UL),0)
</SCREEN>
</SECT2>
<!-- empty header file All/term.h -->
<!-- empty header file All/unctrl.h -->
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->
<!--    at Fri Mar 11 21:39:05 2005 -->
<SECT1 ID=libutil>
<TITLE>Interfaces for libutil</TITLE>
<PARA>
<XREF LINKEND="lib-libutil-def"> defines the library name and shared object name
for the libutil library
</PARA>
<TABLE id="lib-libutil-def">
<TITLE>libutil Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libutil</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libutil.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behavior of the interfaces in this library is specified by the following specifications:<SIMPLELIST COLUMNS=1>
<MEMBER>
<XREF LINKEND="std.LSB">
</MEMBER>
</SIMPLELIST>
</PARA>
<!-- debug: database interface name Utility Functions -->
<SECT2>
<!--libgroup-->
<TITLE>Utility Functions</TITLE>
<PARA>
</PARA>


<SECT3>
<TITLE>Interfaces for Utility Functions</TITLE>
<PARA>
An LSB conforming implementation shall provide the generic functions
for Utility Functions specified in <XREF linkend="tbl-libutil-uti-ints">,
with the full functionality as described in the referenced
underlying specification.
</PARA>
<!--libgroupints-->
<TABLE id="tbl-libutil-uti-ints">
<TITLE>libutil - Utility Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW>
<ENTRY><indexterm><primary>forkpty</primary></indexterm>forkpty <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>login_tty</primary></indexterm>login_tty <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>logwtmp</primary></indexterm>logwtmp <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
<ROW>
<ENTRY><indexterm><primary>login</primary></indexterm>login <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>logout</primary></indexterm>logout <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY><indexterm><primary>openpty</primary></indexterm>openpty <LINK LINKEND="std-130-10-tbl-libutil-uti-ints">[1]</LINK></ENTRY>
<ENTRY></ENTRY>
<ENTRY></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>
<FORMALPARA><TITLE><ANCHOR id="std-130-10-tbl-libutil-uti-ints">[1]</TITLE><para><XREF LINKEND=std.LSB></para></FORMALPARA>
</SECT3>
</SECT2>
</SECT1>
<SECT1 ID=libutilman>
<TITLE>Interface Definitions for libutil</TITLE>
<PARA>
The following interfaces are included in libutil and are defined
by this specification.
Unless otherwise noted, these interfaces shall be included
in the source standard.
</PARA>
<PARA>
Other interfaces listed above for libutil shall behave as described
in the referenced base document.
</PARA>
<REFENTRY ID="libutil-forkpty-3"> <REFMETA>
<REFENTRYTITLE>forkpty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>forkpty
</REFNAME>
<REFPURPOSE>Create a new process attached to an available pseudo-terminal
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-forkpty-3"><PRIMARY>forkpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pty.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
<FUNCDEF>int
<FUNCTION>
forkpty
</FUNCTION>
</FUNCDEF>
  <PARAMDEF>int *
    <PARAMETER><REPLACEABLE>amaster</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>char *
    <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>struct termios *
    <PARAMETER><REPLACEABLE>termp</REPLACEABLE></PARAMETER></PARAMDEF>
  <PARAMDEF>struct winsize *
    <PARAMETER><REPLACEABLE>winp</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <FUNCTION>forkpty</FUNCTION>
function shall find and open a pseudo-terminal device pair in the
same manner as the <FUNCTION>openpty</FUNCTION> function. 
If a pseudo-terminal is available,
<FUNCTION>forkpty</FUNCTION>
shall create a new process in the same manner as the <FUNCTION>fork</FUNCTION>
function, and prepares the new process for login in the same manner as 
<FUNCTION>login_tty</FUNCTION>.
</PARA>
<PARA>
If <PARAMETER>termp</PARAMETER> is not null, 
it shall refer to a <VARNAME>termios</VARNAME> structure that shall be used
to initialize the characteristics of the slave device. 
If <PARAMETER>winp</PARAMETER> is not null, it
shall refer to a <VARNAME>winsize</VARNAME> structure used to 
initialize the window size of the
slave device.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the parent process shall return the process id of the child, and the
child shall return 0. On error, no new process shall be created, -1 shall be
returned, and <VARNAME>errno</VARNAME> shall be set appropriately.
On success, the parent process shall receive the file descriptor of the master
side of the pseudo-terminal in the location referenced by 
<PARAMETER>amaster</PARAMETER>, and, if <PARAMETER>name</PARAMETER> is
not NULL, the filename of the slave device in 
<PARAMETER>name</PARAMETER>. 
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EAGAIN
</TERM>
<LISTITEM>
<PARA>
Unable to create a new process.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
ENOENT
</TERM>
<LISTITEM>
<PARA>
There are no available pseudo-terminals.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-login-3"> <REFMETA>
<REFENTRYTITLE>login</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login
</REFNAME>
<REFPURPOSE>login utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-3"><PRIMARY>login</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
  <FUNCPROTOTYPE>
    <FUNCDEF>void
      <FUNCTION>login</FUNCTION>
    </FUNCDEF>
    <PARAMDEF>struct utmp *
      <PARAMETER><REPLACEABLE>ut</REPLACEABLE></PARAMETER>
    </PARAMDEF>
  </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>login</function> function shall update the user 
accounting databases.
The <parameter>ut</parameter> parameter shall reference a 
<STRUCTNAME>utmp</STRUCTNAME> structure 
for all fields except the following:
<ORDEREDLIST>
<LISTITEM>
<PARA>
The <STRUCTFIELD>ut_type</STRUCTFIELD> field shall be set to <constant>
USER_PROCESS</constant>.
</PARA></LISTITEM>
<LISTITEM><PARA>
The <STRUCTFIELD>ut_pid</STRUCTFIELD> field shall be set to the process identifier
for the current process.
</PARA></LISTITEM>
<LISTITEM><PARA>
The <STRUCTFIELD>ut_line</STRUCTFIELD> field shall be set to the name of the 
controlling terminal device.
The name shall be found by examining the device associated with the
standard input, output and error streams in sequence, until one associated with
a terminal device is found.
If none of these streams refers to a terminal device, the 
<STRUCTFIELD>ut_line</STRUCTFIELD> field shall be set to <constant>"???"</constant>.
If the terminal device is in the <filename>/dev</filename> directory
hierarchy, the <STRUCTFIELD>ut_line</STRUCTFIELD> field shall not contain the leading
<constant>"/dev/"</constant>, otherwise it shall be set to the final component
of the pathname of the device. 
If the user
accounting database imposes a limit on the size of the 
<structfield>ut_line</structfield> field, it shall
truncate the name, but any such limit shall not be smaller than 
<CONSTANT>UT_LINESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
</ORDEREDLIST>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value</TITLE>
<PARA>None</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors</TITLE>
<PARA>None</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-login-tty-3"> <REFMETA>
<REFENTRYTITLE>login_tty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login_tty
</REFNAME>
<REFPURPOSE>Prepare a terminal for login
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-tty-3"><PRIMARY>login_tty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
 <FUNCPROTOTYPE>
  <FUNCDEF>int
    <FUNCTION>login_tty</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>int <PARAMETER><replaceable>fdr</replaceable></PARAMETER></PARAMDEF>
 </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>login_tty</function> function
shall prepare the terminal device referenced by the file
descriptor <parameter>fdr</parameter>. 
This function shall create a new session, make the terminal 
the controlling terminal for the current process, and set the standard 
input, output, and error streams of the current process to the terminal.
If <parameter>fdr</parameter> is not the standard input, output or error stream,
then <function>login_tty</function> shall close <parameter>fdr</parameter>.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, <function>login_tty</function> shall return zero;
otherwise -1 is returned, and errno shall be set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<REFSECT1INFO><DATE>Aug 16 2004</DATE></REFSECT1INFO>
<TITLE>Errors</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOTTY
</TERM>
<LISTITEM>
<PARA>
<parameter>fdr</parameter> does not refer to a terminal device.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-logout-3"> <REFMETA>
<REFENTRYTITLE>logout</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logout
</REFNAME>
<REFPURPOSE>logout utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-logout-3"><PRIMARY>logout</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h&gt;
</FUNCSYNOPSISINFO>
  <FUNCPROTOTYPE>
    <FUNCDEF>int
      <FUNCTION>logout</FUNCTION>
    </FUNCDEF>
    <PARAMDEF>const char *
      <PARAMETER><REPLACEABLE>line</REPLACEABLE></PARAMETER>
    </PARAMDEF>
  </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Given the device <parameter>line</parameter>,
the <function>logout</function> function shall search
the user accounting database which is read by <function>getutent</function>
for an entry with the corresponding line,
and with the type of <CONSTANT>USER_PROCESS</CONSTANT>.
If a corresponding entry is located, it shall be updated as follows:
<ORDEREDLIST>
<LISTITEM><PARA>The <varname>ut_name</varname> field shall be set to zeroes
(<Constant>UT_NAMESIZE</constant> NUL bytes).</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_host</varname> field shall be set to zeroes
(<Constant>UT_HOSTSIZE</constant> NUL bytes).</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_tv</varname> shall be set to the current 
time of day.</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_type</varname> field shall be set to
<constant>DEAD_PROCESS</constant>.</PARA></LISTITEM>
</ORDEREDLIST>
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, the <function>logout</function> function shall return non-zero.
Zero is returned if there was no entry to remove, or if the utmp file
could not be opened or updated.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-logwtmp-3"> <REFMETA>
<REFENTRYTITLE>logwtmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logwtmp
</REFNAME>
<REFPURPOSE>
append an entry to the wtmp file
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;utmp.h>
</FUNCSYNOPSISINFO>
 <FUNCPROTOTYPE>
  <FUNCDEF>void
    <FUNCTION>logwtmp</FUNCTION>
  </FUNCDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>line</REPLACEABLE></PARAMETER>
  </PARAMDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>name</REPLACEABLE></PARAMETER>
  </PARAMDEF>
  <PARAMDEF>const char *
    <PARAMETER><REPLACEABLE>host</REPLACEABLE></PARAMETER>
  </PARAMDEF>
 </FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If the process has permission to update the user accounting databases,
the <FUNCTION>logwtmp</FUNCTION> function
shall append a record to the user accounting database 
that records all logins and logouts. The record to be appended
shall be constructed as follows:
<ORDEREDLIST>
<LISTITEM><PARA>The <varname>ut_line</varname> field shall be initialized
from <parameter>line</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_line</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_LINESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_name</varname> field shall be initialized
from <parameter>name</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_name</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_NAMESIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_host</varname> field shall be initialized
from <parameter>host</parameter>.
If the user accounting database imposes a limit on the size of the 
<structfield>ut_host</structfield> field, it shall
truncate the value, but any such limit shall not be smaller than 
<CONSTANT>UT_HOSTSIZE</CONSTANT>
(including a terminating null character).
</PARA></LISTITEM>
<LISTITEM><PARA>If the <parameter>name</parameter> parameter does not refer
to an empty string (i.e. <constant>""</constant>), 
the <varname>ut_type</varname> field shall be set to 
<constant>USER_PROCESS</constant>; otherwise the
<varname>ut_type</varname> field shall be set to 
<constant>DEAD_PROCESS</constant>.
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_id</varname> field shall be set to the 
process identifier for the current process.
</PARA></LISTITEM>
<LISTITEM><PARA>The <varname>ut_tv</varname> field shall be set to the
current time of day.
</PARA></LISTITEM>
</ORDEREDLIST>
<NOTE><PARA>If a process does not have write access to the 
the user accounting database, the
<function>logwtmp</function> function will not update it. 
Since the function does not return
any value, an application has no way of knowing whether it succeeded or failed.
</PARA></NOTE>
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
None.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="libutil-openpty-3"> <REFMETA>
<REFENTRYTITLE>openpty</REFENTRYTITLE>
<REFMISCINFO>Utility Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>openpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-terminal
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-openpty-3"><PRIMARY>openpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCSYNOPSISINFO>
#include &lt;pty.h&gt;
</FUNCSYNOPSISINFO>
<FUNCPROTOTYPE>
  <FUNCDEF>int
    <FUNCTION>openpty</FUNCTION></FUNCDEF>
    <PARAMDEF>int *<parameter><replaceable>amaster</replaceable></parameter></PARAMDEF>
    <PARAMDEF>int *<parameter><replaceable>aslave</replaceable></parameter></PARAMDEF>
    <PARAMDEF>char *<parameter><replaceable>name</replaceable></parameter></PARAMDEF>
    <PARAMDEF>struct termios *<parameter><replaceable>termp</replaceable></parameter></PARAMDEF>
    <PARAMDEF>struct winsize *<parameter><replaceable>winp</replaceable></parameter></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>

</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The <function>openpty</function>
function shall find an available pseudo-terminal
and return file descriptors for the master and slave devices in
the locations referenced by 
<parameter>amaster</parameter> and <parameter>aslave</parameter>
respectively. 
If <parameter>name</parameter> is not NULL,
the filename of the slave shall be placed in the user supplied buffer 
referenced by <parameter>name</parameter>.
If <parameter>termp</parameter> is not NULL, it shall
point to a <varname>termios</varname> structure used to initialize
the terminal parameters of the slave pseudo-terminal device.
If <parameter>winp</parameter> is not NULL, it shall
point to a <varname>winsize</varname> structure used to initialize
the window size parameters of the slave pseudo-terminal device.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOENT
</TERM>
<LISTITEM>
<PARA>
There are no available pseudo-terminals.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>

</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mklibspec,v 1.64 2005/02/25 13:34:04 anderson Exp 0 -->


</CHAPTER>

</PART>
