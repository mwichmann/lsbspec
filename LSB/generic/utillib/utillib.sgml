<PART ID="tocutillib">
<TITLE>Utility Libraries</TITLE>

<CHAPTER id=utillib>
<TITLE>Libraries</TITLE>

<PARA>
An LSB-conforming implementation may also support some utility libraries which
are built on top of the interfaces provided by the base libraries. These
libraries implement common functionality, and hide additional system dependent
information such as file formats and device names.
</PARA>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Mon Jun 18 13:16:46 2001 -->
<SECT1 ID=libz>
<TITLE></TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libz Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libz</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libz.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
zlib 1.1.3 Manual<FOOTNOTE ID="std-127-24">
<PARA>
zlib 1.1.3 Manual</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Compression Library</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libz - Compression Library Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>adler32<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateInit_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzerror<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzread<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateInit2_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>compress<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateParams<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzflush<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzrewind<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateInit_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>compress2<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateReset<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzgetc<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzseek<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateReset<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>crc32<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateSetDictionary<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzgets<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzsetparams<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSetDictionary<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflate<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>get_crc_table<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzopen<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gztell<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSync<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateCopy<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzclose<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzprintf<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzwrite<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSyncPoint<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateEnd<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzdopen<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzputc<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflate<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>uncompress<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateInit2_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzeof<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzputs<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateEnd<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>zError<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Mon Jun 18 13:16:47 2001 -->
<SECT1 ID=libncurses>
<TITLE></TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libncurses Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libncurses</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libncurses.so.5</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
 CAE Specification, May 1996, X/Open Curses, Issue 4, Version 2 (ISBN:
1-85912-171-3, C610), plus Corrigendum U018<FOOTNOTE ID="std-128-28">
<PARA>
 CAE Specification, May 1996, X/Open Curses, Issue 4, Version 2 (ISBN:
1-85912-171-3, C610), plus Corrigendum U018</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Curses</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libncurses - Curses Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>addch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>has_ic<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_dump<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>has_il<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_init<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>hline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_restore<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>idcok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_get<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>idlok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scrl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_off<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_get<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>immedok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scroll<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_on<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_off<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scrollok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_on<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>set_term<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>setscrreg<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>init_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>init_pair<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwhline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wbkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>initscr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wbkgdset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>baudrate<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>innstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wborder<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>beep<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_clear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>bkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insdelln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>bkgdset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insertln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_init<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclrtobot<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>border<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_label<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclrtoeol<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>box<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_noutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wcolor_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>can_change_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>instr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_refresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wcursyncup<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>cbreak<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>intrflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_restore<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>chgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>is_linetouched<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wdeleteln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>is_wintouched<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_touch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wechochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clearok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>isendwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>standend<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>werase<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clrtobot<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>keyname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>napms<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>standout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clrtoeol<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>keypad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newpad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>start_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>color_content<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>killchar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newterm<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>subpad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>color_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>leaveok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>subwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>whline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>copywin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>longname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>syncok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>curs_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>meta<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nocbreak<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>termattrs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>def_prog_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>move<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nodelay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>termname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>def_shell_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noecho<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetent<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delay_output<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nonl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetflag<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noqiflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetnum<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsdelln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>deleteln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noraw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsertln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delscreen<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>notimeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgoto<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>overlay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetflag<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>derwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvcur<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>overwrite<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetnum<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>doupdate<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pair_content<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wmove<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>dupwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvderwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pechochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>timeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wnoutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>echo<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pnoutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tparm<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>echochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>prefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tputs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wredrawln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>endwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>printw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>typeahead<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>erase<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvhline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>putp<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>ungetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>erasechar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>putwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>untouchwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wscrl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>filter<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>qiflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>use_env<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsetscrreg<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>flash<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>raw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vidattr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wstandend<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>flushinp<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>redrawwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vidputs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wstandout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getbkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>refresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsyncdown<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>reset_prog_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vw_printw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsyncup<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>reset_shell_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vw_scanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wtimeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>resetty<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vwprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wtouchln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>ripoffline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vwscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>halfdelay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>savetty<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>has_colors<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libncurses - Curses Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>curscr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>stdscr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libncurses-ddefs>
<TITLE> Data Definitions for libncurses</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>curses.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned long chtype;

typedef char bool;

typedef chtype attr_t;

typedef struct screen SCREEN;

typedef struct _win_st
{
  short _cury;
  short _curx;
  short _maxy;
  short _maxx;
  short _begy;
  short _begx;
  short _flags;
  attr_t _attrs;
  chtype _bkgd;
  bool _notimeout;
  bool _clear;
  bool _leaveok;
  bool _scroll;
  bool _idlok;
  bool _idcok;
  bool _immed;
  bool _sync;
  bool _use_keypad;
  int _delay;
  struct ldat *_line;
  short _regtop;
  short _regbottom;
  int _parx;
  int _pary;
  struct _win_st *_parent;
}
WINDOW;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Mon Jun 18 13:16:48 2001 -->
<SECT1 ID=libutil>
<TITLE></TITLE>
<PARA>
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-130-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Utility Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libutil - Utility Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>forkpty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>login_tty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>logwtmp<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>login<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>logout<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>openpty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<SECT1 ID=libutilman>
<TITLE>Interface Definitions for libutil</TITLE>
<PARA>
</PARA>
<REFENTRY ID="libutil-forkpty-3"> <REFMETA>
<REFENTRYTITLE>forkpty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>forkpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-forkpty-3"><PRIMARY>forkpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int forkpty(int *<replaceable class="parameter" >amaster</replaceable>, 
	char *<replaceable class="parameter" >name</replaceable>,
	struct termios *<replaceable class="parameter" >termp</replaceable>,
	struct winsize *<replaceable class="parameter" >winp</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The forkpty() function joins openpty(), fork(), and login_tty() to create a new process operating on a pseudo-tty. The file descriptor of the master side of the pseudo-tty is returned in amaster, and null or the filename of the slave in name. If non-null, the termp and winp parameters will determine the terminal attributes and window size of the slave side of the pseudo-tty.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success of the child process, zero is returned. When the parent process receives the PID of its child process, pid is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getopt-3"> <REFMETA>
<REFENTRYTITLE>getopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getopt-3"><PRIMARY>getopt</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
</SYNOPSIS>
<PARA>
GNU supports the following extensions of getopt:
</PARA>
<SYNOPSIS>
int getopt_long(int argc, char * const argv[],
               const char *optstring,
               const struct option *longopts, int *longindex);

int getopt_long_only(int argc, char * const argv[],
                    const char *optstring,
                    const struct option *longopts, int *longindex);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt() function parses command line arguments.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Option Characteristics</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
an element of argv that starts with "-" (and is not exactly "-" or "--") is an option element.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
characters of an option element, aside from the initial "-", are option characters.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
applications using getopt() must obey the following syntax guidelines:
</PARA><PARA>
(1) option name is a single alphanumeric character from the portable character set
</PARA><PARA>
(2) option is preceded by the "-" delimiter character
</PARA><PARA>
(3) options without option-arguments should be accepted when grouped behind one "-" delimiter
</PARA><PARA>
(4) each option and option-argument is a separate argument
</PARA><PARA>
(5) option-arguments are not optional
</PARA><PARA>
(6) all options should precede operands on the command line
</PARA><PARA>
(7) the argument "--" is accepted as a delimiter indicating the end of options and the consideration of subsequent arguments, if any, as operands
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
historical implementations of getopt() support other characters as options as an allowed extension, but applications that use extensions are not maximally portable.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
support for multi-byte option characters is only possible when such characters can be represented as type int.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
applications that call any utility with a first operand starting with "-" should usually specify "--" to mark the end of the options.  Standard utilities that do not support this guideline indicate that fact in the OPTIONS section of the utility description.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Extensions</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if a character is followed by two colons, the option takes an optional arg; if there is text in the current argv-element, it is returned in optarg, otherwise optarg is set to zero.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if optstring contains W followed by a semi-colon, then -W foo is treated as the long option --foo.  (Not available with libraries before GNU libc 2.)
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long() works like getopt() except that it also accepts "long options", or, options that are preface with two dashes instead of one.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
long option names may be abbreviated if the abbreviation is unique or an exact match for some defined option.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
a long option may take a parameter, of the form  --arg=param or --arg param.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long_only() works like getopt_long(), except that both "-" and "--" indicate long option.  If an option that starts with "-" (not "--") doesn't match a long option, but does match a short option, it is parsed instead as a short option.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the -W option is reserved for implementation extensions.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Return Values</TITLE>
<PARA>
GNU specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
GNU specifies the following getopt_long() and getopt_long_only() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
when short option is recognized, the option character is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
when long option is recognized, val is returned if flag is NULL, otherwise, 0 is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
error and -1 returns are the same as for getopt().
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned for an ambiguous match or an extraneous parameter.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options and the first character of opstring is ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character not in optstring is encountered, or if getopt() detects a missing argument and the first character of optstring is not ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if the variable POSIXLY_CORRECT is set, option processing stops as soon as a non-option argument is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if POSIXLY_CORRECT is set, GNU getopt() conforms to POSIX.2.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the variable _[PID]_GNU_nonoption_argv_flags_ was used by bash 2.0 to communicate to GNU libc which arguments resulted from wildcard expansion and so should not be considered as options.  This behavior was removed in bash version 2.01, but the support remains in GNU libc.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
POSIX.2 Interpretation 150 reports a technical error in the function of getopt().  GNU implements the correct behavior of getopt().
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutent-r-3"> <REFMETA>
<REFENTRYTITLE>getutent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutent-r-3"><PRIMARY>getutent_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutent_r(
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutid-r-3"> <REFMETA>
<REFENTRYTITLE>getutid_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutid_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutid-r-3"><PRIMARY>getutid_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutid_r(
const struct utmp *<replaceable class="parameter" >id</replaceable>,
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutline-r-3"> <REFMETA>
<REFENTRYTITLE>getutline_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutline_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutline-r-3"><PRIMARY>getutline_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutline_r(
const struct utmp *<replaceable class="parameter" >id</replaceable>,
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-login-tty-3"> <REFMETA>
<REFENTRYTITLE>login_tty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login_tty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-tty-3"><PRIMARY>login_tty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int login_tty(int <replaceable class="parameter" >fdr</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The login_tty() function sets up for a login on the tty referenced by the file descriptor fd: create a new session, make the tty for the current process the controlling terminal, set the standard input, output, and error streams of the current process, and closing fd.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-login-3"> <REFMETA>
<REFENTRYTITLE>login</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login
</REFNAME>
<REFPURPOSE>login utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-3"><PRIMARY>login</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
void login(struct utmp *<replaceable class="parameter" >ut</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The login() function updates the /var/run/utmp and /var/log/wtmp files with user information contained in ut.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-logout-3"> <REFMETA>
<REFENTRYTITLE>logout</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logout
</REFNAME>
<REFPURPOSE>logout utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-logout-3"><PRIMARY>logout</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int logout(const char *<replaceable class="parameter" >line</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Given the device line, the logout() function removes the entry from the corresponding /var/run/utmp system file.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
Zero is returned if there was no entry to remove. A non-zero return value indicates success.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-mkfifo-3"> <REFMETA>
<REFENTRYTITLE>mkfifo</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mkfifo</REFNAME>
<REFPURPOSE>
make a FIFO special file
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-mkfifo-3"><PRIMARY>mkfifo</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int mkfifo(const char *path, mode_t mode);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mkfifo() function attempts to create a FIFO special file named by the pathname to which the argument path points.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Node Permissions</TITLE>
<PARA>
Permissions are specified in the mode argument.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
permissions are modified by the process umask in the usual way: the permissions of the created node are (mode & ~umask).
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
file permission bits of the new FIFO are initialized from mode.  The file permission bits of the mode argument are modified by the process file creation mask.  When bits in mode other than the file permission bits are set, the effect is implementation-dependent.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
upon successful completion, mkfifo() marks for update the st_atime, st_ctime and st_mtime fields of the file.  Also, the st_ctime and st_mtime fields of the directory that contains the new entry are marked for update.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Errors</TITLE>
<PARA>
POSIX specifies the following error conditions that are not reflected in GNU:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
ELOOP   too many symbolic links were encountered in resolving path
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-mknod-3"> <REFMETA>
<REFENTRYTITLE>mknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mknod</REFNAME>
<REFPURPOSE>
make a directory, a special or regular file
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-mknod-3"><PRIMARY>mknod</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int mknod(const char *path, mode_t mode, dev_t dev);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mknod() function attempts to create a filesystem node named by the pathname to which the argument path points.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Node Type</TITLE>
<PARA>
Node type is specified in the mode argument (using the bitwise OR) from the symb
olic constants S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
a node type specified as zero behaves as S_IFREG.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
for the node types S_IFCHR and S_IFBLK, dev specifies the major and minor numbers of the newly created device special file.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
S_IFDIR may additionally be used to create a directory file.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
S_IFIFO is the only portable use of mknod().
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if mode is not S_IFIFO or dev is not 0, the behavior of mknod() is unspecified.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Node Permissions</TITLE>
<PARA>
Permissions are specified in the mode argument.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
permissions are modified by the process umask in the usual way: the permissions of the created node are (mode & ~umask).
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the mode argument specifies node permissions (using the bitwise OR) from the following symbolic constants:
  S_ISUID  set user ID on execution
  S_ISGID  set group ID on execution
  S_IRWXU  read, write or execute (search) by owner
  S_IRUSR  read by owner
  S_IWUSR  write by owner
  S_IXUSR  execute (search) by owner
  S_IRWXG  read, write or execute (search) by group
  S_IRGRP  read by group
  S_IWGRP  write by group
  S_IXGRP  execute (search) by group
  S_IRWXO  read, write or execute (search) by others
  S_IROTH  read by others
  S_IWOTH  write by others
  S_IXOTH  execute (search) by others
  S_ISVTX  on directories, restricted deletion flag
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
owner, group, and other permission bits of mode are modified by the file mode creation mask of the process.  The mknod() function clears each bit whose corresponding bit in the file mode creation mask of the process is set.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
upon successful completion, mknod() marks for update the st_atime, st_ctime and st_mtime fields of the file.  Also, the st_ctime and st_mtime fields of the directory that contains the new entry are marked for update.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Errors</TITLE>
<PARA>
GNU specifies the following error conditions that are not reflected in POSIX:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
EFAULT  pathname points outside your accessible address space
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
ENOMEM  insufficient kernel memory was available
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies the following error conditions that are not reflected in GNU:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
EIO     an I/O error occurred while accessing the file system
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-openpty-3"> <REFMETA>
<REFENTRYTITLE>openpty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>openpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-openpty-3"><PRIMARY>openpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int openpty(int *<replaceable class="parameter" >amaster</replaceable>, 
	int *<replaceable class="parameter" >aslave</replaceable>, 
	char *<replaceable class="parameter" >name</replaceable>,
	struct termios *<replaceable class="parameter" >termp</replaceable>,
	struct winsize *<replaceable class="parameter" >winp</replaceable>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The openpty() function finds an available pseudo-tty and returns file descriptors for the amaster and aslave. The filename of the slave is returned in name, otherwise a null. The terminal parameters of the slave will be set to the values in termp, otherwise a null. The window size of the slave will be set to the values in winp, otherwise a null.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOENT
</TERM>
<LISTITEM>
<PARA>
There are no available ttys.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
</REFENTRY>

</SECT1>


</CHAPTER>

</PART>
