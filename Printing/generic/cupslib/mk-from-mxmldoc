#!/usr/bin/python

# mk-from-mxmldoc: mxmldoc to DocBook converter
# Copyright 2007 The Linux Foundation.
# Written by Jeff Licquia <licquia@linux-foundation.org>.

# This utility converts documentation as generated by mxmldoc for the
# CUPS APIs into DocBook suitable for use with the LSB Printing
# Specification.  It uses source XML files generated by mxmldoc,
# "api-cups.xml" for libcups, and "api-cupsimage.xml" for
# libcupsimage.  This source file is generally the same as the file
# created by the "apihelp" make target in the CUPS source, but with a
# few differences:
# 
#  - The CUPS builds don't generate the XML file, so this will have to
# be done by specifying an XML target on the mxmldoc command line
# before the source files to read.
#
#  - Since we don't use the HTML, the other command-line arguments are
# basically no-ops.  In particular, the "--intro" argument isn't
# needed, and neither is the intro HTML snippet.

import sys
import re

# ElementTree.  When Python 2.4 goes out of style, this can be made
# much simpler.  The goal: whatever version of ElementTree is
# available gets exposed to this script as the 'etree' module.

try:
    import xml.etree.cElementTree as etree
except ImportError:
    try:
        import cElementTree as etree
    except ImportError:
        try:
            import xml.etree.ElementTree as etree
        except ImportError:
            # If this fails, we just don't have ElementTree.
            import ElementTree.ElementTree as etree

def get_function_list():
    "Return the list of functions we support."

    # XXX: Read these from the database!
    return { "cups": [ "cupsAddDest", "cupsAddOption",
                       "cupsCancelJob", "cupsEncryption",
                       "cupsFreeDests", "cupsFreeJobs",
                       "cupsFreeOptions", "cupsGetDefault",
                       "cupsGetDefault2", "cupsGetDest",
                       "cupsGetDests", "cupsGetDests2",
                       "cupsGetFd", "cupsGetFile", "cupsGetJobs",
                       "cupsGetJobs2", "cupsGetOption", "cupsGetPPD",
                       "cupsGetPPD2", "cupsGetPassword",
                       "cupsLangEncoding", "cupsLangFlush",
                       "cupsLangFree", "cupsLangGet",
                       "cupsLastError", "cupsMarkOptions",
                       "cupsParseOptions", "cupsPrintFile",
                       "cupsPrintFile2", "cupsPrintFiles",
                       "cupsPrintFiles2", "cupsPutFd",
                       "cupsPutFile", "cupsServer",
                       "cupsSetDests", "cupsSetDests2",
                       "cupsSetEncryption", "cupsSetPasswordCB",
                       "cupsSetServer", "cupsSetUser",
                       "cupsTempFd", "cupsUser", "ppdClose",
                       "ppdCollect", "ppdConflicts", "ppdEmit",
                       "ppdEmitFd", "ppdEmitJCL", "ppdErrorString",
                       "ppdFileAttr", "ppdFindChoice",
                       "ppdFindMarkedChoice", "ppdFindNextAttr",
                       "ppdFindOption", "ppdIsMarked", "ppdLastError",
                       "ppdMarkDefaults", "ppdMarkOption", "ppdOpen",
                       "ppdOpenFd", "ppdOpenFile", "ppdPageSize",
                       "ppdPageWidth", "ppdSetConformance" ],
             "cupsimage": [ "cupsRasterClose", "cupsRasterOpen",
                            "cupsRasterReadHeader",
                            "cupsRasterReadPixels",
                            "cupsRasterWriteHeader",
                            "cupsRasterWritePixels" ] }

def parse_mxmldoc(fileobj):
    "Parse the input from fileobj into an ElementTree tree."

    return etree.parse(fileobj)

def main():
    "Main function."

    funcs = get_function_list()

    seen_funcs = {"cups": [], "cupsimage": []}
    for fn in ("api-cups.xml", "api-cupsimage.xml"):
        treename = re.match(r'api-(.+)\.xml', fn).group(1)
        tree = parse_mxmldoc(open(fn))

        qname = etree.QName("http://www.easysw.com", "function")
        for function in tree.getroot().getiterator(qname):
            if function.attrib["name"] not in funcs[treename]:
                continue

            print "function from %s: %s" % (treename,
                                            function.attrib["name"])
            seen_funcs[treename].append(function.attrib["name"])

    for api in funcs.keys():
        for func in funcs[api]:
            if func not in seen_funcs[api]:
                print "Function not seen: " + func

if __name__ == "__main__":
    main()
