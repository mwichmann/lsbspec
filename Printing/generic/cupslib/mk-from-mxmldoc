#!/usr/bin/python

# mk-from-mxmldoc: mxmldoc to DocBook converter
# Copyright 2007 The Linux Foundation.
# Written by Jeff Licquia <licquia@linux-foundation.org>.

# This utility converts documentation as generated by mxmldoc for the
# CUPS APIs into DocBook suitable for use with the LSB Printing
# Specification.  It uses source XML files generated by mxmldoc,
# "api-cups.xml" for libcups, and "api-cupsimage.xml" for
# libcupsimage.  This source file is generally the same as the file
# created by the "apihelp" make target in the CUPS source, but with a
# few differences:
# 
#  - The CUPS builds don't generate the XML file, so this will have to
# be done by specifying an XML target on the mxmldoc command line
# before the source files to read.
#
#  - Since we don't use the HTML, the other command-line arguments are
# basically no-ops.  In particular, the "--intro" argument isn't
# needed, and neither is the intro HTML snippet.

import sys
import re

# StringIO.

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

# ElementTree.  When Python 2.4 goes out of style, this can be made
# much simpler.  The goal: whatever version of ElementTree is
# available gets exposed to this script as the 'etree' module.

try:
    import xml.etree.cElementTree as etree
except ImportError:
    try:
        import cElementTree as etree
    except ImportError:
        try:
            import xml.etree.ElementTree as etree
        except ImportError:
            # If this fails, we just don't have ElementTree.
            import elementtree.ElementTree as etree

# Macro style in the template.  Should return one group in the match
# object, corresponding to the meta key.

subst_re = re.compile(r'@(.+)@')

# Namespace URL for the mxmldoc namespace.

ns_url = "http://www.easysw.com"

def get_function_list():
    "Return the list of functions we support."

    # XXX: Read these from the database!
    return { "cups": [ "cupsAddDest", "cupsAddOption",
                       "cupsCancelJob", "cupsEncryption",
                       "cupsFreeDests", "cupsFreeJobs",
                       "cupsFreeOptions", "cupsGetDefault",
                       "cupsGetDefault2", "cupsGetDest",
                       "cupsGetDests", "cupsGetDests2",
                       "cupsGetFd", "cupsGetFile", "cupsGetJobs",
                       "cupsGetJobs2", "cupsGetOption", "cupsGetPPD",
                       "cupsGetPPD2", "cupsGetPassword",
                       "cupsLangEncoding", "cupsLangFlush",
                       "cupsLangFree", "cupsLangGet",
                       "cupsLastError", "cupsMarkOptions",
                       "cupsParseOptions", "cupsPrintFile",
                       "cupsPrintFile2", "cupsPrintFiles",
                       "cupsPrintFiles2", "cupsPutFd",
                       "cupsPutFile", "cupsServer",
                       "cupsSetDests", "cupsSetDests2",
                       "cupsSetEncryption", "cupsSetPasswordCB",
                       "cupsSetServer", "cupsSetUser",
                       "cupsTempFd", "cupsUser", "ppdClose",
                       "ppdCollect", "ppdConflicts", "ppdEmit",
                       "ppdEmitFd", "ppdEmitJCL", "ppdErrorString",
                       "ppdFileAttr", "ppdFindChoice",
                       "ppdFindMarkedChoice", "ppdFindNextAttr",
                       "ppdFindOption", "ppdIsMarked", "ppdLastError",
                       "ppdMarkDefaults", "ppdMarkOption", "ppdOpen",
                       "ppdOpenFd", "ppdOpenFile", "ppdPageSize",
                       "ppdPageWidth", "ppdSetConformance" ],
             "cupsimage": [ "cupsRasterClose", "cupsRasterOpen",
                            "cupsRasterReadHeader",
                            "cupsRasterReadPixels",
                            "cupsRasterWriteHeader",
                            "cupsRasterWritePixels" ] }

def parse_mxmldoc(fileobj):
    "Parse the input from fileobj into an ElementTree tree."

    return etree.parse(fileobj)

def make_description(description):
    """Descriptions provided by mxmldoc don't have semantic formatting
    to separate paragraphs, etc.  Fix that."""

    docbook_desc = "<para>\n"

    for line in StringIO(description):
        if len(line.strip()) == 0:
            docbook_desc = docbook_desc + "</para>\n<para>\n"
        else:
            docbook_desc = docbook_desc + line

    docbook_desc = docbook_desc + "\n</para>"
    return docbook_desc

def make_parameters(function):
    """Create the parameter list for the function element."""

    docbook_args = ""

    for argument in function.getiterator(etree.QName(ns_url,
                                                     "argument")):
        param_name = argument.attrib["name"]
        param_type = argument.find("./{%s}type" % ns_url)
        param_type_str = param_type.text.strip()
        param_str = \
                  "<paramdef>%s\n<parameter>%s</parameter>\n</paramdef>" \
                  % (param_type_str, param_name)
        docbook_args = docbook_args + param_str + "\n"

    return docbook_args

def extract_meta(function, treename):
    """Translate the data in the function element into metadata to
    interpolate into the DocBook template."""

    # Simple parsing can be done when creating the dict.

    meta = { "function_name": function.attrib["name"],
             "library_name": "lib" + treename }

    func_name_normalized = re.sub(r'_', ".", meta["function_name"])
    meta["refentry_id"] = "%s.%s.1" % (meta["library_name"],
                                       func_name_normalized)

    meta["indexterm_id"] = "ix." + meta["refentry_id"]

    retval_type = function.find("./{%s}returnvalue/{%s}type" %
                                (ns_url, ns_url))
    if retval_type:
        meta["function_retval"] = retval_type.text.strip()
    else:
        meta["function_retval"] = "void"

    meta["function_parameters"] = make_parameters(function)

    if treename == "cups":
        meta["header"] = "cups/cups.h"
    elif treename == "cupsimage":
        meta["header"] = "cups/raster.h"
    else:
        raise ValueError, "unrecognized library name: " + treename

    description = function.find("./{%s}description" % ns_url)
    meta["description"] = make_description(description.text.strip())

    return meta

def write_template(template, meta, outfile):
    """Write template to outfile, substituting the appropriate data
    from meta."""

    for line in template:
        subst_match = subst_re.search(line)
        while subst_match:
            match_key = subst_match.group(1)
            match_re = re.compile('@%s@' % match_key)
            if match_key in meta:
                line = match_re.sub(meta[match_key], line, 1)
            else:
                line = match_re.sub("", line, 1)
            subst_match = subst_re.search(line)

        outfile.write(line)

def main():
    "Main function."

    funcs = get_function_list()
    template = [x for x in open("cupsfunc_template.sgml.in")]

    seen_funcs = {"cups": [], "cupsimage": []}
    for fn in ("api-cups.xml", "api-cupsimage.xml"):
        treename = re.match(r'api-(.+)\.xml', fn).group(1)
        tree = parse_mxmldoc(open(fn))

        qname = etree.QName(ns_url, "function")
        for function in tree.getroot().getiterator(qname):
            if function.attrib["name"] not in funcs[treename]:
                continue

            funcmeta = extract_meta(function, treename)

            docbook = open(funcmeta["function_name"] + ".sgml", "w")
            write_template(template, funcmeta, docbook)
            docbook.close()

            seen_funcs[treename].append(function.attrib["name"])

    for api in funcs.keys():
        for func in funcs[api]:
            if func not in seen_funcs[api]:
                sys.stderr.write("Function not seen: " + func + "\n")

if __name__ == "__main__":
    main()
