#!/usr/bin/perl
#
#	Linux Standard Base, http://www.linuxbase.org/
#	George Kraft IV, gk4@us.ibm.com, 03/09/2000
#	Nick Stoughton, nick@usenix.org, 2004 - 2005
#
#


use DBI;
use Getopt::Long;
use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

local %references;
local %standards;
my $builtins = 0;

sub usage()
{
        print STDERR "mkcmdtable -v <lsbversion> [-b] [-m <submodule>]\n Default module is LSB_Base.\n";
        die;
}
################################################################################
#	lsbOpenDB
################################################################################

sub lsbOpenDB {
	$dbh = DBI->connect("DBI:mysql:$LSBDB:$LSBDBHOST", $LSBUSER, $LSBDBPASSWD);
	die unless $dbh;
}

################################################################################
#	lsbCloseDB
################################################################################

sub lsbCloseDB {
	$dbh->disconnect;
}

################################################################################
#	builtinexcepts
################################################################################

sub builtinexcepts {
	print << "END_BIEXCEPT_TEXT";
<ORDEREDLIST>
<LISTITEM><PARA>
The built in commands and utilities shall be provided by the
<command>sh</command> utility itself, and need not 
be implemented in a manner so that they can be accessed via the 
exec family of functions as defined in <XREF LINKEND="STD.SUSv4">
and should not be invoked directly by those standard utilities 
that execute other utilities (
<SIMPLELIST type=inline>
<MEMBER><COMMAND>env</COMMAND></MEMBER>
<MEMBER><COMMAND>find</COMMAND></MEMBER>
<MEMBER><COMMAND>nice</COMMAND></MEMBER>
<MEMBER><COMMAND>nohup</COMMAND></MEMBER>
<MEMBER><COMMAND>time</COMMAND></MEMBER>
<MEMBER><COMMAND>xargs</COMMAND></MEMBER>
</SIMPLELIST>).
<NOTE>
<TITLE>Rationale (Informative)</TITLE>
<PARA>
Since the built in utilities must affect the environment of the calling
process, they have no effect when executed as a file.
</PARA></NOTE>
</PARA></LISTITEM>
</ORDEREDLIST>
END_BIEXCEPT_TEXT
}

################################################################################
#	cmdexcepts
################################################################################

sub cmdexcepts {
	print << "END_EXCEPT_TEXT";
<ORDEREDLIST>
<LISTITEM><PARA>
If any operand (except one which follows <option>--</option>) starts with a
hyphen, the behavior is unspecified.
<NOTE><TITLE>Rationale (Informative)</TITLE>
<para>Applications should place options before operands, or use
<option>--</option>, as needed.  This text is needed because,
by default, GNU option parsing
differs from POSIX, unless the environment variable 
<ENVAR>POSIXLY_CORRECT</ENVAR>
is set.  For example, <command>ls . -a</command> in GNU
<command>ls</command> means to list the current directory, showing all
files (that is, <option>"."</option> is an operand and <option>-a</option> is an
option).  In POSIX, <option>"."</option> and <option>-a</option> are both operands,
and the command means to list the current directory, and also the file
named <filename>-a</filename>.  Suggesting that applications rely on the
setting of the <envar>POSIXLY_CORRECT</envar> environment variable,
or try to set it, seems worse than just asking the applications to invoke
commands in ways which work with either the POSIX or GNU behaviors.</para>

</NOTE>
</PARA></LISTITEM>
</ORDEREDLIST>
END_EXCEPT_TEXT
}
################################################################################
#	lsbCommands
################################################################################

sub lsbCommands {

	my $status, $title, $tbl, $MainTitle, $builtinCheck;
	if ($builtins) {
		$status = 'Included';
		$builtinCheck = 'Command.Cbuiltin = \'Yes\'';
		$title = 'shell built in utilities';
		$tbl = "tbl-builtins";
		$MainTitle = "Built In Utilities";
	} else {
		$status = 'Included';
		$builtinCheck = 'Command.Cbuiltin <> \'Yes\''; # let's include 'Unknown' builtins here
		$title = 'commands and utilities';
		$tbl = "tbl-cmds";
		$MainTitle = "Commands And Utilities";
	}
	$sth = $dbh->prepare("SELECT DISTINCT Sfull, Sid, Sname FROM Standard,Command
                          LEFT JOIN SModCmd ON Command.Cid=SModCmd.SMCcid
                          LEFT JOIN CmdStd ON CScid=Cid
                          WHERE SModCmd.SMCsmid=$moduleid
                          AND Standard.Sid=CSsid
                          AND SMCappearedin > '' AND SMCappearedin<='$lsbversion'
                          AND (SMCwithdrawnin IS NULL OR SMCwithdrawnin>'$lsbversion')
                          AND Sappearedin > '' AND Sappearedin<='$lsbversion'
                          AND (Swithdrawnin IS NULL OR Swithdrawnin>'$lsbversion')
                          AND CSappearedin > '' AND CSappearedin<='$lsbversion'
                          AND (CSwithdrawnin IS NULL OR CSwithdrawnin>'$lsbversion')
                          AND $builtinCheck
                          ORDER BY Sname");
	$sth->execute;

	if ($sth->rows > 0) {

	$sth->finish;
	printf("<!-- Start of text generated from database -->\n");
	printf("<PARA>\n");
	printf("An LSB conforming implementation shall provide the\n");
	printf("%s as described in <XREF LINKEND=\"%s\">, with at least the behavior\n",
		$title, $tbl);
	printf("described as mandatory in the referenced underlying\n");
	printf("specification, with the following exceptions:\n");
	$builtins ? builtinexcepts : cmdexcepts;

	printf("</PARA>\n");

	$sth = $dbh->prepare("SELECT Cname, CSsid, Sfull, Sid, Sname, Stag FROM Command
                            LEFT JOIN SModCmd ON Command.Cid=SModCmd.SMCcid
                            LEFT JOIN CmdStd ON CScid=Cid
                            LEFT JOIN Standard ON CSsid=Standard.Sid
                            WHERE SMCappearedin > '' AND SMCappearedin<='$lsbversion'
                            AND (SMCwithdrawnin IS NULL OR SMCwithdrawnin>'$lsbversion')
                            AND Sappearedin > '' AND Sappearedin<='$lsbversion'
                            AND (Swithdrawnin IS NULL OR Swithdrawnin>'$lsbversion')
			    AND CSappearedin > '' AND CSappearedin<='$lsbversion'
			    AND (CSwithdrawnin IS NULL OR CSwithdrawnin>'$lsbversion')
                            AND $builtinCheck
                            AND SModCmd.SMCsmid=$moduleid
                            ORDER BY Command.Cname");
	$sth->execute;

	if ($sth->rows < 1) {
		printf("<PARA>No Commands or Utilities found!</PARA>\n");
		$sth->finish;
		return;
	} 

	printf("<TABLE id=\"$tbl\">\n");
	printf("<TITLE>$MainTitle</TITLE>\n");
	printf("<TGROUP COLS=5>\n");
	printf("<TBODY>\n");
	printf("<ROW>\n");

	my $col = 0; #column count
	my $row = 0;
	my $totalrows = int(($sth->rows+4) / 5);

	my $cmds = $sth->fetchall_arrayref({});

	while ($row < $totalrows) {

		#
		# fixed width table ... 5 columns
		#
		if ($col == 5) {
			last if(++$row >= $totalrows);
			printf("</ROW><ROW>\n");
			$col = 0;
		}
		my $idx = ($row + ($col++ * $totalrows));
		$field = $cmds->[($idx)];

		#
		# Shouldn't need this, but we've seen this script 
		# go into an infinite loop before, so this is a safeguard.
		#
		die "OVERFLOW!!! $idx > " . $totalrows * 5 unless ($idx <= $totalrows*5);

		$ref = $permutation{$field->{'CSsid'}};

		#$ftid = sprintf("std-fn-%s-%s",  
		#	$field[1], $permutation{$field[1]});

		printf("<ENTRY>%s\n", $field->{'Cname'});
		# figure out a reference
		# each table is followed by a list of references
		#
		# this is a little complex:
		# %references is a hash, using keys of the form "std-%d-%d"
		#   with values being the names of the standards
		# @ref is an array; each element is a key in %ref
		# $refno is the current index into that array
		if( $field->{'Sid'} ) {

			my $refstr = sprintf "std-cmd%s-%d",
				$builtins ? "bi":"" ,$field->{'Sid'};
			$references{$refstr} = $field->{'Stag'};
			$refno = 0;
			for $r (0..$#ref) {
				$refno = $r;
				last if ($ref[$r] eq $refstr);
			}
			if ($ref[$refno] ne $refstr) {
				push(@ref, $refstr);
				$refno = $#ref;
			}
			
			printf("<LINK LINKEND=\"%s\"> [%d]</LINK>\n", 
				$refstr, $refno+1 );
		}
		printf("</ENTRY>\n");

	}

	printf("</ROW>\n");
	printf("</TBODY>\n");
	printf("</TGROUP>\n");
	printf("</TABLE>\n");
	#
	# now print out the referenced standards list
	#
	if ($#ref >= 0) {
		print "<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>\n";
		for $r (0..$#ref) {
			$refstr = $ref[$r];
			printf "<FORMALPARA><TITLE id=\"%s\">[%d]</TITLE><para><XREF LINKEND=std.%s></para></FORMALPARA>\n",
				$refstr, $r+1, $references{$refstr};
			}
		}
	}
	$sth->finish;

	printf("<!-- End of text generated from database -->\n");
}

################################################################################
#	main
################################################################################

# We can get module id from Module Table. Commands list will be generated as per modules.
GetOptions("b" => \$builtins,
           "m=s" => \$module,
	   "v=s" => \$lsbversion);

lsbOpenDB;

if(!$module) { 
    $module='LSB_Base';
}
($moduleid) = $dbh->selectrow_array("SELECT SMid FROM SubModule WHERE SMname='$module'");
die("Incorrect SubModule name") if not $moduleid;

if(!$lsbversion) { usage(); }

lsbCommands;
lsbCloseDB;

exit;

# EOF
