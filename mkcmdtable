#!/usr/bin/perl
#
#	Linux Standard Base, http://www.linuxbase.org/
#	George Kraft IV, gk4@us.ibm.com, 03/09/2000
#
#


use DBI;
use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

local %references;
local %standards;

################################################################################
#	lsbOpenDB
################################################################################

sub lsbOpenDB {

	$dbh = DBI->connect("DBI:mysql:$LSBDB:$LSBDBHOST", $LSBUSER, $LSBDBPASSWD);
	die unless $dbh;

	$sth = $dbh->prepare( "SHOW TABLES" );
	$sth->execute;

}

################################################################################
#	lsbCloseDB
################################################################################

sub lsbCloseDB {

	$sth = $dbh->prepare( "SHOW TABLES" );
	$sth->execute;

	$sth->finish;
	$dbh->disconnect;
}

################################################################################
#	lsbCommands
################################################################################

sub lsbCommands {

		$sth = $dbh->prepare("SELECT DISTINCT Sfull, Sid, Sname FROM Standard,Command WHERE Standard.Sid=Command.Cstandard AND Command.Cstatus='Included' ORDER BY Sname");
		$sth->execute;

		if ($sth->rows > 0) {

		printf("<!-- Start of text generated from database -->\n");
		printf("<PARA>\n");
		printf("The behavior of the interfaces described in this\n");
		printf("section is specified by the following standards.");
		printf("</PARA>\n");
		printf("<SIMPLELIST COLUMNS=1>\n");

		my $i = 0;
		while ($field = $sth->fetchrow_hashref) {
				$footer{$ftid} = $ref;
				printf("<MEMBER>\n");
				printf("<XREF LINKEND=\"std.%s\">\n", makeid($field->{'Sname'}));

				printf("</MEMBER>\n");
		}
		printf("</SIMPLELIST>\n");

		$sth = $dbh->prepare("SELECT Cname, Cstandard, Sfull, Sid, Sname FROM Command LEFT JOIN Standard ON Command.Cstandard=Standard.Sid WHERE Command.Cstatus='Included' ORDER BY Command.Cname");
		$sth->execute;

		if ($sth->rows < 1) {
			printf("<PARA>No Commands or Utilities found!</PARA>\n");
			return;
		} 

		printf("<TABLE id=\"tbl-cmds\">\n");
		printf("<TITLE>Commands and Utilities</TITLE>\n");
		printf("<TGROUP COLS=5>\n");
		printf("<TBODY>\n");
		printf("<ROW>\n");

		my $i = 0;
		while ($field = $sth->fetchrow_hashref) {
			$ref = $permutation{$field->{'Cstandard'}};

			#
			# fixed width table ... 5 columns
			#
			if ($i != 0 && 0 == ($i % 5)) {
				printf("</ROW><ROW>\n");
			}

			#$ftid = sprintf("std-fn-%s-%s",  
			#	$field[1], $permutation{$field[1]});

			printf("<ENTRY>%s\n", $field->{'Cname'});
			# figure out a reference
			# each table is followed by a list of references
			#
			# this is a little complex:
			# %references is a hash, using keys of the form "std-%d-%d"
			#   with values being the names of the standards
			# @ref is an array; each element is a key in %ref
			# $refno is the current index into that array
			if( $field->{'Sid'} ) {

				my $refstr = sprintf "std-cmd-%d",
					$field->{'Sid'};
				$references{$refstr} = $field->{'Sname'};
				$refno = 0;
				for $r (0..$#ref) {
					$refno = $r;
					last if ($ref[$r] eq $refstr);
				}
				if ($ref[$refno] ne $refstr) {
					push(@ref, $refstr);
					$refno = $#ref;
				}
				
				printf("<LINK LINKEND=\"%s\"> [%d]</LINK>\n", 
					$refstr, $refno+1 );
			}
			printf("</ENTRY>\n");

			++$i;
		}

		printf("</ROW>\n");
		printf("</TBODY>\n");
		printf("</TGROUP>\n");
		printf("</TABLE>\n");
		#
		# now print out the referenced standards list
		#
		if ($#ref >= 0) {
			print "<PARA><EMPHASIS>Referenced Specification(s)</EMPHASIS></PARA>\n";
			for $r (0..$#ref) {
				$refstr = $ref[$r];
				$references{$refstr} = "This specification" if ($references{$refstr} eq "Linux Standard Base");
				printf "<FORMALPARA><TITLE id=\"%s\">[%d]</TITLE><para><XREF LINKEND=std.%s></para></FORMALPARA>\n",
					$refstr, $r+1, makeid($references{$refstr});
				}
			}
		}

		printf("<!-- End of text generated from database -->\n");

#		foreach $key (keys %standards) {
#			printf("<FOOTNOTE ID=\"std-%s-%s\">\n", $key, $permutation{$key});
#			printf("<PARA>\n");
#			printf("%s\n", $standards{$key});
#			printf("</PARA>\n</FOOTNOTE>\n");
#		}

}

################################################################################
#	makeid
################################################################################
sub makeid($) 
{
	my ($name) = @_;
	$name =~ s/\s+/./g;
	$name =~ s/[^A-Za-z0-9.]+/./g;
	# finally, remove any repeated . (e.g. "RPC...XDR" which arose from "RPC & XDR")
	$name =~ s/\.\.+/./g;
	return $name;
}

################################################################################
#	main
################################################################################

lsbOpenDB;
lsbCommands;
lsbCloseDB;

exit;

# EOF
