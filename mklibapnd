#!/usr/bin/perl

use Getopt::Long;
use DBI;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

sub usage()
{
print STDERR "mklibapdn -a <archname> -v <lsbversion> [-m module]\n Default module is 1 (i.e LSB Core)\n";
die;
}

sub makeid($)
{
	my ($name) = @_;
	$name =~ s/\s+/./g;
	$name =~ s/[^A-Za-z0-9.]+/./g;
	# finally, remove any repeated . (e.g. "RPC...XDR" which arose from "RPC & XDR")
	$name =~ s/\.\.+/./g;
	return $name;
}

# Uncomment to trace SQL statments
#$trace=1;

#
# 1) process the arguments
#
GetOptions("a=s" => \$archname,
		   "v=s" => \$lsbversion,
           "m=s" => \$module);
if( !$module ) { $module='LSB_Core'; }

if( !$archname ) { usage(); }
if( !$lsbversion ) { usage(); }

#
# 2) Establish connection to the database
#
$dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;

#
# 3) get & print the architecture info
#
$select = "SELECT * FROM Architecture WHERE ";
$select.= "Architecture.Aname=".$dbh->quote($archname);
print STDERR $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

$entry=$sth->fetchrow_hashref;
$Aid=$entry->{'Aid'};
$Aname=$entry->{'Aname'};
$sth->finish;

printf("<!-- Start of text generated from database -->\n");
printf("<!-- generated from the LSB specification database -->\n");
printf("<!--    by \$Header: mklibapnd 1.22 2006/08/31 19:40:08 nick Exp $- -->\n");
my $now_string = localtime;
printf("<!--    at %s -->\n", $now_string );

print "<APPENDIX ID=app-A>\n";
print "<TITLE>Alphabetical Listing of Interfaces</TITLE>\n";
print "<PARA>\n";
print "</PARA>\n";
#
# 4) get & print the library info
#
$select = "SELECT * FROM Library ";
$select.= "LEFT JOIN ArchLib ON ALlid=Lid ";
if( $module ) {
	$select.= "LEFT JOIN ModLib ON MLlid=Lid ";
	$select.= "LEFT JOIN Module ON MLmid=Mid ";
}
$select.= "WHERE (ALappearedin <= '$lsbversion' AND ALappearedin<>'' ";
$select.= "AND (ALwithdrawnin IS NULL OR ALwithdrawnin > '$lsbversion') ) ";
if( $module ) {
	$select.= "AND Mname='".$module."' ";
}

if( $Aid != 1 ) {
	$select.= "AND (ALaid=$Aid OR (ALaid=1 AND Lid NOT IN ( ";
	$select.= "SELECT Lid FROM Library ";
	$select.= "LEFT JOIN ArchLib ON ALlid=Lid ";
	$select.= "WHERE (ALappearedin <= '$lsbversion' AND ALappearedin<>'' ";
	$select.= "AND (ALwithdrawnin IS NULL OR ALwithdrawnin > '$lsbversion') ) ";
	$select.= "AND ALaid=$Aid ) ) ) ";
}
else {
	$select.= "AND ALaid=$Aid ";
}

$select.= "AND Library.Lname!='libstdcxx' ";
$select.= "ORDER BY Lname ";
print STDERR $select,"\n" if $trace;
$lth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$lth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for(1..$lth->rows) {

$entry=$lth->fetchrow_hashref;
$Lid=$entry->{'Lid'};
$Lname=$entry->{'Lname'};

$select = "SELECT Iname,Istandard,Vname,Sname ";
$select.= "FROM Interface ";
$select.= "INNER JOIN LGInt ON Iid=LGIint ";
$select.= "INNER JOIN LibGroup ON LGIlibg=LGid ";
$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
$select.= "LEFT JOIN Version ON Vid=AIversion ";
$select.= "LEFT JOIN Standard ON Sid=Istandard ";
$select.= "WHERE Itype='Function' ";
$select.= "AND LGlib=$Lid AND AIarch=$Aid ";
$select.= "AND (AIappearedin <= '$lsbversion' and AIappearedin<>'') ";
$select.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'$lsbversion')";
$select.= "ORDER BY Iname";
$inh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$inh->execute or die "Couldn't execute $select query: ".DBI->errstr;
if( $inh->rows == 0) {
	$inh->finish;
	next;
}

print "<SECT1 ID=app-", $Lname, ">\n";
print "<TITLE>", $Lname, "</TITLE>\n";
print "<PARA>\n";
print "</PARA>\n";

#
# 6) Get a list of the Standards that are used by this library
#
print "<PARA>\n";
$select = "SELECT DISTINCT Sname,Sid FROM Standard,LibGroup,LGInt,Interface ";
$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
$select.= "WHERE Sid=Istandard AND Iid=LGIint AND LGIlibg=LGid ";
$select.= "AND LGlib=$Lid AND AIarch=$Aid ";
$select.= "ORDER BY Sname";
print STDERR $select,"\n" if $trace;
$lsh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$lsh->execute or die "Couldn't execute $select query: ".DBI->errstr;
local @refname;
if( $lsh->rows) {
	print "The behavior of the interfaces in this library is specified ";
	print "by the following Standards.";
	print "<SIMPLELIST COLUMNS=1>\n";
	for(1..$lsh->rows) {
		local(*entry);
		$entry=$lsh->fetchrow_hashref;
		$refname[$_] = $entry->{'Sname'};
		print "<MEMBER>\n";
		printf "<XREF LINKEND=\"STD.%s\"> [%s]\n", 
		makeid($entry->{'Sname'}), $entry->{'Sname'};
		print "</MEMBER>\n";
	}
	print "</SIMPLELIST>\n";
}
$lsh->finish;



print "</PARA>\n";
print "<TABLE>\n";
print "<TITLE>$Lname Function Interfaces</TITLE>\n";
print "<TGROUP COLS=3>\n";
print "<TBODY>\n";

#
# 7) Get a list of the interfaces in the library
#
{
	local(*std);
	local(*symver);
	local(*entry);
	local(*xrefs);
	local(*refs);
	# we did the following query back at step 4, 
	# and the results are still there waiting to be fetched ...
	#$select = "SELECT Iname,Istandard,Vname,Sname ";
	#$select.= "FROM Interface,LGInt,LibGroup ";
	#$select.= "LEFT JOIN Version ON Vid=Iversion ";
	#$select.= "LEFT JOIN Standard ON Sid=Istandard ";
	#$select.= "WHERE Iid=LGIint AND LGIlibg=LGid AND Itype='Function' ";
	#$select.= "AND LGlib=$Lid AND Iarch=$Aid AND Istdstatus='Included' ";
	#$select.= "ORDER BY Iname";
	#$inh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
	#$inh->execute or die "Couldn't execute $select query: ".DBI->errstr;
	print STDERR $select,"\n" if $trace;
	for(1..$inh->rows) {
		$entry=$inh->fetchrow_hashref;
		$entry[$_]=$entry->{'Iname'};
		$std[$_]=$entry->{'Istandard'};
		$xrefs[$_]=sprintf ("std.%s", makeid($entry->{'Sname'}));
		$refs[$_]=sprintf "[%s]", $entry->{'Sname'};
		$symver[$_]=$entry->{'Vname'};
	}
	# we now have @entry, an array of interface names
	# @std, an array of Standards (by Sid),
	# @refs, an array of xref labels to the standards in the normative refs,
	# and @symver, an array of symbol versions
	#
	#
	# this is a three column table
	#
	# inc is the last row number ...
	$inc=int(($inh->rows+2)/3);
	for(1..$inc) {
		print "<ROW>";
		printf "<ENTRY>%s", $entry[$_];
		if( $symver[$_] ) {
			printf "(%s)", $symver[$_];
		}
		if( $std[$_] ) {
			printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_], $refs[$_];
		}
		printf "</ENTRY>";
		printf "<ENTRY>%s", $entry[$_+$inc];
		if( $symver[$_+$inc] ) {
			printf "(%s)", $symver[$_+$inc];
		}
		if( $std[$_+$inc] ) {
			printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_+$inc], $refs[$_+$inc];
		}
		printf "</ENTRY>";
		printf "<ENTRY>%s", $entry[$_+(2*$inc)];
		if( $symver[$_+(2*$inc)] ) {
			printf "(%s)", $symver[$_+(2*$inc)];
		}
		if( $std[$_+(2*$inc)] ) {
			printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_+(2*$inc)], $refs[$_+(2*$inc)];
		}
		printf "</ENTRY>";
		print "</ROW>\n";
	}
}
$inh->finish;

print "</TBODY>\n";
print "</TGROUP>\n";
print "</TABLE>\n";
#
# 8) Make a table of data interfaces
#
{
	local(*datasym);
	local(*symver);
	local(*std);
	local(*xrefs);
	local(*refs);
	$select = "SELECT Iname,Istandard,Vname,Sname ";
	$select.= "FROM Interface ";
	$select.= "INNER JOIN LGInt ON Iid=LGIint ";
	$select.= "INNER JOIN LibGroup ON LGIlibg=LGid ";
	$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
	$select.= "LEFT JOIN Version ON Vid=AIversion ";
	$select.= "LEFT JOIN Standard ON Sid=Istandard ";
	$select.= "WHERE Itype='Data' ";
	$select.= "AND LGlib=$Lid AND AIarch=$Aid ";
	$select.= "AND (AIappearedin <= '$lsbversion' and AIappearedin<>'') ";
	$select.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'$lsbversion') ";
	$select.= "ORDER BY Iname";
	print STDERR $select,"\n" if $trace;
	$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
	$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
	if ($sth->rows > 0 ) {
		for(1..$sth->rows) {
			$datasym=$sth->fetchrow_hashref;
			$datasym[$_]=$datasym->{'Iname'};
			$std[$_]=$datasym->{'Istandard'};
			$xrefs[$_]=sprintf ("std.%s", makeid($datasym->{'Sname'}));
			$refs[$_]=sprintf "[%s]", $datasym->{'Sname'};
			$symver[$_]=$datasym->{'Vname'};
		}
		print "<TABLE>\n";
		print "<TITLE>$Lname Data Interfaces</TITLE>\n";
		print "<TGROUP COLS=3>\n";
		print "<TBODY>\n";
		$inc=($sth->rows+2)/3;
		for(1..$inc) {
			print "<ROW>";
			printf "<ENTRY>%s",$datasym[$_];
			if( $datasym[$_] && $std[$_] ) {
				printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_], $refs[$_];
			}
			printf "</ENTRY>";
			printf "<ENTRY>%s",$datasym[$_+$inc];
			if( $datasym[$_+$inc] && $std[$_+$inc] ) {
				printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_+$inc], $refs[$_+$inc];
			}
			printf "</ENTRY>";
			printf "<ENTRY>%s",$datasym[$_+(2*$inc)];
			if( $datasym[$_+(2*$inc)] && $std[$_+(2*$inc)] ) {
				printf "<LINK LINKEND=\"%s\">%s</LINK>", $xrefs[$_+(2*$inc)], $refs[$_+(2*$inc)];
			}
			printf "</ENTRY>";
			print "</ROW>\n";
		}
		print "</TBODY>\n";
		print "</TGROUP>\n";
		print "</TABLE>\n";
	}
	$sth->finish;
}
print "</SECT1>\n";
}
$lth->finish;
$dbh->disconnect;

print "</APPENDIX>\n";
printf("<!-- End of text generated from database -->\n");
printf("<!--    by \$Header: mklibapnd 1.22 2006/08/31 19:40:08 nick Exp $- -->\n");
