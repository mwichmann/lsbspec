<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Coding examples</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="zSeries ELF Application Binary Interface Supplement"
HREF="book1.html"><LINK
REL="UP"
TITLE="Low-level system information"
HREF="c4.html"><LINK
REL="PREVIOUS"
TITLE="Process initialization"
HREF="x877.html"><LINK
REL="NEXT"
TITLE="DWARF definition"
HREF="x1454.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>zSeries ELF Application Binary Interface Supplement</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x877.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Low-level system information</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1454.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CODINGEXAMPLES"
></A
>Coding examples</H1
><P
>This section describes example code sequences for fundamental operations

such as calling functions, accessing static objects, and transferring control

from one part of a program to another. Previous sections discussed how a program

may use the machine or the operating system, and they specified what a program

may and may not assume about the execution environment.  Unlike previous material,

the information in this section illustrates how operations may be done, not

how they must be done.</P
><P
>As before, examples use the ANSI C language.  Other programming languages

may use the same conventions displayed below, but failure to do so does not

prevent a program from conforming to the ABI.  Two main object code models

are available:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Absolute code</DT
><DD
><P
>Instructions can hold absolute addresses under this model. To execute

properly, the program must be loaded at a specific virtual address, making

the program's absolute addresses coincide with the process' virtual addresses.&#13;</P
></DD
><DT
>Position-independent code</DT
><DD
><P
>Instructions under this model hold relative addresses, not absolute

addresses. Consequently, the code is not tied to a specific load address,

allowing it to execute properly at various positions in virtual memory.</P
></DD
></DL
></DIV
><P
>The following sections describe the differences between these models.

When different, code sequences for the models appear together for easier comparison.&#13;</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The examples below show code fragments with various simplifications.

They are intended to explain addressing modes, not to show optimal code sequences

or to reproduce compiler output.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1125"
></A
>Code model overview</H2
><P
>When the system creates a process image, the executable file portion

of the process has fixed addresses and the system chooses shared object library

virtual addresses to avoid conflicts with other segments in the process. 

To maximize text sharing, shared objects conventionally use position-independent

code, in which instructions contain no absolute addresses.  Shared object

text segments can be loaded at various virtual addresses without having to

change the segment images. Thus multiple processes can share a single shared

object text segment, even if the segment resides at a different virtual address

in each process.</P
><P
>Position-independent code relies on two techniques:</P
><P
></P
><UL
><LI
><P
>Control transfer instructions hold addresses relative to the

Current Instruction Address (CIA), or use registers that hold the transfer

address. A CIA-relative branch computes its destination address in terms of

the CIA, not relative to any absolute address.</P
></LI
><LI
><P
>When the program requires an absolute address, it computes

the desired value. Instead of embedding absolute addresses in instructions

(in the text segment),  the compiler generates code to calculate an absolute

address (in a register or in the stack or data segment) during execution.&#13;</P
></LI
></UL
><P
>Because z/Architecture provides CIA-relative branch instructions and

also branch instructions using registers that hold the transfer address, compilers

can satisfy the first condition easily.</P
><P
>A Global Offset Table (GOT), provides information for address calculation.

Position-independent object files (executable and shared object files) have

a table in their data segment that holds addresses. When the system creates

the memory image for an object file, the table entries are relocated to reflect

the absolute virtual address as assigned for an individual process.  Because

data segments are private for each process, the table entries can change &#8211; unlike

text segments, which multiple processes share.</P
><P
>Two position-independent models give programs a choice between more

efficient code with some size restrictions and less efficient code without

those restrictions.  Because of the processor architecture, a GOT with no

more than 512 entries (4096 bytes) is more efficient than a larger one. Programs

that need more entries must use the larger, more general code. In the following

sections, the term "small model position-independent code" is used to refer

to code that assumes the smaller GOT, and "large model position-independent

code" is used to refer to the general code.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1137"
></A
>Function prolog and epilog</H2
><P
>This section describes the prolog and epilog code of functions . A function's

prolog establishes a stack frame, if necessary, and may save any nonvolatile

registers it uses. A function's epilog generally restores registers that were

saved in the prolog code, restores the previous stack frame, and returns to

the caller.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN1140"
></A
>Prolog</H3
><P
>The prolog of a function has to save the state of the calling function

and set up the base register for the code of the function body. The following

is in general done by the function prolog: <P
></P
><UL
><LI
><P
>Save all registers used within the function which the calling

function assumes to be non-volatile.</P
></LI
><LI
><P
>Set up the base register for the literal pool.</P
></LI
><LI
><P
>Allocate stack space by decrementing the stack pointer.</P
></LI
><LI
><P
>Set up the dynamic chain by storing the old stack pointer

value at stack location zero if the "back chain" is implemented.</P
></LI
><LI
><P
>Set up the GOT pointer if the compiler is generating position

independent code. </P
><P
>(A function that is position independent will probably want to load

a pointer to the GOT into a nonvolatile register. This may be omitted if the

function makes no external data references. If external data references are

only made within conditional code, loading the GOT pointer may be deferred

until it is known to be needed.)</P
></LI
><LI
><P
>Set up the frame pointer if the function allocates stack space

dynamically (with alloca).</P
></LI
></UL
></P
><P
>The compiler tries to do as little as possible of the above; the ideal

case is to do nothing at all (for a leaf function without symbolic references).&#13;</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN1158"
></A
>Epilog</H3
><P
>The epilog of a function restores the registers saved in the prolog

(which include the stack pointer) and branches to the return address.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN1161"
></A
>Prolog and epilog example</H3
><DIV
CLASS="FIGURE"
><A
NAME="PROLCODE"
></A
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1165"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>.section&nbsp;&nbsp;.rodata<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.align&nbsp;2<br>
<br>
.LC0:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.string&nbsp;"hello,&nbsp;world\n"<br>
<br>
.text<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.align&nbsp;4<br>
<br>
.globl&nbsp;&nbsp;&nbsp;&nbsp;main<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.type&nbsp;&nbsp;main,@function<br>
<br>
main:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Prolog<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STMG&nbsp;&nbsp;&nbsp;11,15,88(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Save&nbsp;callers&nbsp;registers<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;&nbsp;13,.LT0_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Load&nbsp;literal&nbsp;pool&nbsp;pointer<br>
<br>
.section&nbsp;&nbsp;.rodata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Switch&nbsp;for&nbsp;literal&nbsp;pool<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.align&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;to&nbsp;read-only&nbsp;data&nbsp;section<br>
<br>
.LT0_0:<br>
<br>
.LC2:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;&nbsp;65536<br>
<br>
.LTN0_0:<br>
<br>
.text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Back&nbsp;to&nbsp;text&nbsp;section<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGR&nbsp;&nbsp;&nbsp;&nbsp;1,15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Load&nbsp;stack&nbsp;pointer&nbsp;in&nbsp;GPR&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AGHI&nbsp;&nbsp;&nbsp;15,-160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Allocate&nbsp;stack&nbsp;space<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;&nbsp;1,0(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Store&nbsp;backchain<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Prolog&nbsp;end<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;&nbsp;2,.LC0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3,.LC2-.LT0_0(13)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRASL&nbsp;&nbsp;14,printf<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGHI&nbsp;&nbsp;&nbsp;2,0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Epilog<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4,272(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Load&nbsp;return&nbsp;address<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LMG&nbsp;&nbsp;&nbsp;&nbsp;11,15,248(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Restore&nbsp;registers<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Branch&nbsp;back&nbsp;to&nbsp;caller<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Epilog&nbsp;end</P
><P
></P
></DIV
><P
><B
>Figure 24. Prolog and epilog example</B
></P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1167"
></A
>Profiling</H2
><P
>This section shows a way of providing profiling (entry counting) on

zSeries systems. An ABI-conforming system is not required to provide profiling;

however if it does this is one possible (not required) implementation.</P
><P
>If a function is to be profiled it has to call the _mcount routine after

the function prolog. This routine has a special linkage. It gets an address

in register 1 and returns without having changed any register. The address

is a pointer to a word-aligned one-word static data area, initialized to zero,

in which the _mcount routine is to maintain a count of the number of times

the function is called.</P
><P
>For example <A
HREF="x1109.html#PROFCODE"
>Figure 25</A
> shows how the code after the function

prolog may look.</P
><DIV
CLASS="FIGURE"
><A
NAME="PROFCODE"
></A
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1175"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STMG&nbsp;&nbsp;&nbsp;&nbsp;7,15,56(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<br>
<br>
Save&nbsp;callers&nbsp;registers<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Stack&nbsp;pointer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AGHI&nbsp;&nbsp;&nbsp;&nbsp;15,-160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Allocate&nbsp;new<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,0(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Save&nbsp;backchain<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11,15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Local&nbsp;stack&nbsp;pointer<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.data<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.align&nbsp;4<br>
<br>
.LP0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Profile&nbsp;counter<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.text<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Function&nbsp;profiler<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;14,8(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Preserve&nbsp;r14<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,.LPO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Load&nbsp;address&nbsp;of&nbsp;profile&nbsp;counter<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRASL&nbsp;14,_mcount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Branch&nbsp;to&nbsp;_mcount<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;14,8(15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Restore&nbsp;r14</P
><P
></P
></DIV
><P
><B
>Figure 25. Code for profiling</B
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1177"
></A
>Data objects</H2
><P
>This section describes only objects with static storage duration. It

excludes stack-resident objects because programs always compute their virtual

addresses relative to the stack or frame pointers.</P
><P
>Because zSeries instructions cannot hold 64-bit addresses directly,

a program has to build an address in a register and access memory through

that register. In order to do so a function normally has a literal pool that

holds the addresses of data objects used by the function. Register 13 is set

up in the function prolog to point to the start of this literal pool.</P
><P
>Position-independent code cannot contain absolute addresses. In order

to access a local symbol the literal pool contains the (signed) offset of

the symbol relative to the start of the pool. Combining the offset loaded

from the literal pool with the address in register 13 gives the absolute address

of the local symbol. In the case of a global symbol the address of the symbol

has to be loaded from the Global Offset Table. The offset in the GOT can either

be contained in the instruction itself or in the literal pool. See <A
HREF="x1109.html#ADDRESSES"
>Figure 26</A
> for

an example.</P
><P
><A
HREF="x1109.html#ADDRESSES"
>Figure 26</A
> through <A
HREF="x1109.html#LARGEGOT"
>Figure 28</A
> show sample

assembly language equivalents to C language code for absolute and position-independent

compilations. It is assumed that all shared objects are compiled as position-independent

and only executable modules may have absolute addresses. The code in the figures

contains many redundant operations as it is only intended to show how each

C statement could have been compiled independently of its context. The function

prolog is not shown, and it is assumed that it has loaded the address of the

literal pool in register 13.</P
><DIV
CLASS="FIGURE"
><A
NAME="ADDRESSES"
></A
><A
NAME="AEN1188"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1189"
></A
><P
><B
>Table 15. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1204"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;int&nbsp;src;<br>
<br>
extern&nbsp;int&nbsp;dst;<br>
<br>
extern&nbsp;int&nbsp;*ptr;<br>
<br>
<br>
<br>
dst&nbsp;=&nbsp;src;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;&#38;dst;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
*ptr&nbsp;=&nbsp;src;</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1208"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,dst<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,src<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC&nbsp;&nbsp;&nbsp;0(4,1),0(2)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,ptr<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,dst<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;2,0(1)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,ptr<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,src<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC&nbsp;&nbsp;<br>
<br>
0(4,1),0(2)</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 26. Absolute addressing</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="SMALLGOT"
></A
><A
NAME="AEN1212"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1213"
></A
><P
><B
>Table 16. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1228"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;int&nbsp;src;<br>
<br>
extern&nbsp;int&nbsp;dst;<br>
<br>
extern&nbsp;int&nbsp;*ptr;<br>
<br>
<br>
<br>
dst&nbsp;=&nbsp;src;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;&#38;dst;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
*ptr&nbsp;=&nbsp;src;</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1232"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;12,_GLOBAL_OFFSET_TABLE_<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,dst@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,src@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGF&nbsp;&nbsp;&nbsp;3,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST&nbsp;&nbsp;&nbsp;&nbsp;3,0(1)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;12,_GLOBAL_OFFSET_TABLE_<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,ptr@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,dst@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;2,0(1)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;12,_GLOBAL_OFFSET_TABLE_<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,ptr@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,src@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGF&nbsp;&nbsp;&nbsp;3,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST&nbsp;&nbsp;&nbsp;<br>
<br>
3,0(1)</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 27. Small model position-independent addressing</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="LARGEGOT"
></A
><A
NAME="AEN1236"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1237"
></A
><P
><B
>Table 17. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries Assembler</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1252"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;int&nbsp;src;<br>
<br>
extern&nbsp;int&nbsp;dst;<br>
<br>
extern&nbsp;int&nbsp;*ptr;<br>
<br>
<br>
<br>
dst&nbsp;=&nbsp;src;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;&#38;dst;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
*ptr&nbsp;=&nbsp;src;</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1256"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,dst@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;3,src@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC&nbsp;&nbsp;&nbsp;0(4,2),0(3)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,ptr@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;3,dst@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;3,0(2)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,ptr@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;3,src@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC&nbsp;&nbsp;<br>
<br>
0(4,1),0(3)</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 28. Large model position-independent addressing</B
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1258"
></A
>Function calls</H2
><P
>Programs can use the z/Architecture BRASL  instruction to make direct

function calls. A BRASL instruction has a self-relative branch displacement

that can reach 4 GBytes in either direction. To call functions beyond this

limit (inter-module calls) load the address in a register and use the BASR

instruction for the call. Register 14 is used as the first operand of BASR

to hold the return address as shown in <A
HREF="x1109.html#FNCALLDIRECT"
>Figure 29</A
>.</P
><P
>The called function may be in the same module (executable or shared

object) as the caller, or it may be in a different module. In the former case,

if the called function is not in a shared object, the linkage editor resolves

the symbol. In all other cases the linkage editor cannot directly resolve

the symbol. Instead the linkage editor generates "glue" code and resolves

the symbol to point to the glue code. The dynamic linker will provide the

real address of the function in the Global Offset Table. The glue code loads

this address and branches to the function itself. See <A
HREF="x2233.html#PROCEDURELINKAGETABLE"
>the Section called <I
>Procedure Linkage Table</I
> in the chapter called <I
>Program loading and dynamic linking</I
></A
> for

more details.</P
><DIV
CLASS="FIGURE"
><A
NAME="FNCALLDIRECT"
></A
><A
NAME="AEN1266"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1267"
></A
><P
><B
>Table 18. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="38%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="62%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="38%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1282"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;void&nbsp;func();<br>
<br>
extern&nbsp;void&nbsp;(*ptr)();<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;func;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
func();<br>
<br>
<br>
<br>
(*ptr)&nbsp;();</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="62%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1286"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,ptr<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,func<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;2,0(1)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRASL&nbsp;14,func<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,ptr<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,0(1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BASR&nbsp;<br>
<br>
14,1</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 29. Absolute  function call</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="FNSMALLDIRECT"
></A
><A
NAME="AEN1290"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1291"
></A
><P
><B
>Table 19. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1306"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;void&nbsp;func();<br>
<br>
extern&nbsp;void&nbsp;(*ptr)();<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;func;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
func();<br>
<br>
<br>
<br>
(*ptr)&nbsp;();</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1310"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;12,_GLOBAL_OFFSET_TABLE_<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,ptr@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,func@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;2,0(1)<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRASL&nbsp;14,func@PLT<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;12,_GLOBAL_OFFSET_TABLE_<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,ptr@GOT12(12)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;1,0(1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BASR&nbsp;<br>
<br>
14,1</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 30. Small model position-independent  function call</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="FNLARGEDIRECT"
></A
><A
NAME="AEN1314"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1315"
></A
><P
><B
>Table 20. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1330"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>extern&nbsp;void&nbsp;func();<br>
<br>
extern&nbsp;void&nbsp;(*ptr)();<br>
<br>
<br>
<br>
ptr&nbsp;=&nbsp;func;<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
func();<br>
<br>
<br>
<br>
(*ptr)&nbsp;();</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1334"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
><br>
<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,ptr@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;3,func@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(3)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STG&nbsp;&nbsp;&nbsp;3,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRASL&nbsp;14,func@PLT<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;2,ptr@GOT<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;2,0(2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BASR&nbsp;<br>
<br>
14,2</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 31. Large model position-independent  function call</B
></P
></DIV
><P
></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1337"
></A
>Branching</H2
><P
>Programs use branch instructions to control their execution flow. z/Architecture

has a variety of branch instructions. The most commonly used of these performs

a self-relative jump with a 128-Kbyte range (up to 64 Kbytes in either direction).

For large functions another self-relative jump is available with a range of

4 Gbytes (up to 2 Gbytes in either direction).</P
><DIV
CLASS="FIGURE"
><A
NAME="BRANCHINSN"
></A
><A
NAME="AEN1342"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1343"
></A
><P
><B
>Table 21. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1358"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>label:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;label;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
farlabel:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;farlabel;</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1362"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>.L01:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRC&nbsp;15,.L01<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
.L02:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRCL<br>
<br>
15,.L02</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 32. Branch instruction</B
></P
></DIV
><P
></P
><P
>C language switch statements provide multi-way selection. When the case

labels of a switch statement satisfy grouping constraints the compiler implements

the selection with an address table. The following examples use several simplifying

conventions to hide irrelevant details:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The selection expression resides in register 2.</P
></LI
><LI
><P
>The case label constants begin at zero.</P
></LI
><LI
><P
>The case labels, the default, and the address table use assembly

names .Lcasei, .Ldef and .Ltab respectively.</P
></LI
></OL
><DIV
CLASS="FIGURE"
><A
NAME="ABSSWITCH"
></A
><A
NAME="AEN1375"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1376"
></A
><P
><B
>Table 22. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="37%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1391"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>switch(j)<br>
<br>
{<br>
<br>
case&nbsp;0:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
case&nbsp;1:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
case&nbsp;3:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
default:<br>
<br>
}</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="63%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1395"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGHI&nbsp;&nbsp;1,3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CLGR&nbsp;&nbsp;2,1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRC&nbsp;&nbsp;&nbsp;2,.Ldef<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SLLG&nbsp;&nbsp;2,2,3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,.Ltab<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(1,2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BR&nbsp;&nbsp;&nbsp;&nbsp;3<br>
<br>
.Ltab:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Lcase0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Lcase1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Ldef<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad<br>
<br>
.Lcase3</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 33. Absolute switch code</B
></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="INDSWITCH"
></A
><A
NAME="AEN1399"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="TABLE"
><A
NAME="AEN1400"
></A
><P
><B
>Table 23. </B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="36%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>C</P
></TH
><TH
WIDTH="64%"
ALIGN="LEFT"
VALIGN="TOP"
><P
>zSeries machine instructions (Assembler)&#13;</P
></TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="36%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1415"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>switch(j)<br>
<br>
{<br>
<br>
case&nbsp;0:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
case&nbsp;1:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
case&nbsp;3:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
<br>
default:<br>
<br>
}</P
><P
></P
></DIV
></P
></TD
><TD
WIDTH="64%"
ALIGN="LEFT"
VALIGN="TOP"
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1419"
></A
><P
></P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Literal<br>
<br>
pool<br>
<br>
.LT0:<br>
<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Code<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LGHI&nbsp;&nbsp;1,3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CLGR&nbsp;&nbsp;2,1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BRC&nbsp;&nbsp;&nbsp;2,.Ldef<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SLLG&nbsp;&nbsp;2,2,3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARL&nbsp;&nbsp;1,.Ltab<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LG&nbsp;&nbsp;&nbsp;&nbsp;3,0(1,2)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AGR&nbsp;&nbsp;&nbsp;3,13<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BR&nbsp;&nbsp;&nbsp;&nbsp;3<br>
<br>
.Ltab:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Lcase0-.LT0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Lcase1-.LT0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad&nbsp;.Ldef-.LT0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.quad<br>
<br>
.Lcase3-.LT0</P
><P
></P
></DIV
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></BLOCKQUOTE
><P
><B
>Figure 34. Position-independent switch code, all models</B
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DYNAMICSTACK"
></A
>Dynamic stack space allocation</H2
><P
>The GNU C compiler, and most recent compilers, support dynamic stack

space allocation via alloca.</P
><P
><A
HREF="x1109.html#DYNSTACKALLOC"
>Figure 35</A
> shows the stack frame before and after

dynamic stack allocation. The local variables area is used for storage of

function data, such as local variables, whose sizes are known to the compiler.

This area is allocated at function entry and does not change in size or position

during the function's activation.</P
><P
>The parameter list area holds "overflow" arguments passed in calls to

other functions. (See the OTHER label in <A
HREF="x392.html#PARAMETERPASSING"
>the Section called <I
>Parameter passing</I
></A
>.)

Its size is also known to the compiler and can be allocated along with the

fixed frame area at function entry. However, the standard calling sequence

requires that the parameter list area begin at a fixed offset (160) from the

stack pointer, so this area must move when dynamic stack allocation occurs.&#13;</P
><P
>Data in the parameter list area are naturally addressed at constant

offsets from the stack pointer. However, in the presence of dynamic stack

allocation, the offsets from the stack pointer to the data in the local variables

area are not constant. To provide addressability a frame pointer is established

to locate the local variables area consistently throughout the function's

activation.</P
><P
>Dynamic stack allocation is accomplished by "opening" the stack just

above the parameter list area. The following steps show the process in detail:&#13;</P
><P
></P
><OL
TYPE="1"
><LI
><P
>After a new stack frame is acquired, and before the first

dynamic space allocation, a new register, the frame pointer or FP, is set

to the value of the stack pointer. The frame pointer is used for references

to the function's local, non-static variables. The frame pointer does not

change during the execution of a function, even though the stack pointer may

change as a result of dynamic allocation.</P
></LI
><LI
><P
>The amount of dynamic space to be allocated is rounded up

to a multiple of 8 bytes, so that 8-byte stack alignment is maintained.</P
></LI
><LI
><P
>The stack pointer is decreased by the rounded byte count,

and the address of the previous stack frame (the back chain) may be stored

at the word addressed by the new stack pointer. The back chain is not necessary

to restore from this allocation at the end of the function since the frame

pointer can be used to restore the stack pointer.</P
></LI
></OL
><P
><A
HREF="x1109.html#DYNSTACKALLOC"
>Figure 35</A
> is a snapshot of the stack layout after

the prolog code has dynamically extended the stack frame.</P
><DIV
CLASS="FIGURE"
><A
NAME="DYNSTACKALLOC"
></A
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="pics/dynams64.png"></P
></DIV
><P
><B
>Figure 35. Dynamic Stack Space Allocation</B
></P
></DIV
><P
>The above process can be repeated as many times as desired within a

single function activation. When it is time to return, the stack pointer is

set to the value of the back chain, thereby removing all dynamically allocated

stack space along with the rest of the stack frame. Naturally, a program must

not reference the dynamically allocated stack area after it has been freed.&#13;</P
><P
>Even in the presence of signals, the above dynamic allocation scheme

is "safe." If a signal interrupts allocation, one of three things can happen:&#13;</P
><P
></P
><UL
><LI
><P
>The signal handler can return. The process then resumes the

dynamic allocation from the point of interruption.</P
></LI
><LI
><P
>The signal handler can execute a non-local goto or a jump.

This resets the process to a new context in a previous stack frame, automatically

discarding the dynamic allocation.</P
></LI
><LI
><P
>The process can terminate.</P
></LI
></UL
><P
>Regardless of when the signal arrives during dynamic allocation, the

result is a consistent (though possibly dead) process.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x877.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1454.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Process initialization</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c4.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>DWARF definition</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>