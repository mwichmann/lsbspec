<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Operating system interface</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="S/390 ELF Application Binary Interface Supplement"
HREF="book1.html"><LINK
REL="UP"
TITLE="Low-level system information"
HREF="c4.html"><LINK
REL="PREVIOUS"
TITLE="Function calling sequence"
HREF="x396.html"><LINK
REL="NEXT"
TITLE="Exception interface"
HREF="x834.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>S/390 ELF Application Binary Interface Supplement</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x396.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Low-level system information</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x834.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN794"
></A
>Operating system interface</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN796"
></A
>Virtual address space</H2
><P
>Processes execute in a 31-bit virtual address space. Memory management

translates virtual addresses to physical addresses, hiding physical addressing

and letting a process run anywhere in the system's real memory. Processes

typically begin with three logical segments, commonly called "text", "data"

and "stack". An object file may contain more segments (for example, for debugger

use), and a process can also create additional segments for itself with system

services.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The term "virtual address" as used in this document refers to a 31-bit

address generated by a program, as contrasted with the physical address to

which it is mapped.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN801"
></A
>Page size</H2
><P
>Memory is organized into pages, which are the system's smallest units

of memory allocation. The hardware page size for the ESA/390 architecture

is 4096 bytes.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN804"
></A
>Virtual address assignments</H2
><P
>Processes have the full 31-bit address space available to them.</P
><P
><A
HREF="x794.html#FIGVAC"
>Figure 19</A
> shows the virtual address configuration on the

S/390 architecture. The segments with different properties are typically grouped

in different areas of the address space. The loadable segments may begin at

zero (0); the exact addresses depend on the executable file format (see <A
HREF="c1668.html"
>the chapter called <I
>Object files</I
></A
> and <A
HREF="c2077.html"
>the chapter called <I
>Program loading and dynamic linking</I
></A
>). The process' stack

resides at the end of the virtual memory and grows downwards. Processes can

control the amount of virtual memory allotted for stack space, as described

below.</P
><DIV
CLASS="FIGURE"
><A
NAME="FIGVAC"
></A
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="pics/viradc32.png"></P
></DIV
><P
><B
>Figure 19. Virtual address configuration</B
></P
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Although application programs may begin at virtual address 0, they conventionally

begin above 0x1000 (4 Kbytes), leaving the initial 4 Kbytes with an invalid

address mapping. Processes that reference this invalid memory (for example

by de-referencing a null pointer) generate an translation exception as described

in <A
HREF="x834.html"
>the Section called <I
>Exception interface</I
></A
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Although applications may control their memory assignments, the typical

arrangement follows the diagram above. When applications let the system choose

addresses for dynamic segments (including shared object segments), the system

will prefer addresses in the upper half of the address space (above 1 Gbyte).&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN820"
></A
>Managing the process stack</H2
><P
>The section <A
HREF="x897.html"
>the Section called <I
>Process initialization</I
></A
> describes the initial stack contents.

Stack addresses can change from one system to the next &#8211; even from one

process execution to the next on a single system. A program, therefore, should

not depend on finding its stack at a particular virtual address.</P
><P
>A tunable configuration parameter controls the system maximum stack

size. A process can also use setrlimit to set its own maximum stack size,

up to the system limit. The stack segment is both readable and writable.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN825"
></A
>Coding guidelines</H2
><P
>Operating system facilities, such as mmap, allow a process to establish

address mappings in two ways. Firstly, the program can let the system choose

an address. Secondly, the program can request the system to use an address

the program supplies. The second alternative can cause application portability

problems because the requested address might not always be available. Differences

in virtual address space can be particularly troublesome between different

architectures, but the same problems can arise within a single architecture.&#13;</P
><P
>Processes' address spaces typically have three segments that can change

size from one execution to the next: the stack (through setrlimit); the data

segment (through malloc); and the dynamic segment area (through mmap).  Changes

in one area may affect the virtual addresses available for another. Consequently

an address that is available in one process execution might not be available

in the next. Thus a program that used mmap to request a mapping at a specific

address could appear to work in some environments and fail in others. For

this reason programs that want to establish a mapping in their address space

should let the system choose the address.</P
><P
>Despite these warnings about requesting specific addresses the facility

can be used properly.  For example, a multiprocess application might map several

files into the address space of each process and build relative pointers among

the files' data.  This could be done by having each process ask for a certain

amount of memory at an address chosen by the system.  After each process receives

its own private address from the system it would map the desired files into

memory at specific addresses within the original area.  This collection of

mappings could be at different addresses in each process but their relative

positions would be fixed.  Without the ability to ask for specific addresses,

the application could not build shared data structures because the relative

positions for files in each process would be unpredictable.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN830"
></A
>Processor execution modes</H2
><P
>Two execution modes exist in the ESA/390 architecture: problem (user)

state and supervisor state. Processes run in problem state (the less privileged).

 The operating system kernel runs in supervisor state.  A program executes

an supervisor call (svc) instruction to change execution modes.</P
><P
>Note that the ABI does not define the implementation of individual system

calls. Instead programs shall use the system libraries. Programs with embedded

system call or trap instructions do not conform to the ABI.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x396.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x834.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Function calling sequence</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c4.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Exception interface</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>