<!DOCTYPE IBMIDDOC PUBLIC "+//ISBN 0-933186::IBM//DTD IBMIDDoc//EN" [
<!--ArborText, Inc., 1988-2001, v.4002-->
<!ENTITY ibmboil SYSTEM "ibmboil.ide">
<!ENTITY notices SYSTEM "notices.ide">
<!ENTITY % lzsabi SYSTEM "lzsabi.ent">
<!ENTITY % l390abi SYSTEM "l390abi.ent">
%lzsabi;
<!ENTITY LITHBATPART "XXX-1234">
<!ENTITY e1d9saft SYSTEM "e1d9saft.eps" NDATA graphics>
<!ENTITY b0000 SYSTEM "another.idd" NDATA sgmldoc>
<!ENTITY doc "IBMIDDoc">
<!ENTITY ed "Adept">
]>
<?Pub UDT _bookmark _target>
<?Pub EntList alpha sect tm regtm ndash rbl>
<?Pub Inc>
<ibmiddoc ibmcopyr="2001, 2002" style="IBMXAGD">
<prolog><ibmbibentry><doctitle>
<library><titleblk>
<title>&linuxs; for <ph props="64bit">&system64;</ph><ph props="#NOT 64bit">
&system32;</ph></title>
</titleblk></library>
<titleblk>
<title>ELF Application Binary Interface
Supplement<ph props="comment">

 &ndash; 25.07.2001</ph></title>
<stitle>&linuxs; for <ph props="64bit">&system64;</ph><ph props="#NOT 64bit">
&system32;</ph>: ELF ABI Supplement<ph props="comment"> &ndash; 25.07.2001
</ph></stitle>
</titleblk></doctitle>
<ibmdocnum>LNUX-<ph props="64bit">1107</ph><ph props="#NOT 64bit">1007</ph>-02
</ibmdocnum>
</ibmbibentry>
<revdefs>
<rev id="v1r4" ident="use">
<date>25.7.2001</date>
<desc>Incorrect figure in 31 bit version</desc></rev>
<rev id="v1r3" ident="ignore">
<date>29.3.2001</date>
<desc>Correction to register use</desc></rev>
<rev id="v1r2" ident="ignore">
<date>9.3.2001</date>
<desc>Revision following 8.3.2001 inspection</desc></rev>
<rev id="v1r1" ident="ignore">
<date>27.2.2001</date>
<desc>Clarifications</desc></rev>
<rev id="v0r2" ident="ignore">
<date>14.2.2001</date>
<desc>Revision following 13.2.2001 inspection</desc></rev>
<rev id="v0r1" ident="ignore">
<date>9.2.2001</date>
<desc>Revision following 8.2.2001 inspection</desc></rev>
<rev id="v0r0" ident="ignore">
<date>1.1.2001</date>
<desc>Split zSeries from S/390</desc></rev>
</revdefs>
<maintainer>
<!--This generates reader comment pages.-->
<corp>
<corpname>IBM CORPORATION</corpname>
<address>Attn: &linuxs; for <ph props="64bit">&system64;</ph><ph props="#NOT 64bit">
&system32;</ph>
6300 Diagonal Highway
Boulder, CO, USA
<postalcode>80301-9151</postalcode><phone equip="fax"></phone><phone equip="fax"></phone><ibmmail></ibmmail><internet></internet><vnet></vnet></address>
</corp></maintainer>
<critdates>
<critdate>
<date>&date;</date>
<desc>Processing date</desc></critdate>
</critdates>
<propdefs>
<!--Common IBM phrase classes.-->
<classdef classname="ibmcommand" eletypes="ph" style="bold"><sem>Command names.
For example: COPY command</sem></classdef>
<classdef classname="ibmemphasis" eletypes="ph" style="italic"><sem>Text the
writer wants to emphasize.</sem></classdef>
<classdef classname="ibmfilepath" eletypes="ph"><sem>File path names. For
example: c:\config.sys</sem></classdef>
<classdef classname="ibmguicontrol" eletypes="ph" style="bold"><sem>GUI control
names: menu names, menu choices, entry fields, icons, folders. list boxes,
push buttons, radio buttons, spin buttons, or check boxes; NOT: windows or
notebooks.</sem></classdef>
<classdef classname="compact" eletypes="ol ul dl parml notelist" id="complist"
style="BKM:(compact) IPF:(compact)"><sem>Compact lists. Specify class=compact
to get a compact list.</sem></classdef>
<propdef propname="colfig" eletypes="fig" style="bkm:(width=column place=inline)">
<desc>basic   colfig</desc></propdef>
<propdef propname="colfigzs" eletypes="fig" props="64bit" style="bkm:(width=column place=inline)">
<desc>zSeries colfig</desc></propdef>
<propdef propname="colfig390" eletypes="fig" props="#NOT 64bit" style="bkm:(width=column place=inline)">
<desc>S/390   colfig</desc></propdef>
<propdef propname="zser" props="64bit" rev="v0r0"><desc>zSeries    flag</desc>
</propdef>
<propdef propname="s390" props="#NOT 64bit"><desc>System 390 flag</desc></propdef>
</propdefs>
<qualifdefs>
<qualif id="cdpi3" ident="use"><title><?Pub _bookmark Command="qdef">NOT Programming
Interface information</title><desc>CDPI Classification Number 3</desc></qualif>
<qualif id="cdpi4" ident="use"><title>Programming Interface information</title>
<desc>CDPI Classification Number 4</desc></qualif>
</qualifdefs>
<ldescs>
<!--Cross-book link to book "b0000". From link "l1" to heading ID "heading"-->
<nameloc id="l1" objtype="head">
<nmlist></nmlist>
</nameloc>
</ldescs>
<bibentrydefs>
<!--Book "b0000" is declared as a 'graphic' entity with a notation of 'sgmldoc'-->
<ibmbibentry id="b0000"><doctitle><titleblk><title>&linuxs; for <ph props="64bit">
&system64;</ph><ph props="#NOT 64bit">&system32;</ph>: ELF Application Binary
Interface Supplement</title></titleblk></doctitle>
<ibmdocnum>LNUX&ndash;1009</ibmdocnum>
</ibmbibentry><ibmbibentry id="b0001"><doctitle><titleblk><title>z/Architecture
Principles of Operation</title></titleblk></doctitle>
<ibmdocnum>SA22&ndash;7832</ibmdocnum>
</ibmbibentry><ibmbibentry id="b0002"><doctitle><titleblk><title>ESA/390 Principles
of Operation</title></titleblk></doctitle>
<ibmdocnum>SA22&ndash;7201</ibmdocnum>
</ibmbibentry><ibmbibentry id="b0003"><doctitle><titleblk><title>System V
Application Binary Interface</title></titleblk></doctitle></ibmbibentry></bibentrydefs>
<objlib>
<objlibbody><p id="mypara">Here's a sample paragraph I want to use more than
once.</p>             <!--The IBMBOIL entity contains boilerplate text to be used as-is.
Paragraph blocks (PBLKs) and divisions contain CONLOC attributes the pull
in this boilerplate text.-->&ibmboil;</objlibbody>
</objlib>
</prolog>
<frontm style="display='cover'">
<notices>
<pblk style="lblbox"><title>Note</title>
<p>Before using this information and the product it supports, read the information
in <xref refid="notices">.</p>
</pblk>
</notices>
<ednotices><title>Edition 1.01 (July 2001)</title>
<!--Include the following line for first editions, or as required by your
library. However, if the same documentation supports multiple products or
multiple releases, you do not need to include this line.-->
<p>This edition applies to version 2, release 2, modification 16 of the &linuxs; kernel
and to all subsequent releases and modifications until otherwise indicated
in new editions.</p>
<!--Include the following line for second, or later, editions as required
by, or as applicable to, your library.-->
<p>This edition replaces LNUX-<ph props="64bit">1107</ph><ph props="#NOT 64bit">
1007</ph>-01.</p>
<!--Include the following line only if you must give more than one copyright
attribution. (For example, when IBM purchases or licenses a product from another
company, IBM may be required to give copyright attribution to the other company.
If applicable, consult with your local IPL group. Also refer to IBM Corporate
Standard C-S 0-6045 "Proprietary Protection for IBM Materials (Including Copyrights)"
for the specific statements and for the location of these statements in object,
source, or licensed information.-->
<p props="comment"><?Pub Dtl> &copyr;Copyright OtherCompanyName, Inc. 2000
</p>
<!--The copyright date is gathered from the IBMIDDoc tag's IBMCOPYR attribute;
fill that in with the year for the first year "2000". For two years, fill
in "1997, 2000".-->
<p props="LSB">Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License, Version 1.1;
with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the section entitled "GNU Free
Documentation License".</p>
</ednotices>
<toc>
<gendtitle></toc>
<figlist><gendtitle></figlist>
<tlist><gendtitle></tlist>
<preface>
<!--Describe what this manual covers-->
<specdprolog><titleblk>
<title>About this book</title>
</titleblk></specdprolog><dbody>
<p>The <ph propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph>&regtm; supplement
to the Executable and Linkage Format Application Binary Interface (or ELF
ABI), defines a system interface for compiled application programs. Its purpose
is to establish a standard binary interface for application programs on &linuxs;&regtm; for <ph
propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph> systems.
</p>
<d>
<dprolog><titleblk>
<title>Who should read this book</title>
</titleblk></dprolog>
<dbody>
<annot props="comment">
<annotbody>Describe the intended audience (do not use job titles) and what
the reader is assumed to already know. This knowledge might be as general
as being familiar with the system, display, keyboard, and printers, or as
specific as being familiar with certain aspects of a product.</annotbody>
</annot>
<p>This book should be read by application programmers who wish to write programs
that will install and run on any system compliant with the System V ABI, and
by system programmers who wish to make their systems so compliant.</p>
</dbody></d>
<d props="comment">
<dprolog><titleblk>
<title>Conventions and terminology used in this book</title>
</titleblk></dprolog>
<dbody>
<annot props="comment">
<annotbody>Explain any special style conventions, terminology, notices, or
presentation techniques that are used in the publication, such as naming conventions
particular to some programming languages, unique terms, or the significance
of italics.</annotbody>
</annot>
</dbody></d>
<d props="comment">
<dprolog><titleblk>
<title>How to read syntax diagrams</title>
</titleblk></dprolog>
<dbody>
<annot props="comment">
<annotbody>Explain any special style conventions with regard to syntax diagrams.
For large references, this information can be in the first chapter.</annotbody>
</annot>
</dbody></d>
<d><?Pub Dtl>
<dprolog><titleblk>
<title>Prerequisite and related information</title>
</titleblk></dprolog>
<dbody>
<!--Be sure to separate required reading and related information. Include the title and order number of all IBM publications.  If only parts of the listed prerequisites are required reading, name the specific subjects. If your book has a bibliography, instead of listing the publications here, refer to the bibliography.-->
<p rev="v0r1">This book is a supplement to the generic "System V Application
Binary Interface" and should be read in conjunction with it.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>How to send your comments</title>
</titleblk></dprolog>
<dbody>
<!--Use this section to get feedback on books. If you use more than one method to get feedback, change the wording accordingly.-->
<p>Your feedback is important in helping to provide the most accurate and
high-quality information. If you have any comments about this book or any
other &linuxs; for <ph props="64bit">&system64;</ph><ph props="#NOT 64bit">
&system32;</ph> documentation:<ul>
<li>Go to the &linuxs; for <ph props="64bit">&system64;</ph><ph props="#NOT 64bit">
&system32;</ph> home page at:              <!--Use "our," "the IBM," or whatever is most appropriate.--><p>
http://www.s390.ibm.com/linux/</p><p>There you will find the feedback page
where you can enter and submit your comments.</p></li>
<li>Send your comments by e-mail to linux390@de.ibm.com. Be sure to include
the name of the book, the part number of the book, the version of &linuxs; you
are using, and, if applicable, the specific location of the text you are commenting
on (for example, a page number or table number).</li>
<li>There may be a comment form at the back of this book. Fill out a copy
and return it by mail or by fax or give it to an IBM representative.</li>
</ul></p>
</dbody></d>
</dbody></preface>
<soa>
<!--Summary of changes section-->
<specdprolog><titleblk>
<title>Summary of changes</title>
</titleblk></specdprolog><dbody>
<p>Changes to this information for this edition include:<ul>
<li>Correction to addressing in <xref refid="pimgseg">.</li>
<li props="comment">Register usage correction.</li>
</ul></p>
</dbody></soa>
</frontm>
<body>
<d>
<dprolog><titleblk>
<title>Low-level system information</title>
</titleblk></dprolog>
<dintro><toc><gendtitle></toc></dintro>
<?xpp:page>
<dbody>
<d>
<dprolog><titleblk>
<title>Machine interface</title>
</titleblk></dprolog>
<dbody>
<p>This section describes the processor-specific information for the <ph propsrc="zser">
&system64;</ph><ph propsrc="s390">&system32;</ph> processors.</p>
<d>
<dprolog><titleblk>
<title>Processor architecture</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>Principles of Operation</idxterm></i1>
<p propsrc="zser"><cit><ibmbibentry><doctitle><titleblk><title>z/Architecture
Principles of Operation</title></titleblk></doctitle>
<ibmdocnum>SA22&ndash;7832</ibmdocnum>
</ibmbibentry></cit> (SA22&ndash;7832) defines the &system64; architecture.
</p>
<p propsrc="s390"><cit><ibmbibentry><doctitle><titleblk><title>ESA/390 Principles
of Operation</title></titleblk></doctitle>
<ibmdocnum>SA22&ndash;7201</ibmdocnum>
</ibmbibentry></cit> (SA22&ndash;7201) defines the ESA/390 architecture.</p>
<p>Programs intended to execute directly on the processor use the <ph propsrc="zser">
&system64;</ph><ph propsrc="s390">ESA/390</ph> instruction set, and the instruction
encoding and semantics of the architecture.</p>
<p>An application program can assume that all instructions defined by the
architecture that are neither privileged nor optional exist and work as documented.
</p>
<p>To be ABI-conforming the processor must implement the instructions of the
architecture, perform the specified operations, and produce the expected results.
The ABI neither places performance constraints on systems nor specifies what
instructions must be implemented in hardware. A software emulation of the
architecture could conform to the ABI.</p>
<p propsrc="s390">There are some instructions in the ESA/390 architecture
which are described as 'optional'. &linuxs; for &system32; requires some of
these to be available; in particular:</p>
<ul propsrc="s390">
<li>additional floating point facilities,</li>
<li props="comment" rev="v0r2">checksum instruction,</li>
<li>compare and move extended,</li>
<li>immediate and relative instructions,</li>
<li props="comment" rev="v0r2">square root,</li>
<li>string instructions.</li>
</ul>
<p propsrc="s390"><ph rev="v0r2">The ABI guarantees that these instructions
are present. In order to comply with the ABI the operating system must emulate
these instructions on machines which do not support them in the hardware.
</ph> Other instructions are not available in some current models; programs
using these instructions do not conform to the &system32; ABI and executing
them on machines without the extra capabilities will result in undefined behavior.
</p>
<p>In <ph propsrc="zser">z/Architecture</ph><ph propsrc="s390">the ESA/390
architecture</ph> a processor runs in big-endian mode.<i1><idxterm>big-endian
</idxterm></i1> (See <xref refid="byteordering">.) </p>
</dbody></d>
<?xpp:page>
<d>
<dprolog><titleblk>
<title>Data representation</title>
</titleblk></dprolog>
<dbody>
<d id="byteordering">
<dprolog><titleblk>
<title>Byte ordering</title>
</titleblk></dprolog>
<dbody>
<p>The architecture defines an 8-bit byte, a 16-bit halfword, a 32-bit word<ph
propsrc="s390"> and a 64-bit doubleword</ph><ph propsrc="zser">, a 64-bit
doubleword and a 128-bit quadword</ph>. Byte ordering defines how the bytes
that make up halfwords, words<ph propsrc="s390"> and doublewords</ph><ph propsrc="zser">
, doublewords and quadwords</ph> are ordered in memory. Most significant byte
(MSB) ordering, or "Big-Endian"<i1><idxterm>big-endian</idxterm></i1> as it
is sometimes called, means that the most significant byte of a structure is
located in the lowest addressed byte position in a storage unit (byte 0).
</p>
<p><xref refid="halfword" form="locnum"> to <xref refid="doublewords" form="locnum"
propsrc="s390"><xref refid="quadwords" form="locnum" propsrc="zser"> illustrate
the conventions for bit and byte numbering within storage units of various
widths. These conventions apply to both integer data and floating-point data,
where the most significant byte of a floating-point value holds the sign and
the exponent (or at least the start of the exponent). The figures show <ph
props="comment">little-endian byte numbers in the upper right corners, </ph>big-endian
byte numbers in the upper left corners and bit numbers in the lower corners.
</p>
<fig frame="none" id="halfword" propsrc="colfig"><cap>Bit and byte numbering
in halfwords</cap>
<mmobj><objref obj="halfwrd">
<i1><idxterm>halfword byte ordering</idxterm></i1>
<i1><idxterm>byte ordering</idxterm><i2><idxterm>halfword</idxterm></i2></i1>
<textalt><p><xmp>------------------------------
| 0            | 1           |
|     msb      |     lsb     |
| 0          7 | 8        15 |
------------------------------</xmp></p></textalt></mmobj>
</fig>
<fig frame="none" id="words" propsrc="colfig"><cap>Bit and byte numbering
in words</cap>
<mmobj><objref obj="word">
<i1><idxterm>word byte ordering</idxterm></i1>
<i1><idxterm>byte ordering</idxterm><i2><idxterm>word</idxterm></i2></i1>
<textalt><p><xmp>------------------------------------------------------------
| 0            | 1           | 2             | 3           |
|     msb      |             |               |     lsb     |
| 0          7 | 8        15 | 16         23 | 24       31 |
------------------------------------------------------------</xmp></p></textalt>
</mmobj>
</fig>
<fig frame="none" id="doublewords" propsrc="colfig"><cap>Bit and byte numbering
in doublewords</cap>
<mmobj><objref obj="dblword">
<i1><idxterm>doubleword byte ordering</idxterm></i1>
<i1><idxterm>byte ordering</idxterm><i2><idxterm>doubleword</idxterm></i2>
</i1>
<textalt><p><xmp>------------------------------------------------------------
| 0            | 1           | 2             | 3           |
|     msb      |             |               |             |
| 0          7 | 8        15 | 16         23 | 24       31 |
------------------------------------------------------------
| 4            | 5           | 6             | 7           |
|              |             |               |     lsb     |
| 32        39 | 40       47 | 48         55 | 56       63 |
------------------------------------------------------------</xmp></p></textalt>
</mmobj>
</fig>
<fig frame="none" id="quadwords" propsrc="colfigzs"><cap>Bit and byte numbering
in quadwords</cap>
<mmobj><objref obj="quadword">
<i1><idxterm>quadword byte ordering</idxterm></i1>
<i1><idxterm>byte ordering</idxterm><i2><idxterm>quadword</idxterm></i2></i1>
<textalt><p><xmp>------------------------------------------------------------
| 0            | 1           | 2             | 3           |
|     msb      |             |               |             |
| 0          7 | 8        15 | 16         23 | 24       31 |
------------------------------------------------------------
| 4            | 5           | 6             | 7           |
|              |             |               |             |
| 32        39 | 40       47 | 48         55 | 56       63 |
------------------------------------------------------------
| 8            | 9           | 10            | 11          |
|              |             |               |             |
| 64        71 | 72       79 | 80         87 | 88       95 |
------------------------------------------------------------
| 12           | 13          | 14            | 15          |
|              |             |               |     lsb     |
| 96       103 | 104     111 | 112       119 | 120     127 |
------------------------------------------------------------</xmp></p></textalt>
</mmobj>
</fig>
</dbody></d>
<?xpp:page>
<d>
<dprolog><titleblk>
<title>Fundamental types</title>
</titleblk></dprolog>
<dbody>
<p><xref refid="scalar"> shows how ANSI C scalar types correspond to those
of the <ph propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph> processor.
For all types a NULL pointer has the value zero (binary).</p>
<i1><idxterm>signed char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed char</idxterm></i2></i1>
<i1><idxterm>char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>char</idxterm></i2></i1>
<i1><idxterm>unsigned char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm> unsigned char</idxterm></i2></i1>
<i1><idxterm>short type</idxterm></i1>
<i1><idxterm> type</idxterm><i2><idxterm>short</idxterm></i2></i1>
<i1><idxterm>signed short type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed short</idxterm></i2></i1>
<i1><idxterm>unsigned short type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned short</idxterm></i2></i1>
<i1><idxterm>signed int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed int</idxterm></i2></i1>
<i1><idxterm>int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>int</idxterm></i2></i1>
<i1><idxterm>enum type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>enum</idxterm></i2></i1>
<i1><idxterm>unsigned int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned int</idxterm></i2></i1>
<i1><idxterm>signed long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed long</idxterm></i2></i1>
<i1><idxterm>long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>long</idxterm></i2></i1>
<i1><idxterm>unsigned long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned long</idxterm></i2></i1>
<i1><idxterm>long long type</idxterm></i1>
<i1><idxterm> type</idxterm><i2><idxterm>long long</idxterm></i2></i1>
<i1><idxterm>signed long long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed long long</idxterm></i2></i1>
<i1><idxterm>unsigned long long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned long long</idxterm></i2>
</i1>
<i1><idxterm>pointer type</idxterm></i1>
<i1><idxterm> type</idxterm><i2><idxterm>pointer</idxterm></i2></i1>
<i1><idxterm>floating point type</idxterm></i1>
<i1><idxterm> type</idxterm><i2><idxterm>floating point</idxterm></i2></i1>
<table id="scalar" propsrc="s390"><cap>Scalar types</cap>
<tgroup cols="5">
<?PubTbl tgroup dispwid="7.96in">
<colspec colname="col1" colwidth="66*">
<colspec colname="col2" colwidth="94*">
<colspec colname="col3" colwidth="59*">
<colspec colname="col4" colwidth="64*">
<colspec colname="col5" colwidth="84*">
<thead>
<row>
<entry colname="col1" valign="middle">Type</entry>
<entry colname="col2" valign="middle">ANSI C</entry>
<entry colname="col3" valign="middle">sizeof (bytes)</entry>
<entry colname="col4" valign="middle">Alignment</entry>
<entry colname="col5" valign="middle">type (&system32;)</entry>
</row>
</thead>
<tfoot>
<row>
<entry namest="col1" nameend="col5" valign="top">&sup1;Compilers and systems
may implement the long double data type in some other way, for performance
reasons, using a compiler option. Examples of such formats could be two successive
doubles or even a single double. Such usage does not conform to this ABI however,
and runs the risk of passing a wrongly formatted floating-point number to
another function as an argument. <ph rev="v0r1">Programs using other formats
should transform long double floating-point numbers to a conforming format
before passing them.</ph></entry>
</row>
</tfoot>
<tbody>
<row>
<entry colname="col1" valign="middle">Character </entry>
<entry colname="col2" valign="middle"><xmp>signed char
char
unsigned char</xmp></entry>
<entry colname="col3" valign="middle">1</entry>
<entry colname="col4" valign="middle">1</entry>
<entry colname="col5" valign="middle">byte</entry>
</row>
<row>
<entry colname="col1" valign="middle">Short </entry>
<entry colname="col2" valign="middle"><xmp>signed short
short
unsigned short</xmp></entry>
<entry colname="col3" valign="middle">2</entry>
<entry colname="col4" valign="middle">2</entry>
<entry colname="col5" valign="middle">halfword</entry>
</row>
<row>
<entry colname="col1" valign="middle">Integer </entry>
<entry colname="col2" valign="middle"><xmp>signed int
int
unsigned int
enum
signed long
long
unsigned long</xmp></entry>
<entry colname="col3" valign="middle">4</entry>
<entry colname="col4" valign="middle">4</entry>
<entry colname="col5" valign="middle">word</entry>
</row>
<row>
<entry colname="col1" valign="middle">Long long </entry>
<entry colname="col2" valign="middle"><xmp>signed long long
long long
unsigned long long</xmp></entry>
<entry colname="col3" valign="middle">8</entry>
<entry colname="col4" valign="middle">8</entry>
<entry colname="col5" valign="middle">doubleword</entry>
</row>
<row>
<entry colname="col1" valign="middle">Pointer </entry>
<entry colname="col2" valign="middle"><xmp>any-type *
any-type (*) ()</xmp></entry>
<entry colname="col3" valign="middle">4</entry>
<entry colname="col4" valign="middle">4</entry>
<entry colname="col5" valign="middle">unsigned word</entry>
</row>
<row>
<entry colname="col1" morerows="2" valign="middle">Floating point </entry>
<entry colname="col2" valign="middle"><xmp>float</xmp></entry>
<entry colname="col3" valign="middle">4</entry>
<entry colname="col4" valign="middle">4</entry>
<entry colname="col5" valign="middle">single precision (IEEE)</entry>
</row>
<row>
<entry colname="col2" valign="middle"><xmp>double</xmp></entry>
<entry colname="col3" valign="middle">8</entry>
<entry colname="col4" valign="middle">8</entry>
<entry colname="col5" valign="middle">double precision (IEEE)</entry>
</row>
<row>
<entry colname="col2" valign="middle"><xmp>long double&sup1;</xmp></entry>
<entry colname="col3" valign="middle">16</entry>
<entry colname="col4" valign="middle">16</entry>
<entry colname="col5" valign="middle">extended precision (IEEE)</entry>
</row>
</tbody>
</tgroup>
</table>
<table id="scalar" propsrc="zser" rev="v1r2"><cap>Scalar types</cap>
<tgroup cols="5">
<?PubTbl tgroup dispwid="8.00in">
<colspec colname="col1" colwidth="72*">
<colspec colname="col2" colwidth="93*">
<colspec colname="col3" colwidth="62*">
<colspec colname="col4" colwidth="65*">
<colspec colname="col5" colwidth="88*">
<thead>
<row>
<entry colname="col1" valign="middle">Type</entry>
<entry colname="col2" valign="middle">ANSI C</entry>
<entry colname="col3" valign="middle">sizeof (bytes)</entry>
<entry colname="col4" valign="middle">Alignment</entry>
<entry colname="col5" valign="middle">type (&system64;)</entry>
</row>
</thead>
<tfoot>
<row>
<entry namest="col1" nameend="col5" valign="top">&sup1;Compilers and systems
may implement the long double data type in some other way, for performance
reasons, using a compiler option. Examples of such formats could be two successive
doubles or even a single double. Such usage does not conform to this ABI however,
and runs the risk of passing a wrongly formatted floating-point number to
another function as an argument. <ph rev="v0r1">Programs using other formats
should transform long double floating-point numbers to a conforming format
before passing them.</ph></entry>
</row>
</tfoot>
<tbody>
<row>
<entry colname="col1" valign="middle">Character</entry>
<entry colname="col2" valign="middle"><xmp>signed char
char
unsigned char</xmp></entry>
<entry colname="col3" valign="middle">1</entry>
<entry colname="col4" valign="middle">1</entry>
<entry colname="col5" valign="middle">byte</entry>
</row>
<row>
<entry colname="col1" valign="middle">Short</entry>
<entry colname="col2" valign="middle"><xmp>signed short
short
unsigned short</xmp></entry>
<entry colname="col3" valign="middle">2</entry>
<entry colname="col4" valign="middle">2</entry>
<entry colname="col5" valign="middle">halfword</entry>
</row>
<row>
<entry colname="col1" valign="middle">Integer</entry>
<entry colname="col2" valign="middle"><xmp>signed int
int
unsigned int
enum</xmp></entry>
<entry colname="col3" valign="middle">4</entry>
<entry colname="col4" valign="middle">4</entry>
<entry colname="col5" valign="middle">word</entry>
</row>
<row>
<entry colname="col1" valign="middle"><p>Long</p> <p>Long long</p></entry>
<entry colname="col2" valign="middle"><xmp>signed long
long
unsigned long
signed long long
long long
unsigned long long</xmp></entry>
<entry colname="col3" valign="middle">8</entry>
<entry colname="col4" valign="middle">8</entry>
<entry colname="col5" valign="middle">doubleword</entry>
</row>
<row>
<entry colname="col1" valign="middle">Pointer</entry>
<entry colname="col2" valign="middle"><xmp>any-type *
any-type (*) ()</xmp></entry>
<entry colname="col3" valign="middle"><ph props="comment" rev="v1r2">4</ph><ph
rev="v1r2">8</ph></entry>
<entry colname="col4" valign="middle"><ph props="comment" rev="v1r2">4</ph><ph
rev="v1r2">8</ph></entry>
<entry colname="col5" valign="middle">unsigned <ph props="comment" rev="v1r2">
 word</ph><ph rev="v1r2"> doubleword</ph></entry>
</row>
<row>
<entry colname="col1" morerows="2" valign="middle">Floating point</entry>
<entry colname="col2" valign="middle"><xmp>float</xmp></entry>
<entry colname="col3" valign="middle">4</entry>
<entry colname="col4" valign="middle">4</entry>
<entry colname="col5" valign="middle">single precision (IEEE)</entry>
</row>
<row>
<entry colname="col2" valign="middle"><xmp>double</xmp></entry>
<entry colname="col3" valign="middle">8</entry>
<entry colname="col4" valign="middle">8</entry>
<entry colname="col5" valign="middle">double precision (IEEE)</entry>
</row>
<row>
<entry colname="col2" valign="middle"><xmp>long double&sup1;</xmp></entry>
<entry colname="col3" valign="middle">16</entry>
<entry colname="col4" valign="middle">16</entry>
<entry colname="col5" valign="middle">extended precision (IEEE)</entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Aggregates and unions</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>structures</idxterm></i1>
<i1><idxterm>arrays</idxterm></i1>
<i1><idxterm>aggregates</idxterm></i1>
<i1><idxterm>unions</idxterm></i1>
<p>Aggregates (structures and arrays) and unions assume the alignment of their
most strictly aligned component, that is, the component with the largest alignment.
The size of any object, including aggregates and unions, is always a multiple
of the alignment of the object. An array uses the same alignment as its elements.
Structure and union objects may require padding to meet size and alignment
constraints:</p>
<ul>
<li>An entire structure or union object is aligned on the same boundary as
its most strictly aligned member.</li>
<li>Each member is assigned to the lowest available offset with the appropriate
alignment. This may require internal padding, depending on the previous member.
</li>
<li>If necessary, a structure's size is increased to make it a multiple of
the structure's alignment. This may require tail padding if the last member
does not end on the appropriate boundary.</li>
</ul>
<p>In the following examples (<xref refid="struct1" form="text"> to <xref
refid="struct5" form="text">), member byte offsets (for the big-endian implementation)
appear in the upper left corners.</p>
<fig frame="box" id="struct1" propsrc="colfig"><cap>Structure smaller than
a word</cap>
<p><table frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.27in">
<colspec colname="col1" colwidth="85*">
<colspec colname="col2" colwidth="113*">
<tbody>
<row>
<entry colname="col1"><xmp>struct &lbrace;
         char c;
&rbrace;;

</xmp></entry>
<entry colname="col2"><mmobj><objref obj="strctsmall" depth="1.5cm"><textalt><p><xmp>
Byte aligned, sizeof is 1
|--------------|
| 0            |
|              |
|       c      |
|--------------|

</xmp></p></textalt></mmobj></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig frame="box" id="struct2" propsrc="colfig"><cap>No padding</cap>
<p><table frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<?PubTbl tgroup dispwid="11.13in">
<colspec colnum="1" colname="col1" colwidth="63*">
<colspec colnum="2" colname="col2" align="left" charoff="50" char="" colwidth="135*">
<tbody>
<row>
<entry colname="col1"><xmp propsrc="s390">struct &lbrace;
         char c;
         char d;
         short s;
         long n;
&rbrace;;

</xmp><xmp rev="v1r2" propsrc="zser">struct &lbrace;
         char c;
         char d;
         short s;
         int n;
&rbrace;;

</xmp></entry>
<entry colname="col2"><mmobj><objref obj="strct8nop" depth="2.4cm"><textalt><p><xmp>
Word aligned, sizeof is 8
|--------------|--------------|-----------------------------|
| 0            | 1            | 2                           |
|              |              |                             |
|       c      |      d       |              s              |
|--------------|--------------|-----------------------------|
| 4                                                         |
|                                                           |
|                             n                             |
|-----------------------------------------------------------|

</xmp></p></textalt></mmobj></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig frame="box" id="struct3" propsrc="colfig"><cap>Internal padding</cap>
<p><table frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<?PubTbl tgroup dispwid="11.10in">
<colspec colnum="1" colname="col1" colwidth="63*">
<colspec colnum="2" colname="col2" align="left" charoff="50" char="" colwidth="135*">
<tbody>
<row>
<entry colname="col1"><xmp>struct &lbrace;
         char c;
         short s;
&rbrace;;

</xmp></entry>
<entry colname="col2"><mmobj><objref obj="strct4pad" depth="1.5cm"><textalt><p><xmp>
Halfword aligned, sizeof is 4
|--------------|--------------|-----------------------------|
| 0            | 1            | 2                           |
|              |              |                             |
|       c      |     pad      |              s              |
|--------------|--------------|-----------------------------|

</xmp></p></textalt></mmobj></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig frame="box" id="struct4" propsrc="colfig"><cap>Internal and tail padding
</cap>
<p><table frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<?PubTbl tgroup dispwid="11.10in">
<colspec colnum="1" colname="col1" colwidth="67*">
<colspec colnum="2" colname="col2" align="left" charoff="50" char="" colwidth="132*">
<tbody>
<row>
<entry colname="col1"><xmp>struct &lbrace;
         char c;
         double d;
         short s;
&rbrace;;

</xmp></entry>
<entry colname="col2"><mmobj><objref obj="strct24pad" depth="6.0cm"><textalt><p><xmp>
Doubleword aligned, sizeof is 24
|--------------|--------------------------------------------|
| 0            | 1                                          |
|              |                                            |
|       c      |                  pad                       |
|--------------|--------------------------------------------|
| 4                                                         |
|                                                           |
|                          pad                              |
|-----------------------------------------------------------|
| 8                                                         |
|                                                           |
|                           d                               |
|-----------------------------------------------------------|
| 12                                                        |
|                                                           |
|                           d                               |
|---------------------------|-------------------------------|
| 16                        | 18                            |
|                           |                               |
|              s            |               pad             |
|---------------------------|-------------------------------|
| 20                                                        |
|                                                           |
|                          pad                              |
|-----------------------------------------------------------|

</xmp></p></textalt></mmobj></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig frame="box" id="struct5" propsrc="colfig"><cap>Union padding</cap>
<p><table frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<?PubTbl tgroup dispwid="11.02in">
<colspec colnum="1" colname="col1" colwidth="67*">
<colspec colnum="2" colname="col2" align="left" charoff="50" char="" colwidth="132*">
<tbody>
<row>
<entry colname="col1"><xmp>union  &lbrace;
         char c;
         short s;
         int   j;
&rbrace;;

</xmp></entry>
<entry colname="col2"><mmobj><objref obj="strctunion" depth="3.9cm"><textalt><p><xmp>
Word aligned, sizeof is 4
|--------------|--------------------------------------------|
| 0            | 1                                          |
|              |                                            |
|       c      |                    pad                     |
|--------------|--------------------------------------------|

|-----------------------------|-----------------------------|
| 0                           | 2                           |
|                             |                             |
|              s              |             pad             |
|-----------------------------|-----------------------------|

|-----------------------------------------------------------|
| 0                                                         |
|                                                           |
|                             j                             |
|-----------------------------------------------------------|

</xmp></p></textalt></mmobj></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Bit-fields</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>bit-fields</idxterm></i1>
<p>C struct and union definitions may have "bit-fields," defining integral
objects with a specified number of bits (see <xref refid="bitfieldtable">).
</p>
<table id="bitfieldtable" rev="v0r2"><cap>Bit fields</cap>
<i1><idxterm>signed char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed char</idxterm></i2></i1>
<i1><idxterm>char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>char</idxterm></i2></i1>
<i1><idxterm>unsigned char type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm> unsigned char</idxterm></i2></i1>
<i1><idxterm>signed short type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed short</idxterm></i2></i1>
<i1><idxterm>short type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>short</idxterm></i2></i1>
<i1><idxterm>unsigned short type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned short</idxterm></i2></i1>
<i1><idxterm>signed int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed int</idxterm></i2></i1>
<i1><idxterm>int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>int</idxterm></i2></i1>
<i1><idxterm>unsigned int type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned int</idxterm></i2></i1>
<i1><idxterm>enum type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>enum</idxterm></i2></i1>
<i1><idxterm>signed long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed long</idxterm></i2></i1>
<i1><idxterm>long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>long</idxterm></i2></i1>
<i1><idxterm>unsigned long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned long</idxterm></i2></i1>
<i1><idxterm>signed long long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>signed long long</idxterm></i2></i1>
<i1><idxterm>long long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>long long</idxterm></i2></i1>
<i1><idxterm>unsigned long long type</idxterm></i1>
<i1><idxterm>type</idxterm><i2><idxterm>unsigned long long</idxterm></i2>
</i1>
<tgroup cols="3">
<?PubTbl tgroup dispwid="8.00in">
<colspec colname="col1" colwidth="92*">
<colspec colname="col2" colwidth="89*">
<colspec colname="col3" colwidth="111*">
<thead>
<row>
<entry colname="col1" valign="top">Bit-field type</entry>
<entry colname="col2" valign="top">Width <ph style="italic">n</ph></entry>
<entry colname="col3" valign="top">Range</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>signed char

char

unsigned char

</xmp></entry>
<entry colname="col2" valign="middle" align="center">1 to 8</entry>
<entry colname="col3"><xmp>-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp></entry>
</row>
<row>
<entry colname="col1"><xmp>signed short

short

unsigned short</xmp></entry>
<entry colname="col2" valign="middle" align="center">1 to 16</entry>
<entry colname="col3"><xmp>-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp></entry>
</row>
<row>
<entry colname="col1"><xmp propsrc="s390">signed int

int

unsigned int

enum

signed long

long

unsigned long</xmp><xmp rev="v1r2" propsrc="zser">signed int

int

unsigned int

enum</xmp></entry>
<entry colname="col2" valign="middle" align="center">1 to 32</entry>
<entry colname="col3"><xmp propsrc="s390">-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1

-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp><xmp rev="v1r2" propsrc="zser">-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp></entry>
</row>
<row>
<entry colname="col1"><xmp propsrc="s390">signed long long

long long

unsigned long long</xmp><xmp rev="v1r2" propsrc="zser">signed long

long

unsigned long

signed long long

long long

unsigned long long</xmp></entry>
<entry colname="col2" valign="middle" align="center">1 to 64</entry>
<entry colname="col3"><xmp propsrc="s390">-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp><xmp rev="v1r2" propsrc="zser">-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1

-2&supn;&supminus;&sup1; to 2&supn;&supminus;&sup1; - 1

0 to 2&supn; - 1

0 to 2&supn; - 1</xmp></entry>
</row>
</tbody>
</tgroup>
</table>
<p>"Plain" bit-fields (that is, those neither signed nor unsigned) always
have non-negative values. Although they may have type short, int or long (which
can have negative values), bit-fields of these types have the same range as
bit-fields of the same size with the corresponding unsigned type. Bit-fields
obey the same size and alignment rules as other structure and union members,
with the following additions:</p>
<ul>
<li>Bit-fields are allocated from left to right (most to least significant)<ph
props="comment"> on Big-Endian implementations</ph>.</li>
<li>A bit-field must entirely reside in a storage unit appropriate for its
declared type. Thus, a bit-field never crosses its unit boundary.</li>
<li>Bit-fields must share a storage unit with other structure and union members
(either bit-field or non-bit-field) if and only if there is sufficient space
within the storage unit.</li>
<li>Unnamed bit-fields' types do not affect the alignment of a structure or
union, although an individual bit-field's member offsets obey the alignment
constraints. An unnamed, zero-width bit-field shall prevent any further member,
bit-field or other, from residing in the storage unit corresponding to the
type of the zero-width bit-field.</li>
</ul>
<p>The following examples (<xref refid="figbitnum" form="text"> through <xref
refid="figunnbitf" form="text">) show structure and union member byte offsets<ph
props="comment"> in the upper right corners for Little-Endian implementations,
and</ph> in the upper left corners<ph props="comment"> for Big-Endian implementations
</ph>. Bit numbers appear in the lower corners.</p>
<fig frame="box" id="figbitnum" propsrc="colfig"><cap>Bit numbering</cap>
<mmobj><objref obj="bitnum"><textalt><p><xmp>               |--------------|--------------|--------------|--------------|
               | 0            | 1            | 2            | 3            |
0x01020304     |      01      |       02     |       03     |       04     |
               | 0          7 | 8         15 | 16        23 | 24        31 |
               |--------------|--------------|--------------|--------------|

</xmp></p></textalt></mmobj>
</fig>
<fig frame="box" id="figlralloc" propsrc="colfig"><cap>Left-to-right allocation
</cap>
<mmobj><objref obj="lralloc"><textalt><p><xmp>                   Word aligned, sizeof is 4
struct {          |--------------|--------------|--------------|--------------|
       int j:5;   | 0            |              |              |              |
       int k:6;   |       j      |        k     |        m     |      pad     |
       int m:7;   | 0          4 | 5         10 | 11        17 | 18        31 |
};                |--------------|--------------|--------------|--------------|

</xmp></p></textalt></mmobj>
</fig>
<fig frame="box" id="figbalign" propsrc="colfig"><cap>Boundary alignment</cap>
<mmobj><objref obj="balign"><textalt><p><xmp>                   Word aligned, sizeof is 12
struct {          |----------------|--------------|------------|--------------|
       short s:9; | 0              |              |            | 3            |
       int   j:9; |       s        |      j       |    pad     |       c      |
       char  c;   | 0            8 | 9         17 | 18      23 | 24        31 |
       short t:9; |----------------|------------|-|------------|--------------|
       short u:9; | 4              |            | 6            |              |
       char  d;   |       t        |    pad     |       u      |      pad     |
};                | 32          40 | 41      47 | 48        56 | 57        63 |
                  |--------------|-|------------|--------------|--------------|
                  | 8            | 9                                          |
                  |       d      |                      pad                   |
                  | 64        71 | 72                                      95 |
                  |--------------|--------------|--------------|--------------|

</xmp></p></textalt></mmobj>
</fig>
<fig frame="box" id="figsushar" propsrc="colfig"><cap>Storage unit sharing
</cap>
<mmobj><objref obj="sushar"><textalt><p><xmp>                   Halfword aligned, sizeof is 2
struct {          |--------------|--------------|
       char  c;   | 0            | 1            |
       short s:8; |       c      |        s     |
};                | 0          7 | 8         15 |
                  |--------------|--------------|

</xmp></p></textalt></mmobj>
</fig>
<fig frame="box" id="figunalloc" propsrc="colfig"><cap>Union allocation</cap>
<mmobj><objref obj="unalloc"><textalt><p><xmp>                   Halfword aligned, sizeof is 2
union  {          |--------------|--------------|
       char  c;   | 0            | 1            |
       short s:8; |       c      |       pad    |
};                | 0          7 | 8         15 |
                  |--------------|--------------|

                  |--------------|--------------|
                  | 0            | 1            |
                  |       s      |       pad    |
                  | 0          7 | 8         15 |
                  |--------------|--------------|

</xmp></p></textalt></mmobj>
</fig>
<fig frame="box" id="figunnbitf" propsrc="colfig"><cap>Unnamed bit fields
</cap>
<mmobj><objref obj="unnbitf"><textalt><p><xmp>                   Byte aligned, sizeof is 9
struct {          |--------------|--------------------------------------------|
       char  c;   | 0            | 1                                          |
       int   :0;  |       c      |                      :0                    |
       char  d;   | 0          7 | 8                                       31 |
       short :9;  |--------------|--------------|--------------|--------------|
       char  e;   | 4            | 5            | 6            | 7            |
};                |       d      |      pad     |       :9     |       pad    |
                  | 32        39 | 40        47 | 48        55 | 56        63 |
                  |--------------|--------------|--------------|--------------|
                  | 8            |
                  |       e      |
                  | 64        71 |
                  |--------------|

</xmp></p></textalt></mmobj>
</fig>
</dbody></d>
</dbody></d>
</dbody></d>
<?xpp:page>
<d>
<dprolog><titleblk>
<title>Function calling sequence</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>calling sequence</idxterm></i2>
</i1>
<i1><idxterm>calling sequence, function</idxterm></i1>
<p>This section discusses the standard function calling sequence, including
stack frame layout, register usage, and parameter passing.</p>
<d>
<dprolog><titleblk>
<title>Registers</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>register</idxterm><i2><idxterm>general</idxterm></i2></i1>
<i1><idxterm>register</idxterm><i2><idxterm>floating point</idxterm></i2>
</i1>
<p props="comment" rev="v0r1"><?Pub Dtl><ph propsrc="zser">&system64;</ph><ph
propsrc="s390">&system32;</ph> models have 16 general purpose registers<ph
propsrc="zser"> and 16 floating point registers</ph>. The width of these is <ph
propsrc="zser">64</ph><ph propsrc="s390">32</ph> bits. <ph propsrc="s390">
The number of floating point registers depends on the model. Older systems
have only four floating point registers; recent systems have 16. The 16 registers
were introduced together with the IEEE floating point implementation. &linuxs; for &system32; emulates
IEEE floating point format on older machines that do not have IEEE hardware
implementation. All &linuxs; programs are able to use 16 floating-point registers,
the missing 12 on older hardware are emulated within the &linuxs; kernel</ph>.
The use of the registers is described in the table below.</p>
<p rev="v0r1">The ABI makes the assumption that the processor has 16 general
purpose registers and 16 IEEE floating point registers. <ph propsrc="zser">
&system64; processors have these registers; each register is 64 bits wide.
</ph><ph propsrc="s390">&system32; processors have 16 general purpose registers;
newer models have 16 IEEE floating point registers but older systems have
only four non-IEEE floating point registers. On these older machines &linuxs; for &system32; emulates
16 IEEE registers within the kernel. <ph props="comment" rev="v0r2">The width
of all these registers is 32 bits.</ph><ph rev="v0r2">The width of the general
purpose registers is 32 bits, and the width of the floating point registers
is 64 bits.</ph></ph> The use of the registers is described in the table below.
</p>
<table frame="topbot" colsep="0" rowsep="1" propsrc="s390">
<tgroup cols="3">
<colspec colname="col1" colwidth="144*">
<colspec colname="col2" colwidth="84*">
<colspec colname="col3" colwidth="66*">
<thead>
<row>
<entry colname="col1" valign="top">Register name</entry>
<entry colname="col2" valign="top">Usage</entry>
<entry colname="col3" valign="top">Call effect</entry>
</row>
</thead>
<tfoot>
<row>
<entry namest="col1" nameend="col3" valign="top"><p rev="v0r2">&sup1;Volatile:
These registers are not preserved across function calls.</p><p rev="v0r2">
&sup2;Saved: These registers belong to the calling function. A called function
shall save these registers' values before it changes them, restoring their
values before it returns.</p></entry>
</row>
</tfoot>
<tbody>
<row>
<entry colname="col1"><xmp>r0, r1</xmp></entry>
<entry colname="col2"><ph rev="v0r2">General purpose</ph></entry>
<entry colname="col3">Volatile&sup1;</entry>
</row>
<row>
<entry colname="col1"><xmp>r2, r3</xmp></entry>
<entry colname="col2">Parameter passing and return values</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>r4, r5</xmp></entry>
<entry colname="col2">Parameter passing</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>r6</xmp></entry>
<entry colname="col2">Parameter passing</entry>
<entry colname="col3">Saved&sup2;</entry>
</row>
<row>
<entry colname="col1"><xmp>r7 - r11</xmp></entry>
<entry colname="col2">Local variables</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r12</xmp></entry>
<entry colname="col2">Local variable, commonly used as GOT pointer</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r13</xmp></entry>
<entry colname="col2">Local variable, commonly used as Literal Pool pointer
</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r14</xmp></entry>
<entry colname="col2">Return address</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>r15</xmp></entry>
<entry colname="col2">Stack pointer</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>f0, f2</xmp></entry>
<entry colname="col2">Parameter passing and return values</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>f4, f6</xmp></entry>
<entry colname="col2">General purpose</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>f1,<ph rev="v0r1"> f3,</ph> f5, f7 &ndash; f15
</xmp></entry>
<entry colname="col2">General purpose</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><ph rev="v0r1">Access register 0</ph></entry>
<entry colname="col2"><ph props="comment" rev="v0r1">Local storage address
space</ph><ph rev="v0r2">Reserved for system use</ph></entry>
<entry colname="col3"><ph props="comment" rev="v0r1">Saved</ph><ph rev="v0r2">
Volatile</ph></entry>
</row>
<row>
<entry colname="col1"><ph rev="v0r1">Access registers 1-15</ph></entry>
<entry colname="col2"><ph rev="v0r2">General purpose</ph></entry>
<entry colname="col3"><ph rev="v0r1">Volatile</ph></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="topbot" colsep="0" rowsep="1" propsrc="zser">
<tgroup cols="3">
<colspec colname="col1" colwidth="144*">
<colspec colname="col2" colwidth="84*">
<colspec colname="col3" colwidth="66*">
<thead>
<row>
<entry colname="col1" valign="top">Register name</entry>
<entry colname="col2" valign="top">Usage</entry>
<entry colname="col3" valign="top">Call effect</entry>
</row>
</thead>
<tfoot>
<row>
<entry namest="col1" nameend="col3" valign="top"><p rev="v0r2">&sup1;Volatile:
These registers are not preserved across function calls.</p><p rev="v0r2">
&sup2;Saved: These registers belong to the calling function. A called function
shall save these registers' values before it changes them, restoring their
values before it returns.</p></entry>
</row>
</tfoot>
<tbody>
<row>
<entry colname="col1"><xmp>r0, r1</xmp></entry>
<entry colname="col2"><ph rev="v0r2">General purpose</ph></entry>
<entry colname="col3">Volatile&sup1;</entry>
</row>
<row>
<entry colname="col1"><xmp rev="v1r2">r2<ph props="comment">, r3</ph></xmp></entry>
<entry colname="col2">Parameter passing and return values</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp rev="v1r2"><ph>r3, </ph>r4, r5</xmp></entry>
<entry colname="col2">Parameter passing</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>r6</xmp></entry>
<entry colname="col2">Parameter passing</entry>
<entry colname="col3">Saved&sup2;</entry>
</row>
<row>
<entry colname="col1"><xmp>r7 - r11</xmp></entry>
<entry colname="col2">Local variables</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r12</xmp></entry>
<entry colname="col2">Local variable, commonly used as GOT pointer</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r13</xmp></entry>
<entry colname="col2">Local variable, commonly used as Literal Pool pointer
</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>r14</xmp></entry>
<entry colname="col2">Return address</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>r15</xmp></entry>
<entry colname="col2">Stack pointer</entry>
<entry colname="col3">Saved</entry>
</row>
<row>
<entry colname="col1"><xmp>f0, f2, f4, f6</xmp></entry>
<entry colname="col2">Parameter passing and return values</entry>
<entry colname="col3">Volatile</entry>
</row>
<row>
<entry colname="col1"><xmp>f1, f3, f5, f7</xmp></entry>
<entry colname="col2">General purpose</entry>
<entry colname="col3"><ph props="comment" rev="v1r3">Saved</ph><ph rev="v1r3">
Volatile</ph></entry>
</row>
<row>
<entry colname="col1"><xmp>f8 &ndash; f15</xmp></entry>
<entry colname="col2">General purpose</entry>
<entry colname="col3"><ph props="comment" rev="v1r3">Volatile</ph><ph rev="v1r3">
Saved</ph></entry>
</row>
<row>
<entry colname="col1"><ph rev="v1r2">Access registers 0, 1</ph></entry>
<entry colname="col2"><ph props="comment" rev="v0r1">Local storage address
space</ph><ph rev="v0r2">Reserved for system use</ph></entry>
<entry colname="col3"><ph rev="v0r2">Volatile</ph></entry>
</row>
<row>
<entry colname="col1"><ph rev="v0r1">Access registers 2-15</ph></entry>
<entry colname="col2"><ph rev="v0r2">General purpose</ph></entry>
<entry colname="col3"><ph rev="v0r1">Volatile</ph></entry>
</row>
</tbody>
</tgroup>
</table>
<p><ul>
<li>Registers <xph>r6</xph> through <xph>r13</xph>, <xph>r15, <ph propsrc="s390">
f4 and f6</ph><ph rev="v0r1" propsrc="zser">f1, f3, f5 and f7</ph></xph> are
nonvolatile; that is, they "belong" to the calling function. A called function
shall save these registers' values before it changes them, restoring their
values before it returns.</li>
<li><ph propsrc="s390">Registers <xph>r0, r1, r2, r3, r4, r5, r14, f0,  f1,
f2, f3, f5, f6</xph> through <xph>f15</xph> are volatile; that is, they are
not preserved across function calls.</ph><ph propsrc="zser">Registers <xph>
r0, r1, r2, r3, r4, r5, r14, f0, f2, f4, f6, f8</xph> through <xph>f15</xph> are
volatile; that is, they are not preserved across function calls.</ph></li>
<li>Furthermore the values in registers <xph>r0</xph> and <xph>r1</xph> may
be altered by<ph rev="v0r1"> the interface code in</ph> cross-module calls,
so a function cannot depend on the values in these registers having the same
values that were placed in them by the caller.</li>
</ul> </p>
<p>The following registers have assigned roles in the standard calling sequence:
</p>
<i1><idxterm>register</idxterm><i2><idxterm>calling convention</idxterm></i2>
</i1>
<i1><idxterm>calling convention, registers</idxterm></i1>
<table>
<tgroup cols="2">
<colspec colname="col1" colwidth="62*">
<colspec colname="col2" colwidth="136*">
<tbody>
<row>
<entry colname="col1"><xph rev="v0r1">r12</xph></entry>
<entry colname="col2"><ph rev="v0r2">Global Offset Table pointer.<i1><idxterm>
Global Offset Table (GOT)</idxterm></i1> If a position-independent module
uses cross-linking the compiler <ph style="underlined">must</ph> point <xph>
r12</xph> to the GOT as described in <xref refid="dynamiclinking">. If not
this register may be used locally.</ph></entry>
</row>
<row>
<entry colname="col1"><xph rev="v0r1">r13</xph></entry>
<entry colname="col2"><ph rev="v0r1">Commonly used as the Literal Pool pointer.<i1>
<idxterm>literal pool</idxterm></i1> If the Literal Pool is not required this
register may be used locally.</ph></entry>
</row>
<row>
<entry colname="col1"><xph>r14</xph></entry>
<entry colname="col2">This register will contain the address to which a called
function will normally return.<i1><idxterm>return address</idxterm></i1> <xph>
r14</xph> is volatile across function calls.</entry>
</row>
<row>
<entry colname="col1"><xph>r15</xph></entry>
<entry colname="col2">The stack pointer<i1><idxterm>stack</idxterm><i2><idxterm>
pointer</idxterm></i2></i1><i1><idxterm>pointer</idxterm><i2><idxterm>stack
</idxterm></i2></i1> (stored in <xph>r15</xph>) will maintain an 8-byte alignment.
It will always point to the lowest allocated valid stack frame, and will grow
towards low addresses. The contents of the word addressed by this register
may point to the previously allocated stack frame. If required it can be decremented
by the called function &ndash; see <xref refid="dynamicstack">.</entry>
</row>
</tbody>
</tgroup>
</table>
<p>Signals can interrupt processes.<i1><idxterm>signal handling</idxterm>
</i1> Functions called during signal handling have no unusual restrictions
on their use of registers. Moreover, if a signal handling function returns,
the process will resume its original execution path with all registers restored
to their original values. Thus programs and compilers may freely use all registers
listed above, except those reserved for system use, without the danger of
signal handlers inadvertently changing their values.</p>
<d>
<dprolog><titleblk>
<title>Register usage</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>register</idxterm><i2><idxterm>usage</idxterm></i2></i1>
<p>With these calling conventions the following usage of the registers for
inline assemblies is recommended: <ul>
<li>General registers <xph>r0</xph> and <xph>r1</xph> should be used internally
whenever possible</li>
<li>General registers <xph>r2</xph> to <xph>r5</xph> should be second choice
</li>
<li>General registers <xph>r12</xph> to <xph>r15</xph> should only be used
for their standard function.</li>
</ul></p>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>The stack frame</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>stack</idxterm><i2><idxterm>frame</idxterm></i2></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>runtime</idxterm></i2></i1>
<p props="comment" rev="v0r1">In addition to the registers, each function
may have a stack frame on the runtime stack. This stack grows downwards from
high addresses. <xref refid="stackframe"> shows the stack frame organization. <xph>
SP</xph> in the figure denotes the stack pointer (general purpose register <xph>
r15</xph>) of the called function after it has executed code establishing
its stack frame.</p>
<p rev="v0r1">A function will be passed a frame on the runtime stack by the
function which called it, and may allocate a new stack frame. A new stack
frame is required if the called function will in turn call further functions
(which must be passed the address of the new frame). This stack grows downwards
from high addresses. <xref refid="stackframe"> shows the stack frame organization. <xph>
SP</xph> in the figure denotes the stack pointer (general purpose register <xph>
r15</xph>) passed to the called function <ph props="comment" rev="v0r2">after
it has executed code establishing its stack frame</ph><ph rev="v0r2">on entry
</ph>. Maintenance of the back chain pointers is not a requirement of the
ABI, but the storage area for these pointers must be allocated whether used
or not.</p>
<fig frame="box" id="stackframe" propsrc="colfig"><cap>Standard stack frame 
</cap>
<mmobj rev="v0r2" propsrc="s390"><objref obj="ststfr32"><textalt></textalt>
</mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="ststfr64"><textalt></textalt>
</mmobj>
</fig>
<p rev="v0r1">The format of the register save area created by the gcc compiler
is:</p>
<fig frame="box" id="regsave" rev="v0r1" propsrc="colfig"><cap>Register save
area</cap>
<mmobj propsrc="s390"><objref obj="regsav32"><textalt></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="regsav64"><textalt></textalt>
</mmobj>
</fig>
<p>The following requirements apply to the stack frame:</p>
<ul>
<li>The stack pointer shall maintain 8-byte alignment.</li>
<li props="comment" rev="v0r1">The stack pointer may point to the first word
of the lowest allocated stack frame, the "back chain" word. The stack shall
grow downwards, that is, towards lower addresses. The first word of the stack
frame may point to the previously allocated stack frame (towards higher addresses),
except for the first stack frame, which shall have a back chain of zero (NULL).
</li>
<li rev="v0r1">The stack pointer points to the first word of the lowest allocated
stack frame. If the "back chain" is implemented this word will point to the
previously allocated stack frame (towards higher addresses), except for the
first stack frame, which shall have a back chain of zero (NULL). The stack
shall grow downwards, in other words towards lower addresses.</li>
<li props="comment" rev="v0r1">The stack pointer shall be decremented by the
called function, if required, and restored prior to return.</li>
<li rev="v0r1">The called function may create a new stack frame by decrementing
the stack pointer by the size of the new frame. This is required if this function
calls further functions. The stack pointer must be restored prior to return.
</li>
<li>The parameter list area shall be allocated by the caller and shall be
large enough to contain the arguments that the caller stores in it. Its contents
are not preserved across calls.</li>
<li props="comment" rev="v0r1">Before a function changes the value in any
nonvolatile general register, <xph>rn</xph>, it shall save the value in <xph>
rn</xph> in the word in the general register save area <ph props="comment">
4*(32-n) bytes before the low-addressed end of the floating-point register
save area</ph>.</li>
<li>Other areas depend on the compiler and the code being compiled. The standard
calling sequence does not define a maximum stack frame size. </li>
</ul>
<p props="comment">The stack frame header consists of the back chain word
and the <xph>LR</xph> save word. The back chain word always contains a pointer
to the previously allocated stack frame. Before a function calls another function,
it shall save the contents of the link register at the time the function was
entered in the <xph>LR</xph> save word of its caller's stack frame and shall
establish its own stack frame.</p>
<p>The stack space for the register save area and back chain must be allocated
by the caller. The size of these is <ph propsrc="zser">&stacksize64;</ph><ph
propsrc="s390">&stacksize32;</ph> bytes.</p>
<p>Except for the stack frame header and any padding necessary to make the
entire frame a multiple of 8 bytes in length, a function need not allocate
space for the areas that it does not use. If a function does not call any
other functions and does not require any of the other parts of the stack frame,
it need not establish a stack frame. Any padding of the frame as a whole shall
be within the local variable area; the parameter list area shall immediately
follow the stack frame header, and the register save areas shall contain no
padding.</p>
</dbody></d>
<d id="parameterpassing">
<dprolog><titleblk>
<title>Parameter passing</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>parameter</idxterm><i2><idxterm>passing</idxterm></i2></i1>
<i1><idxterm>register</idxterm><i2><idxterm>parameter passing</idxterm></i2>
</i1>
<p props="comment" rev="v0r1">For <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> up to five words are passed in general purpose registers,
loaded sequentially into general purpose registers <xph>r2</xph> through <xph>
r6</xph>. In addition, up to <ph propsrc="zser">four</ph><ph propsrc="s390">
two</ph> floating-point arguments can be passed in floating-point registers <ph
propsrc="zser"><xph>f0</xph>, <xph>f2</xph>, <xph>f4</xph> and <xph>f6</xph></ph><ph
propsrc="s390"><xph>f0</xph> and <xph>f2</xph></ph>. If fewer (or no) arguments
are passed the unused registers will contain undefined values on entry to
the called function.</p>
<p props="comment" rev="v0r1">Only in the "worst-case" when arguments passed
from a function will not fit in the five general purpose and <ph propsrc="zser">
four</ph><ph propsrc="s390">two</ph> floating-point registers provided must
a function allocate space for arguments in its stack frame. In this case it
needs to allocate only enough space to hold the arguments that do not fit
into registers.</p>
<p>Arguments to called functions are passed in registers. Since all computations
must be performed in registers, memory traffic can be eliminated if the caller
can compute arguments into registers and pass them in the same registers to
the called function, where the called function can then use these arguments
for further computation in the same registers. The number of registers implemented
in a processor architecture naturally limits the number of arguments that
can be passed in this manner.</p>
<p>For &linuxs; for <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph>, the following applies:<ul>
<li>General registers <xph>r2</xph> to <xph>r6</xph> are used for integer
values.</li>
<li>Floating point registers <ph propsrc="zser"><xph>f0, f2, f4</xph> and <xph>
f6</xph></ph><ph propsrc="s390"><xph>f0</xph> and <xph>f2</xph></ph> are used
for <ph props="comment" rev="v0r2">floats</ph><ph rev="v0r2">floating point
values</ph>.</li>
</ul>If there are more than five integral values or <ph propsrc="zser">four
</ph><ph propsrc="s390">two</ph> floating point values, the rest of the arguments
are passed on the stack <ph propsrc="zser">&stacksize64;</ph><ph propsrc="s390">
&stacksize32;</ph> bytes above the<ph rev="v0r1"> initial</ph> stack pointer<ph
props="comment" rev="v0r1"> at function entrance</ph>.</p>
<p>Beside these general rules the following rules apply:<ul>
<li><xph>char, short</xph><ph propsrc="s390"> and <xph>int</xph></ph><ph propsrc="zser">
, <xph rev="v1r2">int, long</xph> and <xph>long long</xph></ph> are passed
in general registers.</li>
<li propsrc="s390"><xph>long long</xph> are passed in two consecutive general
registers if the next available register is smaller than 6. If the upper 32
bits would end in general register 6 then this register is skipped and the
whole 64 bit value is passed on the stack.</li>
<li props="comment" rev="v0r1">Structures with a size of 1, 2<ph propsrc="s390">
 or 4</ph><ph propsrc="zser">, 4, or 8</ph> bytes are passed as integral values.
</li>
<li>Structures with a size of 1, 2<ph propsrc="s390"> or 4</ph><ph propsrc="zser">
, 4, or 8</ph> bytes are passed as integral values.</li>
<li rev="v0r1" propsrc="s390">Structures with a size of 8 bytes are passed
as an integral value in two registers.</li>
<li>All other structures are passed by reference. If needed, the called function
makes a copy of the value.</li>
<li>Complex numbers are passed as structures.</li>
</ul></p>
<fig frame="box" id="prmlistar" propsrc="colfig"><cap>Parameter list area
</cap>
<mmobj rev="v0r2" propsrc="s390"><objref obj="parla32"><textalt></textalt>
</mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="parla64"><textalt></textalt>
</mmobj>
</fig>
<p><i1><idxterm>arguments</idxterm></i1>The following algorithm specifies
where argument data is passed for the C language. For this purpose, consider
the arguments as ordered from left (first argument) to right, although the
order of evaluation of the arguments is unspecified. In this algorithm <xph>
fr</xph> contains the number of the next available floating-point register, <xph>
gr</xph> contains the number of the next available general purpose register,
and <xph>starg</xph> is the address of the next available stack argument word.
</p>
<dl>
<dlentry><term>INITIALIZE</term>
<defn>Set <xph>fr=0</xph>, <xph>gr=2</xph>, and <xph>starg</xph> to the address
of parameter word 1.</defn>
</dlentry>
<dlentry><term>SCAN</term>
<defn>If there are no more arguments, terminate. Otherwise, select one of
the following depending on the type of the next argument:<dl>
<dlentry><term>DOUBLE_OR_FLOAT:</term>
<defn><ph>A <xph rev="v0r2">DOUBLE_OR_FLOAT</xph> is one of the following:
</ph><ul rev="v0r2">
<li>A single length floating point type,</li>
<li>A double length floating point type.</li>
</ul>If <ph propsrc="zser"><xph>fr>6</xph></ph><ph propsrc="s390"><xph>fr>2
</xph></ph>, that is, if there are no more available floating-point registers,
go to <ph style="bold">OTHER</ph>. Otherwise, load the argument value into
floating-point register <xph>fr</xph>, set <xph>fr</xph> to <xph>fr+2</xph>,
and go to <ph style="bold">SCAN</ph>.</defn>
</dlentry>
<dlentry><term>SIMPLE_ARG</term>
<defn>A <xph>SIMPLE_ARG</xph> is one of the following:<ul>
<li>One of the simple integer types no more than <ph propsrc="zser">64</ph><ph
propsrc="s390">32</ph> bits wide (char, short, int, long<ph propsrc="zser">
, long long</ph>, enum).</li>
<li>A pointer to an object of any type.</li>
<li rev="v0r2">A <xph>struct</xph> or a <xph>union</xph> of 1, 2<ph propsrc="s390">
 or 4</ph><ph rev="v1r2" propsrc="zser">, 4 or 8</ph> bytes.</li>
<li>A <ph props="comment" rev="v0r2"><xph>struct</xph>, <xph>union</xph>,
or</ph><ph rev="v0r2"><xph>struct</xph> or <xph>union</xph> of another size,
or a</ph> <xph>long double</xph>, any of which shall be passed as a pointer
to the object, or to a copy of the object where necessary to enforce call-by-value
semantics. Only if the caller can ascertain that the object is "constant"
can it pass a pointer to the object itself.</li>
<li props="comment" rev="v0r1">A <xph>struct</xph> or a <xph>union</xph> of
1, 2<ph propsrc="s390"> or 4</ph><ph propsrc="zser"> or 8</ph> bytes.</li>
</ul><p>If <xph>gr>6</xph>, go to <xph>OTHER</xph>. Otherwise load the argument
value into general register <xph>gr</xph>, set <xph>gr</xph> to <xph>gr+1
</xph>, and go to <ph style="bold">SCAN</ph>. Values shorter than <ph propsrc="zser">
64</ph><ph propsrc="s390">32</ph> bits are <ph props="comment" rev="v1r2">
sign-extended (if signed) or zero-extended</ph><ph rev="v1r2">sign- or zero-extended
(as appropriate) to <ph propsrc="zser">64</ph><ph propsrc="s390">32</ph> bits
</ph>.</p></defn>
</dlentry>
<dlentry props="comment" rev="v0r1"><term>long long</term>
<defn><p>If <xph>gr>5</xph> go to <ph style="bold">OTHER</ph>. Load the lower-addressed
word of the <xph>long long</xph> into <xph>gr</xph> and the higher-addressed
word into <xph>gr+1</xph>, set <xph>gr</xph> to <xph>gr+2</xph>, and go to <ph
style="bold">SCAN</ph>.</p></defn>
</dlentry>
<dlentry propsrc="s390"><term rev="v0r1">DOUBLE_ARG</term>
<defn><ph rev="v0r1">A <xph>DOUBLE_ARG</xph> is one of type <xph>long long
</xph>, or is a <xph>struct</xph> or a <xph>union</xph> of size 8 bytes.</ph><p>
If <xph>gr>5</xph><ph rev="v0r1"> set <xph>gr</xph> to 7 and</ph> go to <ph
style="bold">OTHER</ph>. Load the lower-addressed word of the <xph>long long
</xph> into <xph>gr</xph> and the higher-addressed word into <xph>gr+1</xph>,
set <xph>gr</xph> to <xph>gr+2</xph>, and go to <ph style="bold">SCAN</ph>.
</p></defn>
</dlentry>
</dl></defn>
</dlentry>
<dlentry><term>OTHER</term>
<defn>Arguments not otherwise handled above are passed in the parameter words
of the caller's stack frame. <ph propsrc="s390"><xph>SIMPLE_ARG</xph>s, as
defined above, are considered to have 4-byte size, with simple integer types
shorter than 32 bits sign- or zero-extended (as appropriate) to 32 bits. <xph>
float</xph> arguments are considered to have 4-byte size; <xph>long long</xph> and <xph>
double</xph> arguments are considered to have 8-byte size.</ph><ph rev="v1r2"
propsrc="zser"><xph>SIMPLE_ARG</xph>s, as defined above, are considered to
have 8-byte size, with simple integer types shorter than 64 bits sign- or
zero-extended (as appropriate) to 64 bits. <xph>float</xph><xph props="comment"
rev="v1r2">, long long,</xph> and <xph>double</xph> arguments are considered
to have 8-byte size.</ph> <ph props="comment" rev="v1r1"><?Pub Dtl>Round <xph>
starg</xph> up to a multiple of the <ph>size</ph><ph props="comment"> alignment
requirement</ph> of the argument and copy the argument byte-for-byte, beginning
with its lowest addressed byte, into <xph>starg</xph>, <xph>starg+1</xph>,
..., <xph>starg+size-1</xph>. Set <xph>starg</xph> to <xph>starg+size</xph>,
then go to <ph style="bold">SCAN</ph>.</ph><ph rev="v1r1">Pad the stack by
increasing <xph>starg</xph>  to satisfy the alignment requirements of the
argument, and copy the argument byte for byte to the new stack position. Update <xph>
starg</xph> to point to the next byte after this copy, then go to <ph style="bold">
SCAN</ph>.</ph></defn>
</dlentry>
</dl>
<p>The contents of registers and words which are skipped by the above algorithm
for alignment purposes (padding) are undefined. </p>
<p>As an example, assume the declarations and the function call shown in <xref
refid="prmpass">. The corresponding register allocation and storage would
be as shown in <xref refid="tabprmpass">.</p>
<fig frame="box" id="prmpass" propsrc="colfig"><cap>Parameter passing example
</cap>
<xmp props="comment" rev="v0r1">int i, j, k, l;
long long ll;
double f, g, h;

x = func(i, j, g, k, l, ll, f, h);</xmp>
<xmp rev="v0r1">int i, j, k, l;
long long ll;
double f, g, h;
int m;

x = func(i, j, g, k, l, ll, f, h, m);</xmp>
</fig>
<table id="tabprmpass" propsrc="s390" rev="v0r1"><cap>Parameter passing example:
Register allocation</cap>
<tgroup cols="3" rev="v0r1">
<colspec colname="col1">
<colspec colname="col2">
<colspec colname="col3">
<thead>
<row>
<entry colname="col1" valign="top">General purpose registers</entry>
<entry colname="col2" valign="top">Floating-point registers</entry>
<entry colname="col3" valign="top">Stack frame offset</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xph>r2: i</xph></entry>
<entry colname="col2"><xph>f0: g</xph></entry>
<entry colname="col3"><xph> 96: ll</xph></entry>
</row>
<row>
<entry colname="col1"><xph>r3: j</xph></entry>
<entry colname="col2"><xph>f2: f</xph></entry>
<entry colname="col3"><xph>104: h</xph></entry>
</row>
<row>
<entry colname="col1"><xph>r4: k</xph></entry>
<entry colname="col2"></entry>
<entry colname="col3"><xph>112: m</xph></entry>
</row>
<row>
<entry colname="col1"><xph>r5: l</xph></entry>
<entry colname="col2"></entry>
<entry colname="col3"></entry>
</row>
<row>
<entry colname="col1"><xph>r6: -</xph></entry>
<entry colname="col2"></entry>
<entry colname="col3"></entry>
</row>
</tbody>
</tgroup>
</table>
<p rev="v0r1" propsrc="s390">In this example <xph>r6</xph> is unused as the <xph>
long long</xph> variable <xph>ll</xph> will not fit into a single register.
</p>
<table id="tabprmpass" propsrc="zser" rev="v1r2"><cap>Parameter passing example:
Register allocation</cap>
<tgroup cols="3" rev="v0r1">
<colspec colname="col1">
<colspec colname="col2">
<colspec colname="col3">
<thead>
<row>
<entry colname="col1" valign="top">General purpose registers</entry>
<entry colname="col2" valign="top">Floating-point registers</entry>
<entry colname="col3" valign="top">Stack frame offset</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xph>r2: i</xph></entry>
<entry colname="col2"><xph>f0: g</xph></entry>
<entry colname="col3"><xph>160: m</xph></entry>
</row>
<row>
<entry colname="col1"><xph>r3: j</xph></entry>
<entry colname="col2"><xph>f2: f</xph></entry>
<entry colname="col3"></entry>
</row>
<row>
<entry colname="col1"><xph>r4: k</xph></entry>
<entry colname="col2"><xph>f4: h</xph></entry>
<entry colname="col3"></entry>
</row>
<row>
<entry colname="col1"><xph>r5: l</xph></entry>
<entry colname="col2"></entry>
<entry colname="col3"></entry>
</row>
<row>
<entry colname="col1"><xph>r6: ll</xph></entry>
<entry colname="col2"></entry>
<entry colname="col3"></entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Variable argument lists</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>arguments</idxterm></i1>
<p>Some otherwise portable C programs depend on the argument passing scheme,
implicitly assuming that <ph style="bold">1)</ph> all arguments are passed
on the stack, and <ph style="bold">2)</ph> arguments appear in increasing
order on the stack. Programs that make these assumptions  have never been
portable, but they have worked on many implementations. However, they do not
work on <ph propsrc="zser">z/Architecture</ph><ph propsrc="s390">the ESA/390
architecture</ph> because some arguments are passed in registers. Portable
C programs use the header files <xph>&lt;stdarg.h&gt;</xph> or <xph>&lt;varargs.h&gt;
</xph> to deal with variable argument lists on <ph propsrc="zser">&system64;
</ph><ph propsrc="s390">&system32;</ph> and other machines as well.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Return values</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>return values</idxterm></i1>
<p>In general, arguments are returned in registers, as described in <xref
refid="retreg">.</p>
<table frame="topbot" colsep="0" rowsep="1" id="retreg" propsrc="s390" rev="v0r2">
<cap>Registers for return values</cap>
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colname="col1" colwidth="88*">
<colspec colname="col2" colwidth="109*">
<thead>
<row>
<entry colname="col1" valign="top">Type</entry>
<entry colname="col2" valign="top">Returned in register: </entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1">char, short, int and long</entry>
<entry colname="col2">general register 2 (<xph>r2</xph>)</entry>
</row>
<row>
<entry colname="col1">long long</entry>
<entry colname="col2">general registers 2 and 3 (<xph>r2</xph>, <xph>r3</xph>)
</entry>
</row>
<row>
<entry colname="col1">double and float </entry>
<entry colname="col2">floating point register 0 (<xph>f0</xph>)</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="topbot" colsep="0" rowsep="1" id="retreg" propsrc="zser" rev="v1r2">
<cap>Registers for return values</cap>
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colname="col1" colwidth="88*">
<colspec colname="col2" colwidth="109*">
<thead>
<row>
<entry colname="col1" valign="top">Type</entry>
<entry colname="col2" valign="top">Returned in register: </entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1">char, short, int, long and long long</entry>
<entry colname="col2">general register 2 (<xph>r2</xph>)</entry>
</row>
<row>
<entry colname="col1">double and float </entry>
<entry colname="col2">floating point register 0 (<xph>f0</xph>)</entry>
</row>
</tbody>
</tgroup>
</table>
<p rev="v0r1"><i1><idxterm>structures</idxterm><i2><idxterm>as return values
</idxterm></i2></i1>Structures are returned on the stack, in the segment allocated
by the caller. The pointer to the stack is passed as an invisible first argument
in register 2.</p>
<p><i1><idxterm>function</idxterm><i2><idxterm>return values</idxterm></i2>
</i1>Functions shall return float or double values in <xph>f0,</xph> with <xph>
float</xph> values rounded to single precision. Functions shall return values
of type <xph>int, long, </xph><ph propsrc="zser"><xph rev="v1r2">long long, 
</xph></ph><xph>enum, short</xph> and <xph>char, </xph>or a pointer to any
type as unsigned or signed integers as appropriate, zero- or sign-extended
to <ph propsrc="zser">64</ph><ph propsrc="s390">32</ph> bits if necessary,
in <xph>r2.</xph> <ph rev="v0r1">A structure or union whose size is 1, 2,
4 or 8 bytes</ph> shall be returned in <xph>r2</xph><ph propsrc="s390"> and <xph>
r3</xph></ph> as if it were first stored in an 8-byte aligned memory area
and then <ph propsrc="s390">the lower addressed half were </ph> loaded into <xph>
r2</xph><ph propsrc="s390"> and the higher into <xph rev="v0r1">r3</xph></ph>.
Bits beyond the last member of the structure or union are not defined. </p>
<p propsrc="s390">Values of type <xph>long long</xph> and <xph>unsigned long
long</xph> shall be returned with the lower addressed half in <xph>r2</xph> and
the higher in <xph>r3</xph>.</p>
<p>Values of type <xph>long double</xph> and structures or unions that do
not meet the requirements for being returned in registers are returned in
a storage buffer allocated by the caller. The address of this buffer is passed
as a hidden argument in <xph>r2</xph> as if it were the first argument, causing <xph>
gr</xph> in the argument passing algorithm above to be initialized to 3 instead
of <ph props="comment" rev="v0r1">4</ph><ph rev="v0r1">2</ph>.</p>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Operating system interface</title>
</titleblk></dprolog>
<dbody>
<d>
<dprolog><titleblk>
<title>Virtual address space</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>address space</idxterm></i1>
<i1><idxterm>virtual address</idxterm></i1>
<i1><idxterm>address</idxterm><i2><idxterm>virtual</idxterm></i2></i1>
<p>Processes execute in a <ph propsrc="zser">64</ph><ph propsrc="s390">31
</ph>-bit virtual address space. Memory management translates virtual addresses
to physical addresses, hiding physical addressing and letting a process run
anywhere in the system's real memory. Processes typically begin with three
logical segments, commonly called "text", "data" and "stack". An object file
may contain more segments (for example, for debugger use), and a process can
also create additional segments for itself with system services.</p>
<note><notebody>The term "virtual address" as used in this document refers
to a <ph propsrc="zser">64</ph><ph propsrc="s390">31</ph>-bit address generated
by a program, as contrasted with the physical address to which it is mapped.<ph
props="comment" rev="v0r1"> The <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> documentation refers to this type of address as a "virtual
address" or as an "effective address."</ph></notebody></note>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Page size</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>page size</idxterm></i1>
<p>Memory is organized into pages, which are the system's smallest units of
memory allocation. The hardware page size for <ph propsrc="zser">z/Architecture
</ph><ph propsrc="s390">the ESA/390 architecture</ph> is 4096 bytes.</p>
<p propsrc="zser"><?xpp:page></p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Virtual address assignments</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>virtual address</idxterm></i1>
<i1><idxterm>address</idxterm><i2><idxterm>virtual</idxterm></i2></i1>
<p>Processes have <ph rev="v1r2" propsrc="zser">a 42, 53 or 64</ph><ph propsrc="s390">
the full 31</ph>-bit address space available to them<ph rev="v1r2" propsrc="zser">
, depending on the &linuxs; kernel level</ph>.</p>
<p><xref refid="figvac"> shows the virtual address configuration on the <ph
propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph> architecture.
The segments with different properties are typically grouped in different
areas of the address space. The loadable segments may begin at zero (0); the
exact addresses depend on the executable file format (see <xref refid="chobjfiles"> and <xref
refid="chprogload">). The process' stack resides at the end of the virtual
memory and grows downwards. Processes can control the amount of virtual memory
allotted for stack space, as described below.</p>
<fig frame="box" id="figvac" propsrc="colfig"><cap><ph rev="v1r2" propsrc="zser">
42&ndash;bit virtual address configuration</ph><ph propsrc="s390">Virtual
address configuration</ph></cap>
<mmobj propsrc="s390"><objref obj="viradc32"><textalt><p><xmp>0x7fffffff   ------------------------------ End of memory
             |                            |
             |           Stack            |
             |                            |
            ------------------------------
             |                            |
             |      Dynamic segments      |
  Anonymous  |                            |
mapping base ------------------------------
             |                            |
             |            Heap            |
             |                            |
             ------------------------------
             |                            |
             |      Executable file       |
             |                            |
Program base  ------------------------------
             |                            |
             |         Unmapped           |
             |                            |
0x00000000   ------------------------------ Beginning of memory

</xmp></p></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="viradc64"><textalt><p><xmp>
0x3ffffffffff------------------------------ End of memory
             |                            |
             |           Stack            |
             |                            |
            ------------------------------
             |                            |
             |      Dynamic segments      |
  Anonymous  |                            |
mapping base ------------------------------
             |                            |
             |            Heap            |
             |                            |
             ------------------------------
             |                            |
             |      Executable file       |
             |                            |
Program base  ------------------------------
             |                            |
             |         Unmapped           |
             |                            |
0x00000000   ------------------------------ Beginning of memory

</xmp></p></textalt></mmobj>
</fig>
<note><notebody><i1><idxterm>application address</idxterm></i1><i1><idxterm>
address</idxterm><i2><idxterm>application</idxterm></i2></i1><i1><idxterm>
program base</idxterm></i1><i1><idxterm>dynamic segments</idxterm></i1>Although
application programs may begin at virtual address 0, they conventionally begin
above 0x1000 (4 Kbytes), leaving the initial 4 Kbytes with an invalid address
mapping. Processes that reference this invalid memory (for example by de-referencing
a null pointer) generate an translation exception as described in <xref refid="exceptionint">.
</notebody></note>
<note props="comment" rev="v0r1"><notebody>A program base of 0x00400000 (4
Mbytes) is recommended, for reasons given in <xref refid="chprogload">.</notebody>
</note>
<p>Although applications may control their memory assignments, the typical
arrangement follows the diagram above. When applications let the system choose
addresses for dynamic segments (including shared object segments), the system
will prefer addresses <ph rev="v1r2">in the upper half of the address space 
</ph><ph rev="v1r2" propsrc="s390">(above 1 Gbyte)</ph><ph rev="v1r2" propsrc="zser">
(for a 42&ndash;bit address space this means addresses above 1 TByte)</ph>.
</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Managing the process stack</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>process stack</idxterm></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>process</idxterm></i2></i1>
<p>The section <xref refid="procinit"> describes the initial stack contents.
Stack addresses can change from one system to the next &ndash; even from one
process execution to the next on a single system. A program, therefore, should
not depend on finding its stack at a particular virtual address.</p>
<p>A tunable configuration parameter controls the system maximum stack size.
A process can also use <xph>setrlimit</xph> to set its own maximum stack size,
up to the system limit. The stack segment is both readable and writable.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Coding guidelines</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>code</idxterm><i2><idxterm>guidelines</idxterm></i2></i1>
<i1><idxterm>address</idxterm><i2><idxterm>mapping</idxterm></i2></i1>
<p>Operating system facilities, such as <xph>mmap</xph>, allow a process to
establish address mappings in two ways. Firstly, the program can let the system
choose an address. Secondly, the program can request the system to use an
address the program supplies. The second alternative can cause application
portability problems because the requested address might not always be available.
Differences in virtual address space can be particularly troublesome between
different architectures, but the same problems can arise within a single architecture.
</p>
<p>Processes' address spaces typically have three segments that can change
size from one execution to the next: the stack (through <xph>setrlimit</xph>);
the data segment (through <xph>malloc</xph>); and the dynamic segment area
(through <xph>mmap</xph>).  Changes in one area may affect the virtual addresses
available for another. Consequently an address that is available in one process
execution might not be available in the next. Thus a program that used <xph>
mmap</xph> to request a mapping at a specific address could appear to work
in some environments and fail in others. For this reason programs that want
to establish a mapping in their address space should let the system choose
the address.</p>
<p>Despite these warnings about requesting specific addresses the facility
can be used properly.  For example, a multiprocess application might map several
files into the address space of each process and build relative pointers among
the files' data.  This could be done by having each process ask for a certain
amount of memory at an address chosen by the system.  After each process receives
its own private address from the system it would map the desired files into
memory at specific addresses within the original area.  This collection of
mappings could be at different addresses in each process but their relative
positions would be fixed.  Without the ability to ask for specific addresses,
the application could not build shared data structures because the relative
positions for files in each process would be unpredictable.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Processor execution modes</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>processor execution mode</idxterm></i1>
<i1><idxterm>problem state</idxterm></i1>
<i1><idxterm>user state</idxterm></i1>
<i1><idxterm>supervisor state</idxterm></i1>
<p>Two execution modes exist in <ph propsrc="zser">z/Architecture</ph><ph
propsrc="s390">the ESA/390 architecture</ph>: problem (user) state and supervisor
state. Processes run in problem state (the less privileged).  The operating
system kernel runs in supervisor state.  A program executes an supervisor
call (<xph>svc</xph>) instruction to change execution modes.</p>
<p>Note that the ABI does not define the implementation of individual system
calls. Instead programs shall use the system libraries. Programs with embedded
system call or <xph>trap</xph> instructions do not conform to the ABI. </p>
</dbody></d>
</dbody></d>
<?xpp:page>
<d id="exceptionint">
<dprolog><titleblk>
<title>Exception interface</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>exceptions</idxterm></i1>
<p>The <ph propsrc="zser">z/Architecture</ph><ph propsrc="s390">ESA/390</ph> exception
mechanism allows the processor to change to supervisor state as a result of
six different causes: system calls, I/O interrupts, external interrupts, machine
checks, restart interruptions or program checks (unusual conditions arising
in the execution of instructions).</p>
<p>When exceptions occur:<ol>
<li>information (such as the address of the next instruction to be executed
after control is returned to the original program) is saved,</li>
<li>program control passes from user to supervisor level, and</li>
<li>software continues execution at an address (the exception vector) predetermined
for each exception.</li>
</ol> </p>
<p>Exceptions may be synchronous or asynchronous. Synchronous exceptions,
being caused by instruction execution, can be explicitly generated by a process.
The operating system handles an exception either by completing the faulting
operation in a manner transparent to the application or by delivering a signal
to the application. The correspondence between exceptions and signals is shown
in <xref refid="exceptions">.</p>
<table id="exceptions"><cap>Exceptions and Signals</cap>
<tgroup cols="3">
<colspec colname="col1" colwidth="73*">
<colspec colname="col2" colwidth="45*">
<colspec colname="col3" colwidth="175*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Exception Name</ph></entry>
<entry colname="col2"><ph style="bold">Signal</ph></entry>
<entry colname="col3"><ph style="bold">Examples</ph></entry>
</row>
<row>
<entry colname="col1">Illegal instruction</entry>
<entry colname="col2"><xph>SIGILL</xph></entry>
<entry colname="col3">Illegal or privileged instruction, Invalid instruction
form, Optional, unimplemented instruction</entry>
</row>
<row>
<entry colname="col1">Storage access</entry>
<entry colname="col2"><xph>SIGSEGV</xph></entry>
<entry colname="col3">Unmapped instruction or data location access, Storage
protection violation</entry>
</row>
<row>
<entry colname="col1"><ph rev="v0r1">Alignment</ph></entry>
<entry colname="col2"><ph rev="v0r1"><xph>SIGBUS</xph></ph></entry>
<entry colname="col3"><ph rev="v0r1">Invalid data item alignment, Invalid
memory access</ph></entry>
</row>
<row>
<entry colname="col1">Breakpoint</entry>
<entry colname="col2"><xph>SIGTRAP</xph></entry>
<entry colname="col3">Breakpoint program check</entry>
</row>
<row>
<entry colname="col1">Floating exception</entry>
<entry colname="col2"><xph>SIGFPE</xph></entry>
<entry colname="col3">Floating point overflow or underflow, Floating point
divide by zero, Floating point conversion overflow, Other enabled floating
point exceptions</entry>
</row>
</tbody>
</tgroup>
</table>
<p>The signals that an exception may give rise to are <xph>SIGILL</xph>, <xph>
SIGSEGV</xph>, <xph>SIGBUS</xph>, <xph>SIGTRAP</xph>, and <xph>SIGFPE</xph>.
 If one of these signals is generated due to an exception when the signal
is blocked, the behavior is undefined. </p>
</dbody></d>
<d id="procinit">
<dprolog><titleblk>
<title>Process initialization</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>process initialization</idxterm></i1>
<i1><idxterm>initialization of process </idxterm></i1>
<i1><idxterm>main</idxterm><i2><idxterm>function</idxterm></i2></i1>
<i1><idxterm>main</idxterm><i2><idxterm>arguments</idxterm></i2></i1>
<i1><idxterm>function</idxterm><i2><idxterm>main</idxterm></i2></i1>
<i1><idxterm>arguments</idxterm><i2><idxterm>to main</idxterm></i2></i1>
<p>This section describes the machine state that <xph>exec</xph> creates for
"infant" processes, including argument passing, register usage, and stack
frame layout. Programming language systems use this initial program state
to establish a standard environment for their application programs. For example,
a C program begins executing at a function named <xph>main</xph>, conventionally
declared in the way described in <xref refid="declmain">:</p>
<fig frame="box" id="declmain" propsrc="colfig"><cap>Declaration for main
</cap>
<xmp>   extern int main (int argc, char *argv[ ], char *envp[ ]);</xmp>
</fig>
<p>Briefly, <xph>argc</xph> is a non-negative argument count; <xph>argv</xph> is
an array of argument strings, with <xph>argv[argc] == 0</xph>, and <xph>envp
</xph> is an array of environment strings, also terminated by a <xph>NULL
</xph> pointer.</p>
<p>Although this section does not describe C program initialization, it gives
the information necessary to implement the call to <xph>main</xph> or to the
entry point for a program in any other language.</p>
<d>
<dprolog><titleblk>
<title>Registers</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>register</idxterm><i2><idxterm>usage</idxterm></i2></i1>
<p>When a process is first entered (from an <xph>exec</xph> system call),
the contents of registers other than those listed below are unspecified. Consequently,
a program that requires registers to have specific values must set them explicitly
during process initialization.  It should not rely on the operating system
to set all registers to 0.  Following are the registers whose contents are
specified:</p>
<table>
<tgroup cols="2">
<colspec colname="col1" colwidth="27*">
<colspec colname="col2" colwidth="170*">
<tbody>
<row>
<entry colname="col1"><xph rev="v0r2">r15</xph></entry>
<entry colname="col2"><ph rev="v0r2">The initial stack pointer<i1><idxterm>
stack</idxterm><i2><idxterm>pointer</idxterm></i2></i1><i1><idxterm>pointer
</idxterm><i2><idxterm>stack</idxterm></i2></i1>, aligned to a 8-byte boundary
and pointing to a stack location that contains the argument count (see <xref
refid="processstack"> for further information about the initial stack layout)
</ph></entry>
</row>
<row>
<entry colname="col1"><xph rev="v0r2">fpc</xph></entry>
<entry colname="col2"><ph rev="v0r1">The floating point control register<i1>
<idxterm>floating point control register</idxterm></i1><i1><idxterm>register
</idxterm><i2><idxterm>floating point control</idxterm></i2></i1> contains
0, specifying "round to nearest" mode and the disabling of floating-point
exceptions</ph></entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
<d id="processstack">
<dprolog><titleblk>
<title>Process stack</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>process stack</idxterm></i1>
<i1><idxterm> stack</idxterm><i2><idxterm>process</idxterm></i2></i1>
<p>Every process has a stack, but the system defines no fixed stack address.
Furthermore, a program's stack address can change from one system to another &ndash; even
from one process invocation to another. Thus the process initialization code
must use the stack address in general purpose register <xph>r15</xph>. Data
in the stack segment at addresses below the stack pointer contain undefined
values.</p>
<p>Whereas the argument and environment vectors transmit information from
one application program to another, the auxiliary vector conveys information
from the operating system to the program. This vector is an array of structures,
which are defined in <xref refid="auxstruct">.</p>
<fig frame="box" id="auxstruct" propsrc="colfig"><cap>Auxiliary vector structure
</cap>
<i1><idxterm>auxiliary vector</idxterm></i1>
<xmp>typedef struct {
                <ph propsrc="s390">int</ph><ph rev="v1r2" propsrc="zser">
long</ph> a_type;
                union {
                       long a_val;
                       void *a_ptr;
                       void (*a_fcn)();
               } a_un;
} auxv_t;</xmp>
</fig>
<p>The structures are interpreted according to the <xph>a_type</xph> member,
as shown in <xref refid="auxtypes">.</p>
<table id="auxtypes"><cap>Auxiliary Vector Types, a_type</cap>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>types</idxterm></i2></i1>
<tgroup cols="3">
<?PubTbl tgroup dispwid="4.66in">
<colspec colname="col1" colwidth="112*">
<colspec colname="col2" colwidth="81*">
<colspec colname="col3" colwidth="103*">
<tbody>
<row>
<?PubTbl row rht="0.39in">
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Value</ph></entry>
<entry colname="col3"><ph style="bold">a_un</ph></entry>
</row>
<row>
<entry colname="col1">AT_NULL</entry>
<entry colname="col2">0</entry>
<entry colname="col3">ignored</entry>
</row>
<row>
<entry colname="col1">AT_IGNORE</entry>
<entry colname="col2">1</entry>
<entry colname="col3">ignored</entry>
</row>
<row>
<entry colname="col1">AT_EXECFD</entry>
<entry colname="col2">2</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_PHDR</entry>
<entry colname="col2">3</entry>
<entry colname="col3">a_ptr</entry>
</row>
<row>
<entry colname="col1">AT_PHENT</entry>
<entry colname="col2">4</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_PHNUM</entry>
<entry colname="col2">5</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_PAGESZ</entry>
<entry colname="col2">6</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_BASE</entry>
<entry colname="col2">7</entry>
<entry colname="col3">a_ptr</entry>
</row>
<row>
<entry colname="col1">AT_FLAGS</entry>
<entry colname="col2">8</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_ENTRY</entry>
<entry colname="col2">9</entry>
<entry colname="col3">a_ptr</entry>
</row>
<row>
<entry colname="col1">AT_NOTELF</entry>
<entry colname="col2">10</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_UID</entry>
<entry colname="col2">11</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_EUID</entry>
<entry colname="col2">12</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_GID</entry>
<entry colname="col2">13</entry>
<entry colname="col3">a_val</entry>
</row>
<row>
<entry colname="col1">AT_EGID</entry>
<entry colname="col2">14</entry>
<entry colname="col3">a_val</entry>
</row>
</tbody>
</tgroup>
</table>
<p><xph>a_type</xph> auxiliary vector types are described in <ph style="italic">
'Auxiliary Vector Types Description'</ph> below.</p>
<dl id="auxtypesdesc">
<dlblk><title><ph style="underlined bold">Auxiliary Vector Types Description
</ph></title>
<dlentry><term>AT_NULL</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>end</idxterm></i2></i1>
<defn>The auxiliary vector has no fixed length; so an entry of this type is
used to denote the end of the vector. The corresponding value of <xph>a_un
</xph> is undefined.</defn>
</dlentry>
<dlentry><term>AT_IGNORE</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>ignore</idxterm></i2>
</i1>
<defn>This type indicates the entry has no meaning. The corresponding value
of <xph>a_un</xph> is undefined.</defn>
</dlentry>
<dlentry><term>AT_EXECFD</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>file descriptor</idxterm>
</i2></i1>
<i1><idxterm>file descriptor, auxiliary vector</idxterm></i1>
<defn><xph>exec</xph> may pass control to an interpreter program. When this
happens, the system places either an entry of type <xph>AT_EXECFD</xph> or
one of type <xph>AT_PHDR</xph> in the auxiliary vector. The <xph>a_val</xph> field
in the <xph>AT_EXECFD</xph> entry contains a file descriptor for the application
program's object file.</defn>
</dlentry>
<dlentry><term>AT_PHDR</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>program header table</idxterm>
</i2></i1>
<i1><idxterm>program header table, auxiliary vector</idxterm></i1>
<defn>Under some conditions, the system creates the memory image of the application
program before passing control to an interpreter program. When this happens,
the <xph>a_ptr</xph> field of the <xph>AT_PHDR</xph> entry tells the interpreter
where to find the program header table in the memory image. If the <xph>AT_PHDR
</xph> entry is present, entries of types <xph>AT_PHENT, AT_PHNUM</xph> and <xph>
AT_ENTRY</xph> must also be present.  See the section <xref refid="chprogload"> for
more information about the program header table.</defn>
</dlentry>
<dlentry><term>AT_PHENT</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>entry size</idxterm></i2>
</i1>
<defn>The <xph>a_val</xph> field of this entry holds the size, in bytes, of
one entry in the program header table at which the <xph>AT_PHDR</xph> entry
points.</defn>
</dlentry>
<dlentry><term>AT_PHNUM</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>entries</idxterm></i2>
</i1>
<defn>The <xph>a_val</xph> field of this entry holds the number of entries
in the program header table at which the <xph>AT_PHDR</xph> entry points.
</defn>
</dlentry>
<dlentry><term>AT_PAGESZ</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>page size</idxterm></i2>
</i1>
<defn>If present this entry's <xph>a_val</xph> field gives the system page
size in bytes. The same information is also available through <xph>sysconf
</xph>.</defn>
</dlentry>
<dlentry><term>AT_BASE</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>base address</idxterm>
</i2></i1>
<i1><idxterm>base address, auxiliary vector</idxterm></i1>
<defn>The a_ptr member of this entry holds the base address at which the interpreter
program was loaded into memory.<ph props="comment"> See the section Program
Header in Chapter 5 of the System V ABI  for more information about the base
address.</ph></defn>
</dlentry>
<dlentry><term>AT_FLAGS</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>flags</idxterm></i2></i1>
<i1><idxterm>flags, auxiliary vector</idxterm></i1>
<defn>If present, the <xph>a_val</xph> field of this entry holds 1-bit flags.
Undefined bits are set to zero.</defn>
</dlentry>
<dlentry><term>AT_ENTRY</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>entry point</idxterm>
</i2></i1>
<defn>The <xph>a_ptr</xph> field of this entry holds the entry point of the
application program to which the interpreter program should transfer control.
</defn>
</dlentry>
<dlentry><term>AT_NOTELF</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>not ELF</idxterm></i2>
</i1>
<defn>The <xph>a_val</xph> field of this entry is non-zero if the program
is in another format than <xph>ELF</xph>, for example in the old <xph>COFF
</xph> format.</defn>
</dlentry>
<dlentry><term>AT_UID</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>real user id</idxterm>
</i2></i1>
<defn>The <xph>a_ptr</xph> field of this entry holds the real user id of the
process.</defn>
</dlentry>
<dlentry><term>AT_EUID</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>effective user id</idxterm>
</i2></i1>
<defn>The <xph>a_ptr</xph> field of this entry holds the effective user id
of the process.</defn>
</dlentry>
<dlentry><term>AT_GID</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>real group id</idxterm>
</i2></i1>
<defn>The <xph>a_ptr</xph> field of this entry holds the real group id of
the process.</defn>
</dlentry>
<dlentry><term>AT_EGID</term>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>effective group id</idxterm>
</i2></i1>
<defn>The <xph>a_ptr</xph> field of this entry holds the effective group id
of the process.</defn>
</dlentry>
</dlblk>
</dl>
<p>Other auxiliary vector types are reserved. No flags are currently defined
for <xph>AT_FLAGS</xph> on the <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> architecture. </p>
<p>When a process receives control, its stack holds the arguments, environment,
and auxiliary vector from <xph>exec</xph>.  Argument strings, environment
strings, and the auxiliary information appear in no specific order within
the information block; the system makes no guarantees about their relative
arrangement.  The system may also leave an unspecified amount of memory between
the null auxiliary vector entry and the beginning of the information block.
A sample initial stack is shown in <xref refid="inistack">.</p>
<fig frame="box" id="inistack" propsrc="colfig"><cap>Initial Process Stack
</cap>
<i1><idxterm>initial process stack</idxterm></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>initial process</idxterm></i2></i1>
<mmobj propsrc="s390"><objref obj="inipst32"><textalt><p><xmp>      ----------------------------------  Top of Stack
      |  Information block, including  |
      |  argument and environment      |
      |  strings and auxiliary         |
      |  information (size varies)     |
      ----------------------------------
      |        Unspecified             |
      ----------------------------------
      | AT_NULL auxiliary vector entry |
      ----------------------------------
      |       Auxiliary vector         |
      |       (2-word entries)         |
      ----------------------------------
      |          zero word             |
      ----------------------------------
      |       Environment pointers     |
      |          (1-word each)         |
      ----------------------------------
      |          zero word             |
      ----------------------------------
      |        Argument pointers       |
      |          (1-word each)         |
      ----------------------------------
      |      Argument count word       |
%r15  ----------------------------------  Low Address

</xmp></p></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="inipst64"><textalt><p><xmp>
      ----------------------------------  Top of Stack
      |  Information block, including  |
      |  argument and environment      |
      |  strings and auxiliary         |
      |  information (size varies)     |
      ----------------------------------
      |        Unspecified             |
      ----------------------------------
      | AT_NULL auxiliary vector entry |
      ----------------------------------
      |       Auxiliary vector         |
      |       (4-word entries)         |
      ----------------------------------
      |       zero doubleword          |
      ----------------------------------
      |       Environment pointers     |
      |          (2-word each)         |
      ----------------------------------
      |       zero doubleword          |
      ----------------------------------
      |        Argument pointers       |
      |          (2-word each)         |
      ----------------------------------
      |   Argument count doubleword    |
%r15  ----------------------------------  Low Address

</xmp></p></textalt></mmobj>
</fig>
</dbody></d>
</dbody></d>
<d id="codingexamples">
<dprolog><titleblk>
<title>Coding examples</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>code</idxterm><i2><idxterm>examples</idxterm></i2></i1>
<p>This section describes example code sequences for fundamental operations
such as calling functions, accessing static objects, and transferring control
from one part of a program to another. Previous sections discussed how a program
may use the machine or the operating system, and they specified what a program
may and may not assume about the execution environment.  Unlike previous material,
the information in this section illustrates how operations may be done, not
how they must be done.</p>
<p>As before, examples use the ANSI C language.  Other programming languages
may use the same conventions displayed below, but failure to do so does not
prevent a program from conforming to the ABI.  Two main object code models
are available:</p>
<dl>
<dlentry><term>Absolute code</term>
<i1><idxterm>absolute code</idxterm></i1>
<i1><idxterm>code</idxterm><i2><idxterm>absolute</idxterm></i2></i1>
<defn>Instructions can hold absolute addresses under this model. To execute
properly, the program must be loaded at a specific virtual address, making
the program's absolute addresses coincide with the process' virtual addresses.
</defn>
</dlentry>
<dlentry><term>Position-independent code</term>
<i1><idxterm>position-independent code</idxterm></i1>
<i1><idxterm>code</idxterm><i2><idxterm>position-independent</idxterm></i2>
</i1>
<defn>Instructions under this model hold relative addresses, not absolute
addresses. Consequently, the code is not tied to a specific load address,
allowing it to execute properly at various positions in virtual memory.</defn>
</dlentry>
</dl>
<p>The following sections describe the differences between these models. When
different, code sequences for the models appear together for easier comparison. 
</p>
<note><notebody>The examples below show code fragments with various simplifications.
They are intended to explain addressing modes, not to show optimal code sequences
or to reproduce compiler output.<ph props="comment" rev="v0r1"> None of them
reference data in the small data area.</ph></notebody></note>
<d>
<dprolog><titleblk>
<title>Code model overview</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>code</idxterm><i2><idxterm>model</idxterm></i2></i1>
<p>When the system creates a process image, the executable file portion of
the process has fixed addresses and the system chooses shared object library
virtual addresses to avoid conflicts with other segments in the process. 
To maximize text sharing, shared objects conventionally use position-independent
code, in which instructions contain no absolute addresses.  Shared object
text segments can be loaded at various virtual addresses without having to
change the segment images. Thus multiple processes can share a single shared
object text segment, even if the segment resides at a different virtual address
in each process.</p>
<p>Position-independent code relies on two techniques:</p>
<ul>
<li>Control transfer instructions hold addresses relative to the <ph props="comment"
rev="v0r1"><i1><idxterm>effective address</idxterm></i1>Effective Address
</ph><ph rev="v0r1"><i1><idxterm>current instruction address</idxterm></i1>Current
Instruction Address</ph> <ph props="comment" rev="v0r1">(EA)</ph><ph rev="v0r1">
(CIA)</ph>, or use registers that hold the transfer address. <ph props="comment"
rev="v0r1">An EA</ph><ph rev="v0r1">A CIA</ph>-relative branch computes its
destination address in terms of the <ph props="comment" rev="v0r1">current
EA</ph><ph rev="v0r1">CIA</ph>, not relative to any absolute address.</li>
<li>When the program requires an absolute address, it computes the desired
value. Instead of embedding absolute addresses in instructions (in the text
segment),  the compiler generates code to calculate an absolute address (in
a register or in the stack or data segment) during execution.</li>
</ul>
<p>Because <ph propsrc="zser">z/Architecture</ph><ph propsrc="s390">the ESA/390
architecture</ph> provides <ph props="comment" rev="v0r1">EA</ph><ph rev="v0r1">
CIA</ph>-relative branch instructions and also branch instructions using registers
that hold the transfer address, compilers can satisfy the first condition
easily. </p>
<p>A Global Offset Table (GOT),<i1><idxterm>Global Offset Table (GOT)</idxterm>
</i1> provides information for address calculation. Position-independent object
files (executable and shared object files) have a table in their data segment
that holds addresses. When the system creates the memory image for an object
file, the table entries are relocated to reflect the absolute virtual address
as assigned for an individual process.  Because data segments are private
for each process, the table entries can change &ndash; unlike text segments,
which multiple processes share.</p>
<p>Two position-independent models give programs a choice between more efficient
code with some size restrictions and less efficient code without those restrictions.
 Because of the processor architecture, a GOT with no more than <ph propsrc="s390">
1024</ph><ph rev="v1r2" propsrc="zser">512</ph> entries (4096 bytes) is more
efficient than a larger one. Programs that need more entries must use the
larger, more general code. In the following sections, the term "small model
position-independent code" is used to refer to code that assumes the smaller
GOT, and "large model position-independent code" is used to refer to the general
code. </p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Function prolog and epilog</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>prolog</idxterm></i2></i1>
<i1><idxterm>function</idxterm><i2><idxterm>epilog</idxterm></i2></i1>
<i1><idxterm>prolog, function</idxterm></i1>
<i1><idxterm>epilog, function</idxterm></i1>
<p>This section describes the prolog and epilog code of functions . A function's
prolog establishes a stack frame, if necessary, and may save any nonvolatile
registers it uses. A function's epilog generally restores registers that were
saved in the prolog code, restores the previous stack frame, and returns to
the caller. </p>
<p props="comment" rev="v0r1">Except for the rules below, this ABI does not
mandate predetermined code sequences for function prologs and epilogs.<ph
props="comment"><?Pub Dtl> However, the following rules, which permit reliable
call chain backtracing, shall be followed:</ph></p>
<i1><idxterm>stack</idxterm><i2><idxterm>frame</idxterm></i2></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>pointer</idxterm></i2></i1>
<i1><idxterm>pointer</idxterm><i2><idxterm>stack</idxterm></i2></i1>
<i1><idxterm>link register</idxterm></i1>
<i1><idxterm>register</idxterm><i2><idxterm>link</idxterm></i2></i1>
<ol props="comment">
<li>Before a function calls any other function, it shall establish its own
stack frame, the size of which shall be a multiple of 16 bytes, and shall
save the link register at the time of entry in the <xph>LR</xph> save word
of its caller's frame.</li>
<li>If a function establishes a stack frame, it shall update the back chain
word of the stack frame atomically with the stack pointer (<xph>r15</xph>)
using one of the "Store Word with Update" instructions.<ul>
<li>For small (no larger than 32 Kbytes) stack frames, this may be accomplished
with a "Store Word with Update" instruction with an appropriate negative displacement.
</li>
<li>For larger stack frames, the prolog shall load a volatile register with
the two's complement of the size of the frame (computed with <xph>addis</xph> and <xph>
addi</xph> or <xph>ori</xph> instructions) and issue a "Store Word with Update
Indexed" instruction.</li>
</ul></li>
<li>The only permitted references with negative offsets from the stack pointer
are those described here for establishing a stack frame.</li>
<li>When a function de-allocates its stack frame, it must do so atomically,
either by loading the stack pointer (<xph>r15</xph>) with the value in the
back chain field or by incrementing the stack pointer by the same amount by
which it has been decremented.</li>
</ol>
<p props="comment"><?Pub Dtl>Inline code may be used to save or restore nonvolatile
general or floating-point registers that the function uses. However, if there
are many registers to be saved or restored, it may be more efficient to call
one of the system subroutines described below.</p>
<p props="comment"><?Pub Dtl>A function that is position independent will
probably want to load a pointer to the global offset table into a nonvolatile
register. This may be omitted if the function makes no external data references.
If external data references are only made within conditional code, loading
the global offset table pointer may be deferred until it is known to be needed.
</p>
<d>
<dprolog><titleblk>
<title>Prolog</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>prolog</idxterm></i2></i1>
<i1><idxterm>prolog, function</idxterm></i1>
<i1><idxterm>stack</idxterm></i1>
<p>The prolog of a function has to save the state of the calling function
and set up the base register for the code of the function body. The following
is in general done by the function prolog:<ul>
<li>Save all registers used within the function which the calling function
assumes to be non-volatile.</li>
<li>Set up the base register for the literal pool.</li>
<li props="comment">Set up the argument pointer, if arguments are passed on
the stack.</li>
<li>Allocate stack space by decrementing the stack pointer.</li>
<li>Set up the dynamic chain by storing the old stack pointer value at stack
location zero<ph props="comment" rev="v0r1">. (This step is optional.)</ph><ph
rev="v0r1"> if the "back chain" is implemented.</ph></li>
<li>Set up the GOT pointer if the compiler is generating position independent
code. <p>(A function that is position independent will probably want to load
a pointer to the GOT into a nonvolatile register. This may be omitted if the
function makes no external data references. If external data references are
only made within conditional code, loading the GOT pointer may be deferred
until it is known to be needed.)</p></li>
<li>Set up the frame pointer if the function allocates stack space dynamically
(with <xph>alloca</xph>).</li>
</ul></p>
<p>The compiler tries to do as little as possible of the above; the ideal
case is to do nothing at all (for a leaf function without symbolic references).
</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Epilog</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>epilog</idxterm></i2></i1>
<i1><idxterm>epilog, function</idxterm></i1>
<p>The epilog of a function restores the registers saved in the prolog<ph
rev="v0r2"> (which include the stack pointer)</ph> and branches to the return
address.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Prolog and epilog example</title>
</titleblk></dprolog>
<dbody>
<fig frame="box" id="prolcode" propsrc="colfig"><cap>Prolog and epilog example
</cap>
<xmp propsrc="s390">.LC18:
          .string "hello, world\n"
          .align  4
          .globl  main
          .type   main,@function
main:
                                       # Prolog
          STM     11,15,44(15)         # Save callers registers
          BRAS    13,.LTN0_0           # Set up literal pool and branch over
.LT0_0:
.LC21:
          .long   .LC18
.LC22:
          .long   printf
.LTN0_0:
          LR      1,15                 # Load stack pointer in GPR 1
          AHI     15,-96               # Allocate stack space
          ST      1,0(15)              # Save backchain
                                       # Prolog end
          L       2,.LC21-.LT0_0(13)
          L       1,.LC22-.LT0_0(13)
          BASR    14,1
          SLR     2,2

                                       # Epilog
          L       4,152(15)            # Load return address
          LM      11,15,140(15)        # Restore registers
          BR      4                    # Branch back to caller
                                       # Epilog end

</xmp>
<xmp propsrc="zser">.section  .rodata
          .align 2
.LC0:
          .string "hello, world\n"
.text
          .align 4
.globl    main
          .type  main,@function
main:
                                       # Prolog
          STMG   11,15,88(15)          # Save callers registers
          LARL   13,.LT0_0             # Load literal pool pointer
.section  .rodata                      # Switch for literal pool
          .align 2                     #  to read-only data section
.LT0_0:
.LC2:
          .quad  65536
.LTN0_0:
.text                                  # Back to text section
          LGR    1,15                  # Load stack pointer in GPR 1
          AGHI   15,-160               # Allocate stack space
          STG    1,0(15)               # Store backchain
                                       # Prolog end
          LARL   2,.LC0
          LG     3,.LC2-.LT0_0(13)
          BRASL  14,printf
          LGHI   2,0
                                       # Epilog
          LG     4,272(15)             # Load return address
          LMG    11,15,248(15)         # Restore registers
          BR     4                     # Branch back to caller
                                       # Epilog end

</xmp>
</fig>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Profiling</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>profile</idxterm></i1>
<i1><idxterm>entry counting</idxterm></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>frame</idxterm></i2></i1>
<p>This section shows a way of providing profiling (entry counting) on <ph
propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph> systems.
An ABI-conforming system is not required to provide profiling; however if
it does this is one possible (not required) implementation.</p>
<p>If a function is to be profiled it has to call the <xph>_mcount</xph> routine
after the function prolog. This routine has a special linkage. It gets an
address in register 1 and returns without having changed any register. The
address is a pointer to a word-aligned one-word static data area, initialized
to zero, in which the <xph>_mcount</xph> routine is to maintain a count of
the number of <ph props="comment" rev="v0r1">entries</ph><ph rev="v0r1">times
the function is called</ph>.</p>
<p>For example <xref refid="profcode"> shows how the code after the function
prolog may look.</p>
<fig frame="box" id="profcode" propsrc="colfig"><cap>Code for profiling</cap>
<xmp propsrc="s390">          STM     7,15,28(15)          # Save callers registers
          BRAS    13,.LTN0_0           # Jump to function prolog
.LT0_0:
.LC3:     .long   _mcount              # Literal pool entry for _mcount
.LC4:     .long   .LP0                 # Literal pool entry for profile counter
.LTN0_0:
          LR      1,15                 # Stack pointer
          AHI     15,-96               # Allocate new
          ST      1,0(15)              # Save backchain
          LR      11,15                # Local stack pointer
          .data
          .align 4
.LP0:     .long   0                    # Profile counter
          .text
                                       # Function profiler
          ST    14,4(15)               # Preserve r14
          L     14,.LC3-.LT0_0(13)     # Load address of _mcount
          L     1,.LC4-.LT0_0(13)      # Load address of profile counter
          BASR  14,14                  # Branch to _mcount
          L     14,4(15)               # Restore r14

</xmp>
<xmp rev="v1r2" propsrc="zser">          STMG    7,15,56(15)          # Save callers registers
          LGR     1,15                 # Stack pointer
          AGHI    15,-160              # Allocate new
          STG     1,0(15)              # Save backchain
          LGR     11,15                # Local stack pointer
          .data
          .align 4
.LP0:     .quad   0                    # Profile counter
          .text
                                       # Function profiler
          STG   14,8(15)               # Preserve r14
          LARL  1,.LPO                 # Load address of profile counter
          BRASL 14,_mcount             # Branch to _mcount
          LG    14,8(15)               # Restore r14

</xmp>
</fig>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Data objects</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>data objects</idxterm></i1>
<p>This section describes only objects with static storage duration. It excludes
stack-resident objects because programs always compute their virtual addresses
relative to the stack or frame pointers.</p>
<i1><idxterm>address</idxterm><i2><idxterm>indirect</idxterm></i2></i1>
<p>Because <ph propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;
</ph> instructions cannot hold <ph propsrc="zser">64</ph><ph propsrc="s390">
31</ph>-bit addresses directly, a program has to build an address in a register
and access memory through that register. In order to do so a function normally
has a literal pool that holds the addresses of data objects used by the function.
Register 13 is set up in the function prolog to point to the start of this
literal pool.</p>
<p>Position-independent code cannot contain absolute addresses. In order to
access a local symbol the literal pool contains the (signed) offset of the
symbol relative to the start of the pool. Combining the offset loaded from
the literal pool with the address in register 13 gives the absolute address
of the local symbol. In the case of a global symbol the address of the symbol
has to be loaded from the Global Offset Table.<i1><idxterm>Global Offset Table
(GOT)</idxterm></i1> The offset in the GOT can either be contained in the
instruction itself or in the literal pool.<i1><idxterm>literal pool</idxterm>
</i1> See <xref refid="addresses"> for an example.</p>
<p><xref refid="addresses" form="text"> through <xref refid="largegot" form="text"> show
sample assembly language equivalents to C language code for absolute and position-independent
compilations. It is assumed that all shared objects are compiled as position-independent
and only executable modules may have absolute addresses. The code in the figures
contains many redundant operations as it is only intended to show how each
C statement could have been compiled independently of its context. The function
prolog is not shown, and it is assumed that it has loaded the address of the
literal pool in register 13.</p>
<fig id="addresses" propsrc="colfig"><cap>Absolute addressing</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colnum="1" colname="col1" colwidth="72*">
<colspec colnum="2" colname="col2" colwidth="121*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;








ptr = &amp;dst;







*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




                              # Literal pool
.LT0:
.LC1:      .long dst
.LC2:      .long src
                              # Code
           L     2,.LC1-.LT0(13)
           L     1,.LC2-.LT0(13)
           MVC   0(4,2),0(1)

                              # Literal pool
.LT0:
.LC1:      .long ptr
.LC2:      .long dst
                              # Code
           L     1,.LC1-.LT0(13)
           MVC   0(4,1),.LC2-.LT0(13)

                              # Literal pool
.LT0:
.LC1:      .long ptr
.LC2:      .long src
                              # Code
           L     1,.LC1-.LT0(13)
           L     2,.LC2-.LT0(13)
           L     3,0(1)
           MVC   0(4,3),0(2)</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colnum="1" colname="col1" colwidth="72*">
<colspec colnum="2" colname="col2" colwidth="121*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;



ptr = &amp;dst;



*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




           LARL  1,dst
           LARL  2,src
           MVC   0(4,1),0(2)

           LARL  1,ptr
           LARL  2,dst
           STG   2,0(1)

           LARL  2,ptr
           LG    1,0(2)
           LARL  2,src
           MVC   0(4,1),0(2)</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig id="smallgot" propsrc="colfig"><cap>Small model position-independent
addressing</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.97in">
<colspec colname="col1" colwidth="73*">
<colspec colname="col2" colwidth="122*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;









ptr = &amp;dst;









*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     2,dst@GOT(12)
           L     1,src@GOT(12)
           MVC   0(4,2),0(1)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,dst@GOT(12)
           ST    2,0(1)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,src@GOT(12)
           L     3,0(1)
           MVC   0(4,3),0(2)</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.97in">
<colspec colname="col1" colwidth="73*">
<colspec colname="col2" colwidth="122*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;





ptr = &amp;dst;




*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




           LARL  12,_GLOBAL_OFFSET_TABLE_
           LG    1,dst@GOT12(12)
           LG    2,src@GOT12(12)
           LGF   3,0(2)
           ST    3,0(1)

           LARL  12,_GLOBAL_OFFSET_TABLE_
           LG    1,ptr@GOT12(12)
           LG    2,dst@GOT12(12)
           STG   2,0(1)

           LARL  12,_GLOBAL_OFFSET_TABLE_
           LG    2,ptr@GOT12(12)
           LG    1,0(2)
           LG    2,src@GOT12(12)
           LGF   3,0(2)
           ST    3,0(1)</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig id="largegot" propsrc="colfig"><cap>Large model position-independent
addressing</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="73*">
<colspec colname="col2" colwidth="122*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; Assembler</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;













ptr = &amp;dst;













*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




                              # Literal pool
.LT0:
.LC1:      .long dst@GOT
.LC2:      .long src@GOT
.LC3:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC3-.LT0(13)
           LA    12,0(12,13)
           L     2,.LC1-.LT0(13)
           L     1,.LC2-.LT0(13)
           L     2,0(2,12)
           L     1,0(1,12)
           MVC   0(4,2),0(1)

                              # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long dst@GOT
.LC3:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC3-.LT0(13)
           LA    12,0(12,13)
           L     2,.LC1-.LT0(13)
           L     1,.LC2-.LT0(13)
           L     2,0(2,12)
           L     1,0(1,12)
           ST    1,0(2)

                              # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long src@GOT
.LC3:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L   12,.LC1-.LT0(13)
           LA  12,0(12,13)
           L   1,.LC1-.LT0(13)
           L   2,.LC2-.LT0(13)
           L   1,0(1,12)
           L   2,0(2,12)
           L   3,0(1)
           MVC 0(4,3),0(2)</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="73*">
<colspec colname="col2" colwidth="122*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; Assembler</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern int src;
extern int dst;
extern int *ptr;

dst = src;





ptr = &amp;dst;





*ptr = src;</xmp></entry>
<entry colname="col2"><xmp>




           LARL  2,dst@GOT
           LG    2,0(2)
           LARL  3,src@GOT
           LG    3,0(3)
           MVC   0(4,2),0(3)

           LARL  2,ptr@GOT
           LG    2,0(2)
           LARL  3,dst@GOT
           LG    3,0(3)
           STG   3,0(2)

           LARL  2,ptr@GOT
           LG    2,0(2)
           LG    1,0(2)
           LARL  3,src@GOT
           LG    3,0(3)
           MVC   0(4,1),0(3)</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Function calls</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>call</idxterm></i2></i1>
<p>Programs can use the <ph propsrc="zser">z/Architecture <xph rev="v1r2">
BRASL</xph> </ph><ph propsrc="s390">ESA/390 <xph>BRAS</xph> </ph> instruction
to make direct function calls. A <xph propsrc="s390">BRAS</xph><xph rev="v1r2"
propsrc="zser">BRASL</xph> instruction has a self-relative branch displacement
that can reach <ph propsrc="s390">64 Kbytes</ph><ph rev="v1r2" propsrc="zser">
4 GBytes</ph> in either direction.<ph propsrc="s390"> Hence the use of the <xph>
BRAS</xph> instruction is limited to very rare cases.</ph> <ph propsrc="s390">
The <ph rev="v0r1">usual method of calling</ph> a function is to</ph><ph rev="v1r2"
propsrc="zser">To call functions beyond this limit (inter-module calls)</ph> load
the address in a register and use the <xph>BASR</xph> instruction for the
call. Register 14 is used as the first operand of <xph>BASR</xph> to hold
the return address as shown in <xref refid="fncalldirect">.</p>
<p><ph props="comment"><?Pub Dtl>A compiler normally generates the <xph>BRAS
</xph> instruction to call a function as shown in <xref refid="branchinsn">. 
</ph>The called function may be in the same module (executable or shared object)
as the caller, or it may be in a different module. <ph props="comment" rev="v0r1"><?Pub Dtl>
In the former case, the linkage editor resolves the symbol and the address
is written to the literal pool.. In the latter case,</ph><ph rev="v0r1">In
the former case, if the called function is not in a shared object, the linkage
editor resolves the symbol<ph props="comment" rev="v1r2"> and the address
is written to the literal pool</ph>. In all other cases</ph> the linkage editor
cannot directly resolve the symbol. Instead the linkage editor generates "glue"
code and <ph props="comment" rev="v1r2">inserts the address of the glue code
in the literal pool</ph><ph rev="v1r2">resolves the symbol to point to the
glue code</ph>. The dynamic linker will provide the real address of the function
in the Global Offset Table.<i1><idxterm>Global Offset Table (GOT)</idxterm>
</i1> The glue code loads this address and branches to the function itself.
See <xref refid="procedurelinkagetable"> for more details.</p>
<fig id="fncalldirect" rev="v0r1" propsrc="colfig"><cap>Absolute <ph propsrc="s390">
direct</ph> function call</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.03in">
<colspec colname="col1" colwidth="75*">
<colspec colname="col2" colwidth="123*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;








func();





(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                              # Literal pool
.LT0:
.LC1:      .long ptr
.LC2:      .long func
                              # Code
           L     1,.LC1-.LT0(13)
           MVC   0(4,1),.LC2-.LT0(13)

                              # Literal pool
.LT0:
.LC1:      .long func
                              # Code
           L     1,.LC1-.LT0(13)
           BASR  14,1

                              # Literal pool
.LT0:
.LC1:      .long ptr
                              # Code
           L     1,.LC1-.LT0(13)
           L     1,0(1)
           BASR  14,1</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.03in">
<colspec colname="col1" colwidth="75*">
<colspec colname="col2" colwidth="123*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;



func();

(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



           LARL  1,ptr
           LARL  2,func
           STG   2,0(1)

           BRASL 14,func

           LARL  1,ptr
           LG    1,0(1)
           BASR  14,1</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig id="fnsmalldirect" rev="v0r1" propsrc="colfig"><cap>Small model position-independent <ph
propsrc="s390">direct</ph> function call</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;









func();











(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,func@GOT(12)
           ST    2,0(1)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
.LC2:      .long func@PLT-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,.LC2-.LT0(13)
           BAS   14,0(1,13)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,0(1)
           BASR  14,2</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;




func();

(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



           LARL  12,_GLOBAL_OFFSET_TABLE_
           LG    1,ptr@GOT12(12)
           LG    2,func@GOT12(12)
           STG   2,0(1)

           BRASL 14,func@PLT

           LARL  12,_GLOBAL_OFFSET_TABLE_
           LG    1,ptr@GOT12(12)
           LG    1,0(1)
           BASR  14,1</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig id="fnlargedirect" rev="v0r1" propsrc="colfig"><cap>Large model position-independent <ph
propsrc="s390">direct</ph> function call</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colname="col1" colwidth="72*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;














func();








(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                              # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long func@GOT
.LC3:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC3-.LT0(13)
           LA    12,0(12,13)
           L     2,.LC1-.LT0(13)
           L     1,.LC2-.LT0(13)
           L     2,0(2,12)
           L     1,0(1,12)
           ST    1,0(2)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
.LC2:      .long func@PLT-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,.LC2-.LT0(13)
           BAS   14,0(1,13)

                             # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                             # Code
           L     12,.LC2-.LT0(13)
           LA    12,0(12,13)
           L     1,.LC1-.LT0(13)
           L     1,0(1,12)
           L     2,0(1)
           BASR  14,2</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colname="col1" colwidth="72*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr)();

ptr = func;





func();

(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



           LARL  2,ptr@GOT
           LG    2,0(2)
           LARL  3,func@GOT
           LG    3,0(3)
           STG   3,0(2)
           
           BRASL 14,func@PLT

           LARL  2,ptr@GOT
           LG    2,0(2)
           LG    2,0(2)
           BASR  14,2</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<p propsrc="s390"><fig id="fncall" propsrc="colfig"><cap>Absolute indirect
function call</cap>
<p><table>
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.03in">
<colspec colname="col1" colwidth="75*">
<colspec colname="col2" colwidth="123*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr) ();

ptr = func;







(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                             # Literal pool
.LT0:
.LC1:     .long ptr
.LC2:     .long func
                             # Code
          L     1,.LC1-.LT0(13)
          MVC   0(4,1),.LC2-.LT0(13)

                             # Literal pool
.LT0:
.LC1:     .long ptr
                             # Code
          L     1,.LC1-.LT0(13)
          L     1,0(1)
          BASR  14,1</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig><fig id="fnsmallgot" propsrc="colfig"><cap>Small model position-independent
indirect function call</cap>
<p><table>
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr) ();

ptr = func;









(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC2-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,func@GOT(12)
           ST    2,0(1)

                              # Literal pool
.LT0:
.LC1:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC1-.LT0(13)
           LA    12,0(12,13)
           L     1,ptr@GOT(12)
           L     2,0(1)
           BASR  14,2</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig><fig id="fnlargegot" propsrc="colfig"><cap>Large model position-independent
indirect function call</cap>
<p><table>
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.02in">
<colspec colname="col1" colwidth="72*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>extern void func();
extern void (*ptr) ();

ptr = func;













(*ptr) ();</xmp></entry>
<entry colname="col2"><xmp>



                              # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long func@GOT
.LC3:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                              # Code
           L     12,.LC3-.LT0(13)
           LA    12,0(12,13)
           L     2,.LC1-.LT0(13)
           L     1,.LC2-.LT0(13)
           L     2,0(2,12)
           L     1,0(1,12)
           ST    1,0(2)

                              # Literal pool
.LT0:
.LC1:      .long ptr@GOT
.LC2:      .long _GLOBAL_OFFSET_TABLE_-.LT0
                             # Code
           L     12,.LC2-.LT0(13)
           LA    12,0(12,13)
           L     1,.LC1-.LT0(13)
           L     1,0(1,12)
           L     2,0(1)
           BASR  14,2</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig></p>
<p propsrc="zser"><?xpp:page></p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Branching</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>branch instructions</idxterm></i1>
<p>Programs use branch instructions to control their execution flow. <ph propsrc="zser">
z/Architecture</ph><ph rev="v0r1" propsrc="s390">The ESA/390 architecture
</ph> has a variety of branch instructions. The most commonly used of these
performs a self-relative jump with a 128-Kbyte range (up to 64 Kbytes in either
direction). <ph rev="v1r2" propsrc="zser">For large functions another self-relative
jump is available with a range of 4 Gbytes (up to 2 Gbytes in either direction).
</ph></p>
<fig id="branchinsn" propsrc="colfig"><cap>Branch instruction</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>label:
        ...
        goto label;</xmp></entry>
<entry colname="col2"><xmp rev="v0r2">.L01:
           ...
           BRC 15,.L01</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.99in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>label:
        ...
        goto label;
        ...
        ...
        ...
farlabel:
        ...
        ...
        ...
        goto farlabel;</xmp></entry>
<entry colname="col2"><xmp rev="v0r2">.L01:
           ...
           BRC 15,.L01
           ...
           ...
           ...
.L02:
           ...
           ...
           ...
           BRCL 15,.L02</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<i1><idxterm>switch</idxterm></i1>
<p></p>
<p>C language <xph>switch</xph> statements provide multi-way selection. When
the <xph>case</xph> labels of a <xph>switch</xph> statement satisfy grouping
constraints the compiler implements the selection with an address table. The
following examples use several simplifying conventions to hide irrelevant
details:</p>
<ol>
<li>The selection expression resides in register 2.</li>
<li>The case label constants begin at zero.</li>
<li>The case labels, the default, and the address table use assembly names <xph>
.Lcase</xph><ph style="italic">i</ph>, <xph>.Ldef</xph> and <xph>.Ltab</xph> respectively.
</li>
</ol>
<fig id="absswitch" propsrc="colfig"><cap>Absolute switch code</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.97in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>switch(j)
{
case 0:
        ...
case 1:
        ...
case 3:
        ...
default:
}</xmp></entry>
<entry colname="col2"><xmp rev="v0r2">                              # Literal pool
.LT0:
.LC1:      .long .Ltab
                              # Code
           LHI    1,3
           CLR    2,1
           BRC    2,.Ldef
           SLL    2,2
           A      2,.LC1-.LT0(13)
           L      1,0(2)
           BR     1
.Ltab:     .long .Lcase0
           .long .Lcase1
           .long .Ldef
           .long .Lcase3</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="7.97in">
<colspec colname="col1" colwidth="74*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>switch(j)
{
case 0:
        ...
case 1:
        ...
case 3:
        ...
default:
}</xmp></entry>
<entry colname="col2"><xmp rev="v0r2">           LGHI  1,3
           CLGR  2,1
           BRC   2,.Ldef
           SLLG  2,2,3
           LARL  1,.Ltab
           LG    3,0(1,2)
           BR    3
.Ltab:     .quad .Lcase0
           .quad .Lcase1
           .quad .Ldef
           .quad .Lcase3</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
<fig id="indswitch" propsrc="colfig"><cap>Position-independent switch code,
all models</cap>
<p><table propsrc="s390">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.03in">
<colspec colname="col1" colwidth="71*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system32; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>switch(j)
{
case 0:
        ...
case 1:
        ...
case 3:
        ...
default:
}</xmp></entry>
<entry colname="col2"><xmp rev="v0r1">                              # Literal pool
.LT0:
.LC1:      .long .Ltab-.LT0
                              # Code
           LHI   1,3
           CLR   2,1
           BRC   2,.Ldef
           SLL   2,2
           L     1,.LC1-.LT0(13)
           LA    1,0(1,13)
           L     2,0(1,2)
           LA    2,0(2,13)
           BR    2
.Ltab:     .long .Lcase0-.LT0
           .long .Lcase1-.LT0
           .long .Ldef-.LT0
           .long .Lcase3-.LT0</xmp></entry>
</row>
</tbody>
</tgroup>
</table><table propsrc="zser" rev="v1r2">
<tgroup cols="2">
<?PubTbl tgroup dispwid="8.03in">
<colspec colname="col1" colwidth="71*">
<colspec colname="col2" colwidth="124*">
<thead>
<row>
<entry colname="col1" valign="top">C</entry>
<entry colname="col2" valign="top">&system64; machine instructions (Assembler)
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="col1"><xmp>switch(j)
{
case 0:
        ...
case 1:
        ...
case 3:
        ...
default:
}</xmp></entry>
<entry colname="col2"><xmp rev="v0r1">                              # Literal pool
.LT0:

                              # Code
            LGHI  1,3
            CLGR  2,1
            BRC   2,.Ldef
            SLLG  2,2,3
            LARL  1,.Ltab
            LG    3,0(1,2)
            AGR   3,13
            BR    3
.Ltab:      .quad .Lcase0-.LT0
            .quad .Lcase1-.LT0
            .quad .Ldef-.LT0
            .quad .Lcase3-.LT0</xmp></entry>
</row>
</tbody>
</tgroup>
</table></p>
</fig>
</dbody></d>
<d id="dynamicstack">
<dprolog><titleblk>
<title>Dynamic stack space allocation</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>dynamic stack space allocation</idxterm></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>dynamic space allocation</idxterm>
</i2></i1>
<i1><idxterm>space allocation</idxterm></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>frame</idxterm></i2></i1>
<i1><idxterm>stack</idxterm><i2><idxterm>pointer</idxterm></i2></i1>
<i1><idxterm>pointer</idxterm><i2><idxterm>stack</idxterm></i2></i1>
<i1><idxterm>frame pointer</idxterm></i1>
<i1><idxterm>pointer</idxterm><i2><idxterm>frame</idxterm></i2></i1>
<i1><idxterm>function</idxterm><i2><idxterm>allocating dynamic stack</idxterm>
</i2></i1>
<i1><idxterm>parameter</idxterm><i2><idxterm>list</idxterm></i2></i1>
<p props="comment">Unlike some other languages, C does not need dynamic stack
allocation within a stack frame. Frames are allocated dynamically on the program
stack, depending on program execution, but individual stack frames can have
static sizes. Nevertheless, the architecture supports dynamic allocation for
those languages that require it. The mechanism for allocating dynamic space
is embedded completely within a function and does not affect the standard
calling sequence. Thus languages that need dynamic stack frame sizes can call
C functions, and vice versa.</p>
<p>The GNU C compiler, and most recent compilers, support dynamic stack space
allocation via <xph>alloca</xph>.</p>
<p><xref refid="dynstackalloc" form="text"> shows the stack frame before and
after dynamic stack allocation. The local variables area is used for storage
of function data, such as local variables, whose sizes are known to the compiler.
This area is allocated at function entry and does not change in size or position
during the function's activation.</p>
<p>The parameter list area holds "overflow" arguments passed in calls to other
functions. (See the <xph>OTHER</xph> label in <xref refid="parameterpassing">.)
Its size is also known to the compiler and can be allocated along with the
fixed frame area at function entry. However, the standard calling sequence
requires that the parameter list area begin at a fixed offset (<ph propsrc="zser">
&stacksize64;</ph><ph propsrc="s390">&stacksize32;</ph>) from the stack pointer,
so this area must move when dynamic stack allocation occurs. </p>
<p>Data in the parameter list area are naturally addressed at constant offsets
from the stack pointer. However, in the presence of dynamic stack allocation,
the offsets from the stack pointer to the data in the local variables area
are not constant. To provide addressability a frame pointer is established
to locate the local variables area consistently throughout the function's
activation. </p>
<p>Dynamic stack allocation is accomplished by "opening" the stack just above
the parameter list area. The following steps show the process in detail:</p>
<ol>
<li>After a new stack frame is acquired, and before the first dynamic space
allocation, a new register, the frame pointer or FP, is set to the value of
the stack pointer. The frame pointer is used for references to the function's
local, non-static variables.<ph rev="v0r2"> The frame pointer does not change
during the execution of a function, even though the stack pointer may change
as a result of dynamic allocation.</ph></li>
<li>The amount of dynamic space to be allocated is rounded up to a multiple
of 8 bytes, so that 8-byte stack alignment is maintained.</li>
<li>The stack pointer is decreased by the rounded byte count, and the address
of the previous stack frame (the back chain) may be stored at the word addressed
by the new stack pointer. <ph props="comment">This will be accomplished atomically
by using <xph>stwu rS,-length(r1)</xph> if the length is less than 32768 bytes,
or by using <xph>stwux rS,r1,rspace</xph>, where <xph>rS</xph> is the contents
of the back chain word and <xph>rspace</xph> contains the (negative) rounded
number of bytes to be allocated.</ph><ph>The back chain is not necessary to
restore from this allocation at the end of the function since the frame pointer
can be used to restore the stack pointer.</ph></li>
</ol>
<p rev="v0r2"><xref refid="dynstackalloc"> is a snapshot of the stack layout
after the prolog code has dynamically extended the stack frame.</p>
<fig frame="box" id="dynstackalloc" propsrc="colfig"><cap>Dynamic Stack Space
Allocation</cap>
<mmobj rev="v0r2" propsrc="s390"><objref obj="dynams32"><textalt><p><xmp>
        Before Dynamic Stack Allocation           After Dynamic Stack Allocation

      |                                |        |                                |
      |                                |        |                                |
      |      Previous stack frame      |        |      Previous stack frame      |
      |                                |        |                                |
      ----------------------------------        ----------------------------------
      |                                |        |                                |
   -->|      Back chain (optional)     |     -->|      Back chain (optional)     |
 /    |                                |   /    |                                |
|     ----------------------------------  |     ----------------------------------
|     |                                |  |     |                                |
|     |  Local and spill variable area |  |     |  Local and spill variable area |
|     |      of calling function       |  |     |      of calling function       |
| 96+n|                                |  |     |                                |  &lt;---  FP+96+n
|     ----------------------------------  |     ----------------------------------      |
|     |                                |  |     |                                |      |
|     |        Parameter area          |  |     |                                |      |
|     |   passed to called function    |  |     |                                |      |
|   96|                                |  |     |                                |      |
|     ----------------------------------  |     |                                |      |
|     |                                |  |     |                                |      |
|     |      Register save area        |  |     |                                |      |
|     |   for called function use      |  |     |                                |      |
|    8|                                |  |     |                                |      |
|     ----------------------------------  |     |                                |      |
|     |                                |  |     |                                |      |
|     |     Reserved for compiler use  |  |     |                                |      |
|     |                                |  |     |                                |      |
 \    ----------------------------------  |     |                                |      |
  ----|                                |  |     |                                |      |
 SP-> |      Back chain (optional)     |  |     |                                |  &lt;-- FP
     0|                                |  |     |                                |
      ----------------------------------  |     |    Dynamic Allocation Area     |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          | 96+n|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |        Parameter area          |
                                          |     |   passed to called function    |
                                          |   96|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |      Register save area        |
                                          |     |   for called function use      |
                                          |    8|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |     Reserved for compiler use  |
                                          |     |                                |
                                           \    ----------------------------------
                                             ----                                |
                                           SP-> |      Back chain (optional)     |
                                               0|                                |
                                                ----------------------------------

</xmp></p></textalt></mmobj>
<mmobj rev="v0r2" propsrc="zser"><objref obj="dynams64"><textalt><p><xmp>
        Before Dynamic Stack Allocation           After Dynamic Stack Allocation

      |                                |        |                                |
      |                                |        |                                |
      |      Previous stack frame      |        |      Previous stack frame      |
      |                                |        |                                |
      ----------------------------------        ----------------------------------
      |                                |        |                                |
   -->|      Back chain (optional)     |     -->|      Back chain (optional)     |
 /    |                                |   /    |                                |
|     ----------------------------------  |     ----------------------------------
|     |                                |  |     |                                |
|     |  Local and spill variable area |  |     |  Local and spill variable area |
|     |      of calling function       |  |     |      of calling function       |
|160+n|                                |  |     |                                |  &lt;---  FP+160+n
|     ----------------------------------  |     ----------------------------------      |
|     |                                |  |     |                                |      |
|     |        Parameter area          |  |     |                                |      |
|     |   passed to called function    |  |     |                                |      |
|  160|                                |  |     |                                |      |
|     ----------------------------------  |     |                                |      |
|     |                                |  |     |                                |      |
|     |      Register save area        |  |     |                                |      |
|     |   for called function use      |  |     |                                |      |
|   16|                                |  |     |                                |      |
|     ----------------------------------  |     |                                |      |
|     |                                |  |     |                                |      |
|     |     Reserved for compiler use  |  |     |                                |      |
|     |                                |  |     |                                |      |
 \    ----------------------------------  |     |                                |      |
  ----|                                |  |     |                                |      |
 SP-> |      Back chain (optional)     |  |     |                                |  &lt;-- FP
     0|                                |  |     |                                |
      ----------------------------------  |     |    Dynamic Allocation Area     |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |     |                                |
                                          |160+n|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |        Parameter area          |
                                          |     |   passed to called function    |
                                          |  160|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |      Register save area        |
                                          |     |   for called function use      |
                                          |   16|                                |
                                          |     ----------------------------------
                                          |     |                                |
                                          |     |     Reserved for compiler use  |
                                          |     |                                |
                                           \    ----------------------------------
                                             ----                                |
                                           SP-> |      Back chain (optional)     |
                                               0|                                |
                                                ----------------------------------

</xmp></p></textalt></mmobj>
</fig>
<p>The above process can be repeated as many times as desired within a single
function activation. When it is time to return, the stack pointer is set to
the value of the back chain, thereby removing all dynamically allocated stack
space along with the rest of the stack frame. Naturally, a program must not
reference the dynamically allocated stack area after it has been freed. </p>
<p>Even in the presence of signals, the above dynamic allocation scheme is
"safe." If a signal interrupts allocation, one of three things can happen:
</p>
<ul>
<li>The signal handler can return. The process then resumes the dynamic allocation
from the point of interruption.</li>
<li>The signal handler can execute a non-local goto or a jump. This resets
the process to a new context in a previous stack frame, automatically discarding
the dynamic allocation.</li>
<li>The process can terminate.</li>
</ul>
<p>Regardless of when the signal arrives during dynamic allocation, the result
is a consistent (though possibly dead) process.</p>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>DWARF definition</title>
</titleblk></dprolog>
<dbody>
<i1 seetext="Debug with Arbitrary Record Format" seeid="dwarf" props="comment">
<idxterm>DWARF</idxterm></i1>
<i1 id="dwarf"><idxterm>Debug with Arbitrary Record Format (DWARF)</idxterm>
</i1>
<p>This section defines the "Debug with Arbitrary Record Format" (DWARF) debugging
format for the <ph propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;
</ph> processor family. The <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> ABI does not define a debug format. However, all systems that
do implement DWARF shall use the following definitions.</p>
<p>DWARF is a specification developed for symbolic source-level debugging.
The debugging information format does not favor the design of any compiler
or debugger.</p>
<p>The DWARF definition requires some machine-specific definitions. The register
number mapping is specified for the <ph propsrc="zser">&system64;</ph><ph
propsrc="s390">&system32;</ph> processors in <xref refid="dwarfreg">.<ph props="comment"
rev="v0r2"> In addition, the DWARF Version 2 specification requires processor-specific
address class codes to be defined.</ph></p>
<i1><idxterm>register</idxterm><i2><idxterm>DWARF mapping</idxterm></i2></i1>
<table id="dwarfreg"><cap>DWARF register number mapping</cap>
<tgroup cols="2">
<colspec colname="col1">
<colspec colname="col2">
<tbody>
<row>
<entry colname="col1">DWARF number</entry>
<entry colname="col2"><ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> register</entry>
</row>
<row>
<entry colname="col1"><xph>0-15</xph></entry>
<entry colname="col2"><xph>gpr0-gpr15</xph></entry>
</row>
<row>
<entry colname="col1"><xph>16</xph></entry>
<entry colname="col2"><xph>fpr0</xph></entry>
</row>
<row>
<entry colname="col1"><xph>17</xph></entry>
<entry colname="col2"><xph>fpr2</xph></entry>
</row>
<row>
<entry colname="col1"><xph>18</xph></entry>
<entry colname="col2"><xph>fpr4</xph></entry>
</row>
<row>
<entry colname="col1"><xph>19</xph></entry>
<entry colname="col2"><xph>fpr6</xph></entry>
</row>
<row>
<entry colname="col1"><xph>20</xph></entry>
<entry colname="col2"><xph>fpr1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>21</xph></entry>
<entry colname="col2"><xph>fpr3</xph></entry>
</row>
<row>
<entry colname="col1"><xph>22</xph></entry>
<entry colname="col2"><xph>fpr5</xph></entry>
</row>
<row>
<entry colname="col1"><xph>23</xph></entry>
<entry colname="col2"><xph>fpr7</xph></entry>
</row>
<row>
<entry colname="col1"><xph>24</xph></entry>
<entry colname="col2"><xph>fpr8</xph></entry>
</row>
<row>
<entry colname="col1"><xph>25</xph></entry>
<entry colname="col2"><xph>fpr10</xph></entry>
</row>
<row>
<entry colname="col1"><xph>26</xph></entry>
<entry colname="col2"><xph>fpr12</xph></entry>
</row>
<row>
<entry colname="col1"><xph>27</xph></entry>
<entry colname="col2"><xph>fpr14</xph></entry>
</row>
<row>
<entry colname="col1"><xph>28</xph></entry>
<entry colname="col2"><xph>fpr9</xph></entry>
</row>
<row>
<entry colname="col1"><xph>29</xph></entry>
<entry colname="col2"><xph>fpr11</xph></entry>
</row>
<row>
<entry colname="col1"><xph>30</xph></entry>
<entry colname="col2"><xph>fpr13</xph></entry>
</row>
<row>
<entry colname="col1"><xph>31</xph></entry>
<entry colname="col2"><xph>fpr15</xph></entry>
</row>
<row>
<entry colname="col1"><xph>32&ndash;47</xph></entry>
<entry colname="col2"><xph rev="v0r1">cr0-cr15</xph></entry>
</row>
<row>
<entry colname="col1"><xph>48&ndash;63</xph></entry>
<entry colname="col2"><xph rev="v0r1">ar0-ar15</xph></entry>
</row>
<row>
<entry colname="col1"><xph>64</xph></entry>
<entry colname="col2"><xph rev="v0r1">PSW mask</xph></entry>
</row>
<row>
<entry colname="col1"><xph>65</xph></entry>
<entry colname="col2"><xph rev="v0r1">PSW address</xph></entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
</dbody></d>
<d id="chobjfiles">
<dprolog><titleblk>
<title>Object files</title>
</titleblk></dprolog>
<dintro><toc><gendtitle></toc></dintro>
<dbody>
<p>This section describes the Executable and Linking Format (ELF).</p>
<i1><idxterm>object file</idxterm></i1>
<d>
<dprolog><titleblk>
<title>ELF Header</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>ELF header</idxterm></i1>
<i1><idxterm>header</idxterm><i2><idxterm>ELF</idxterm></i2></i1>
<i1><idxterm>file identification</idxterm></i1>
<i1><idxterm>processor identification</idxterm></i1>
<d>
<dprolog><titleblk>
<title>Machine Information</title>
</titleblk></dprolog>
<dbody>
<p>For file identification in <xph>e_ident</xph> the <ph propsrc="zser">&system64;
</ph><ph propsrc="s390">&system32;</ph> processor family requires the values
shown in <xref refid="eident">.</p>
<table id="eident"><cap>Auxiliary Vector Types Description</cap>
<i1><idxterm>auxiliary vector</idxterm><i2><idxterm>types</idxterm></i2></i1>
<tgroup cols="3">
<colspec colname="col1">
<colspec colname="col2">
<colspec colname="col3">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Position</ph></entry>
<entry colname="col2"><ph style="bold">Value</ph></entry>
<entry colname="col3"><ph style="bold">Comments</ph></entry>
</row>
<row>
<entry colname="col1"><xph>e_ident[EI_CLASS]</xph></entry>
<entry colname="col2"><xph propsrc="zser">ELFCLASS64</xph><xph propsrc="s390">
ELFCLASS32</xph></entry>
<entry colname="col3">For all <ph propsrc="zser">64</ph><ph propsrc="s390">
32</ph>bit implementations</entry>
</row>
<row>
<entry colname="col1"><xph>e_ident[EI_DATA]</xph></entry>
<entry colname="col2"><xph propsrc="zser">ELFDATA64MSB</xph><xph propsrc="s390">
ELFDATA32MSB</xph></entry>
<entry colname="col3">For all Big-Endian implementations</entry>
</row>
</tbody>
</tgroup>
</table>
<p>The ELF header's <xph>e_flags</xph> field holds bit flags associated with
the file. Since the <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> processor family defines no flags, this member contains zero.
</p>
<p>Processor identification resides in the ELF header's<i1><idxterm>ELF header
</idxterm></i1> <xph>e_machine</xph> field and must have the value 22, defined
as the name <xph>EM_S390</xph>.</p>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Sections</title>
</titleblk></dprolog>
<dbody>
<d>
<dprolog><titleblk>
<title>Special Sections</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>special sections</idxterm></i1>
<i1><idxterm>section</idxterm><i2><idxterm>special</idxterm></i2></i1>
<p>Various sections hold program and control information.  The sections listed
in <xref refid="sections"> are used by the system and have the types and attributes
shown.</p>
<table id="sections"><cap>Special Sections</cap>
<tgroup cols="3">
<colspec colname="col1">
<colspec colname="col2">
<colspec colname="col3">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Type</ph></entry>
<entry colname="col3"><ph style="bold">Attributes</ph></entry>
</row>
<row>
<entry colname="col1"><xph>.got</xph></entry>
<entry colname="col2"><xph>SHT_PROGBITS</xph></entry>
<entry colname="col3"><xph>SHF_ALLOC + SHF_WRITE</xph></entry>
</row>
<row>
<entry colname="col1"><xph>.plt</xph></entry>
<entry colname="col2"><xph>SHT_PROGBITS</xph></entry>
<entry colname="col3"><xph>SHF_ALLOC + SHF_WRITE + SHF_EXECINSTR</xph></entry>
</row>
</tbody>
</tgroup>
</table>
<p>Special sections are described in <xref refid="secdesc">.</p>
<i1><idxterm>Global Offset Table (GOT)</idxterm></i1>
<table id="secdesc"><cap>Special Sections Description</cap>
<tgroup cols="2">
<colspec colname="col1" colwidth="42*">
<colspec colname="col2" colwidth="157*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Description</ph></entry>
</row>
<row>
<entry colname="col1"><xph>.got</xph></entry>
<entry colname="col2">This section holds the Global Offset Table, or GOT.
See <xref refid="codingexamples"> and <xref refid="globaloffsettable"> for
more information.</entry>
</row>
<row>
<entry colname="col1"><xph>.plt</xph></entry>
<entry colname="col2">This section holds the Procedure Linkage Table, or PLT.
See <xref refid="procedurelinkagetable"> for more information.</entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Symbol Table</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>symbol</idxterm><i2><idxterm>table</idxterm></i2></i1>
<d id="symbolvalues">
<dprolog><titleblk>
<title>Symbol Values</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>symbol</idxterm><i2><idxterm>values</idxterm></i2></i1>
<i1><idxterm>dynamic linking</idxterm></i1>
<p>If an executable file contains a reference to a function defined in one
of its associated shared objects, the symbol table section for the file will
contain an entry for that symbol.  The <xph>st_shndx</xph> field of that symbol
table entry contains <xph>SHN_UNDEF</xph>.  This informs the dynamic linker
that the symbol definition for that function is not contained in the executable
file itself. If that symbol has been allocated a Procedure Linkage Table<i1>
<idxterm>Procedure Linkage Table (PLT)</idxterm></i1> entry in the executable
file, and the <xph>st_value</xph> field for that symbol table entry is nonzero,
the value is the virtual address of the first instruction of that PLT entry.
Otherwise the <xph>st_value</xph> field contains zero. This PLT entry address
is used by the dynamic linker in resolving references to the address of the
function.  See <xref refid="functionaddresses"> for details.</p>
</dbody></d>
</dbody></d>
<d>
<dprolog><titleblk>
<title>Relocation</title>
</titleblk></dprolog>
<dbody>
<d>
<dprolog><titleblk>
<title>Relocation Types</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>relocation</idxterm><i2><idxterm>entries</idxterm></i2></i1>
<p>Relocation entries describe how to alter the instruction and data relocation
fields shown in <xref refid="relocfields"> (bit numbers appear in the lower
box corners; byte numbers appear in the upper left box corners).</p>
<fig id="relocfields" propsrc="colfig"><cap>Relocation Fields</cap>
<mmobj propsrc="s390"><objref obj="relocf32"><textalt><p><xmp>-------------------------------------------------
|0          |1          |2          |3          |
|                     word32                    |
|0                                            31|
-------------------------------------------------

-------------------------
|0          |1          |
|         half16        |
|0                    15|
-------------------------

-------------------------
|0          |1          |
|         pc16          |
|0                    15|
-------------------------

-------------------------
|0    |     |1          |
|     |       low12     |
|0   3|4              15|
-------------------------

-------------
|0          |
|   byte8   |
|0         7|
-------------

</xmp></p></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="relocf64"><textalt><p><xmp>
-------------------------------------------------------------------------------------------------
|0          |1          |2          |3          |4          |5          |6          |7          |
|                                            quad64                                             |
|0                                                                                            63|
-------------------------------------------------------------------------------------------------

-------------------------------------------------
|0          |1          |2          |3          |
|                     word32                    |
|0                                            31|
-------------------------------------------------

-------------------------------------------------
|0          |1          |2          |3          |
|                      pc32                     |
|0                                            31|
-------------------------------------------------

-------------------------
|0          |1          |
|         half16        |
|0                    15|
-------------------------

-------------------------
|0          |1          |
|         pc16          |
|0                    15|
-------------------------

-------------------------
|0    |     |1          |
|     |       low12     |
|0   3|4              15|
-------------------------

-------------
|0          |
|   byte8   |
|0         7|
-------------

</xmp></p></textalt></mmobj>
</fig>
<dl>
<dlentry rev="v1r2" propsrc="zser"><term><xph>quad64</xph></term>
<defn>This specifies a 64-bit field occupying 8 bytes, the alignment of which
is 4 bytes unless otherwise specified.</defn>
</dlentry>
<dlentry><term><xph>word32</xph></term>
<defn>This specifies a 32-bit field occupying 4 bytes, the alignment of which
is 4 bytes unless otherwise specified.</defn>
</dlentry>
<dlentry rev="v1r2" propsrc="zser"><term><xph>pc32</xph></term>
<defn>This specifies a 32-bit field occupying 4 bytes with 2-byte alignment.
The signed value in this field is shifted to the left by 1 before it is used
as a program counter relative displacement (for example, the immediate field
of a "Load Address Relative Long" instruction).</defn>
</dlentry>
<dlentry><term><xph>half16</xph></term>
<defn>This specifies a 16-bit field occupying 2 bytes with 2-byte alignment
(for example, the immediate field of an "Add Halfword Immediate" instruction).
</defn>
</dlentry>
<dlentry><term><xph>pc16</xph></term>
<defn>This specifies a 16-bit field occupying 2 bytes with 2-byte alignment.
The signed value in this field is shifted to the left by 1 before it is used
as a program counter relative displacement (for example, the immediate field
of an "Branch Relative" instruction).</defn>
</dlentry>
<dlentry><term><xph>low12</xph></term>
<defn>This specifies a 12-bit field contained within a halfword with a 2-byte
alignment. The 12 bit unsigned value is the displacement of a memory reference.
</defn>
</dlentry>
<dlentry><term><xph>byte8</xph></term>
<defn>This specifies a 8-bit field with a 1-byte alignment.</defn>
</dlentry>
</dl>
<p>Calculations in <xref refid="relocations"> assume the actions are transforming
a relocatable file into either an executable or a shared object file. Conceptually,
the linkage editor merges one or more relocatable files to form the output.
It first determines how to combine and locate the input files, next it updates
the symbol values, and then it performs relocations.</p>
<p>Relocations applied to executable or shared object files are similar and
accomplish the same result. The following notations are used in <xref refid="relocations">:
</p>
<dl>
<dlentry><term><xph>A</xph></term>
<defn>Represents the addend used to compute the value of the relocatable field.
</defn>
</dlentry>
<dlentry><term><xph>B</xph></term>
<defn>Represents the base address at which a shared object has been loaded
into memory during execution. Generally, a shared object file is built with
a 0 base virtual address, but the execution address will be different.<ph
props="comment"> See Program Header in the System V ABI for more information
about the base address.</ph></defn>
</dlentry>
<dlentry><term><xph>G</xph></term>
<defn>Represents the section offset or address of the Global Offset Table.<i1>
<idxterm>Global Offset Table (GOT)</idxterm></i1>  See <xref refid="codingexamples"> and <xref
refid="globaloffsettable"> for more information.</defn>
</dlentry>
<dlentry><term><xph>L</xph></term>
<defn>Represents the section offset or address of the Procedure Linkage Table<i1>
<idxterm>Procedure Linkage Table (PLT)</idxterm></i1> entry for a symbol.
 A PLT entry redirects a function call to the proper destination.  The linkage
editor builds the initial PLT<ph props="comment" rev="v0r1">, and the dynamic
linker modifies the entries during execution</ph>.  See <xref refid="procedurelinkagetable"> for
more information.</defn>
</dlentry>
<dlentry><term><xph>O</xph></term>
<defn>Represents the offset into the GOT at which the address of the relocation
entry's symbol will reside during execution.  See <xref refid="codingexamples"> and <xref
refid="globaloffsettable"> for more information.</defn>
</dlentry>
<dlentry><term><xph>P</xph></term>
<defn>Represents the place (section offset or address) of the storage unit
being relocated (computed using <xph>r_offset</xph>).</defn>
</dlentry>
<dlentry><term><xph>R</xph></term>
<defn>Represents the offset of the symbol within the section in which the
symbol is defined (its section-relative address).</defn>
</dlentry>
<dlentry><term><xph>S</xph></term>
<defn>Represents the value of the symbol whose index resides in the relocation
entry.</defn>
</dlentry>
</dl>
<p>Relocation entries apply to<ph rev="v0r1"> bytes,</ph> halfwords or words.
In either case, the <xph>r_offset</xph> value designates the offset or virtual
address of the first byte of the affected storage unit.  The relocation type
specifies which bits to change and how to calculate their values.  The <ph
propsrc="zser">&system64;</ph><ph propsrc="s390">&system32;</ph> family uses
only the <xph rev="v1r2" propsrc="zser">Elf64_Rela</xph><xph propsrc="s390">
Elf32_Rela</xph> relocation entries with explicit addends.  For the relocation
entries, the <xph>r_addend</xph> field serves as the relocation addend.  In
all cases, the offset, addend, and the computed result use the byte order
specified in the ELF header.</p>
<p>The following general rules apply to the interpretation of the relocation
types in <xref refid="relocations">: </p>
<ul>
<li>"+" and "-" denote <ph propsrc="zser">64</ph><ph propsrc="s390">32</ph>-bit
modulus addition and subtraction, respectively.  ">>" denotes arithmetic right-shifting
(shifting with sign copying) of the value of the left operand by the number
of bits given by the right operand.</li>
<li>For relocation type <xph>half16</xph>, the upper <ph propsrc="zser">48
</ph><ph propsrc="s390">16</ph> bits of the value computed must <ph props="comment"
rev="v0r1">all be the same</ph><ph rev="v0r1">be all ones or all zeroes</ph>.
 For relocation type <xph>pc16</xph>, the upper <ph propsrc="zser">47</ph><ph
propsrc="s390">15</ph> bits of  the value computed must <ph props="comment"
rev="v0r1">all be the same</ph><ph rev="v0r1">be all ones or all zeroes</ph> and
the lowest bit must be zero. <ph rev="v1r2" propsrc="zser">For relocation
type <xph>pc32</xph>, the upper 31 bits of  the value computed must be all
ones or all zeroes and the lowest bit must be zero.</ph> For relocation type <xph>
low12</xph>, the upper <ph propsrc="zser">52</ph><ph propsrc="s390">20</ph> bits
of the value computed must all be zero and for relocation type <xph>byte8
</xph>, the upper <ph propsrc="zser">56</ph><ph propsrc="s390">24</ph> bits
of the value computed must all be zero.</li>
<li>Reference in a calculation to the value <xph>G</xph> or <xph>O</xph> implicitly
creates a GOT entry for the indicated symbol<ph rev="v0r1"> and a reference
to <xph>L</xph> implicitly creates a PLT entry</ph>.</li>
</ul>
<table id="relocations" propsrc="s390"><cap>Relocation Types</cap>
<i1><idxterm>relocation</idxterm><i2><idxterm>types</idxterm></i2></i1>
<tgroup cols="4">
<colspec colname="col1" colwidth="122*">
<colspec colname="col2" colwidth="56*">
<colspec colname="col3" colwidth="85*">
<colspec colname="col4" colwidth="126*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Value</ph></entry>
<entry colname="col3"><ph style="bold">Field</ph></entry>
<entry colname="col4"><ph style="bold">Calculation</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_NONE</xph></entry>
<entry colname="col2">0</entry>
<entry colname="col3">none</entry>
<entry colname="col4">none</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_8</xph></entry>
<entry colname="col2">1</entry>
<entry colname="col3"><xph>byte8</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_12</xph></entry>
<entry colname="col2">2</entry>
<entry colname="col3"><xph>low12</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_16</xph></entry>
<entry colname="col2">3</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_32</xph></entry>
<entry colname="col2">4</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC32</xph></entry>
<entry colname="col2">5</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT12</xph></entry>
<entry colname="col2">6</entry>
<entry colname="col3"><xph>low12</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT32</xph></entry>
<entry colname="col2">7</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT32</xph></entry>
<entry colname="col2">8</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>L + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_COPY</xph></entry>
<entry colname="col2">9</entry>
<entry colname="col3">none</entry>
<entry colname="col4"><ph props="comment" rev="v0r1">none</ph><ph rev="v0r1">
(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GLOB_DAT</xph></entry>
<entry colname="col2">10</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A</xph> <ph rev="v0r1">(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_JMP_SLOT</xph></entry>
<entry colname="col2">11</entry>
<entry colname="col3">none</entry>
<entry colname="col4">(see below)</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_RELATIVE</xph></entry>
<entry colname="col2">12</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>B + A</xph> <ph rev="v0r1">(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOTOFF</xph></entry>
<entry colname="col2">13</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A - G</xph></entry>
</row>
<row>
<?PubTbl row rht="0.52in">
<entry colname="col1"><xph>R_390_GOTPC</xph></entry>
<entry colname="col2">14</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>G + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT16</xph></entry>
<entry colname="col2">15</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC16</xph></entry>
<entry colname="col2">16</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>S + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC16DBL</xph></entry>
<entry colname="col2">17</entry>
<entry colname="col3"><xph>pc16</xph></entry>
<entry colname="col4"><xph>(S + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT16DBL</xph></entry>
<entry colname="col2">18</entry>
<entry colname="col3"><xph>pc16</xph></entry>
<entry colname="col4"><xph>(L + A - P) >> 1</xph></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="relocations" propsrc="zser" rev="v1r2"><cap>Relocation Types</cap>
<i1><idxterm>relocation</idxterm><i2><idxterm>types</idxterm></i2></i1>
<tgroup cols="4">
<colspec colname="col1" colwidth="122*">
<colspec colname="col2" colwidth="56*">
<colspec colname="col3" colwidth="85*">
<colspec colname="col4" colwidth="126*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Value</ph></entry>
<entry colname="col3"><ph style="bold">Field</ph></entry>
<entry colname="col4"><ph style="bold">Calculation</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_NONE</xph></entry>
<entry colname="col2">0</entry>
<entry colname="col3">none</entry>
<entry colname="col4">none</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_8</xph></entry>
<entry colname="col2">1</entry>
<entry colname="col3"><xph>byte8</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_12</xph></entry>
<entry colname="col2">2</entry>
<entry colname="col3"><xph>low12</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_16</xph></entry>
<entry colname="col2">3</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_32</xph></entry>
<entry colname="col2">4</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC32</xph></entry>
<entry colname="col2">5</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>S + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT12</xph></entry>
<entry colname="col2">6</entry>
<entry colname="col3"><xph>low12</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT32</xph></entry>
<entry colname="col2">7</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT32</xph></entry>
<entry colname="col2">8</entry>
<entry colname="col3"><xph>word32</xph></entry>
<entry colname="col4"><xph>L + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_COPY</xph></entry>
<entry colname="col2">9</entry>
<entry colname="col3">none</entry>
<entry colname="col4"><ph props="comment" rev="v0r1">none</ph><ph rev="v0r1">
(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GLOB_DAT</xph></entry>
<entry colname="col2">10</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>S + A</xph> <ph rev="v0r1">(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_JMP_SLOT</xph></entry>
<entry colname="col2">11</entry>
<entry colname="col3">none</entry>
<entry colname="col4">(see below)</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_RELATIVE</xph></entry>
<entry colname="col2">12</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>B + A</xph> <ph rev="v0r1">(see below)</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOTOFF</xph></entry>
<entry colname="col2">13</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>S + A - G</xph></entry>
</row>
<row>
<?PubTbl row rht="0.52in">
<entry colname="col1"><xph>R_390_GOTPC</xph></entry>
<entry colname="col2">14</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>G + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT16</xph></entry>
<entry colname="col2">15</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC16</xph></entry>
<entry colname="col2">16</entry>
<entry colname="col3"><xph>half16</xph></entry>
<entry colname="col4"><xph>S + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC16DBL</xph></entry>
<entry colname="col2">17</entry>
<entry colname="col3"><xph>pc16</xph></entry>
<entry colname="col4"><xph>(S + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT16DBL</xph></entry>
<entry colname="col2">18</entry>
<entry colname="col3"><xph>pc16</xph></entry>
<entry colname="col4"><xph>(L + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC32DBL</xph></entry>
<entry colname="col2">19</entry>
<entry colname="col3"><xph>pc32</xph></entry>
<entry colname="col4"><xph>(S + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT32DBL</xph></entry>
<entry colname="col2">20</entry>
<entry colname="col3"><xph>pc32</xph></entry>
<entry colname="col4"><xph>(L + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOTPCDBL</xph></entry>
<entry colname="col2">21</entry>
<entry colname="col3"><xph>pc32</xph></entry>
<entry colname="col4"><xph>(G + A - P) >> 1</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_64</xph></entry>
<entry colname="col2">22</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>S + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PC64</xph></entry>
<entry colname="col2">23</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>S + A - P</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOT64</xph></entry>
<entry colname="col2">24</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>O + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_PLT64</xph></entry>
<entry colname="col2">25</entry>
<entry colname="col3"><xph>quad64</xph></entry>
<entry colname="col4"><xph>L + A</xph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GOTENT</xph></entry>
<entry colname="col2">26</entry>
<entry colname="col3"><xph>pc32</xph></entry>
<entry colname="col4"><xph>(G + O + A - P) >> 1</xph></entry>
</row>
</tbody>
</tgroup>
</table>
<table><cap>Relocation type descriptions</cap>
<tgroup cols="2">
<colspec colname="col1" colwidth="57*">
<colspec colname="col2" colwidth="137*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Name</ph></entry>
<entry colname="col2"><ph style="bold">Description</ph></entry>
</row>
<row>
<entry colname="col1"><xph>R_390_COPY</xph></entry>
<entry colname="col2">The linkage editor creates this relocation type for
dynamic linking. Its offset member refers to a location in a writable segment.
The symbol table index specifies a symbol that should exist both in the current
object file and in a shared object. During execution, the dynamic linker copies
data associated with the shared object's symbol to the location specified
by the offset.</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_GLOB_DAT</xph></entry>
<entry colname="col2">This relocation type resembles <xph propsrc="s390">
R_390_32</xph><xph rev="v1r2" propsrc="zser">R_390_64</xph>, except that it
sets a Global Offset Table<i1><idxterm>Global Offset Table (GOT)</idxterm>
</i1> entry to the address of the specified symbol.  This special relocation
type allows one to determine the correspondence between symbols and GOT entries.
</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_JMP_SLOT</xph></entry>
<entry colname="col2">The linkage editor creates this relocation type for
dynamic linking.  Its offset member gives the location of a Procedure Linkage
Table<i1><idxterm>Procedure Linkage Table (PLT)</idxterm></i1> entry. The
dynamic linker modifies the PLT entry to transfer control to the designated
symbol's address (see <xref refid="procedurelinkagetable">).</entry>
</row>
<row>
<entry colname="col1"><xph>R_390_RELATIVE</xph></entry>
<entry colname="col2">The linkage editor creates this relocation type for
dynamic linking.<i1><idxterm>dynamic linking</idxterm></i1>  Its offset member
gives a location within a shared object that contains a value representing
a relative address.  The dynamic linker computes the corresponding virtual
address by adding the virtual address at which the shared object was loaded
to the relative address. Relocation entries for this type must specify 0 for
the symbol table index.</entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
</dbody></d>
</dbody></d>
</dbody></d>
<d id="chprogload">
<dprolog><titleblk>
<title>Program loading and dynamic linking</title>
</titleblk></dprolog>
<dintro><toc><gendtitle></toc></dintro>
<dbody>
<p>This section describes how the Executable and Linking Format (ELF) is used
in the construction and execution of programs.</p>
<d>
<dprolog><titleblk>
<title>Program Loading</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>program loading</idxterm></i1>
<i1><idxterm>process image</idxterm></i1>
<i1><idxterm>virtual address</idxterm></i1>
<i1><idxterm>address</idxterm><i2><idxterm>virtual</idxterm></i2></i1>
<p>As the system creates or augments a process image, it logically copies
a file's segment to a virtual memory segment.  When &ndash; and if &ndash; the
system physically reads the file depends on the program's execution behavior,
on the system load, and so on. A process does not require a physical page
until it references the logical page during execution, and processes commonly
leave many pages unreferenced. Therefore, <ph props="comment" rev="v0r1">
delaying physical reads frequently obviates them</ph><ph rev="v0r1">if physical
reads can be delayed they can frequently be dispensed with</ph>, improving
system performance. To obtain this efficiency in practice, executable and
shared object files must have segment images of which the offsets and virtual
addresses are congruent modulo the page size.</p>
<p>Virtual addresses and file offsets for the <ph propsrc="zser">&system64;
</ph><ph propsrc="s390">&system32;</ph> processor family segments are congruent
modulo <ph propsrc="s390">4 Kbytes</ph><ph rev="v1r2" propsrc="zser">the system
page size</ph>. The value of the <xph>p_align</xph> field of each program
header in a shared object file must be <ph propsrc="s390">0x1000 (4 Kbytes)
</ph><ph rev="v1r2" propsrc="zser">a multiple of the system page size</ph>. <xref
refid="execfile"> is an example of an executable file assuming an executable
program linked with a base address of <ph propsrc="s390">0x00400000 (4 Mbytes)
</ph><ph rev="v1r2" propsrc="zser">0x80000000 (2 Gbytes)</ph>.</p>
<fig frame="box" id="execfile" propsrc="colfig"><cap>Executable File Example
</cap>
<mmobj propsrc="s390"><objref obj="execfi32"><textalt><p><xmp>File Offset                               Virtual Address
         0 ------------------------------ 0x00400000
           |         ELF header         |
           |    Program header table    |
           |     Other information      |
           |                            |
           |         Text segment       |
           |           . . .            |
           |        0x1bf58 bytes       |
           |                            | 0x0041bfff
           ------------------------------
   0x1bf58 |                            | 0x0041cf58
           |        Data segment        |
           |           . . .            |
           |        0x17c4 bytes        |
           |                            | 0x0041d72b
           ------------------------------
   0x1d72c |     Other Information      |
           ------------------------------

</xmp></p></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="execfi64"><textalt><p><xmp>
File Offset                               Virtual Address
         0 ------------------------------ 0x80000000
           |         ELF header         |
           |    Program header table    |
           |     Other information      |
           |                            |
           |         Text segment       |
           |           . . .            |
           |        0x1bf58 bytes       |
           |                            | 0x8001bfff
           ------------------------------
   0x1bf58 |                            | 0x8001cf58
           |        Data segment        |
           |           . . .            |
           |        0x17c4 bytes        |
           |                            | 0x8001d72b
           ------------------------------
   0x1d72c |     Other Information      |
           ------------------------------

</xmp></p></textalt></mmobj>
</fig>
<table id="phdr"><cap>Program Header Segments</cap>
<i1><idxterm>program header</idxterm></i1>
<i1><idxterm>ELF header</idxterm></i1>
<i1><idxterm>header</idxterm><i2><idxterm>program</idxterm></i2></i1>
<i1><idxterm>header</idxterm><i2><idxterm>ELF</idxterm></i2></i1>
<tgroup cols="3">
<colspec colname="col1">
<colspec colname="col2">
<colspec colname="col3">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Member</ph></entry>
<entry colname="col2"><ph style="bold">Text</ph></entry>
<entry colname="col3"><ph style="bold">Data</ph></entry>
</row>
<row>
<entry colname="col1"><xph>p_type</xph></entry>
<entry colname="col2"><xph>PT_LOAD</xph></entry>
<entry colname="col3"><xph>PT_LOAD</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_offset</xph></entry>
<entry colname="col2"><xph>0x0</xph></entry>
<entry colname="col3"><xph>0x1bf58</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_vaddr</xph></entry>
<entry colname="col2"><xph propsrc="s390">0x400000</xph><xph rev="v1r2" propsrc="zser">
0x80000000</xph></entry>
<entry colname="col3"><xph propsrc="s390">0x41cf58</xph><xph rev="v1r2" propsrc="zser">
0x8001cf58</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_paddr</xph></entry>
<entry colname="col2">unspecified</entry>
<entry colname="col3">unspecified</entry>
</row>
<row>
<entry colname="col1"><xph>p_filesz</xph></entry>
<entry colname="col2"><xph>0x1bf58</xph></entry>
<entry colname="col3"><xph>0x17c4</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_memsz</xph></entry>
<entry colname="col2"><xph>0x1bf58</xph></entry>
<entry colname="col3"><xph>0x2578</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_flags</xph></entry>
<entry colname="col2"><xph>PF_R+PF_X</xph></entry>
<entry colname="col3"><xph>PF_R+PF_W</xph></entry>
</row>
<row>
<entry colname="col1"><xph>p_align</xph></entry>
<entry colname="col2"><xph>0x1000</xph></entry>
<entry colname="col3"><xph>0x1000</xph></entry>
</row>
</tbody>
</tgroup>
</table>
<p>Although the file offsets and virtual addresses are congruent modulo 4
Kbytes for both text and data, up to four file pages can hold impure text
or data (depending on page size and file system block size). </p>
<ul>
<li>The first text page contains the ELF header, the program header table,
and other information.</li>
<li>The last text page may hold a copy of the beginning of data.</li>
<li>The first data page may have a copy of the end of text.</li>
<li>The last data page may contain file information not relevant to the running
process.</li>
</ul>
<p>Logically, the system enforces memory permissions as if each segment were
complete and separate; segment addresses are adjusted to ensure that each
logical page in the address space has a single set of permissions.  In the
example in <xref refid="phdr"> the file region holding the end of text and
the beginning of data is mapped twice; at one virtual address for text and
at a different virtual address for data.</p>
<p>The end of the data segment requires special handling for uninitialized
data, which the system defines to begin with zero values.  Thus if the last
data page of a file includes information <ph props="comment" rev="v0r1">not
in</ph><ph rev="v0r1">beyond</ph> the logical memory page, the extraneous
data must be set to zero<ph rev="v0r1"> by the loader</ph>, rather than to
the unknown contents of the executable file.  'Impurities' in the other three <ph
props="comment" rev="v0r1">pages</ph><ph rev="v0r1">segments</ph> are not
logically part of the process image, and whether the system <ph props="comment"
rev="v0r1">expunges</ph><ph rev="v0r1">clears</ph> them is unspecified.  The
memory image for the program in <xref refid="phdr" form="text"> is presented
in <xref refid="pimgseg" form="text"><ph props="comment" rev="v0r1">, assuming
4096 (0x1000) byte pages</ph>.</p>
<fig frame="box" id="pimgseg" propsrc="colfig"><cap>Process Image Segments
</cap>
<i1><idxterm>process image segments</idxterm></i1>
<mmobj rev="v1r4" propsrc="s390"><objref obj="procim32"><textalt><p><xmp>
Virtual Address                             Segment
  0x00400000 ------------------------------
             |         ELF header         |
             |    Program header table    |
             |     Other information      |
             |                            |  Text
             |         Text segment       |
             |           . . .            |
             |        0x1bf58 bytes       |
             ------------------------------
  0x0041bf58 |        Page padding        |
             |         0xa8 bytes         |
             ------------------------------

             ------------------------------
  0x0041c000 |          Padding           |
             |         0xf58 bytes        |
             ------------------------------
  0x0041cf58 |                            |
             |        Data segment        |
             |           . . .            |  Data
             |        0x17c4 bytes        |
             |                            |
             ------------------------------
  0x0041e71c |     Uninitialized data     |
             |        0xdb4 bytes         |
             ------------------------------
  0x0041f4d0 |        Page padding        |
             |        0xb30 bytes         |
  0x0041ffff ------------------------------</xmp></p></textalt></mmobj>
<mmobj rev="v1r2" propsrc="zser"><objref obj="procim64"><textalt><p><xmp>
Virtual Address                             Segment
  0x80000000 ------------------------------
             |         ELF header         |
             |    Program header table    |
             |     Other information      |
             |                            |  Text
             |         Text segment       |
             |           . . .            |
             |        0x1bf58 bytes       |
             ------------------------------
  0x8001bf58 |        Page padding        |
             |         0xa8 bytes         |
             ------------------------------

             ------------------------------
  0x8001c000 |          Padding           |
             |         0xf58 bytes        |
             ------------------------------
  0x8001cf58 |                            |
             |        Data segment        |
             |           . . .            |  Data
             |        0x17c4 bytes        |
             |                            |
             ------------------------------
  0x8001e71c |     Uninitialized data     |
             |        0xdb4 bytes         |
             ------------------------------
  0x8001f4d0 |        Page padding        |
             |        0xb30 bytes         |
  0x8001ffff ------------------------------</xmp></p></textalt></mmobj>
</fig>
<p>One aspect of segment loading differs between executable files and shared
objects.  Executable file segments may contain absolute code.  For the process
to execute correctly, the segments must reside at the virtual addresses assigned
when building the executable file, with the system using the <xph>p_vaddr
</xph> values unchanged as virtual addresses.</p>
<p>On the other hand, shared object segments typically contain position-independent
code.  This allows a segment's virtual address to change from one process
to another, without invalidating execution behavior. Though the system chooses
virtual addresses for individual processes, it maintains the "relative positions"
of the segments. Because position-independent code uses relative addressing
between segments, the difference between virtual addresses in memory must
match the difference between virtual addresses in the file.  <xref refid="soseg"> shows
possible shared object virtual address assignments for several processes,
illustrating constant relative positioning.  The table also illustrates the
base address computations.</p>
<table id="soseg" propsrc="s390"><cap>Shared Object Segment Example</cap>
<i1><idxterm>shared object segment</idxterm></i1>
<tgroup cols="4">
<colspec colname="col1" colwidth="99*">
<colspec colname="col2" colwidth="99*">
<colspec colname="col3" colwidth="86*">
<colspec colname="col4" colwidth="113*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Source</ph></entry>
<entry colname="col2"><ph style="bold">Text</ph></entry>
<entry colname="col3"><ph style="bold">Data</ph></entry>
<entry colname="col4"><ph style="bold">Base Address</ph></entry>
</row>
<row>
<entry colname="col1">File</entry>
<entry colname="col2"><xph>0x00000200</xph></entry>
<entry colname="col3"><xph>0x0002a400</xph></entry>
<entry colname="col4"></entry>
</row>
<row>
<entry colname="col1">Process 1</entry>
<entry colname="col2"><xph>0x40000000</xph></entry>
<entry colname="col3"><xph>0x4002a400</xph></entry>
<entry colname="col4"><xph>0x40000000</xph></entry>
</row>
<row>
<entry colname="col1">Process 2</entry>
<entry colname="col2"><xph rev="v0r2">0x40010000</xph></entry>
<entry colname="col3"><xph>0x4003a400</xph></entry>
<entry colname="col4"><xph>0x40010000</xph></entry>
</row>
<row>
<entry colname="col1">Process 3</entry>
<entry colname="col2"><xph>0x40020000</xph></entry>
<entry colname="col3"><xph>0x4004a400</xph></entry>
<entry colname="col4"><xph>0x40020000</xph></entry>
</row>
<row>
<entry colname="col1">Process 4</entry>
<entry colname="col2"><xph>0x40030000</xph></entry>
<entry colname="col3"><xph>0x4005a400</xph></entry>
<entry colname="col4"><xph>0x40030000</xph></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="soseg" propsrc="zser" rev="v1r2"><cap>Shared Object Segment Example
for 42&ndash;bit address space</cap>
<i1><idxterm>shared object segment</idxterm></i1>
<tgroup cols="4">
<colspec colname="col1" colwidth="99*">
<colspec colname="col2" colwidth="99*">
<colspec colname="col3" colwidth="97*">
<colspec colname="col4" colwidth="101*">
<tbody>
<row>
<entry colname="col1"><ph style="bold">Source</ph></entry>
<entry colname="col2"><ph style="bold">Text</ph></entry>
<entry colname="col3"><ph style="bold">Data</ph></entry>
<entry colname="col4"><ph style="bold">Base Address</ph></entry>
</row>
<row>
<entry colname="col1">File</entry>
<entry colname="col2"><xph>0x00000000200</xph></entry>
<entry colname="col3"><xph>0x0000002a400</xph></entry>
<entry colname="col4"></entry>
</row>
<row>
<entry colname="col1">Process 1</entry>
<entry colname="col2"><xph>0x20000000000</xph></entry>
<entry colname="col3"><xph>0x2000002a400</xph></entry>
<entry colname="col4"><xph>0x20000000000</xph></entry>
</row>
<row>
<entry colname="col1">Process 2</entry>
<entry colname="col2"><xph rev="v0r2">0x20000010000</xph></entry>
<entry colname="col3"><xph>0x2000003a400</xph></entry>
<entry colname="col4"><xph>0x20000010000</xph></entry>
</row>
<row>
<entry colname="col1">Process 3</entry>
<entry colname="col2"><xph>0x20000020000</xph></entry>
<entry colname="col3"><xph>0x2000004a400</xph></entry>
<entry colname="col4"><xph>0x20000020000</xph></entry>
</row>
<row>
<entry colname="col1">Process 4</entry>
<entry colname="col2"><xph>0x20000030000</xph></entry>
<entry colname="col3"><xph>0x2000005a400</xph></entry>
<entry colname="col4"><xph>0x20000030000</xph></entry>
</row>
</tbody>
</tgroup>
</table>
</dbody></d>
<?xpp:page>
<d id="dynamiclinking">
<dprolog><titleblk>
<title>Dynamic Linking</title>
</titleblk></dprolog>
<dbody>
<d>
<dprolog><titleblk>
<title>Dynamic Section</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>dynamic linking</idxterm></i1>
<i1><idxterm>linking, dynamic</idxterm></i1>
<i1><idxterm>dynamic section</idxterm></i1>
<i1><idxterm>section</idxterm><i2><idxterm>dynamic</idxterm></i2></i1>
<i1><idxterm>object file</idxterm></i1>
<p>Dynamic section entries give information to the dynamic linker.  Some of
this information is processor-specific, including the interpretation of some
entries in the dynamic structure.</p>
<dl>
<dlentry><term><xph>DT_PLTGOT</xph></term>
<defn>The <xph>d_ptr</xph> field of this entry gives the address of the first
byte in the Procedure Linkage Table<i1><idxterm>Procedure Linkage Table (PLT)
</idxterm></i1> (<xph>.PLT</xph> in <xref refid="procedurelinkagetable">).
</defn>
</dlentry>
<dlentry><term><xph>DT_JMPREL</xph></term>
<defn><ph props="comment">As explained in the System V ABI , </ph>This entry
is associated with a table of relocation entries for the PLT.  For<ph props="comment"
rev="v0r1"> the</ph> <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> this entry is mandatory both for executable and shared object
files. Moreover, the relocation table's entries must have a one-to-one correspondence
with the PLT. The table of <xph>DT_JMPREL</xph> relocation entries is wholly
contained within the <xph>DT_RELA</xph> referenced table. See <xref refid="procedurelinkagetable"> for
more information.</defn>
</dlentry>
</dl>
</dbody></d>
<d id="globaloffsettable">
<dprolog><titleblk>
<title>Global Offset Table</title>
</titleblk></dprolog>
<dbody>
<i1 id="idxgot"><idxterm>Global Offset Table (GOT)</idxterm></i1>
<i1 seetext="Global Offset Table" seeid="idxgot" props="comment"><idxterm>
GOT</idxterm></i1>
<i1><idxterm>virtual address</idxterm></i1>
<i1><idxterm>address</idxterm><i2><idxterm>virtual</idxterm></i2></i1>
<i1><idxterm>position-independent code</idxterm></i1>
<i1><idxterm>dynamic linking</idxterm></i1>
<i1><idxterm>linking, dynamic</idxterm></i1>
<p>Position-independent code cannot, in general, contain absolute virtual
addresses.  Global Offset Tables hold absolute addresses in private data,
thus making the addresses available without compromising the position-independence
and sharability of a program's text.  A program references its GOT using position-independent
addressing and extracts absolute values, thus redirecting position-independent
references to absolute locations.</p>
<p>When the dynamic linker creates memory segments for a loadable object file,
it processes the relocation entries, some of which will be of type <xph>R_390_GLOB_DAT
</xph>, referring to the GOT.  The dynamic linker determines the associated
symbol values, calculates their absolute addresses, and sets the GOT entries
to the proper values. Although the absolute addresses are unknown when the
linkage editor builds an object file, the dynamic linker knows the addresses
of all memory segments and can thus calculate the absolute addresses of the
symbols contained therein.</p>
<p>A GOT entry provides direct access to the absolute address of a symbol
without compromising position-independence and sharability. Because the executable
file and shared objects have separate GOTs, a symbol may appear in several
tables.  The dynamic linker processes all the GOT relocations before giving
control to any code in the process image, thus ensuring the absolute addresses
are available during execution.</p>
<p>The dynamic linker may choose different memory segment addresses for the
same shared object in different programs; it may even choose different library
addresses for different executions of the same program.  Nevertheless, memory
segments do not change addresses once the process image is established. As
long as a process exists, its memory segments reside at fixed virtual addresses.
</p>
<p rev="v0r1">The format and interpretation of the Global Offset Table is
processor specific. For <ph propsrc="zser">&system64;</ph><ph propsrc="s390">
&system32;</ph> the symbol <xph>_GLOBAL_OFFSET_TABLE_</xph> may be used to
access the table.  The symbol <ph props="comment" rev="v0r2">resides at</ph><ph
rev="v0r2">refers to</ph> the start of the <xph>.got</xph> section. Two words
in the GOT are reserved:</p>
<ul>
<li>The word at <xph>_GLOBAL_OFFSET_TABLE_[0]</xph> is set by the linkage
editor to hold the address of the dynamic structure, referenced with the symbol <xph>
_DYNAMIC</xph>. This allows a program, such as the dynamic linker, to find
its own dynamic structure without having yet processed its relocation entries.
 This is especially important for the dynamic linker, because it must initialize
itself without relying on other programs to relocate its memory image.</li>
<li>The word at <xph>_GLOBAL_OFFSET_TABLE_[1]</xph> is reserved for future
use.</li>
</ul>
<p>The Global Offset Table resides in the ELF <xph>.got</xph> section.</p>
</dbody></d>
<d id="functionaddresses" rev="v0r1">
<dprolog><titleblk>
<title>Function Addresses</title>
</titleblk></dprolog>
<dbody>
<i1><idxterm>function</idxterm><i2><idxterm>address</idxterm></i2></i1>
<i1><idxterm>address</idxterm><i2><idxterm>function</idxterm></i2></i1>
<i1><idxterm>dynamic  linking</idxterm></i1>
<i1><idxterm>linking, dynamic</idxterm></i1>
<p rev="v0r1">References to a function address from an executable file and
from the shared objects associated with the file must resolve to the same
value. References from within shared objects will normally be resolved (by
the dynamic linker) to the virtual address of the function itself.  References
from within the executable file to a function defined in a shared object will
normally be resolved (by the linkage editor) to the address of the Procedure
Linkage Table<i1><idxterm>Procedure Linkage Table (PLT)</idxterm></i1> entry
for that function within the executable file.</p>
<p props="comment" rev="v0r1">References to a function address from an executable
file and from the shared objects associated with the file must resolve to
the same value. Function references used in comparisons need to use the fully
resolved address of the functions rather than the address of the Procedure
Linkage Table entries. The compiler has to generate code that will load the
function addresses to be compared from the Global Offset Table. Just like
variable references held in the GOT, this type of function reference will
be resolved by the dynamic linker before the program is started.</p>
<p rev="v0r1">To allow comparisons of function addresses to work as expected,
if an executable file references a function defined in a shared object, the
linkage editor will place the address of the PLT entry for that function in
its associated symbol table entry.  See <xref refid="symbolvalues"> for details.
The dynamic linker treats such symbol table entries specially.  If the dynamic
linker is searching for a symbol and encounters a symbol table entry for that
symbol in the executable file, it normally follows these rules:</p>
<ul rev="v0r1">
<li>If the <xph>st_shndx</xph> field of the symbol table entry is not <xph>
SHN_UNDEF</xph>, the dynamic linker has found a definition for the symbol
and uses its <xph>st_value</xph> field as the symbol's address.</li>
<li>If the <xph>st_shndx</xph> field is <xph>SHN_UNDEF</xph> and the symbol
is of type <xph>STT_FUNC</xph> and the <xph>st_value</xph> field is not zero,
the dynamic linker recognizes this entry as special and uses the <xph>st_value
</xph> field as the symbol's address.</li>
<li>Otherwise, the dynamic linker considers the symbol to be undefined within
the executable file and continues processing.</li>
</ul>
<p>Some relocations are associated with PLT entries. These entries are used
for direct function calls rather than for references to function addresses.
These relocations are not treated specially as described above because the
dynamic linker must not redirect PLT entries to point to themselves.</p>
</dbody></d>
<d id="procedurelinkagetable">
<dprolog><titleblk>
<title>Procedure Linkage Table</title>
</titleblk></dprolog>
<dbody>
<i1 id="idxplt"><idxterm>Procedure Linkage Table (PLT)</idxterm></i1>
<i1 seetext="Procedure Linkage Table" seeid="idxplt" props="comment"><idxterm>
PLT</idxterm></i1>
<i1><idxterm>linkage table, procedure</idxterm></i1>
<i1><idxterm>linkage editor</idxterm></i1>
<i1><idxterm>dynamic linking</idxterm></i1>
<p>Much as the Global Offset Table<i1><idxterm>Global Offset Table (GOT)</idxterm>
</i1> redirects position-independent address calculations to absolute locations,
the Procedure Linkage Table redirects position-independent function calls
to absolute locations. The linkage editor cannot resolve execution transfers
(such as function calls) from one executable or shared object to another,
so instead it arranges for the program to transfer control to entries in the
PLT. The dynamic linker determines the absolute addresses of the destinations
and stores them in the GOT, from which they are loaded by the PLT entry. The
dynamic linker can thus redirect the entries without compromising the position-independence
and sharability of the program text.  Executable files and shared object files
have separate PLTs.</p>
<p>As mentioned above, a relocation table is associated with the PLT. The <xph>
DT_JMPREL</xph> entry in the <xph>_DYNAMIC</xph> array gives the location
of the first relocation entry.  The relocation table entries match the PLT
entries in a one-to-one correspondence (relocation table entry 1 applies to
PLT entry 1 and so on).  The relocation type for each entry shall be <xph>
R_390_JMP_SLOT</xph>. The relocation offset shall specify the address of the
GOT entry containing the address of the function and the symbol table index
shall reference the appropriate symbol.</p>
<p>To illustrate Procedure Linkage Tables, <xref refid="pltex"> shows how
the linkage editor might initialize the PLT when linking a shared executable
or shared object.</p>
<fig frame="box" id="pltex" propsrc="colfig"><cap>Procedure Linkage Table
Example</cap>
<xmp props="comment" rev="v1r2"><?Pub Dtl>                              # PLT for executables (not position independent)
PLT1:     BASR  1,0
          L     1,22(1)       # Load address of the GOT entry
          L     1,0(0,1)      # Load function address from the GOT to r1
          BCR   15,1          # Jump to address
RET1:     BASR  1,0           # Return from GOT first time (lazy binding)
          L     1,14(1)       # Load offset in symbol table to r1
          BRC   15,-x         # Jump to start of PLT
          .word 0             # Filler
          .long ?             # Address of the GOT entry
          .long ?             # Offset into the symbol table

                              # PLT for shared objects (position independent)
PLT1:     BASR  1,0
          L     1,22(1)       # Load offset into the GOT to r1
          L     1,(1,12)      # Load address from the GOT to r1
          BCR   15,1          # Jump to address
RET1:     BASR  1,0           # Return from GOT first time (lazy binding)
          L     1,14(1)       # Load offset in symbol table to r1
          BRC   15,-x         # Jump to start of PLT
          .word 0             # Filler
          .long ?             # Offset in the GOT
          .long ?             # Offset in the symbol table</xmp>
<xmp rev="v1r2" propsrc="s390">*                                  # PLT for executables (not position independent)
PLT1      BASR  1,0                # Establish base
BASE1     L     1,AGOTENT-BASE1(1) # Load address of the GOT entry
          L     1,0(0,1)           # Load function address from the GOT to r1
          BCR   15,1               # Jump to address
RET1      BASR  1,0                # Return from GOT first time (lazy binding)
BASE2     L     1,ASYMOFF-BASE2(1) # Load offset in symbol table to r1
          BRC   15,-x              # Jump to start of PLT
          .word 0                  # Filler
AGOTENT   .long ?                  # Address of the GOT entry
ASYMOFF   .long ?                  # Offset into the symbol table

*                                  # PLT for shared objects (position independent)
PLT1      BASR  1,0                # Establish base
BASE1     L     1,AGOTOFF-BASE1(1) # Load offset into the GOT to r1
          L     1,(1,12)           # Load address from the GOT to r1
          BCR   15,1               # Jump to address
RET1      BASR  1,0                # Return from GOT first time (lazy binding)
BASE2     L     1,ASYMOFF-BASE2(1) # Load offset in symbol table to r1
          BRC   15,-x              # Jump to start of PLT
          .word 0                  # Filler
AGOTOFF   .long ?                  # Offset in the GOT
ASYMOFF   .long ?                  # Offset in the symbol table</xmp>
<xmp props="comment" rev="v1r2"><?Pub Dtl>                              # PLT for executables (not position independent)
PLT1:     BASR  1,0
          L     1,22(1)       # Load address of the GOT entry
          L     1,0(0,1)      # Load function address from the GOT to r1
          BCR   15,1          # Jump to address
RET1:     BASR  1,0           # Return from GOT first time (lazy binding)
          L     1,14(1)       # Load offset in symbol table to r1
          BRC   15,-x         # Jump to start of PLT
          .word 0             # Filler
          .long ?             # Address of the GOT entry
          .long ?             # Offset into the symbol table

                              # PLT for shared objects (position independent)
PLT1:     LARL  1,&lt;<ph style="italic">fn</ph>&gt;@GOTENT # Load address of GOT entry in r1
          LG    1,0(1)        # Load function address from the GOT to r1
          BCR   15,1          # Jump to address
RET1:     BASR  1,0           # Return from GOT first time (lazy binding)
          LGF   1,12(1)       # Load offset in symbol table to r1
          BRCL  15,-x         # Jump to start of PLT
          .long ?             # Offset into symbol table</xmp>
<xmp rev="v1r2" propsrc="zser">*                                  # PLT for executables (not position independent)
PLT1      BASR  1,0                # Establish base
BASE1     L     1,AGOTENT-BASE1(1) # Load address of the GOT entry
          L     1,0(0,1)           # Load function address from the GOT to r1
          BCR   15,1               # Jump to address
RET1      BASR  1,0                # Return from GOT first time (lazy binding)
BASE2     L     1,ASYMOFF-BASE2(1) # Load offset in symbol table to r1
          BRC   15,-x              # Jump to start of PLT
          .word 0                  # Filler
AGOTENT   .long ?                  # Address of the GOT entry
ASYMOFF   .long ?                  # Offset into the symbol table

*                                  # PLT for shared objects (position independent)
PLT1      LARL  1,&lt;<ph style="italic">fn</ph>&gt;@GOTENT      # Load address of GOT entry in r1
          LG    1,0(1)             # Load function address from the GOT to r1
          BCR   15,1               # Jump to address
RET1      BASR  1,0                # Return from GOT first time (lazy binding)
BASE2     LGF   1,ASYMOFF-BASE2(1) # Load offset in symbol table to r1
          BRCL  15,-x              # Jump to start of PLT
ASYMOFF   .long ?                  # Offset into symbol table</xmp>
</fig>
<p>As described below the dynamic linker and the program cooperate to resolve
symbolic references through the PLT. Again, the details described below are
for explanation only. The precise execution-time behavior of the dynamic linker
is not specified.</p>
<ol>
<li>The caller of a function in a different shared object transfers control
to the start of the PLT entry associated with the function.</li>
<i1><idxterm>lazy binding</idxterm></i1>
<i1><idxterm>binding, lazy</idxterm></i1>
<li>The first part of the PLT entry loads the address from the GOT entry associated
with the function to be called. The control is transferred to the code referenced
by the address. If the function has already been called at least once, or
lazy binding is not used, then the address found in the GOT is the address
of the function.</li>
<li>If a function has never been called and lazy binding is used then the
address in the GOT points to the second half of the PLT. The second half loads
the offset in the symbol table associated with the called function. Control
is then transferred to the special first entry of the PLT.</li>
<li>This first entry of the PLT entry (<xref refid="plt0ex">) calls the dynamic
linker giving it the offset into the symbol table and the address of a structure
that identifies the location of the caller.</li>
<li>The dynamic linker finds the real address of the symbol. It will store
this address in the GOT entry of the function in the object code of the caller
and it will then transfer control to the function.</li>
<li>Subsequent calls to the function from this object will find the resolved
address in the first half of the PLT entry and will transfer control directly
without invoking the dynamic linker.</li>
</ol>
<fig frame="box" id="plt0ex" propsrc="colfig"><cap>Special first entry in
Procedure Linkage Table</cap>
<xmp props="comment" rev="v1r2"><?Pub Dtl>                              # PLT0 for static object (not position-independent)
PLT0:     ST    1,28(15)      # R1 has offset into symbol table
          BASR  1,0
          L     1,18(0,1)     # Get address of GOT
          MVC   24(4,15),4(1) # Move loader info to stack
          L     1,8(1)        # Get address of loader
          BR    1             # Jump to loader
          .word 0             # Filler
          .long got           # Address of GOT

                              # PLT0 for shared object (position-independent)
PLT0:     ST    1,28(15)      # R1 has offset into symbol table
          L     1,4(12)       # Get loader info (object struct address)
          ST    1,24(15)      # Store address
          L     1,8(12)       # Entry address of loader in R1
          BR    1             # Jump to loader</xmp>
<xmp rev="v1r2" propsrc="s390">*                               # PLT0 for static object (not position-independent)
PLT0      ST    1,28(15)        # R1 has offset into symbol table
          BASR  1,0             # Establish base
BASE1     L     1,AGOT-BASE1(1) # Get address of GOT
          MVC   24(4,15),4(1)   # Move loader info to stack
          L     1,8(1)          # Get address of loader
          BR    1               # Jump to loader
          .word 0               # Filler
AGOT      .long got             # Address of GOT

                                # PLT0 for shared object (position-independent)
PLT0      ST    1,28(15)        # R1 has offset into symbol table
          L     1,4(12)         # Get loader info (object struct address)
          ST    1,24(15)        # Store address
          L     1,8(12)         # Entry address of loader in R1
          BR    1               # Jump to loader</xmp>
<xmp props="comment" rev="v1r2"><?Pub Dtl>                              # PLT0 for static object (not position-independent)
PLT0:     ST    1,28(15)      # R1 has offset into symbol table
          BASR  1,0
          L     1,18(0,1)     # Get address of GOT
          MVC   24(4,15),4(1) # Move loader info to stack
          L     1,8(1)        # Get address of loader
          BR    1             # Jump to loader
          .word 0             # Filler
          .long got           # Address of GOT

                              # PLT0 for shared object (position-independent)
PLT0:     STG   1,56(15)      # R1 has offset into symbol table
          LARL  1,_GLOBAL_OFFSET_TABLE_
          MVC   48(8,15),8(1) # move loader info (object struct address) to stack
          LG    1,16(12)      # Entry address of loader in R1
          BCR   15,1          # Jump to loader</xmp>
<xmp rev="v1r2" propsrc="zser">*                               # PLT0 for static object (not position-independent)
PLT0      ST    1,28(15)        # R1 has offset into symbol table
          BASR  1,0             # Establish base
BASE1     L     1,AGOT-BASE1(1) # Get address of GOT
          MVC   24(4,15),4(1)   # Move loader info to stack
          L     1,8(1)          # Get address of loader
          BR    1               # Jump to loader
          .word 0               # Filler
AGOT      .long got             # Address of GOT

                                # PLT0 for shared object (position-independent)
PLT0      STG   1,56(15)        # R1 has offset into symbol table
          LARL  1,_GLOBAL_OFFSET_TABLE_
          MVC   48(8,15),8(1)   # move loader info (object struct address) to stack
          LG    1,16(12)        # Entry address of loader in R1
          BCR   15,1            # Jump to loader</xmp>
</fig>
<p>The <xph>LD_BIND_NOW</xph> environment variable can change dynamic linking
behavior. If its value is not null the dynamic linker resolves the function
call binding at load time, before transferring control to the program. In
other words the dynamic linker processes relocation entries of type <xph>
R_390_JMP_SLOT</xph> during process initialization.  If <xph>LD_BIND_NOW</xph> is
null the dynamic linker evaluates PLT entries lazily, delaying symbol resolution
and relocation until the first execution of a table entry.</p>
<note><notebody>Lazy binding generally improves overall application performance
because unused symbols do not incur the overhead of dynamic linking. Nevertheless,
two situations make lazy binding undesirable for some applications:<ol>
<li>The initial reference to a shared object function takes longer than subsequent
calls because the dynamic linker intercepts the call to resolve the symbol,
and some applications cannot tolerate this unpredictability.</li>
<li>If an error occurs and the dynamic linker cannot resolve the symbol, the
dynamic linker will terminate the program. Under lazy binding, this might
occur at arbitrary times. Once again, some applications cannot tolerate this
unpredictability. By turning off lazy binding, the dynamic linker forces the
failure to occur during process initialization, before the application receives
control.</li>
</ol></notebody></note>
</dbody></d>
</dbody></d>
</dbody></d>
</body>
<backm>
<appendix>
<!--Appendixes-->
<d props="comment">
<dprolog><titleblk>
<title>More information</title>
</titleblk></dprolog>
<dbody>
<p>This is a sample appendix. Include these as needed:<ul>
<li>Supplemental information</li>
<li>Hardware Warranty (if required)</li>
<li>System Programs License Agreement (for hardware, if required)</li>
<li>License Information (if not a separate document)</li>
</ul></p>
</dbody></d>
<d props="LSB">
<dprolog><titleblk>
<title>GNU Free Documentation License</title>
</titleblk></dprolog>
<dintro><toc><gendtitle></toc></dintro>
<dbody>
<p>A current copy of the license can be found at:</p>
<p>http://www.linuxbase.org/spec/refspecs/LSB_1.2.0/gLSB/gfdl.html</p>
<p>Version 1.1, March 2000       </p>
<p>Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place, Suite
330, Boston, MA 02111-1307 USA      Everyone is permitted to copy and distribute
verbatim copies of this license document, but changing it is not allowed.
</p>
<d>
<dprolog><titleblk>
<title>PREAMBLE</title>
</titleblk></dprolog>
<dbody>
<p>The purpose of this License is to make a manual, textbook, or other written
document "free" in the sense of freedom: to assure everyone the effective
freedom to copy and redistribute it, with or without modifying it, either
commercially or noncommercially. Secondarily, this License preserves for the
author and publisher a way to get credit for their work, while not being considered
responsible for modifications made by others.  This License is a kind of "copyleft",
which means that derivative works of the document must themselves be free in
the same sense. It complements the GNU General Public License, which is a
copyleft license designed for free software.  We have designed this License
in order to use it for manuals for free software, because free software needs
free documentation: a free program should come with manuals providing the
same freedoms that the software does. But this License is not limited to software
manuals; it can be used for any textual work, regardless of subject matter
or whether it is published as a printed book. We recommend this License principally for
works whose purpose is instruction or reference.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>APPLICABILITY AND DEFINITIONS</title>
</titleblk></dprolog>
<dbody>
<p>This License applies to any manual or other work that contains a notice
placed by the copyright holder saying it can be distributed under the terms
of this License. The "Document", below, refers to any such manual or work.
Any member of the public is a licensee, and is addressed as "you".  </p>
<p>A "Modified Version" of the Document means any work containing the Document
or a portion of it, either copied verbatim, or with modifications and/or translated
into another language.  </p>
<p>A "Secondary Section" is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the publishers
or authors of the Document to the Document's overall subject (or to related
matters) and contains nothing that could fall directly within that overall
subject. (For example, if the Document is in part a textbook of mathematics,
a Secondary Section may not explain any mathematics.) The relationship could
be a matter of historical connection with the subject or with related matters, or
of legal, commercial, philosophical, ethical or political position regarding
them.  </p>
<p>The "Invariant Sections" are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says
that the Document is released under this License.  </p>
<p>The "Cover Texts" are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document
is released under this License.  </p>
<p>A "Transparent" copy of the Document means a machine-readable copy, represented
in a format whose specification is available to the general public, whose
contents can be viewed and edited directly and straightforwardly with generic
text editors or (for images composed of pixels) generic paint programs or
(for drawings) some widely available drawing editor, and that is suitable
for input to text formatters or for automatic translation to a variety of
formats suitable for input to text formatters. A copy made in an otherwise Transparent
file format whose markup has been designed to thwart or discourage subsequent
modification by readers is not Transparent. A copy that is not "Transparent"
is called "Opaque".  </p>
<p>Examples of suitable formats for Transparent copies include plain ASCII
without markup, Texinfo input format, LaTeX input format, SGML or XML using
a publicly available DTD, and standard-conforming simple HTML designed for
human modification. Opaque formats include PostScript, PDF, proprietary formats
that can be read and edited only by proprietary word processors, SGML or XML
for which the DTD and/or processing tools are not generally available, and
the machine-generated HTML produced by some word processors for output purposes only.
 </p>
<p>The "Title Page" means, for a printed book, the title page itself, plus
such following pages as are needed to hold, legibly, the material this License
requires to appear in the title page. For works in formats which do not have
any title page as such, "Title Page" means the text near the most prominent
appearance of the work's title, preceding the beginning of the body of the
text.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>VERBATIM COPYING</title>
</titleblk></dprolog>
<dbody>
<p>You may copy and distribute the Document in any medium, either commercially
or noncommercially, provided that this License, the copyright notices, and
the license notice saying this License applies to the Document are reproduced
in all copies, and that you add no other conditions whatsoever to those of
this License. You may not use technical measures to obstruct or control the
reading or further copying of the copies you make or distribute. However,
you may accept compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3.  </p>
<p>You may also lend copies, under the same conditions stated above, and you
may publicly display copies.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>COPYING IN QUANTITY</title>
</titleblk></dprolog>
<dbody>
<p>If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover
Texts on the front cover, and Back-Cover Texts on the back cover. Both covers
must also clearly and legibly identify you as the publisher of these copies.
The front cover must present the full title with all words of the title equally
prominent and visible. You may add other material on the covers in addition. Copying
with changes limited to the covers, as long as they preserve the title of
the Document and satisfy these conditions, can be treated as verbatim copying
in other respects.  </p>
<p>If the required texts for either cover are too voluminous to fit legibly,
you should put the first ones listed (as many as fit reasonably) on the actual
cover, and continue the rest onto adjacent pages.  </p>
<p>If you publish or distribute Opaque copies of the Document numbering more
than 100, you must either include a machine-readable Transparent copy along
with each Opaque copy, or state in or with each Opaque copy a publicly-accessible
computer-network location containing a complete Transparent copy of the Document,
free of added material, which the general network-using public has access
to download anonymously at no charge using public-standard network protocols.
If you use the latter option, you must take reasonably prudent steps, when you
begin distribution of Opaque copies in quantity, to ensure that this Transparent
copy will remain thus accessible at the stated location until at least one
year after the last time you distribute an Opaque copy (directly or through
your agents or retailers) of that edition to the public.  </p>
<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give them
a chance to provide you with an updated version of the Document.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>MODIFICATIONS</title>
</titleblk></dprolog>
<dbody>
<p>You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the Modified
Version under precisely this License, with the Modified Version filling the
role of the Document, thus licensing distribution and modification of the
Modified Version to whoever possesses a copy of it. In addition, you must
do these things in the Modified Version:</p>
<ul>
<li>Use in the Title Page (and on the covers, if any) a title distinct from
that of the Document, and from those of previous versions (which should, if
there were      any, be listed in the History section of the Document). You
may use the same title as a previous version if the original publisher of
that version gives      permission.</li>
<li>List on the Title Page, as authors, one or more persons or entities responsible
for authorship of the modifications in the Modified Version, together with
at      least five of the principal authors of the Document (all of its principal
authors, if it has less than five).</li>
<li>State on the Title page the name of the publisher of the Modified Version,
as the publisher.</li>
<li>Preserve all the copyright notices of the Document.</li>
<li>Add an appropriate copyright notice for your modifications adjacent to
the other copyright notices.</li>
<li>Include, immediately after the copyright notices, a license notice giving
the public permission to use the Modified Version under the terms of this
License, in      the form shown in the Addendum below.</li>
<li>Preserve in that license notice the full lists of Invariant Sections and
required Cover Texts given in the Document's license notice.</li>
<li>Include an unaltered copy of this License.</li>
<li>Preserve the section entitled "History", and its title, and add to it
an item stating at least the title, year, new authors, and publisher of the
Modified Version as      given on the Title Page. If there is no section entitled
"History" in the Document, create one stating the title, year, authors, and
publisher of the Document as      given on its Title Page, then add an item
describing the Modified Version as stated in the previous sentence.</li>
<li> Preserve the network location, if any, given in the Document for public
access to a Transparent copy of the Document, and likewise the network locations
     given in the Document for previous versions it was based on. These may
be placed in the "History" section. You may omit a network location for a
work that      was published at least four years before the Document itself,
or if the original publisher of the version it refers to gives permission.
</li>
<li>In any section entitled "Acknowledgements" or "Dedications", preserve
the section's title, and preserve in the section all the substance and tone
of each of the      contributor acknowledgements and/or dedications given
therein.</li>
<li>Preserve all the Invariant Sections of the Document, unaltered in their
text and in their titles. Section numbers or the equivalent are not considered
part of the      section titles.</li>
<li>Delete any section entitled "Endorsements". Such a section may not be
included in the Modified Version.</li>
<li>Do not retitle any existing section as "Endorsements" or to conflict in
title with any Invariant Section.</li>
</ul>
<p>If the Modified Version includes new front-matter sections or appendices
that qualify as Secondary Sections and contain no material copied from the
Document, you may at your option designate some or all of these sections as
invariant. To do this, add their titles to the list of Invariant Sections
in the Modified Version's license notice. These titles must be distinct from
any other section titles.  </p>
<p>You may add a section entitled "Endorsements", provided it contains nothing
but endorsements of your Modified Version by various parties--for example,
statements of peer review or that the text has been approved by an organization
as the authoritative definition of a standard.  </p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list of
Cover Texts in the Modified Version. Only one passage of Front-Cover Text
and one of Back-Cover Text may be added by (or through arrangements made by)
any one entity. If the Document already includes a cover text for the same
cover, previously added by you or by arrangement made by the same entity you
are acting on behalf of, you may not add another; but you may replace the old
one, on explicit permission from the previous publisher that added the old
one.  </p>
<p>The author(s) and publisher(s) of the Document do not by this License give
permission to use their names for publicity for or to assert or imply endorsement
of any Modified Version.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>COMBINING DOCUMENTS</title>
</titleblk></dprolog>
<dbody>
<p>You may combine the Document with other documents released under this License,
under the terms defined in section 4 above for modified versions, provided
that you include in the combination all of the Invariant Sections of all of
the original documents, unmodified, and list them all as Invariant Sections
of your combined work in its license notice.  </p>
<p>The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there
are multiple Invariant Sections with the same name but different contents,
make the title of each such section unique by adding at the end of it, in
parentheses, the name of the original author or publisher of that section
if known, or else a unique number. Make the same adjustment to the section
titles in the list of Invariant Sections in the license notice of the combined work.
 </p>
<p>In the combination, you must combine any sections entitled "History" in
the various original documents, forming one section entitled "History"; likewise
combine any sections entitled "Acknowledgements", and any sections entitled
"Dedications". You must delete all sections entitled "Endorsements."</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>COLLECTIONS OF DOCUMENTS</title>
</titleblk></dprolog>
<dbody>
<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this License
in the various documents with a single copy that is included in the collection,
provided that you follow the rules of this License for verbatim copying of
each of the documents in all other respects.  </p>
<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this License
into the extracted document, and follow this License in all other respects
regarding verbatim copying of that document.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>AGGREGATION WITH INDEPENDENT WORKS</title>
</titleblk></dprolog>
<dbody>
<p>A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or distribution
medium, does not as a whole count as a Modified Version of the Document, provided
no compilation copyright is claimed for the compilation. Such a compilation
is called an "aggregate", and this License does not apply to the other self-contained
works thus compiled with the Document, on account of their being thus compiled,
if they are not themselves derivative works of the Document.  </p>
<p>If the Cover Text requirement of section 3 is applicable to these copies
of the Document, then if the Document is less than one quarter of the entire
aggregate, the Document's Cover Texts may be placed on covers that surround
only the Document within the aggregate. Otherwise they must appear on covers
around the whole aggregate.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>TRANSLATION</title>
</titleblk></dprolog>
<dbody>
<p>Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4. Replacing Invariant
Sections with translations requires special permission from their copyright
holders, but you may include translations of some or all Invariant Sections
in addition to the original versions of these Invariant Sections. You may
include a translation of this License provided that you also include the original
English version of this License. In case of a disagreement between the translation and
the original English version of this License, the original English version
will prevail.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>TERMINATION</title>
</titleblk></dprolog>
<dbody>
<p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License. Any other attempt to copy, modify,
sublicense or distribute the Document is void, and will automatically terminate
your rights under this License. However, parties who have received copies,
or rights, from you under this License will not have their licenses terminated
so long as such parties remain in full compliance.</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>FUTURE REVISIONS OF THIS LICENSE</title>
</titleblk></dprolog>
<dbody>
<p>The Free Software Foundation may publish new, revised versions of the GNU
Free Documentation License from time to time. Such new versions will be similar
in spirit to the present version, but may differ in detail to address new
problems or concerns. See http://www.gnu.org/copyleft/.  </p>
<p>Each version of the License is given a distinguishing version number. If
the Document specifies that a particular numbered version of this License
"or any later version" applies to it, you have the option of following the
terms and conditions either of that specified version or of any later version
that has been published (not as a draft) by the Free Software Foundation.
If the Document does not specify a version number of this License, you may
choose any version ever published (not as a draft) by the Free Software Foundation.
</p>
</dbody></d>
<d>
<dprolog><titleblk>
<title>How to use this License for your documents</title>
</titleblk></dprolog>
<dbody>
<p>To use this License in a document you have written, include a copy of the
License in the document and put the following copyright and license notices
just after the title page:</p>
<lines>	Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute 
	and/or modify this document under the terms of the GNU Free Documentation 
	License, Version 1.1 or any later version published by the Free Software Foundation; 
	with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover 
	Texts being LIST, and with the Back-Cover Texts 	being LIST. 
	A copy of the license is included in the section entitled
     "GNU Free Documentation License".</lines>
<p>If you have no Invariant Sections, write "with no Invariant Sections" instead
of saying which ones are invariant. If you have no Front-Cover Texts, write
"no Front-Cover Texts" instead of "Front-Cover Texts being LIST"; likewise
for Back-Cover Texts.  </p>
<p>If your document contains nontrivial examples of program code, we recommend
releasing these examples in parallel under your choice of free software license,
such as the GNU General Public License, to permit their use in free software.
</p>
</dbody></d><?Pub Caret>
</dbody></d>
</appendix>&notices;
<glossary props="comment"><?Pub Dtl>
<!--Glossary-->
<specdprolog><gendtitle></specdprolog><dbody>
<gl>
<glentry><term>aardvark</term><defn>Long&ndash;snouted, ant-eating African
mammal.</defn></glentry>
<glentry><term>zebra</term><defn>Horselike African mammal marked with light
and dark stripes.</defn></glentry>
</gl>
</dbody></glossary>
<bibliog>
<!--Bibliography-->
<specdprolog><gendtitle></specdprolog><dbody>
<p>Related publications:<ul>
<li propsrc="zser"><cit bibid="b0001">: SA22&ndash;7832</li>
<li propsrc="s390"><cit bibid="b0002">: SA22&ndash;7201</li>
<li><cit bibid="b0003"></li>
</ul></p>
</dbody></bibliog>
<index><gendtitle></index>
<rcf>
<!--Reader comment form, this is optional.-->
<gendtitle></rcf>
</backm>
</ibmiddoc>
<?Pub *0000264145>
