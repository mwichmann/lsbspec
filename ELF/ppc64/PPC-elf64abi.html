<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>64-bit PowerPC ELF Application Binary Interface Supplement 1.6</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>64-bit PowerPC ELF Application Binary Interface Supplement 1.6</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN21"
></A
>Ian Lance Taylor</H3
><DIV
CLASS="AFFILIATION"
><SPAN
CLASS="ORGNAME"
>Zembu Labs<BR></SPAN
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 1999, 2003 IBM Corporation</P
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2003 Free Standards Group</P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN14"
></A
><P
>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free 
		Documentation License, Version 1.1; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover 
		Texts. A copy of the license is available from 
		<A
HREF="http://www.linuxbase.org/spec/refspecs/LSB_1.2.0/gLSB/gfdl.html"
TARGET="_top"
>http://www.linuxbase.org/spec/refspecs/LSB_1.2.0/gLSB/gfdl.html</A
>.
		</P
><P
></P
></DIV
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN17"
></A
><P
>The following terms are trademarks or registered trademarks of International Business Machines Corporation in 
		the United States and/or other countires: AIX, PowerPC.  A full list U.S. trademarks owned by IBM may be found at 
		<A
HREF="http://www.ibm.com/legal/copytrade.shtml"
TARGET="_top"
>http://www.ibm.com/legal/copytrade.shtml</A
>.
		</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#TOCINTRO"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#HOWTO"
>How to Use the 64-bit PowerPC ELF ABI Supplement</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#INSTALL"
>Software Installation</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN110"
>Physical Distribution Media and Formats</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#LOW-LEVEL"
>Low Level System Information</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#MACHINE"
>Machine Interface</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#PROCESSOR"
>Processor Architecture</A
></DT
><DT
>3.1.2. <A
HREF="#DATA-REP"
>Data Representation</A
></DT
><DT
>3.1.3. <A
HREF="#BYTEORDER"
>Byte Ordering</A
></DT
><DT
>3.1.4. <A
HREF="#FUND-TYPE"
>Fundamental Types</A
></DT
><DT
>3.1.5. <A
HREF="#AGG-UNION"
>Aggregates and Unions</A
></DT
><DT
>3.1.6. <A
HREF="#BITFIELD"
>Bit-fields</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="#FUNC-CALL"
>Function Calling Sequence</A
></DT
><DD
><DL
><DT
>3.2.1. <A
HREF="#REG"
>Registers</A
></DT
><DT
>3.2.2. <A
HREF="#STACK"
>The Stack Frame</A
></DT
><DT
>3.2.3. <A
HREF="#PARAM-PASS"
>Parameter Passing</A
></DT
><DT
>3.2.4. <A
HREF="#RETURN-VAL"
>Return Values</A
></DT
><DT
>3.2.5. <A
HREF="#FUNC-DES"
>Function Descriptors</A
></DT
></DL
></DD
><DT
>3.3. <A
HREF="#TRACEBACK"
>Traceback Tables</A
></DT
><DD
><DL
><DT
>3.3.1. <A
HREF="#MAND-FIELD"
>Mandatory Fields</A
></DT
><DT
>3.3.2. <A
HREF="#OPT-FIELD"
>Optional Fields</A
></DT
></DL
></DD
><DT
>3.4. <A
HREF="#PROC-INIT"
>Process Initialization</A
></DT
><DD
><DL
><DT
>3.4.1. <A
HREF="#PROC-REG"
>Registers</A
></DT
><DT
>3.4.2. <A
HREF="#PROC-STACK"
>Process Stack</A
></DT
></DL
></DD
><DT
>3.5. <A
HREF="#CODE-EX"
>Coding Examples</A
></DT
><DD
><DL
><DT
>3.5.1. <A
HREF="#MOD-OVER"
>Code Model Overview</A
></DT
><DT
>3.5.2. <A
HREF="#TOC-SEC"
>The TOC section</A
></DT
><DT
>3.5.3. <A
HREF="#TOCALS"
>TOC Assembly Language Syntax</A
></DT
><DT
>3.5.4. <A
HREF="#PRO-EP"
>Function Prologue and Epilogue</A
></DT
><DT
>3.5.5. <A
HREF="#SAVE-RES"
>Register Saving and Restoring Functions</A
></DT
><DT
>3.5.6. <A
HREF="#SAVEREG"
>Saving General Registers Only</A
></DT
><DT
>3.5.7. <A
HREF="#SAVE-FLOAT"
>Saving General Registers and Floating Point Registers</A
></DT
><DT
>3.5.8. <A
HREF="#AEN628"
>Saving Floating Point Registers Only</A
></DT
><DT
>3.5.9. <A
HREF="#SAVE-RESTORE"
>Save and Restore Services</A
></DT
><DT
>3.5.10. <A
HREF="#DATA-OBJ"
>Data Objects</A
></DT
><DT
>3.5.11. <A
HREF="#FUNC-CALLS"
>Function Calls</A
></DT
><DT
>3.5.12. <A
HREF="#BRANCH"
>Branching</A
></DT
><DT
>3.5.13. <A
HREF="#DYNAM-STACK"
>Dynamic Stack Space Allocation</A
></DT
></DL
></DD
><DT
>3.6. <A
HREF="#DW-DEF"
>DWARF Definition</A
></DT
><DD
><DL
><DT
>3.6.1. <A
HREF="#AEN728"
>DWARF Release Number</A
></DT
><DT
>3.6.2. <A
HREF="#DW-REG"
>DWARF Register Number Mapping</A
></DT
></DL
></DD
></DL
></DD
><DT
>4. <A
HREF="#OBJ-FILES"
>Object Files</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#ELF-HEAD"
>ELF Header</A
></DT
><DT
>4.2. <A
HREF="#SPECIAL"
>Special Sections</A
></DT
><DT
>4.3. <A
HREF="#TOC"
>TOC</A
></DT
><DT
>4.4. <A
HREF="#SYM"
>Symbol Table</A
></DT
><DD
><DL
><DT
>4.4.1. <A
HREF="#SYM-VAL"
>Symbol Values</A
></DT
></DL
></DD
><DT
>4.5. <A
HREF="#RELOC"
>Relocation</A
></DT
><DD
><DL
><DT
>4.5.1. <A
HREF="#RELOC-TYPE"
>Relocation Types</A
></DT
></DL
></DD
></DL
></DD
><DT
>5. <A
HREF="#PROG-LOAD-DL"
>Program Loading and Dynamic Linking</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#PROG-DL"
>Program Loading</A
></DT
><DD
><DL
><DT
>5.1.1. <A
HREF="#PROG-INT"
>Program Interpreter</A
></DT
></DL
></DD
><DT
>5.2. <A
HREF="#DYNAM-LINK"
>Dynamic Linking</A
></DT
><DD
><DL
><DT
>5.2.1. <A
HREF="#DYNAM-SECT"
>Dynamic Section</A
></DT
><DT
>5.2.2. <A
HREF="#GLOBAL"
>Global Offset Table</A
></DT
><DT
>5.2.3. <A
HREF="#FUNC-ADDRESS"
>Function Addresses</A
></DT
><DT
>5.2.4. <A
HREF="#PROC-LINK"
>Procedure Linkage Table</A
></DT
></DL
></DD
></DL
></DD
><DT
>6. <A
HREF="#LIB"
>Libraries</A
></DT
><DT
>A. <A
HREF="#GFDL"
>GNU Free Documentation License</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#GFDL-0"
>PREAMBLE</A
></DT
><DT
>A.2. <A
HREF="#GFDL-1"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>A.3. <A
HREF="#GFDL-2"
>VERBATIM COPYING</A
></DT
><DT
>A.4. <A
HREF="#GFDL-3"
>COPYING IN QUANTITY</A
></DT
><DT
>A.5. <A
HREF="#GFDL-4"
>MODIFICATIONS</A
></DT
><DT
>A.6. <A
HREF="#GFDL-5"
>COMBINING DOCUMENTS</A
></DT
><DT
>A.7. <A
HREF="#GFDL-6"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>A.8. <A
HREF="#GFDL-7"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>A.9. <A
HREF="#GFDL-8"
>TRANSLATION</A
></DT
><DT
>A.10. <A
HREF="#GFDL-9"
>TERMINATION</A
></DT
><DT
>A.11. <A
HREF="#GFDL-10"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>A.12. <A
HREF="#GFDL-11"
>How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>3-1. <A
HREF="#AEN136"
>Bit and Byte Numbering in Halfwords</A
></DT
><DT
>3-2. <A
HREF="#AEN139"
>Bit and Byte Numbering in Words</A
></DT
><DT
>3-3. <A
HREF="#AEN142"
>Bit and Byte Numbering in Doublewords</A
></DT
><DT
>3-4. <A
HREF="#AEN145"
>Bit and Byte Numbering in Quadwords</A
></DT
><DT
>3-5. <A
HREF="#AEN170"
>Structure Smaller Than a Word</A
></DT
><DT
>3-6. <A
HREF="#AEN175"
>No Padding</A
></DT
><DT
>3-7. <A
HREF="#AEN180"
>Internal Padding</A
></DT
><DT
>3-8. <A
HREF="#AEN185"
>Internal and Tail Padding</A
></DT
><DT
>3-9. <A
HREF="#AEN190"
>Union Allocation</A
></DT
><DT
>3-10. <A
HREF="#AEN220"
>Bit Numbering</A
></DT
><DT
>3-11. <A
HREF="#AEN223"
>Bit-field Allocation</A
></DT
><DT
>3-12. <A
HREF="#AEN228"
>Boundary Alignment</A
></DT
><DT
>3-13. <A
HREF="#AEN233"
>Doubleword Boundary Alignment</A
></DT
><DT
>3-14. <A
HREF="#AEN238"
>Storage Unit Sharing</A
></DT
><DT
>3-15. <A
HREF="#AEN243"
>Union Allocation</A
></DT
><DT
>3-16. <A
HREF="#AEN248"
>Unnamed bit-fields</A
></DT
><DT
>3-17. <A
HREF="#AEN297"
>Stack Frame Organiztion</A
></DT
><DT
>3-18. <A
HREF="#AEN383"
>Parameter Passing</A
></DT
><DT
>4-1. <A
HREF="#AEN832"
>Relocation Table</A
></DT
><DT
>5-1. <A
HREF="#AEN899"
>Virtual Address</A
></DT
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TOCINTRO"
></A
>Chapter 1. Introduction</H1
><P
>ELF defines a linking interface for compiled application programs. ELF is described in two parts.  The first part 
		is the generic System V ABI.  The second part is a processor specific supplement.
		</P
><P
>This document is the processor specific supplement for use with ELF on 64-bit 
		<SPAN
CLASS="TRADEMARK"
>PowerPC</SPAN
>&reg; processor systems.
		</P
><P
>This document is not a complete System V Application Binary Interface Supplement, because it does not 
		define any library interfaces.
		</P
><P
>In the 64-bit <SPAN
CLASS="TRADEMARK"
>PowerPC Architecture</SPAN
>&#8482;, a processor can run in either of 
		two modes: big-endian mode or 
		little-endian mode.  (See <A
HREF="#BYTEORDER"
>Section 3.1.3</A
>.)  Accordingly, this ABI specification 
		really defines two binary interfaces, a big-endian ABI and a little-endian ABI.  Programs and (in general) data 
		produced by programs that run on an implementation of the big-endian interface are not portable to an implementation 
		of the little-endian interface, and vice versa. The 64-bit PowerPC ELF ABI is not the same as the 32-bit PowerPC 
		ELF ABI, nor is it a simple extension.  A system which supports the 64-bit PowerPC ELF ABI may, but need not, 
		support the 32-bit PowerPC ELF ABI.
		</P
><P
>The <I
CLASS="CITETITLE"
>64-bit PowerPC ELF ABI</I
> is intended to use the same structure layout and calling 
		convention rules as the 64-bit PowerOpen ABI.
		</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HOWTO"
>1.1. How to Use the 64-bit PowerPC ELF ABI Supplement</A
></H2
><P
>While the generic <I
CLASS="CITETITLE"
>System V ABI</I
> is the prime reference document, this document contains  64-bit PowerPC 
		processor-specific implementation details, some of which supersedes information in the generic ABI.
		</P
><P
>As with the System V ABI, this document refers to other publicly available documents, especially the book 
		titled <I
CLASS="CITETITLE"
>IBM PowerPC User Instruction Set Architecture</I
>, all of which should be considered part of 
		this <I
CLASS="CITETITLE"
>64-bit PowerPC Processor ABI Supplement</I
> and just as binding as the requirements and data it explicitly includes.
		</P
><P
>The following documents may be of interest to the reader of this specification:
		</P
><P
></P
><UL
><LI
><P
><I
CLASS="CITETITLE"
>System V Interface Definition</I
>, Issue 3.</P
></LI
><LI
><P
><I
CLASS="CITETITLE"
>The PowerPC Architecture: A Specification for A New Family of RISC 
				Processors</I
>.  International Business Machines (IBM). San Francisco:  Morgan 
				Kaufmann, 1994.</P
></LI
><LI
><P
><I
CLASS="CITETITLE"
>DWARF Debugging Information Format, Revision: Version 2.0.0
				</I
>, July 27, 1993.  UNIX International, Program Languages SIG.</P
></LI
><LI
><P
><I
CLASS="CITETITLE"
>The [32-bit] PowerPC Processor Supplement</I
>, Sun 
				Microsystems, 1995.</P
></LI
><LI
><P
><I
CLASS="CITETITLE"
>The 64-bit AIX ABI</I
></P
></LI
><LI
><P
><I
CLASS="CITETITLE"
>The PowerOpen ABI</I
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INSTALL"
></A
>Chapter 2. Software Installation</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN110"
>2.1. Physical Distribution Media and Formats</A
></H2
><P
>This document does not specify any physical distribution media or formats.  Any agreed upon distribution 
		media may be used.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOW-LEVEL"
></A
>Chapter 3. Low Level System Information</H1
><P
></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MACHINE"
>3.1. Machine Interface</A
></H2
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROCESSOR"
>3.1.1. Processor Architecture</A
></H3
><P
><I
CLASS="CITETITLE"
>The PowerPC Architecture: A Specification for A New Family of RISC Processors
			</I
> defines the 64-bit PowerPC Architecture.  Programs intended to execute directly on the 
			processor use the 64-bit PowerPC instruction set, and the instruction encodings and semantics of the 
			architecture.
			</P
><P
>An application program can assume that all instructions defined by the architecture that are neither 
			privileged nor optional exist and work as documented.  However, the "Fixed-Point Move Assist" 
			instructions are not available in little-endian implementations.  In little-endian mode, these instructions 
			always cause alignment exceptions in the 64-bit PowerPC Architecture; in big-endian mode they are 
			usually slower than a sequence of other instructions that have the same effect.
			</P
><P
>To be ABI-conforming, the processor must implement the instructions of the architecture, perform the 
			 specified operations, and produce the expected results.  The ABI neither places performance constraints 
			on systems nor specifies what instructions must be implemented in hardware.  A software emulation of the 
			architecture could conform to the ABI.
			</P
><P
>Some processors might support the optional instructions in the 64-bit PowerPC Architecture, or 
			additional non-64-bit-PowerPC instructions or capabilities.  Programs that use those instructions or 
			capabilities do not conform to the 64-bit PowerPC ABI; executing them on machines without the additional 
			capabilities gives undefined behavior.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DATA-REP"
>3.1.2. Data Representation</A
></H3
><P
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BYTEORDER"
>3.1.3. Byte Ordering</A
></H3
><P
>The architecture defines an 8-bit byte, a 16-bit halfword, a 32-bit word, a 64-bit doubleword, and a 
			128-bit quadword.  Byte ordering defines how the bytes that make up halfwords, words, doublewords, and 
			quadwords are ordered in memory.  Most significant byte (MSB) byte ordering, or "big-endian" as it is 
			sometimes called, means that the most significant byte is located in the lowest addressed byte position 
			in a storage unit (byte 0).  Least significant byte (LSB) byte ordering, or "little-endian" as it is sometimes 
			called, means that the least significant byte is located in the lowest addressed byte position in a storage 
			unit (byte 0).
			</P
><P
>The 64-bit PowerPC processor family supports either big-endian or little-endian byte ordering.  This 
			specification defines two ABIs, one for each type of byte ordering.  An implementation must state which 
			type of byte ordering it supports. The following figures illustrate the conventions for bit and byte numbering 
			within various width storage units.  These conventions apply to both integer data and floating-point data, 
			where the most significant byte of a floating-point value holds the sign and at least the start of the exponent.
  			The figures show little-endian byte numbers in the upper right corners, big-endian byte numbers in the 
			upper left corners, and bit numbers in the lower corners.
			</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In the 64-bit PowerPC Architecture documentation, the bits in a word are 
					numbered from left to right (MSB to LSB), and figures usually show only the big-endian 
					byte order.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN136"
></A
><P
><B
>Figure 3-1. Bit and Byte Numbering in Halfwords</B
></P
><PRE
CLASS="SCREEN"
>+-------+-------+
|0     1|1     0|
|  msb  |  lsb  |
|0     7| 8   15|
+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN139"
></A
><P
><B
>Figure 3-2. Bit and Byte Numbering in Words</B
></P
><PRE
CLASS="SCREEN"
>+-------+-------+-------+-------+
|0     3|1     2|2     1|3     0|
|  msb  |       |       |  lsb  |
|0     7|8    15|16   23|24   31|
+-------+-------+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN142"
></A
><P
><B
>Figure 3-3. Bit and Byte Numbering in Doublewords</B
></P
><PRE
CLASS="SCREEN"
>+-------+-------+-------+-------+
|0     7|1     6|2     5|3     4|
|  msb  |       |       |       |
|0     7|8    15|16   23|24   31|
+-------+-------+-------+-------+
|4     3|5     2|6     1|7     0|
|       |       |       |  lsb  |
|32   39|40   47|48   55|56   63|
+-------+-------+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN145"
></A
><P
><B
>Figure 3-4. Bit and Byte Numbering in Quadwords</B
></P
><PRE
CLASS="SCREEN"
>+-------+-------+-------+-------+
|0    15|1    14|2    13|3    12|
|  msb  |       |       |       |
|0     7|8    15|16   23|24   31|
+-------+-------+-------+-------+
|4    11|5    10|6     9|7     8|
|       |       |       |       |
|32   39|40   47|48   55|56   63|
+-------+-------+-------+-------+
|8     7|9     6|10    5|11    4|
|       |       |       |       |
|64   71|72   79|80   87|88   95|
+-------+-------+-------+-------+
|12    3|13    2|14    1|15    0|
|       |       |       |  lsb  |
|96  103|104 111|112 119|120 127|
+-------+-------+-------+-------+</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FUND-TYPE"
>3.1.4. Fundamental Types</A
></H3
><P
>The following table shows how ANSI C scalar types correspond to those of the 64-bit PowerPC 
			processor. For all types, a NULL pointer has the value zero.  The alignment column specifies the required 
			alignment of a field of the given type within a struct.  The required alignment of a double or long double 
			field is word, not doubleword or quadword as might be expected from the size of the field.  Variables may 
			be more strictly aligned than is shown in the table above, but fields in a struct must follow the alignment 
			specified above in order to ensure consistent struct mapping.
			</P
><P
>"Extended precision" IBM <SPAN
CLASS="TRADEMARK"
>AIX</SPAN
>&reg; 128-bit long double 
			format composed of two  double-precision numbers with different magnitudes that do not overlap.  The 
			high-order double-precision value (the one that comes first in storage) must have the larger magnitude. The  			 value of the extended-precision number is the sum of the two double-precision values.  For a value of 
			NaN or infinity, you must encode one of these values within the high-order double-precision value. The 
			low-order value is not significant.  Extended precision provides the same range of double precision (about 
			10<SUP
>(-308)</SUP
> to 10<SUP
>308</SUP
>) but more precision (a variable amount, about 31 decimal digits or more).  The 
			software support is restricted to round-to-nearest mode. Programs that use extended precision must ensure 
			that this rounding mode is in effect when extended-precision calculations are performed.
			</P
><PRE
CLASS="SCREEN"
>Type         ANSI C          sizeof    Alignment    PowerPC
-------------------------------------------------------------------------
Character    char            1         byte         unsigned byte
             unsigned char
             ------------------------------------------------------------
             signed char     1         byte         signed byte
             ------------------------------------------------------------
             short           2         halfword     signed halfword
             signed short
             ------------------------------------------------------------
             unsigned short  2         halfword     unsigned halfword
-------------------------------------------------------------------------
Integral     int             4         word         signed word
             signed int
             enum
             ------------------------------------------------------------
             unsigned int    4         word         unsigned word
             ------------------------------------------------------------
             long int        8         doubleword   signed doubleword
             signed long
             long long
             ------------------------------------------------------------
             unsigned long   8         doubleword   unsigned doubleword
             unsigned long long
-------------------------------------------------------------------------
Pointer      any *           8         doubleword   unsigned doubleword
             any (*) ()
-------------------------------------------------------------------------
Floating     float           4         word         single precision
             ------------------------------------------------------------
             double          8         word         double precision
             ------------------------------------------------------------
             long double     16        word         extended precision
				</PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>When compared to the 32-bit PowerPC Processor Supplement, the size and alignment of 
				long has changed, and the alignment of double and long double has changed.  A compiler may 
				provide options to use different sizes and alignments; however, any object compiled with those 
				options will not conform to the 64-bit PowerPC Processor Supplement.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AGG-UNION"
>3.1.5. Aggregates and Unions</A
></H3
><P
>Aggregates (structures and arrays) and unions assume the alignment of their most strictly aligned 
			component, that is, the component with the largest alignment.  The size of any object, including aggregates 
			and unions, is always a multiple of the alignment of the object.  An array uses the same alignment as its 
			elements.  Structure and union objects may require padding to meet size and alignment constraints:
			</P
><P
></P
><UL
><LI
><P
>An entire structure or union object is aligned on the same 
					boundary   as its most strictly aligned member.</P
></LI
><LI
><P
>Each member is assigned to the lowest available offset with the appropriate 
					alignment. This may require internal padding, depending on the previous member.
					</P
></LI
><LI
><P
>If necessary, a structure's size is increased to make it a multiple of the 
					structure's alignment.  This may require tail padding, depending on the last member.
					</P
></LI
></UL
><P
>In the following examples, members' byte offsets for little-endian implementations appear in the upper 
			 right corners; offsets for big-endian implementations in the upper left corners.
			</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN170"
></A
><P
><B
>Figure 3-5. Structure Smaller Than a Word</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  char c;
};
					</PRE
><PRE
CLASS="SYNOPSIS"
>byte aligned, sizeof is 1</PRE
><PRE
CLASS="SCREEN"
>+-------+
|0     0|
|   c   |
+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN175"
></A
><P
><B
>Figure 3-6. No Padding</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  char  c;
  char  d;
  short s;
  int   n;
};
					</PRE
><PRE
CLASS="SYNOPSIS"
>word aligned, sizeof is 8</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+-------+-------+
|              2|      1|      0|
|       s       |   d   |   c   |
+-------+-------+-------+-------+
|                              4|
|               n               |
+-------+-------+-------+-------+
					
big endian:

+-------+-------+-------+-------+
|0      |1      |2              |
|   c   |   d   |       s       |
+-------+-------+-------+-------+
|4                              |
|               n               |
+-------+-------+-------+-------+
					</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN180"
></A
><P
><B
>Figure 3-7. Internal Padding</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  char  c;
  short s;
};</PRE
><PRE
CLASS="SYNOPSIS"
>halfword aligned, sizeof is 4</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+-------+-------+
|              2|      1|      0|
|       s       |  pad  |   c   |
+-------+-------+-------+-------+

big endian:

+-------+-------+-------+-------+
|0      |1      |2              |
|   c   |  pad  |       s       |
+-------+-------+-------+-------+
					</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN185"
></A
><P
><B
>Figure 3-8. Internal and Tail Padding</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
 char   c;
 double d;
 short  s;
};
						</PRE
><PRE
CLASS="SYNOPSIS"
>word aligned, sizeof is 16</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+-------+-------+
|                      1|      0|
|          pad          |   c   |
+-------+-------+-------+-------+
|                              4|
|               d               |
+-------+-------+-------+-------+
|                              8|
|               d               |
+-------+-------+-------+-------+
|             14|             12|
|      pad      |       s       |
+-------+-------+-------+-------+

big endian:

+-------+-------+-------+-------+
|0      |1                      |
|   c   |          pad          |
+-------+-------+-------+-------+
|4                              |
|               d               |
+-------+-------+-------+-------+
|8                              |
|               d               |
+-------+-------+-------+-------+
|12             |14             |
|       s       |      pad      |
+-------+-------+-------+-------+
						</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN190"
></A
><P
><B
>Figure 3-9. Union Allocation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>union {
  char  c;
  short s;
  int   j;
};</PRE
><PRE
CLASS="SYNOPSIS"
>word aligned, sizeof is 4</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+-------+-------+
|                      1|      0|
|          pad          |   c   |
+-------+-------+-------+-------+
|              2|              0|
|      pad      |       s       |
+-------+-------+-------+-------+
|                              0|
|               j               |
+-------+-------+-------+-------+

big endian:

+-------+-------+-------+-------+
|0      |1                      |
|   c   |          pad          |
+-------+-------+-------+-------+
|0              |2              |
|       s       |      pad      |
+-------+-------+-------+-------+
|0                              |
|               j               |
+-------+-------+-------+-------+
						</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BITFIELD"
>3.1.6. Bit-fields</A
></H3
><P
>C struct and union definitions may have "bit-fields," defining integral objects with a specified 
			number of bits.
			</P
><P
>In the following table, a signed range goes from  - (2<SUP
>(w - 1)</SUP
>) to 
			(2<SUP
>(w - 1)</SUP
>) - 1 and an unsigned range goes from 0 to 
			(2<SUP
>w</SUP
>) - 1.  In these formulas, the operator ** represents exponentiation.</P
><PRE
CLASS="SCREEN"
>Bit-field type        Width (w)          Range
-------------------------------------------------
signed char           1 to 8             signed
char                                     unsigned
unsigned char                            unsigned
-------------------------------------------------
signed short          1 to 16            signed
short                                    signed
unsigned short                           unsigned
-------------------------------------------------
signed int            1 to 32            signed
int                                      signed
unsigned int                             unsigned
enum                                     unsigned
-------------------------------------------------
signed long           1 to 64            signed
long                                     signed
unsigned long                            unsigned</PRE
><P
>"Plain" bit-fields (that is, those neither signed nor unsigned) may have either positive or negative 
			values, except in the case of plain char, which is always positive.  Bit-fields obey the same size and 
			alignment rules as other structure and union members, with the following additions:
			</P
><P
></P
><UL
><LI
><P
>Bit-fields are allocated from right to left (least to most significant) on 
					little-endian implementations and from left to right (most to least significant) on 
					big-endian implementations.</P
></LI
><LI
><P
>Bit-fields are limited to at most 64 bits.  Adjacent bit-fields that cross a 
					64-bit boundary will start a new storage unit.</P
></LI
><LI
><P
>The alignment of a bit-field is the same as the alignment of the base 
					type of the bit-field.  Thus, an int bit-field will have word alignment.</P
></LI
><LI
><P
>Bit-fields must share a storage unit with other structure and union 
					members (either bit-field or non-bit-field) if and only if there is sufficient space within the 
					 storage unit.</P
></LI
><LI
><P
>Unnamed bit-fields' types do not affect the alignment of a structure or 
					union, although an individual bit-field's member offsets obey the alignment constraints.  
					An unnamed, zero-width bit-field shall prevent any further member, bit-field or other, 
					from residing in the storage unit corresponding to the type of the zero-width bit-field.
					</P
></LI
></UL
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The 64-bit PowerOpen ABI restricts bit-fields to be of type signed int, unsigned int, plain 
				int, long, or unsigned long.  This document does not have that restriction.</P
><P
>The 32-bit PowerPC Processor Supplement specifies that a bit-field must entirely reside in 
				 a storage unit appropriate for its declared type.  This document only restricts bit-fields to a 64-bit 
				storage unit.</P
></TD
></TR
></TABLE
></DIV
><P
>The following examples show struct and union members' byte offsets in the upper right corners for 
			little-endian implementations, and in the upper left corners for big-endian implementations. Bit numbers 
			appear in the lower corners.
			</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN220"
></A
><P
><B
>Figure 3-10. Bit Numbering</B
></P
><PRE
CLASS="SCREEN"
>0x01020304

+-------+-------+-------+-------+
|0     3|1     2|2     1|3     0|
|  01   |  02   |  03   |  04   |
|0     7|8    15|16   23|24   31|
+-------+-------+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN223"
></A
><P
><B
>Figure 3-11. Bit-field Allocation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  int j : 5;
  int k : 6;
  int m : 7;
};</PRE
><PRE
CLASS="SYNOPSIS"
>word aligned, sizeof is 4</PRE
><PRE
CLASS="SCREEN"
>little endian:

+----------+-------+------+-----+
|          |       |      |    0|
|    pad   |   m   |  k   |  j  |
|0       13|14   20|21  26|27 31|
+----------+-------+------+-----+

big endian:

+-----+------+-------+----------+
|0    |      |       |          |
|  j  |  k   |   m   |   pad    |
|0   4|5   10|11   17|18      31|
+-----+------+-------+----------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN228"
></A
><P
><B
>Figure 3-12. Boundary Alignment</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  short s : 9;
  int   j : 9;
  char  c;
  short t : 9;
  short u : 9;
  char  d;
};</PRE
><PRE
CLASS="SYNOPSIS"
>word aligned, sizeof is 8</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-----+--------+--------+
|      3|     |        |       0|
|   c   | pad |   j    |   s    |
|0     7|8  13|14    22|23    31|
+-------+-----+--------+--------+
|      7|     |        |       4|
|   d   | pad |   u    |   t    |
|0     7|8  13|14    22|23    31|
+-------+-----+--------+--------+

big endian:

+--------+--------+-----+-------+
|0       |        |     |3      |
|   s    |   j    | pad |   c   |
|0      8|9     17|18 23|24   31|
+--------+--------+-----+-------+
|4       |        |     |7      |
|   t    |   u    | pad |   d   |
|0      8|9     17|18 23|24   31|
+--------+--------+-----+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN233"
></A
><P
><B
>Figure 3-13. Doubleword Boundary Alignment</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  long i : 56;
  int  j : 9:
};</PRE
><PRE
CLASS="SYNOPSIS"
>doubleword aligned, sizeof is 16</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------------------------------+
|                              0|
|              i                |
|0                            31|
+-------+-----------------------+
|       |                      4|
|  pad  |         i             |
|32   39|40                   63|
+-------+--------------+--------+
|                      |       8|
|         pad          |   j    |
|0                   22|23    31|
+----------------------+--------+
|                             12|
|             pad               |
|0                            31|
+-------------------------------+

big endian:

+-------------------------------+
|0                              |
|              i                |
|0                            31|
+-----------------------+-------+
|4                      |       |
|           i           |  pad  |
|32                   55|56   63|
+--------+--------------+-------+
|8       |                      |
|   j    |        pad           |
|0      8|9                   31|
+----------------------+--------+
|12                             |
|             pad               |
|0                            31|
+-------------------------------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN238"
></A
><P
><B
>Figure 3-14. Storage Unit Sharing</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  char  c;
  short s : 8;
};</PRE
><PRE
CLASS="SYNOPSIS"
>halfword aligned, sizeof is 2</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+
|      1|      0|
|   s   |   c   |
|0     7|8    15|
+-------+-------+

big endian:

+-------+-------+
|0      |1      |
|   c   |   s   |
|0     7|8    15|
+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN243"
></A
><P
><B
>Figure 3-15. Union Allocation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>union {
  char  c;
  short s : 8;
};</PRE
><PRE
CLASS="SYNOPSIS"
>halfword aligned, sizeof is 2</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-------+-------+
|      1|      0|
|  pad  |   c   |
|0     7|8    15|
+-------+-------+
|      1|      0|
|  pad  |   s   |
|0     7|8    15|
+-------+-------+

big endian:

+-------+-------+
|0      |1      |
|   c   |  pad  |
|0     7|8    15|
+-------+-------+
|0      |1      |
|   s   |  pad  |
|0     7|8    15|
+-------+-------+</PRE
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="AEN248"
></A
><P
><B
>Figure 3-16. Unnamed bit-fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>struct {
  char  c;
  int   : 0;
  char  d;
  short : 9;
  char  e;
};</PRE
><PRE
CLASS="SYNOPSIS"
>byte aligned, sizeof is 8</PRE
><PRE
CLASS="SCREEN"
>little endian:

+-----------------------+-------+
|                      1|      0|
|           :0          |   c   |
|0                    23|24   31|
+-------+------+--------+-------+
|      7|      |        |      4|
|   e   | pad  |   :9   |   d   |
|0     7|8   14|15    23|24   31|
+-------+------+--------+-------+

big endian:

+-------+-----------------------+
|0      |1                      |
|   c   |          :0           |
|0     7|8                    31|
+-------+--------+------+-------+
|4      |        |      |7      |
|   d   |   :9   | pad  |   e   |
|0     7|8     16|17  23|24   31|
+-------+--------+------+-------+</PRE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In this example, the presence of the unnamed int and short fields does not affect the 
				alignment of the structure.  They align the named members relative to the beginning of the 
				structure, but the named members may not be aligned in memory on suitable boundaries.  For 
				example, the d members in an array of these structures will not all be on an int (4-byte) boundary.
				</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FUNC-CALL"
>3.2. Function Calling Sequence</A
></H2
><P
>This section discusses the standard function calling sequence, including stack frame layout, register usage, 
		and parameter passing.</P
><P
>C programs follow the conventions given here.  For specific information on the implementation of C, see 
		<A
HREF="#CODE-EX"
>Section 3.5</A
>.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The standard calling sequence requirements apply only to global functions.  Local functions that are
			 not reachable from other compilation units may use different conventions as long as they provide 
			traceback tables as described in <A
HREF="#TRACEBACK"
>Section 3.3</A
>.  Nonetheless, it is recommended that all 
			functions use the standard calling sequences when possible.
			</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="REG"
>3.2.1. Registers</A
></H3
><P
>The 64-bit PowerPC Architecture provides 32 general purpose registers, each 64 bits wide. In 
			addition, the architecture provides 32 floating-point registers, each 64 bits wide, and several special 
			purpose registers.  All of the integer, special purpose, and floating-point registers are global to all functions 
			in a running program.  The following table shows how the registers are used.
			</P
><PRE
CLASS="SCREEN"
>r0        Volatile register used in function prologs
r1        Stack frame pointer
r2        TOC pointer
r3        Volatile parameter and return value register
r4-r10    Volatile registers used for function parameters
r11       Volatile register used in calls by pointer and as an
          environment pointer for languages which require one
r12       Volatile register used for exception handling and glink code
r13       Reserved for use as system thread ID
r14-r31   Nonvolatile registers used for local variables

f0        Volatile scratch register
f1-f4     Volatile floating point parameter and return value registers
f5-f13    Volatile floating point parameter registers
f14-f31   Nonvolatile registers

LR        Link register (volatile)
CTR       Loop counter register (volatile)
XER       Fixed point exception register (volatile)
FPSCR     Floating point status and control register (volatile)

CR0-CR1   Volatile condition code register fields
CR2-CR4   Nonvolatile condition code register fields
CR5-CR7   Volatile condition code register fields</PRE
><P
>Registers r1, r14 through r31, and f14 through f31 are nonvolatile, which means that they preserve 
			their values across function calls.  Functions which use those registers must save the value before 
			changing it, restoring it before the function returns.  Register r2 is technically nonvolatile, but it is handled 
			specially during function calls as described below: in some cases the calling function must restore its value 
			 after a function call.
			</P
><P
>Registers r0, r3 through r12, f0 through f13, and the special purpose registers LR, CTR, XER, and 
			FPSCR are volatile, which means that they are not preserved across function calls.  Furthermore, registers 
			r0, r2, r11, and r12 may be modified by cross-module calls, so a function can not assume that the values of 
			 one of these registers is that placed there by the calling function.
			</P
><P
>The condition code register fields CR0, CR1, CR5, CR6, and CR7 are volatile.  The condition code 
			register fields CR2, CR3, and CR4 are nonvolatile; a function which modifies them must save and restore at 
			least those fields of the CR.  Languages that require "environment pointers" shall use r11 for that 
			purpose.
			</P
><P
>The following registers have assigned roles in the standard calling sequence:
			</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>r1</DT
><DD
><P
>The stack pointer (stored in r1) shall maintain quadword 
						alignment.  It shall always point to the lowest allocated valid stack frame, and 
						 grow toward low addresses.  The contents of the word at that address 
						always point to the previously allocated stack frame.  If required, it can be 
						decremented by the called function.  See <A
HREF="#DYNAM-STACK"
>Section 3.5.13</A
> 
						for additional infromation.  As discussed later in this chapter, the lowest valid 
						stack address is 288 bytes less than the value in the stack pointer.  The 
						stack pointer must be atomically updated by a single instruction, thus 
						avoiding any timing window in which an interrupt can occur with a partially 
						updated stack.</P
></DD
><DT
>r2</DT
><DD
><P
>This register holds the TOC base.  See 
						<A
HREF="#TOC-SEC"
>Section 3.5.2</A
> for additional information.</P
></DD
><DT
>r3 through r10 and f1 through f13</DT
><DD
><P
>These sets of volatile 
						registers may be modified across function invocations and shall therefore be 
						presumed by the calling function to be destroyed.  They are used for 
						passing parameters to the called function.  See 		
						<A
HREF="#PARAM-PASS"
>Section 3.2.3</A
> for additional information.  In addition, 
						registers r3 and f1 through f4 are used to return values from the called 
						function, as described in Return Values.</P
></DD
><DT
>LR (Link Register)</DT
><DD
><P
>This register shall contain the address to which a 
						called function normally returns.  LR is volatile across function calls.</P
></DD
></DL
></DIV
><P
>Signals can interrupt processes (see signal (BA-OS) in the System V Interface Definition).  					Functions called during signal handling have no unusual restrictions on their use of registers.  Moreover, if 
			a signal handling function returns, the process resumes its original execution path with all registers restored 
			to their original values.  Thus, programs and compilers may freely use all registers above except those 
			reserved for system use without the danger of signal handlers inadvertently changing their values.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STACK"
>3.2.2. The Stack Frame</A
></H3
><P
>In addition to the registers, each function may have a stack frame on the runtime stack.  This stack 
			grows downward from high addresses.  The following figure shows the stack frame organization.  SP in the 
			figure denotes the stack pointer (general purpose register r1) of the called function after it has executed 
			code establishing its stack frame.
			</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN297"
></A
><P
><B
>Figure 3-17. Stack Frame Organiztion</B
></P
><PRE
CLASS="SCREEN"
>High Address

          +-&#62; Back chain
          |   Floating point register save area
          |   General register save area
          |   Local variable space
          |   Parameter save area    (SP + 48)
          |   TOC save area          (SP + 40)
          |   link editor doubleword (SP + 32)
          |   compiler doubleword    (SP + 24)
          |   LR save area           (SP + 16)
          |   CR save area           (SP + 8)
SP  ---&#62;  +-- Back chain             (SP + 0)

Low Address</PRE
></DIV
><P
>The following requirements apply to the stack frame:
			</P
><P
></P
><UL
><LI
><P
>The stack pointer shall maintain quadword alignment.</P
></LI
><LI
><P
>The stack pointer shall point to the first word of the lowest allocated 
					stack frame, the "back chain" word.  The stack shall grow   downward, that is, toward 
					lower addresses.  The first word of the stack frame shall always point to the previously 
					allocated stack   frame (toward higher addresses), except for the first stack frame,   
					which shall have a back chain of 0 (NULL).</P
></LI
><LI
><P
>The stack pointer shall be decremented by the called function in its 
					prologue, if required, and restored prior to return.</P
></LI
><LI
><P
>					The stack pointer shall be decremented and the back chain updated
					atomically using one of the "Store Double Word with Update"
					instructions, so that the stack pointer always points to the
					beginning of a linked list of stack frames.
					</P
></LI
><LI
><P
>The sizes of the floating-point and general register save areas may 
					vary within a function and are as determined by the traceback table described below.
					</P
></LI
><LI
><P
>Before a function changes the value in any nonvolatile floating-point 
					register, frn, it shall save the value in frn in the double word in the floating-point 
					register save area 8*(32-n) bytes before the back chain word of the previous frame.  
					The floating-point register save area is always doubleword aligned.  The size of the 
					floating-point register save area depends upon the number of floating point registers 
					which must be saved. It ranges from 0 bytes to a maximum of 144 bytes (18 * 8).</P
></LI
><LI
><P
>Before a function changes the value in any nonvolatile general 
					register, rn, it shall save the value in rn in the word in the general register save area 
					8*(32-n) bytes before the low addressed end of the floating-point register save area.  
					The general register save area is always doubleword aligned.  The size of the general 
					register save area depends upon the number of general registers which must be saved.
					  It ranges from 0 bytes to a maximum of 144 bytes (18 * 8).</P
></LI
><LI
><P
>The local variable space contains any local variable storage required 
					by the function.</P
></LI
><LI
><P
>The parameter save area shall be allocated by the caller.  It shall be 
					doubleword aligned, and shall be at least 8 doublewords in length.  If a function needs 
					to pass more than 8 doublewords of arguments, the parameter save area shall be large 
					enough to contain the arguments that the caller stores in it.  Its contents are not 
					preserved across function calls.</P
></LI
><LI
><P
>The TOC save area is used by global linkage code to save the TOC 
					pointer register.  See The TOC section later in the chapter.</P
></LI
><LI
><P
>The link editor doubleword is reserved for use by code generated by 
					the link editor.  This ABI does not specify any usage; the AIX link editor uses this 
					space under certain circumstances.</P
></LI
><LI
><P
>The compiler doubleword is reserved for use by the compiler.  This 
					ABI does not specify any usage; the AIX compiler uses this space under certain 
					circumstances.</P
></LI
><LI
><P
>Before a function calls any other functions, it shall save the value 
					in the LR register in the LR save area.</P
></LI
><LI
><P
>Before a function changes the value in any nonvolatile field in the 
					condition register, it shall save the values in all the nonvolatile fields of the condition 
					register at the time of entry to the function in the CR save area.</P
></LI
><LI
><P
>A function which does not call any other function and which needs no 
					local variables does not need to have a stack frame.  It may use non-volatile registers, 
					saving their old values on the stack.  Thus, the lowest possible valid stack address is 
					288 bytes (144 + 144) less than the current value of the stack pointer.  Functions may 
					use this stack space as volatile storage which is not preserved across function calls.  
					Interrupt handlers and any other code which can not be seen by compiled code must 
					avoid using this area.</P
></LI
></UL
><P
>The stack frame header consists of the back chain word, the CR save area, the LR save area, the 
			compiler and link editor doublewords, and the TOC save area, for a total of 48 bytes.  The back chain word 
			always contains a pointer to the previously allocated stack frame.  Before a function calls another function, 
			it shall save the contents of the link register at the time the function was entered in the LR save area of its 
			caller's stack frame and shall establish its own stack frame.
			</P
><P
>Except for the stack frame header and any padding necessary to make the entire frame a multiple of 
			16 bytes in length, a function need not allocate space for the areas that it does not use.  If a function does 
			not call any other functions and does not require any of the other parts of the stack frame, it need not 
			establish a stack frame.  Any padding of the frame as a whole shall be within the local variable area; the 
			parameter save area shall immediately follow the stack frame header, and the register save areas shall 
			contain no padding.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PARAM-PASS"
>3.2.3. Parameter Passing</A
></H3
><P
>For a RISC machine such as 64-bit PowerPC, it is generally more efficient to pass arguments to 
			called functions in registers (both general and floating-point registers) than to construct an argument list in 
			storage or to push them onto a stack.  Since all computations must be performed in registers anyway, 
			memory traffic can be eliminated if the caller can compute arguments into registers and pass them in the 
			same registers to the called function, where the called function can then use them for further computation in 
			 the same registers.  The number of registers implemented in a processor architecture naturally limits the 
			number of arguments that can be passed in this manner.
			</P
><P
>For the 64-bit PowerPC, up to eight doublewords are passed in general purpose registers, loaded 
			sequentially into general purpose registers r3 through r10.  In addition, up to thirteen floating-point 
			arguments can be passed in floating-point registers f1 through f13.  If fewer (or no) arguments are passed, 
			the unneeded registers are not loaded and will contain undefined values on entry to the called function. 
			</P
><P
>The parameter save area, which is located at a fixed offset of 48 bytes from the stack pointer, is 
			reserved in each stack frame for use as an argument list.  A minimum of 8 doublewords is always reserved.
			  The size of this area must be sufficient to hold the longest argument list being passed by the function 
			which owns the stack frame.  Although not all arguments for a particular call are located in storage, 
			consider them to be forming a list in this area, with each argument occupying one or more doublewords.
			</P
><P
>If more arguments are passed than can be stored in registers, the remaining arguments are stored in 
			the parameter save area.  The values passed on the stack are identical to those that have been placed in 
			registers; thus, the stack contains register images.
			</P
><P
>The rules for parameter passing are as follows:
			</P
><P
></P
><UL
><LI
><P
>Each argument is mapped to as many doublewords of the parameter 
					save area as are required to hold its value.</P
><P
></P
><UL
><LI
><P
>Single precision floating point values are mapped to the 
						first word in a single doubleword.
						</P
></LI
><LI
><P
>Double precision floating point values are mapped to a 
						single doubleword.</P
></LI
><LI
><P
>Extended precision floating point values are mapped to two 
						consecutive doublewords.</P
></LI
><LI
><P
>Simple integer types (char, short, int, long, enum) are 
						mapped to a single doubleword.  Values shorter than a doubleword are sign 
						or zero extended as necessary.</P
></LI
><LI
><P
>Pointers are mapped to a single doubleword.</P
></LI
><LI
><P
>						Fixed size aggregates and unions passed by value are mapped to as
						many doublewords of the parameter save area as the value uses in
						memory.  An aggregate or union smaller than one doubleword in size
						is padded so that it appears in the least significant bits of the
						doubleword.  All others are padded, if necessary, at their tail.
						Variable size aggregates or unions are passed by reference.
						</P
></LI
><LI
><P
>Other scalar values, such as FORTRAN complex numbers, 
						are mapped to the number of doublewords required by their size.</P
></LI
></UL
></LI
><LI
><P
>If the callee has a known prototype, arguments are converted to the 
					type of the corresponding parameter before being mapped into the parameter save 
					area.  For example, if a long is used as an argument to a float double parameter, the 
					value is converted to double-precision and mapped to a doubleword in the parameter 
					save area.</P
></LI
><LI
><P
>The first eight doublewords mapped to the parameter save area are 
					never stored in the parameter save area by the calling function.  Instead, these 							doublewords are passed in registers as described below.</P
></LI
><LI
><P
>Argument values beyond the first eight doublewords must be stored in 
					the parameter save area following the first eight doublewords, even though these 
					arguments may also be passed in the floating point registers as described below.  The 
					first eight doublewords in the parameter save area are reserved for the initial 
					arguments, even though they are passed in registers.</P
></LI
><LI
><P
>General registers are used to pass some values.  The first eight 
					doublewords mapped to the parameter save area correspond to the register r3 through 
					r10.  If the arguments are mapped to fewer than eight doublewords of the parameter 
					save area, registers corresponding to those unused doublewords are not used.</P
><P
></P
><UL
><LI
><P
>If there is no known function prototype for a 
							callee, or the known prototype contains an ellipsis, the first eight 
							doublewords mapped to the parameter save area are passed in 
							their corresponding general registers.</P
></LI
><LI
><P
>If the callee has a prototype with no ellipsis, values other 
						than single and double precision floating point values are passed in their 
						corresponding general registers.  General registers corresponding to single 
						and double precision floating-point arguments are not used.  The floating 
						point  values are placed in floating-point registers instead.</P
></LI
></UL
></LI
><LI
><P
>Floating point registers are used consecutively to pass up to 13 
					single and double precision floating point values.  Each floating point register holds at 
					most a single value, whether the argument is single or double precision.</P
><P
></P
><UL
><LI
><P
>If there is no known prototype for a callee, or 
							the known prototype contains an ellipsis, up to 13 floating point 
							values are passed in f1 through f13.  In this case, floating point 
							values mapped to the  first eight doublewords of the parameter 
							save area are also passed in general registers.</P
></LI
><LI
><P
>If there is a known prototype for the callee, and it 
							doesn't contain an ellipsis, up to 13 floating point values are 
							passed in f1 through f13.  In this case, floating point values 
							mapped to the first eight doublewords of the parameter save 
							argument area are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> also passed in the 
							general registers.</P
></LI
></UL
></LI
><LI
><P
>If the callee takes the address of any of its parameters, then r3 
					through r10 must be stored by the callee into the parameter save area, except when 
					any of these general registers correspond to single or double precision floating point 
					parameters, in which case the floating point registers are stored rather than the general 
					registers.  This is because the caller may have had a function prototype for the callee, 
					and therefore put floating point parameters in floating point registers only.</P
></LI
></UL
><P
>If the compilation unit for the caller contains a function prototype, but the callee has a mismatching 
			definition, and if the callee takes the address of any of its parameters, the wrong values may be stored in 
			the first eight doublewords of the parameter save area.
			</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN383"
></A
><P
><B
>Figure 3-18. Parameter Passing</B
></P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
  int    a;
  double dd;
} sparm;
sparm   s, t;
int     c, d, e;
long double ld;
double  ff, gg, hh;

x = func(c, ff, d, ld, s, gg, t, e, hh);</PRE
><PRE
CLASS="SCREEN"
>Parameter     Register     Offset in parameter save area
c             r3           0-7    (not stored in parameter save area)
ff            f1           8-15   (not stored)
d             r5           16-23  (not stored)
ld            r6,r7        24-39  (not stored)
s             r8,r9        40-55  (not stored)
gg            f2           56-63  (not stored)
t             (none)       64-79  (stored in parameter save area)
e             (none)       80-87  (stored)
hh            f3           88-95  (stored)</PRE
></DIV
><P
>The above is complete if a prototype with no ellipsis is in scope.  If a prototype is not in scope, or if 
			the prototype contains an ellipsis, then, in addition to the above, ff is passed in r4 and gg is passed in r10.  
			The floating point argument hh is passed in two places: the value is stored both in f3 and on the stack.  If a 
			prototype is not in scope, or if the prototype contains an ellipsis, then the floating point arguments ff and gg 
			are also passed in two places, in both a general register and a floating point register.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RETURN-VAL"
>3.2.4. Return Values</A
></H3
><P
>Functions shall return float or double values in f1, with float values rounded to single precision.
			</P
><P
>Functions shall return values of type int, long, enum, short, and char, or a pointer to any type, as 
			unsigned or signed integers as appropriate, zero- or sign-extended to 64 bits if necessary, in r3.  Character 
			 arrays of length 8 bytes or less, or bit strings of length 64 bits or less, will be returned right justified in r3.  
			Aggregates or unions of any length, and character strings of length longer than 8 bytes, will be returned in 
			a storage buffer allocated by the caller.  The caller will pass the address of this buffer as a hidden first 
			argument in r3, causing the first explicit argument to be passed in r4.  This hidden argument is treated as a 
			normal formal parameter, and corresponds to the first doubleword of the parameter save area.
			</P
><P
>Functions shall return floating point scalar values of size 16 or 32 bytes in f1:f2 and f1:f4, 
			respectively.
			</P
><P
>Functions shall return floating point complex values of size 16 (four or eight byte complex) in f1:f2 
			and floating point complex values of size 32 (16 byte complex) in f1:f4.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FUNC-DES"
>3.2.5. Function Descriptors</A
></H3
><P
>A function descriptor is a three doubleword data structure that contains the following values:
			</P
><P
></P
><UL
><LI
><P
>The first doubleword contains the address of the entry point of the 
					function.</P
></LI
><LI
><P
>The second doubleword contains the TOC base address for the 
					function (see <A
HREF="#TOC"
>Section 4.3</A
> later in this chapter).</P
></LI
><LI
><P
>The third doubleword contains the environment pointer for languages 
					such as Pascal and PL/1.</P
></LI
></UL
><P
>For an externally visible function, the value of the symbol with the same name as the function is the 
			address of the function descriptor.  Symbol names with a dot (.) prefix are reserved for holding entry point 
			addresses.  The value of a symbol named &quot;.FN&quot; is the entry point of the function &quot;FN&quot;.
			</P
><P
>The value of a function pointer in a language like C is the address of the function descriptor.  
			Examples of calling a function through a pointer are provided in <A
HREF="#FUNC-CALLS"
>Section 3.5.11</A
>.
			</P
><P
>When the link editor processes relocatable object files in order to produce an executable or shared 
			object, it must treat direct function calls specially, as described below.
			</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TRACEBACK"
>3.3. Traceback Tables</A
></H2
><P
>To support debuggers and exception handlers, the 64-bit PowerPC ELF ABI defines traceback tables.  
		Compilers must support generation of at least the mandatory part of traceback tables, and system libraries should 
		contain the mandatory part.  Compilers should provide an option to turn off traceback table generation to save space 
		when the information is not needed.
		</P
><P
>Traceback tables are intended to be compatible with the 64-bit PowerOpen ABI.
		</P
><P
>Compilers should generate a traceback table following the end of the code for every function.  Debuggers and 
		 exception handlers can locate the traceback tables by scanning forward from the instruction address at the point of 
		interruption.  The beginning of the traceback table is marked by a word of zeroes, which is an illegal instruction.  If 
		read-only constants are compiled into the same section as the function code, they must follow the traceback table.  
		A word of zeroes as read-only data must not be the first word following the code for a function.  A traceback table is 
		word-aligned.
		</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAND-FIELD"
>3.3.1. Mandatory Fields</A
></H3
><P
>The following are the mandatory fields of a traceback table:
			</P
><PRE
CLASS="SCREEN"
>version        Eight-bit field.  This defines the type code for the
               table.  The only currently defined value is zero.

lang           Eight-bit field.  This defines the source language for
               the compiler that generated the code for which this
               traceback table applies.  The default values are as
               follows:
                  C             0
                  FORTRAN       1
                  Pascal        2
                  Ada           3
                  PL/1          4
                  Basic         5
                  LISP          6
                  COBOL         7
                  Modula2       8
                  C++           9
                  RPG           10
                  PL.8,PLIX     11
                  Assembly      12
               The codes 0xd to 0xfa are reserved.  The codes 0xfb to
               0xff are reserved for IBM.

globalink      One-bit field.  This field is set to 1 if this routine
               is a special routine used to support the linkage
               convention: a linkage function or a ._ptrgl function.
               See the section Function Calls for more information.
               These routines have unusual register usage and stack
               format.

is_eprol       One-bit field.  This field is set to 1 if this routine
               is an out-of-line prologue or epilogue function.  See
               the section Function Prologue and Epilogue for more
               information.  These routines have unusual register
               usage and stack format.

has_tboff      One-bit field.  This field is set to 1 if the offset of
               the traceback table from the start of the function is
               stored in the tb_offset field.

int_proc       One-bit field.  This field is set to 1 if this function
               is a stackless leaf function that does not have a
               separate stack frame.

has_ctl        One-bit field.  This field is set to 1 if ctl_info is
               provided.

tocless        One-bit field.  This field is set to 1 if this function
               does not have a TOC.  For example, a stackless leaf
               assembly language routine with no references to
               external objects.

fp_present     One-bit field.  This field is set to 1 if  the function
               uses floating-point processor instructions.

log_abort      One-bit field.  Reserved.

int_handl      One-bit field.  Reserved.

name_present   One-bit field.  This field is set to 1 if the name for
               the procedure is present following the traceback field,
               as determined by the name_len and name fields.

uses_alloca    One-bit field.  This field is set to 1 if the procedure
               performs dynamic stack allocation.  To address their
               local variables, these procedures require a different
               register to hold the stack pointer value.  This
               register may be chosen by the compiler, and must be
               indicated by setting the value of the alloc_reg field.

cl_dis_inv     Three-bit field.  Reserved.

saves_cr       One-bit field.  This field is set to 1 if the function
               saves the CR in the CR save area.

saves_lr       One-bit field.  This field is set to 1 if the function
               saves the LR in the LR save area.

stores_bc      One-bit field.  This field is set to 1 if the function
               saves the back chain (the SP of its caller) in the
               stack frame header.

fixup          One-bit field.  This field is set to 1 if the link
               editor replaced the original instruction by a branch
               instruction to a special fixup instruction sequence.

fp_saved       Six-bit field.  This field is set to the number of
               non-volatile floating point registers that the function
               saves.  The last register saved is always f31, so, for
               example, a value of 2 in this field indicates that f30
               and f31 are saved.

spare3         Two-bit field.  Reserved.

gpr_saved      Six-bit field.  This field is set to the number of
               non-volatile general registers that the function
               saves.  As with fp_saved, the last register saved is
               always r31.

fixedparms     Eight-bit field.  This field is set to the number of
               fixed point parameters.

floatparms     Seven-bit field.  This field is set to the number of
               floating point parameters.

parmsonstk     One-bit field.  This field is set to 1 if all of the
               parameters are placed in the parameter save area.</PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If either fixedparms or floatparms is set to a non-zero value, the parminfo field exists.
			</P
><P
>A debugger can use the fixedparms, floatparms, and parmsonstk field to support displaying the 
			parameters passed to a function.  They specify the number of parameters passed in the general registers 
			and the number passed in the floating point registers; they also specify whether the parameters are stored 
			in the parameter save area.  The parameters are stored in the parameter save area if the number of 
			parameters is variable, or if the address of one of the parameters is taken, or if the compiler always stores 
			the parameters at the optimization level of the compilation.  If either the fixedparms or floatparms field is set 
			to a non-zero value, then the next field, parminfo, can be used by a debugger to determine the relative 
			order and types of the parameters.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="OPT-FIELD"
>3.3.2. Optional Fields</A
></H3
><P
>The following are the optional fields of a traceback table:
			</P
><PRE
CLASS="SCREEN"
>parminfo       Unsigned int.  This field is only present if either
               fixedparms or floatparms is set to a non-zero value.
               It can be used by a debugger to determine which
               registers were used to pass parameters to the routine
               and to determine the layout of the parameter save
               area.  This word is interpreted from left to right, as
               follows:
                  bit is 0: the corresponding parameter is a fixed
                     point parameter passed in a general register or a
                     single doubleword in the parameter save area.
                  bit is 1: the corresponding parameter is a floating
                     point parameter, and the following bit determines
                     whether the parameter is single precision (the
                     following bit is 0) or double precision  (the
                     following bit is 1).

               Note: Since this field is only 32 bits long, there is a
               limit to how many parameters can be described.  This
               limit is in the range of 16 to 32 parameters depending
               upon the type of the parameters.  Note that it takes
               two bits to describe a floating point parameter and one
               bit for each non floating point parameter.

tb_offset      Unsigned int.  This word is only present if the
               has_tboff field is set to 1.  It holds the length of
               the function code.

hand_mask      Int.  Reserved.

ctl_info       Int.  This word is only present if the has_ctl field is
               set to 1.  It gives the number of controlled automatic
               anchor blocks defined for this procedure.  If an
               exception handler is unwinding the stack to restart
               some earlier function, the the controlled automatic
               storage must be released.  Controlled automatic storage
               is used by PL/1 and PL.8.

ctl_info_disp  Int[*].  This field is only present if the has_ctl
               field is set to 1.  The ctl_info field indicates the
               number of words.  Each word is the displacement to the
               location of the information.

name_len       Short.  This field is only present if the name_present
               field is set to 1.  It is the length of the function
               name that immediately follows this field.

name           char[*].  This field is only present if the
               name_present field is set to 1.  The name_len field
               indicates the number of characters.  The name is in
               seven-bit ASCII, and is not delimited by a null
               character.

alloca_reg     Char.  This field is only present if the uses_alloca
               bit is set to 1.  It holds the register number that is
               used as the base for variable accesses.</PRE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROC-INIT"
>3.4. Process Initialization</A
></H2
><P
>This section describes the machine state that exec creates for "infant" processes, including argument passing, 
		register usage, and stack frame layout. Programming language systems use this initial program state to establish a 
		standard environment for their application programs.  For example, a C program begins executing at a function named 
		main, conventionally declared as follows:
		</P
><PRE
CLASS="PROGRAMLISTING"
>extern int main (int argc, char *argv[], char *envp[]);</PRE
><P
>Briefly, <VAR
CLASS="PARAMETER"
>argc</VAR
> is a non-negative argument count; <VAR
CLASS="PARAMETER"
>argv</VAR
> is an 			array of argument strings, with argv[argc] == 0; and envp is an array of environment strings, also terminated by a NULL 
		 pointer.
		</P
><P
>Although this section does not describe C program initialization, it gives the information necessary to implement 
		the call to main or to the entry point for a program in any other language.
		</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROC-REG"
>3.4.1. Registers</A
></H3
><P
>When a process is first entered (from an exec(BA_OS) system call), the contents of registers other 
			than those listed below are unspecified. Consequently, a program that requires registers to have specific 
			values must set them explicitly during process initialization.  It should not rely on the operating system to set 
			all registers to 0.  Following are the registers whose contents are specified:
			</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>r1</DT
><DD
><P
>The initial stack pointer, aligned to a quadword boundary and 
						pointing to a word containing a NULL pointer.</P
></DD
><DT
>r2</DT
><DD
><P
>The initial TOC pointer register value, obtained via the 
						function descriptor pointed at by the e_entry field in the ELF header.  For more 
						 information on function decscriptors, see <A
HREF="#FUNC-DES"
>Section 3.2.5</A
>.  For 
						more information on the ELF Header, see <A
HREF="#ELF-HEAD"
>Section 4.1</A
>.
						</P
></DD
><DT
>r3</DT
><DD
><P
>Contains argc, the number of arguments.</P
></DD
><DT
>r4</DT
><DD
><P
>Contains argv, a pointer to the array of argument pointers in the stack.  
					The array is immediately followed by a NULL pointer.  If there are no arguments, r4 
					points to a NULL pointer.</P
></DD
><DT
>r5</DT
><DD
><P
>Contains envp, a pointer to the array of environment pointers 
						in the stack.  The array is immediately followed by a NULL pointer.  If no 
						environment exists, r5 points to a NULL pointer .</P
></DD
><DT
>r6</DT
><DD
><P
>Contains a pointer to the auxiliary vector.  The auxiliary 
						vector shall have at least one member, a terminating entry with an a_type of 
						AT_NULL (see below).</P
></DD
><DT
>r7</DT
><DD
><P
>Contains a termination function pointer.  If r7 contains a 
						nonzero value, the value represents a function pointer that the application 
						should register with <CODE
CLASS="FUNCTION"
>atexit(BA_OS)</CODE
>.  If r7 contains zero, 
						no action is required.
						</P
></DD
><DT
>fpscr</DT
><DD
><P
>Contains 0, specifying "round to nearest" mode, IEEE Mode, 
						and the disabling of floating-point exceptions.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROC-STACK"
>3.4.2. Process Stack</A
></H3
><P
>Every process has a stack, but the system defines no fixed stack address.  Furthermore, a program's 
			stack address can change from one system to another--even from one process invocation to another.  Thus 
			the process initialization code must use the stack address in general purpose register r1.  Data in the stack 
			segment at addresses below the stack pointer contain undefined values.
			</P
><P
>Whereas the argument and environment vectors transmit information from one application program to 
			another, the auxiliary vector conveys information from the operating system to the program.  This vector is 
			an array of structures, defined as follows:
			</P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct
{
  int     a_type;
  union
    {
      long  a_val;
      void  *a_ptr;
      void  (*a_fcn)();
    } a_un;
} auxv_t;</PRE
><PRE
CLASS="SCREEN"
>Name                Value       a_un field

AT_NULL             0           ignored
AT_IGNORE           1           ignored
AT_EXECFD           2           a_val
AT_PHDR             3           a_ptr
AT_PHENT            4           a_val
AT_PHNUM            5           a_val
AT_PAGESZ           6           a_val
AT_BASE             7           a_ptr
AT_FLAGS            8           a_val
AT_ENTRY            9           a_ptr
AT_DCACHEBSIZE      10          a_val
AT_ICACHEBSIZE      11          a_val
AT_UCACHEBSIZE      12          a_val</PRE
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>AT_NULL</DT
><DD
><P
>The auxiliary vector has no fixed length; instead an entry of
this type denotes the end of the vector.  The corresponding value of
a_un is undefined.</P
></DD
><DT
>AT_IGNORE</DT
><DD
><P
>This type indicates the entry has no meaning. The
corresponding value of a_un is undefined.</P
></DD
><DT
>AT_EXECFD</DT
><DD
><P
>As Chapter 5 in the System V ABI describes, exec may pass
control to an interpreter program.  When this happens, the system
places either an entry of type AT_EXECFD or one of type AT_PHDR in the
auxiliary vector.  The entry for type AT_EXECFD uses the a_val member
to contain a file descriptor open to read the application program's
object file.</P
></DD
><DT
>AT_PHDR</DT
><DD
><P
>Under some conditions, the system creates the memory image of
the application program before passing control to an interpreter
program.  When this happens, the a_ptr member of the AT_PHDR entry
tells the interpreter where to find the program header table in the
memory image.  If the AT_PHDR entry is present, entries of types
AT_PHENT, AT_PHNUM, and AT_ENTRY must also be present.  See the
section Program Header in Chapter 5 of the System V ABI and <A
HREF="#PROG-LOAD-DL"
>Chapter 5</A
> of this processor supplement for
more information about the program header table.</P
></DD
><DT
>AT_PHENT</DT
><DD
><P
>The a_val member of this entry holds the size, in bytes, of
one entry in the program header table to which the AT_PHDR entry
points.</P
></DD
><DT
>AT_PHNUM</DT
><DD
><P
>The a_val member of this entry holds the number of entries
in the program header table to which the AT_PHDR entry points.</P
></DD
><DT
>AT_PAGESZ</DT
><DD
><P
>If present, this entry's a_val member gives the system page
size in bytes.  The same information is also available through the
sysconf system call.</P
></DD
><DT
>AT_BASE</DT
><DD
><P
>The a_ptr member of this entry holds the base address at
which the interpreter program was loaded into memory.  See the section
Program Header in Chapter 5 of the System V ABI for more information
about the base address.</P
></DD
><DT
>AT_FLAGS</DT
><DD
><P
>If present, the a_val member of this entry holds 1-bit
flags.  Bits with undefined semantics are set to zero.</P
></DD
><DT
>AT_ENTRY</DT
><DD
><P
>The a_ptr member of this entry holds the entry point of the
application program to which the interpreter program should transfer
control.</P
></DD
><DT
>AT_DCACHEBSIZE</DT
><DD
><P
>The a_val member of this entry gives the data cache
block size for processors on the system on which this program is
running.  If the processors have unified caches, AT_DCACHEBSIZE is the
same as AT_UCACHEBSIZE.</P
></DD
><DT
>AT_ICACHEBSIZE</DT
><DD
><P
>The a_val member of this entry gives the instruction
cache block size for processors on the system on which this program is
running.  If the processors have unified caches, AT_DCACHEBSIZE is the
same as AT_UCACHEBSIZE.</P
></DD
><DT
>AT_UCACHEBSIZE</DT
><DD
><P
>The a_val member of this entry is zero if the
processors on the system on which this program is running do not have
a unified instruction and data cache.  Otherwise, it gives the cache
block size.</P
></DD
></DL
></DIV
><P
>Other auxiliary vector types are reserved.  No flags are currently
defined for AT_FLAGS on the 64-bit PowerPC Architecture.
			</P
><P
>When a process receives control, its stack holds the arguments,
environment, and auxiliary vector from exec.  Argument strings,
environment strings, and the auxiliary information appear in no
specific order within the information block; the system makes no
guarantees about their relative arrangement.  The system may also
leave an unspecified amount of memory between the null auxiliary
vector entry and the beginning of the information block.  The back
chain word of the first stack frame contains a null pointer (0).
			</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CODE-EX"
>3.5. Coding Examples</A
></H2
><P
>This section describes example code sequences for fundamental
operations such as calling functions, accessing static objects, and
transferring control from one part of a program to another.  Previous
sections discussed how a program may use the machine or the operating
system, and they specified what a program may and may not assume about
the execution environment.  Unlike previous material, the information
in this section illustrates how operations may be done, not how they
must be done.</P
><P
>As before, examples use the ANSI C language.  Other programming
languages may use the same conventions displayed below, but failure to
do so does not prevent a program from conforming to the ABI.
		</P
><P
>64-bit PowerPC code is normally position independent.  That is, the
code is not tied to a specific load address, and may be executed
properly at various positions in virtual memory.  Although it is
possible to write position dependent code on the 64-bit PowerPC, these
code examples only show position independent code.
		</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The examples below show code fragments with various simplifications.  They are intended to explain 
			addressing modes, not to show optimal code sequences or to reproduce compiler output.
			</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MOD-OVER"
>3.5.1. Code Model Overview</A
></H3
><P
>When the system creates a process image, the executable file portion
of the process has fixed addresses and the system chooses shared
object library virtual addresses to avoid conflicts with other
segments in the process.  To maximize text sharing, shared objects
conventionally use position-independent code, in which instructions
contain no absolute addresses.  Shared object text segments can be
loaded at various virtual addresses without having to change the
segment images.  Thus multiple processes can share a single shared
object text segment, even if the segment resides at a different
virtual address in each process.</P
><P
>Position-independent code relies on two techniques:</P
><P
></P
><UL
><LI
><P
>Control transfer instructions hold addresses relative to the
  effective address (EA) or use registers that hold the transfer
  address.  An EA-relative branch computes its destination address in
  terms of the current EA, not relative to any absolute address.</P
></LI
><LI
><P
>When the program requires an absolute address, it computes the
  desired value.  Instead of embedding absolute addresses in
  instructions (in the text segment), the compiler generates code to
  calculate an absolute address (in a register or in the stack or data
  segment) during execution.</P
></LI
></UL
><P
>Because the 64-bit PowerPC Architecture provides EA-relative branch
instructions and also branch instructions using registers that hold
the transfer address, compilers can satisfy the first condition
easily.
			</P
><P
>A "Global Offset Table," or GOT, provides information for address
calculation.  Position independent object files (executable and shared
object files) have a table in their data segment that holds addresses.
When the system creates the memory image for an object file, the table
entries are relocated to reflect the absolute virtual address as
assigned for an individual process.  Because data segments are private
for each process, the table entries can change--unlike text segments,
which multiple processes share.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TOC-SEC"
>3.5.2. The TOC section</A
></H3
><P
>ELF processor-specific supplements normally define a GOT ("Global
Offset Table") section used to hold addresses for position independent
code.  Some ELF processor-specific supplements, including the 32-bit
PowerPC Processor Supplement, define a small data section.  The same
register is sometimes used to address both the GOT and the small data
section.
			</P
><P
>The 64-bit PowerOpen ABI defines a TOC ("Table of Contents") section.
The TOC combines the functions of the GOT and the small data section.
			</P
><P
>This ABI uses the term TOC.  The TOC section defined here is intended
to be similar to that defined by the 64-bit PowerOpen ABI.  The TOC
section contains a conventional ELF GOT, and may optionally contain a
small data area.  The GOT and the small data area may be intermingled
in the TOC section.
			</P
><P
>The TOC section is accessed via the dedicated TOC pointer register,
r2.  Accesses are normally made using the register indirect with
immediate index mode supported by the 64-bit PowerPC processor, which
limits a single TOC section to 65,536 bytes, enough for 8,192 GOT
entries.
			</P
><P
>The value of the TOC pointer register is called the TOC base.  The TOC
base is typically the first address in the TOC plus 0x8000, thus
permitting a full 64 Kbyte TOC.
			</P
><P
>A relocatable object file must have a single TOC section and a single
TOC base.  However, when the link editor combines relocatable object
files to form a single executable or shared object, it may create
multiple TOC sections.  The link editor is responsible for deciding
how to associate TOC sections with object files.  Normally the link
editor will only create multiple TOC sections if it has more than
65,536 bytes to store in a TOC.
			</P
><P
>All link editors which support this ABI must support a single TOC
section, but support for multiple TOC sections is optional.
			</P
><P
>Each shared object will have a separate TOC or TOCs.
			</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This ABI does not actually restrict the size of a TOC section.
It is permissible to use a larger TOC section, if code uses a
different addressing mode to access it.  The AIX link editor, in
particular, does not support multiple TOC sections, but instead
inserts call out code at link time to support larger TOC sections.
				</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TOCALS"
>3.5.3. TOC Assembly Language Syntax</A
></H3
><P
>Desire for compatibility with both ELF systems and PowerOpen systems
suggests two different assembly language syntaxes to be used when
referring to the TOC section.  This syntax is not part of the official
ABI.  The description here is only for information purposes.
Particular assemblers may support both syntaxes, only one, or neither.
			</P
><P
>The ELF syntax uses @got and @toc.  The syntax SYMBOL@got refers to the offset in the TOC at 
			which the value of SYMBOL (that is, the address of the variable whose name is SYMBOL) is stored, 
			assuming the offset is no larger than 16 bits.  For example,
			</P
><PRE
CLASS="PROGRAMLISTING"
>ld   r3,x@got(r2)</PRE
><P
>SYMBOL@got will be an offset within the global offset table, which as
noted above, forms part of the TOC section.
			</P
><P
>Ordinarily the link editor will avoid having a TOC, and hence a GOT,
larger than 64 Kbytes, perhaps by support multiple TOC sections, or
via some other technique.  However, for flexibility, there is a syntax
for 32 bit offsets to the GOT.  The syntaxes SYMBOL@got@ha,
SYMBOL@got@h, and SYMBOL@got@l refer to the high adjusted, high, and
low parts of the GOT offset.  (The meaning of ``high adjusted'' is
explained in <A
HREF="#RELOC-TYPE"
>Section 4.5.1</A
>).
			</P
><P
>The syntax SYMBOL@toc refers to the value (SYMBOL - base (TOC)), where
base (TOC) represents the TOC base for the current object file.  This
provides the address of the variable whose name is SYMBOL, as an
offset from the TOC base.  This assumes that the variable may be found
within the TOC, and that its offset is no larger than 16 bits.
			</P
><P
>As with the GOT, the syntaxes SYMBOL@toc@ha, SYMBOL@toc@h, and
SYMBOL@toc@l refer to the high adjusted, high, and low parts of the
TOC offset.
			</P
><P
>The syntax SYMBOL@got@plt may be used to refer to the offset in the
TOC of a procedure linkage table entry stored in the global offset
table.  The corresponding syntaxes SYMBOL@got@plt@ha,
SYMBOL@got@plt@h, and SYMBOL@got@plt@l are also defined.
			</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Note that if X is a variable stored in the TOC, then X@got will be the
offset within the TOC of a doubleword whose value is X@toc.</P
></TD
></TR
></TABLE
></DIV
><P
>The special symbol .TOC.@tocbase is used to represent the TOC base for
the current object file.  The following might appear in a function
descriptor definition:
			</P
><PRE
CLASS="PROGRAMLISTING"
>      .quad .TOC.@tocbase</PRE
><P
>The PowerOpen syntax is more complex.  It is derived from the
different representation of the TOC section in XCOFF.
			</P
><P
>Assembly code first uses the .toc pseudo-op to enter the TOC section.
It then uses a label to name a particular element.  It then uses the
.tc pseudo-op to indicate which GOT entry it wishes to name.  Later in
the code, the label is used with the TOC register to load the address.  For example:
			</P
><PRE
CLASS="PROGRAMLISTING"
>      .toc
  .L1:
      .tc  x[TC],x
      ...
      ld   r3,.L1(r2)</PRE
><P
>This creates a GOT entry for the variable x, and names that entry .L1
for the remainder of the assembly.  The effect is the same as the
single ELF-style instruction above.
			</P
><P
>The special value TOC[tc0] is used to represent the TOC base for the
current object file:
			</P
><PRE
CLASS="PROGRAMLISTING"
>      .quad TOC[tc0]</PRE
><P
>The PowerOpen syntax permits other data to be stored in the .toc
section.  The assembler will output this data in a .toc section, and
convert references as though its address were specified with @toc
rather than @got.
			</P
><P
>There is a significant difference in representation of the TOC in this
ABI and in the 64-bit PowerOpen ABI.  Relocatable object files created
using the 64-bit PowerOpen ABI have a .toc section which contains real
data.  The link editor uses garbage collection to discard duplicate
information including in particular TOC entries which refer to the
same variable.  In this ABI, relocatable object files do not contain
.got sections holding real data.  Instead, the GOT is created by the
link editor based on relocations created by @got references.  This ABI
does not require the link editor to support garbage collection.  This
ABI does permit real data to exist in .toc sections, but this data
will never be referred to directly by instructions which use @got
references.  @got references always refer to the GOT which is created
by the link editor when creating an executable or a shared object.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRO-EP"
>3.5.4. Function Prologue and Epilogue</A
></H3
><P
>This section describes functions' prologue and epilogue code.  A
function's prologue establishes a stack frame, if necessary, and may
save any nonvolatile registers it uses.  A function's epilogue
generally restores registers that were saved in the prologue code,
restores the previous stack frame, and returns to the caller.
Except for the rules below, this ABI does not mandate predetermined
code sequences for function prologues and epilogues.  However, the
following rules, which permit reliable call chain backtracing, shall
be followed:
			</P
><P
></P
><UL
><LI
><P
>If the function uses any nonvolatile general registers, it shall
save them in the general register save area.  If the function does not
require a stack frame, this may be done using negative stack offsets
from the caller's stack pointer.</P
></LI
><LI
><P
>If the function uses any nonvolatile floating point registers, it
shall save them in the floating point register save area.  If the
function does not require a stack frame, this may be done using
negative stack offsets from the caller's stack pointer.</P
></LI
><LI
><P
>Before a function calls any other function, it shall establish its
own stack frame, whose size shall be a multiple of 16 bytes, and shall
save the link register at the time of entry in the LR save area of its
caller's stack frame.</P
></LI
><LI
><P
>If the function uses any nonvolatile fields in the CR, it shall
save the CR in the CR save area of the caller's stack frame.</P
></LI
><LI
><P
>If a function establishes a stack frame, it shall update the back
chain word of the stack frame atomically with the stack pointer (r1)
using one of the "Store Double Word with Update" instructions.</P
><P
></P
><UL
><LI
><P
>For small (no larger than 32 Kbytes) stack frames, 
							this may be accomplished with a "Store Double Word with Update" 
							instruction with an appropriate negative displacement.</P
></LI
><LI
><P
>For larger stack frames, the prologue shall load a 
							volatile register with the two's complement of the size of the frame 
							(computed with addis and addi or ori instructions) and issue a 
							"Store Double Word with Update Indexed" instruction.</P
></LI
></UL
></LI
><LI
><P
>When a function deallocates its stack frame, it must do so
atomically, either by loading the stack pointer (r1) with the value in
the back chain field or by incrementing the stack pointer by the same
amount by which it has been decremented.</P
></LI
></UL
><P
>In-line code may be used to save or restore nonvolatile general or
floating-point registers that the function uses.  However, if there
are many registers to be saved or restored, it may be more efficient
to call one of the system subroutines described below.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SAVE-RES"
>3.5.5. Register Saving and Restoring Functions</A
></H3
><P
>The register saving and restoring functions described in this section
use nonstandard calling conventions which ordinarily require them to
be statically linked into any executable or shared object modules in
which they are used.  Nevertheless, unlike 32-bit PowerPC ELF, these
functions are considered part of the official ABI.  In particular, the
link editor is permitted to treat calls to these functions specially,
such as by changing a call to one of these function into a call to an
absolute address as in the PowerOpen ABI.
			</P
><P
>As shown in The Stack Frame section above, the general register save
area is not at a fixed offset from either the caller's SP or the
callee's SP.  The floating point register save area starts at a fixed
position from the caller's SP on entry to the callee, but the position
of the general register save area depends upon the number of floating
point registers to be saved.  Thus it is impossible to write a general
register saving routine which uses fixed offsets from the SP.
			</P
><P
>If the routine needs to save both general and floating point
registers, code can use r12 as the pointer for saving and restoring
the general purpose registers.  (r12 is a volatile register but does
not contain input parameters).  This leads to the definition of
multiple register save and restore routines, each of which saves or
restores M floating point registers and N general registers.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SAVEREG"
>3.5.6. Saving General Registers Only</A
></H3
><P
>For a function that saves/restores N general registers and no floating
point registers, the saving can be done using individual store/load
instructions or by calling system provided routines as shown below.
			</P
><P
>In the following, the number of registers being saved is N, and &lt;32-N&gt;
is the first register number to be saved/restored.  All registers from
&lt;32-N&gt; up to 31, inclusive, are saved/restored.
			</P
><P
>FRAME_SIZE is the size of the stack frame, here assumed to be less
than 32 Kbytes.
			</P
><PRE
CLASS="PROGRAMLISTING"
>    mflr  r0                    # Move LR into r0
    bl    _savegpr0_&lt;32-N&gt;      # Call routine to save general registers
    stdu  r1,(-FRAME_SIZE)(r1)  # Create stack frame
    ...
    (save CR if necessary)
    ...                         # Body of function
    ...
    (reload CR if necessary)
    ...
    (reload caller's SP into r1)
    b     _restgpr0_&lt;32-N&gt;      # Restore registers and return</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SAVE-FLOAT"
>3.5.7. Saving General Registers and Floating Point Registers</A
></H3
><P
>For a function that saves/restores N general registers and M floating
point registers, the saving can be done using individual store/load
instructions or by calling system provided routines as shown below.</P
><PRE
CLASS="PROGRAMLISTING"
>    mflr  r0                    # Move LR into r0
    subi  r12,r1,8*M            # Set r12 to general reg save area
    bl    _savegpr1_&lt;32-N&gt;      # Call routine to save general registers
    bl    _savefpr_&lt;32-M&gt;       # Call routine to save floating point regs
    stdu  r1,(-FRAME_SIZE)(r1)  # Create stack frame
    ...
    (save CR if necessary)
    ...                         # Body of function
    ...
    (reload CR if necessary)
    ...
    (reload caller's SP into r1)
    subi  r12,r1,8*M            # Set r12 to general reg save area
    bl    _restgpr1_&lt;32-N&gt;      # Restore general registers
    b     _restfpr_&lt;32-M&gt;       # Restore floating point regs and return</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN628"
>3.5.8. Saving Floating Point Registers Only</A
></H3
><P
>For a function that saves/restores M floating point registers and no
general registers, the saving can be done using individual store/load
instructions or by calling system provided routines as shown below.</P
><PRE
CLASS="PROGRAMLISTING"
>    mflr  r0                    # Move LR into r0
    bl    _savefpr_&lt;32-M&gt;       # Call routine to save general registers
    stdu  r1,(-FRAME_SIZE)(r1)  # Create stack frame
    ...
    (save CR if necessary)
    ...                         # Body of function
    ...
    (reload CR if necessary)
    ...
    (reload caller's SP into r1)
    b     _restgpr_&lt;32-M&gt;       # Restore registers and return</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SAVE-RESTORE"
>3.5.9. Save and Restore Services</A
></H3
><P
>Systems must provide three sets of routines, which may be implemented
as multiple entry point routines or as individual routines.  They must
adhere to the following rules.</P
><P
>Each _savegpr0_N routine saves the general registers from rN to r31,
inclusive.  Each routine also saves the LR.  When the routine is
called, r1 must point to the start of the general register save area,
and r0 must contain the value of LR on function entry.
			</P
><P
>The _restgpr0_N routines restore the general registers from rN to r31,
and then return to the caller.  When the routine is called, r1 must
point to the start of the general register save area.
			</P
><P
>Here is a sample implementation of _savegpr0_N and _restgpr0_N.
			</P
><PRE
CLASS="PROGRAMLISTING"
>  _savegpr0_14:  std  r14,-144(r1)
  _savegpr0_15:  std  r15,-136(r1)
  _savegpr0_16:  std  r16,-128(r1)
  _savegpr0_17:  std  r17,-120(r1)
  _savegpr0_18:  std  r18,-112(r1)
  _savegpr0_19:  std  r19,-104(r1)
  _savegpr0_20:  std  r20,-96(r1)
  _savegpr0_21:  std  r21,-88(r1)
  _savegpr0_22:  std  r22,-80(r1)
  _savegpr0_23:  std  r23,-72(r1)
  _savegpr0_24:  std  r24,-64(r1)
  _savegpr0_25:  std  r25,-56(r1)
  _savegpr0_26:  std  r26,-48(r1)
  _savegpr0_27:  std  r27,-40(r1)
  _savegpr0_28:  std  r28,-32(r1)
  _savegpr0_29:  std  r29,-24(r1)
  _savegpr0_30:  std  r30,-16(r1)
  _savegpr0_31:  std  r31,-8(r1)
                 std  r0, 16(r1)
                 blr


  _restgpr0_14:  ld   r14,-144(r1)
  _restgpr0_15:  ld   r15,-136(r1)
  _restgpr0_16:  ld   r16,-128(r1)
  _restgpr0_17:  ld   r17,-120(r1)
  _restgpr0_18:  ld   r18,-112(r1)
  _restgpr0_19:  ld   r19,-104(r1)
  _restgpr0_20:  ld   r20,-96(r1)
  _restgpr0_21:  ld   r21,-88(r1)
  _restgpr0_22:  ld   r22,-80(r1)
  _restgpr0_23:  ld   r23,-72(r1)
  _restgpr0_24:  ld   r24,-64(r1)
  _restgpr0_25:  ld   r25,-56(r1)
  _restgpr0_26:  ld   r26,-48(r1)
  _restgpr0_27:  ld   r27,-40(r1)
  _restgpr0_28:  ld   r28,-32(r1)
  _restgpr0_29:  ld   r0, 16(r1)
                 ld   r29,-24(r1)
                 mtlr r0
                 ld   r30,-16(r1)
                 ld   r31,-8(r1)
                 blr
  _restgpr0_30:  ld   r30,-16(r1)
  _restgpr0_31:  ld   r0, 16(r1)
                 ld   r31,-8(r1)
                 mtlr r0
                 blr</PRE
><P
>Each _savegpr1_N routine saves the general registers from rN to r31,
inclusive.  When the routine is called, r12 must point to the start of
the general register save area.
			</P
><P
>The _restgpr1_N routines restore the general registers from rN to r31.
When the routine is called, r12 must point to the start of the general
register save area.
			</P
><P
>Here is a sample implementation of _savegpr1_N and _restgpr1_N.
			</P
><PRE
CLASS="PROGRAMLISTING"
>  _savegpr1_14:  std  r14,-144(r12)
  _savegpr1_15:  std  r15,-136(r12)
  _savegpr1_16:  std  r16,-128(r12)
  _savegpr1_17:  std  r17,-120(r12)
  _savegpr1_18:  std  r18,-112(r12)
  _savegpr1_19:  std  r19,-104(r12)
  _savegpr1_20:  std  r20,-96(r12)
  _savegpr1_21:  std  r21,-88(r12)
  _savegpr1_22:  std  r22,-80(r12)
  _savegpr1_23:  std  r23,-72(r12)
  _savegpr1_24:  std  r24,-64(r12)
  _savegpr1_25:  std  r25,-56(r12)
  _savegpr1_26:  std  r26,-48(r12)
  _savegpr1_27:  std  r27,-40(r12)
  _savegpr1_28:  std  r28,-32(r12)
  _savegpr1_29:  std  r29,-24(r12)
  _savegpr1_30:  std  r30,-16(r12)
  _savegpr1_31:  std  r31,-8(r12)
                 blr


  _restgpr1_14:  ld   r14,-144(r12)
  _restgpr1_15:  ld   r15,-136(r12)
  _restgpr1_16:  ld   r16,-128(r12)
  _restgpr1_17:  ld   r17,-120(r12)
  _restgpr1_18:  ld   r18,-112(r12)
  _restgpr1_19:  ld   r19,-104(r12)
  _restgpr1_20:  ld   r20,-96(r12)
  _restgpr1_21:  ld   r21,-88(r12)
  _restgpr1_22:  ld   r22,-80(r12)
  _restgpr1_23:  ld   r23,-72(r12)
  _restgpr1_24:  ld   r24,-64(r12)
  _restgpr1_25:  ld   r25,-56(r12)
  _restgpr1_26:  ld   r26,-48(r12)
  _restgpr1_27:  ld   r27,-40(r12)
  _restgpr1_28:  ld   r28,-32(r12)
  _restgpr1_29:  ld   r29,-24(r12)
  _restgpr1_30:  ld   r30,-16(r12)
  _restgpr1_31:  ld   r31,-8(r12)
                 blr</PRE
><P
>Each _savefpr_M routine saves the floating point registers from fM to
f31, inclusive.  When the routine is called, r1 must point to the
start of the floating point register save area, and r0 must contain
the value of LR on function entry.
			</P
><P
>The _restfpr_M routines restore the floating point registers from fM
to f31.  When the routine is called, r1 must point to the start of the
floating point register save area.
			</P
><P
>Here is a sample implementation of _savepr_M and _restfpr_M.
			</P
><PRE
CLASS="PROGRAMLISTING"
>  _savefpr_14:  stfd f14,-144(r1)
  _savefpr_15:  stfd f15,-136(r1)
  _savefpr_16:  stfd f16,-128(r1)
  _savefpr_17:  stfd f17,-120(r1)
  _savefpr_18:  stfd f18,-112(r1)
  _savefpr_19:  stfd f19,-104(r1)
  _savefpr_20:  stfd f20,-96(r1)
  _savefpr_21:  stfd f21,-88(r1)
  _savefpr_22:  stfd f22,-80(r1)
  _savefpr_23:  stfd f23,-72(r1)
  _savefpr_24:  stfd f24,-64(r1)
  _savefpr_25:  stfd f25,-56(r1)
  _savefpr_26:  stfd f26,-48(r1)
  _savefpr_27:  stfd f27,-40(r1)
  _savefpr_28:  stfd f28,-32(r1)
  _savefpr_29:  stfd f29,-24(r1)
  _savefpr_30:  stfd f30,-16(r1)
  _savefpr_31:  stfd f31,-8(r1)
                std  r0, 16(r1)
                blr


  _restfpr_14:  lfd  f14,-144(r1)
  _restfpr_15:  lfd  f15,-136(r1)
  _restfpr_16:  lfd  f16,-128(r1)
  _restfpr_17:  lfd  f17,-120(r1)
  _restfpr_18:  lfd  f18,-112(r1)
  _restfpr_19:  lfd  f19,-104(r1)
  _restfpr_20:  lfd  f20,-96(r1)
  _restfpr_21:  lfd  f21,-88(r1)
  _restfpr_22:  lfd  f22,-80(r1)
  _restfpr_23:  lfd  f23,-72(r1)
  _restfpr_24:  lfd  f24,-64(r1)
  _restfpr_25:  lfd  f25,-56(r1)
  _restfpr_26:  lfd  f26,-48(r1)
  _restfpr_27:  lfd  f27,-40(r1)
  _restfpr_28:  lfd  f28,-32(r1)
  _restfpr_29:  lfd  f29,-24(r1)
  _restfpr_29:  ld   r0, 16(r1)
                lfd  f29,-24(r1)
                mtlr r0
                lfd  f30,-16(r1)
                lfd  f31,-8(r1)
                blr
  _restfpr_30:  lfd  f30,-16(r1)
  _restfpr_31:  ld   r0, 16(r1)
                lfd  f31,-8(r1)
                mtlr r0
                blr</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DATA-OBJ"
>3.5.10. Data Objects</A
></H3
><P
>This section describes only objects with static storage duration. It
excludes stack-resident objects because programs always compute their
virtual addresses relative to the stack or frame pointers.
			</P
><P
>In the 64-bit PowerPC Architecture, only load and store instructions
access memory.  Because 64-bit PowerPC instructions cannot hold 64-bit
addresses directly, a program normally computes an address into a
register and accesses memory through the register.
			</P
><P
>It is possible to build addresses using absolute code which puts
symbol addresses into instructions.  However, the difficulty of
building a 64-bit address means that 64-bit PowerPC code normally
loads an address out of a memory location in the TOC section.
Combining the TOC offset of the symbol with the TOC address in
register r2 gives the absolute address of the TOC entry holding the
desired address.
			</P
><P
>The following figures show sample assembly language equivalents to C
language code.  The @got syntax is explained above, in the section TOC
Assembly Language Syntax.
			</P
><P
>Load and Store; variables are not in TOC:</P
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly

extern int src;
extern int dst;
extern int *ptr;

dst = src;
                              ld  r6,src@got(r2)
                              ld  r7,dst@got(r2)
                              lwz r0,0(r6)
                              stw r0,0(r7)

ptr = &amp;dst;
                              ld  r0,dst@got(r2)
                              ld  r7,ptr@got(r2)
                              std r0,0(r7)

*ptr = src;
                              ld  r6,src@got(r2)
                              ld  r7,ptr@got(r2)
                              lwz r0,0(r6)
                              ld  r7,0(r7)
                              stw r0,0(r7)</PRE
><P
>The next example shows the same code assuming that the variables are
all stored in the TOC.  Shared objects normally can not assume that
globally visible variables are stored in the TOC.  If they did, it
would be impossible for the variable references to be redirected to
overriding variables in the main program.  Therefore, shared objects
should normally always use the type of code shown above.
			</P
><P
>Load and Store; variables in TOC:
			</P
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly

extern int src;
extern int dst;
extern int *ptr;

dst = src;
                              lwz r0,src@toc(r2)
                              stw r0,dst@toc(r2)

ptr = &amp;dst;
                              la  r0,dst@toc(r2)
                              std r0,ptr@toc(r2)

*ptr = src;
                              lwz r0,src@toc(r2)
                              ld  r7,ptr@toc(r2)
                              stw r0,0(r7)</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FUNC-CALLS"
>3.5.11. Function Calls</A
></H3
><P
>Programs use the 64-bit PowerPC bl instruction to make direct function
calls.  The bl instruction must be followed by a nop instruction.  For
PowerOpen compatibility, the nop instruction must be:
			</P
><PRE
CLASS="PROGRAMLISTING"
>    ori  r0,r0,0</PRE
><P
>For PowerOpen compatibility, the link editor must also accept these
instructions as valid nop instructions:
			</P
><PRE
CLASS="PROGRAMLISTING"
>    cror 15,15,15
    cror 31,31,31</PRE
><P
>In a relocatable object file, a direct function call should be made to
the function entry point, which is a symbol beginning with dot (.).
See <A
HREF="#FUNC-DES"
>Section 3.2.5</A
> for more information.
			</P
><P
>When the link editor is creating an executable or shared object, and
it sees a function call followed by a nop instruction, it determines
whether the caller and the callee share the same TOC.  If they do, it
leaves the nop instruction unchanged.  If they do not, the link editor
constructs a linkage function.  The linkage function loads the TOC
register with the callee TOC and branches to the callee entry point.
The link editor modifies the bl instruction to branch to the linkage
function, and modifies the nop instruction to be
			</P
><PRE
CLASS="PROGRAMLISTING"
>    ld   r2,40(r1)</PRE
><P
>This will reload the TOC register from the TOC save area after the
callee returns.
			</P
><P
>A bl instruction has a self-relative branch displacement that can
reach 32 Mbytes in either direction.  Hence, the use of a bl
instruction to effect a call within an executable or shared object
file limits the size of the executable or shared object file text
segment.
			</P
><P
>If the callee is in a different shared object, a similar procedure of
linkage code and a modified nop instruction is used.  In this case,
the dynamic linker must complete the link by filling in the function
descriptor at run time.  See <A
HREF="#PROC-LINK"
>Section 5.2.4</A
> for
more details.
			</P
><P
>Here is an example of the assembly code generated for a function call:
			</P
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly

extern void func (void);
func ();
                              bl   .func
                              ori  r0,r0,0

Here is an example of how the link editor transforms this code if the
callee has a different TOC than the caller:

C                             Assembly

extern void func (void);
func ();
                              bl   &lt;linkage_for_func&gt;
                              ld   r2,40(r1)</PRE
><P
>Here is an example of the linkage code created by the link editor.
Remember that func@got@plt contains the address of the procedure
linkage entry for func, which is a function descriptor.  The function
descriptor holds the addresses of the function entry point and the
function TOC base.
			</P
><PRE
CLASS="PROGRAMLISTING"
>&lt;linkage_for_func&gt;:
    ld    r12,func@got@plt(r2)
    std   r2,40(r1)
    ld    r0,0(r12)
    ld    r2,8(r12)
    mtctr r0
    bctr</PRE
><P
>The value of a function pointer is the address of the function
descriptor, not the address of the function entry point itself.
			</P
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly
extern void func (void);
extern void (*ptr) (void);
ptr = func;
                              ld    r6,func@got(r2)
                              ld    r7,ptr@got(r2)
                              std   r6,0(r7)

(*ptr) ();
                              ld    r6,ptr@got(r2)
                              ld    r6,0(r6)
                              ld    r0,0(r6)
                              std   r2,40(r1)
                              mtctr r0
                              ld    r2,8(r6)
                              bctrl
                              ld    r2,40(r1)</PRE
><P
>Since most of the code sequence used for a call through a pointer is
the same no matter what function pointer is being used, it is also
possible to do it by calling a function with an unusual calling
convention provided by a library.  With this approach, efficiency
requires that the function be linked in directly, and not come from a
shared library.  The PowerOpen ABI uses a function named ._ptrgl for
this purpose, passing the function pointer value in r11, and it is
recommended that this name and calling convention be used as well when
using this approach under ELF.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BRANCH"
>3.5.12. Branching</A
></H3
><P
>Programs use branch instructions to control their execution flow.  As
defined by the architecture, branch instructions hold a self-relative
value with a 64-Mbyte range, allowing a jump to locations up to 32
Mbytes away in either direction.
			</P
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly
label:
                              .L01:
    ...
    goto label
                                  b .L01</PRE
><P
>C switch statements provide multiway selection.  When the case labels
of a switch statement satisfy grouping constraints, the compiler
implements the selection with an address table.  The following example
uses several simplifying conventions to hide irrelevant details:
			</P
><P
></P
><UL
><LI
><P
>The selection expression resides in r12, and is of type int.</P
></LI
><LI
><P
>The case label constants begin at zero.</P
></LI
><LI
><P
>The case labels, the default, and the address table use assembly
  names .Lcasei, .Ldef, and .Ltab, respectively.
					</P
></LI
></UL
><PRE
CLASS="PROGRAMLISTING"
>C                             Assembly
switch (j)
  {
  case 0:
    ...
  case 1:
    ...
  case 3:
    ...
  default:
    ...
  }
                                  cmplwi  r12,4
                                  bge     .Ldef
                                  bl      .L1
                              .L1:
                                  slwi    r12,2
                                  mflr    r11
                                  addi    r12,r12,.Ltab-.L1
                                  add     r0,r12,r11
                                  mtctr   r0
                                  bctr
                              .Ltab:
                                  b       .Lcase0
                                  b       .Lcase1
                                  b       .Ldef
                                  b       .Lcase3</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DYNAM-STACK"
>3.5.13. Dynamic Stack Space Allocation</A
></H3
><P
>Unlike some other languages, C does not need dynamic stack allocation
within a stack frame.  Frames are allocated dynamically on the program
stack, depending on program execution, but individual stack frames can
have static sizes.  Nonetheless, the architecture supports dynamic
allocation for those languages that require it.  The mechanism for
allocating dynamic space is embedded completely within a function and
does not affect the standard calling sequence.  Thus languages that
need dynamic stack frame sizes can call C functions, and vice versa.
			</P
><P
>Here is the stack frame before dynamic stack allocation:</P
><PRE
CLASS="SCREEN"
>High address

          +-&gt; Back chain
          |   Floating point register save area
          |   General register save area
          |   Local variable space
          |   Parameter save area    (SP + 48)
          |   TOC save area          (SP + 40)  --+
          |   link editor doubleword (SP + 32)    |
          |   compiler doubleword    (SP + 24)    |--stack frame header
          |   LR save area           (SP + 16)    |
          |   CR save area           (SP + 8)     |
SP  ---&gt;  +-- Back chain             (SP + 0)   --+

Low address</PRE
><P
>Here is the stack frame after dynamic stack allocation:</P
><PRE
CLASS="SCREEN"
>High address

          +-&gt; Back chain
          |   Floating point register save area
          |   General register save area
          |   Local variable space
          |   -- Old parameter save area, now allocated space
          |   -- Old stack frame header, now allocated space
          |   -- More newly allocated space
          |   New parameter save area    (SP + 48)
          |   New TOC save area          (SP + 40)
          |   New link editor doubleword (SP + 32)
          |   New compiler doubleword    (SP + 24)
          |   New LR save area           (SP + 16)
          |   New CR save area           (SP + 8)
SP  ---&gt;  +-- New Back chain             (SP + 0)

Low address</PRE
><P
>The local variables area is used for storage of function data, such as
local variables, whose sizes are known to the compiler.  This area is
allocated at function entry and does not change in size or position
during the function's activation.
			</P
><P
>The parameter save area is reserved for arguments passed in calls to
other functions.  See <A
HREF="#PARAM-PASS"
>Section 3.2.3</A
> for more information.  Its size
is also known to the compiler and can be allocated along with the
fixed frame area at function entry.  However, the standard calling
sequence requires that the parameter save area begin at a fixed offset
(48) from the stack pointer, so this area must move when dynamic stack
allocation occurs.
			</P
><P
>The stack frame header must also be at a fixed offset (0) from the
stack pointer, so this area must also move when dynamic stack
allocation occurs.
			</P
><P
>Data in the parameter save area are naturally addressed at constant
offsets from the stack pointer.  However, in the presence of dynamic
stack allocation, the offsets from the stack pointer to the data in
the local variables area are not constant.  To provide addressability,
a frame pointer is established to locate the local variables area
consistently throughout the function's activation.
			</P
><P
>Dynamic stack allocation is accomplished by "opening" the stack just
above the parameter save area.  The following steps show the process
in detail:
			</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Sometime after a new stack frame is acquired and before the first
   dynamic space allocation, a new register, the frame pointer, is set
   to the value of the stack pointer.  The frame pointer is used for
   references to the function's local, non-static variables.</P
></LI
><LI
><P
>The amount of dynamic space to be allocated is rounded up to a
   multiple of 16 bytes, so that quadword stack alignment is
   maintained.</P
></LI
><LI
><P
>The stack pointer is decreased by the rounded byte count, and the
   address of the previous stack frame (the back chain) is stored at
   the word addressed by the new stack pointer.  This shall be
   accomplished atomically by using stdu rS,-length(r1) if the length
   is less than 32768 bytes, or by using stdux rS,r1,rspace, where rS
   is the contents of the back chain word and rspace contains the
   (negative) rounded number of bytes to be allocated.</P
></LI
></OL
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is only strictly necessary to copy the back chain.  The
information in the parameter save area is recreated for each function
call.  The information in the stack frame header, other than the back
chain, is only used by a called function.  In some cases, a compiler
may need to copy the TOC save area as well, depending upon precisely
how it generates linkage code.</P
></TD
></TR
></TABLE
></DIV
><P
>The above process can be repeated as many times as desired within a
single function activation.  When it is time to return, the stack
pointer is set to the value of the back chain, thereby removing all
dynamically allocated stack space along with the rest of the stack
frame.  Naturally, a program must not reference the dynamically
allocated stack area after it has been freed.
			</P
><P
>Even in the presence of signals, the above dynamic allocation scheme
is "safe."  If a signal interrupts allocation, one of three things can
happen:
			</P
><P
></P
><UL
><LI
><P
>The signal handler can return. The process then resumes the dynamic
  allocation from the point of interruption.</P
></LI
><LI
><P
>The signal handler can execute a non-local goto or a jump.  This
  resets the process to a new context in a previous stack frame,
  automatically discarding the dynamic allocation.</P
></LI
><LI
><P
>The process can terminate.</P
></LI
></UL
><P
>Regardless of when the signal arrives during dynamic allocation, the
result is a consistent (though possibly dead) process.
			</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DW-DEF"
>3.6. DWARF Definition</A
></H2
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN728"
>3.6.1. DWARF Release Number</A
></H3
><P
>This section defines the Debug With Arbitrary Record Format (DWARF)
debugging format for the 64-bit PowerPC processor family.  The 64-bit
PowerPC ABI does not define a debug format.  However, all systems that
do implement DWARF shall use the following definitions.
			</P
><P
>DWARF is a specification developed for symbolic, source-level
debugging.  The debugging information format does not favor the design
of any compiler or debugger.  For more information on DWARF, see the
documents cited in <A
HREF="#TOCINTRO"
>Chapter 1</A
>.
			</P
><P
>The DWARF definition requires some machine-specific definitions.  The
register number mapping needs to be specified for the 64-bit PowerPC
registers.  In addition, the DWARF Version 2 specification requires
processor-specific address class codes to be defined.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DW-REG"
>3.6.2. DWARF Register Number Mapping</A
></H3
><P
>This table outlines the register number mapping for the 64-bit PowerPC
processor family.  Note that for all special purpose registers, the
number is simply 100 plus the SPR register number, as defined in the
64-bit PowerPC Architecture.  Registers with an asterisk before their
name are MPC601 chip-specific and are not part of the generic 64-bit
PowerPC chip architecture.
			</P
><PRE
CLASS="SCREEN"
>Register Name              Number        Abbreviation

General Register 0-31      0-31          r0-r31

Floating Register 0-31     32-63         f0-f31

Condition Register         64            CR

Floating-Point Status and  65            FPSCR
Control Register

* MQ Register              100           MQ or SPR0

Fixed-Point Exception      101           XER or SPR1
Register

* Real Time Clock          104           RTCU or SPR4
Upper Register

* Real Time Clock          105           RTCL or SPR5
Lower Register

Link Register              108           LR or SPR8

Count Register             109           CTR or SPR9</PRE
><P
>For kernel debuggers, the mapping for all privileged registers is also
defined in this table.
			</P
><PRE
CLASS="SCREEN"
>Register Name              Number        Abbreviation

Machine State Register     66            MSR

Segment Register 0-15      70-85         SR0-SR15

Data Storage Interrupt     118           DSISR or SPR18
Status Register

Data Address Register      119           DAR or SPR19

Decrementer                122           DEC or SPR22

Storage Description        125           SDR1 or SPR25
Register 1

Machine Status             126           SRR0 or SPR26
Save/Restore Register 0

Machine Status             127           SRR1 or  SPR27
Save/Restore Register 1

Software-use Special       372           SPRG0 or SPR272
Purpose Register 0

Software-use Special       373           SPRG1 or SPR273
Purpose Register 1

Software-use Special       374           SPRG2 or SPR274
Purpose Register 2

Software-use Special       375           SPRG3 or SPR275
Purpose Register 3

Address Space Register     380           ASR or SPR280

External Access Register   382           EAR or SPR282

Time Base                  384           TB or SPR284

Time Base Upper            385           TBU or SPR285

Processor Version Register 387           PVR or SPR287

Instruction BAT Register   628           IBAT0U or SPR528
0 Upper

Instruction BAT Register   629           IBAT0L or SPR529
0 Lower

Instruction BAT Register   630           IBAT1U or SPR530
1 Upper

Instruction BAT Register   631           IBAT1L or SPR531
1 Lower

Instruction BAT Register   632           IBAT2U or SPR532
2 Upper

Instruction BAT Register   633           IBAT2L or SPR533
2 Lower

Instruction BAT Register   634           IBAT3U or SPR534
3 Upper

Instruction BAT Register   635           IBAT3L or SPR535
3 Lower

Data BAT Register 0 Upper  636           DBAT0U or SPR536

Data BAT Register 0 Lower  637           DBAT0L or SPR537

Data BAT Register 1 Upper  638           DBAT1U or SPR538

Data BAT Register 1 Lower  639           DBAT1L or SPR539

Data BAT Register 2 Upper  640           DBAT2U or SPR540

Data BAT Register 2 Lower  641           DBAT2L or SPR541

Data BAT Register 3 Upper  642           DBAT3U or SPR542

Data BAT Register 3 Lower  643           DBAT3L or SPR543

* Hardware Implementation  1108          HID0 or SPR1008
Register 0

* Hardware Implementation  1109          HID1 or SPR1009
Register 1

* Hardware Implementation  1110          HID2 or IABR or SPR1010
Register 2

* Hardware Implementation  1113          HID5 or DABR or SPR1013
Register 5

* Hardware Implementation  1123          HID15 or PIR or SPR1023
Register 15</PRE
><P
>The 64-bit PowerPC processor family defines the address class codes
described in the following table:
			</P
><PRE
CLASS="SCREEN"
>Code                       Value         Meaning

ADDR_none                  0             No class specified</PRE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="OBJ-FILES"
></A
>Chapter 4. Object Files</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="ELF-HEAD"
>4.1. ELF Header</A
></H2
><P
>For file identification in e_ident, the 64-bit PowerPC processor
family requires the values shown below:
		</P
><PRE
CLASS="PROGRAMLISTING"
>e_ident[EI_CLASS]   ELFCLASS64   For all 64-bit implementations.
e_ident[EI_DATA]    ELFDATA2MSB  For all big-endian implementations.
e_ident[EI_DATA]    ELFDATA2LSB  For all little-endian implementations.</PRE
><P
>The ELF header's e_flags member holds bit flags associated with the
file.  Since the 64-bit PowerPC processor family defines no flags,
this member contains zero.
		</P
><P
>Processor identification resides in the ELF header's e_machine member,
and must have the value 21, defined as the name EM_PPC64.
		</P
><P
>The e_entry field in the ELF header holds the address of a function
descriptor.  See Function Descriptors in chapter 3.  This function
descriptor supplies both the address of the function entry point and
the initial value of the TOC pointer register.
		</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIAL"
>4.2. Special Sections</A
></H2
><P
>Various sections hold program and control information.  The sections
listed in the following table are used by the system and have the
types and attributes shown.
		</P
><PRE
CLASS="SCREEN"
>Name          Type               Attributes

.glink        SHT_PROGBITS       SHF_ALLOC + SHF_EXECINSTR
.got          SHT_PROGBITS       SHF_ALLOC + SHF_WRITE
.toc          SHT_PROGBITS       SHF_ALLOC + SHF_WRITE
.tocbss       SHT_NOBITS         SHF_ALLOC + SHF_WRITE
.plt          SHT_NOBITS         SHF_ALLOC + SHF_WRITE</PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The .plt section on the 64-bit PowerPC is of type SHT_NOBITS,
not SHT_PROGBITS as on most other processors.</P
></TD
></TR
></TABLE
></DIV
><P
>Special sections are described below.
		</P
><PRE
CLASS="SCREEN"
>Name     Description

.glink   This section may be used to hold the global linkage table which
         aids the procedure linkage table. See Procedure Linkage Table
         in Chapter 5 for more information.

.got     This section may be used to hold the Global Offset Table, or
         GOT.  See The Toc Section and Coding Examples in Chapter 3
         and Global Offset Table in Chapter 5 for more information.

.toc     This section may be used to hold the initialized Table of
         Contents, or TOC.  See TOC, below, The Toc Section and Coding
         examples in Chapter 3 and Global Offset Table in Chapter 5
         for more information.

.tocbss  This section may be used to hold the uninitialized portions
         of the TOC.  This data may also be stored as zero-initialized
         data in a .toc section.

.plt     This section holds the procedure linkage table. See Procedure
         Linkage Table in Chapter 5 for more information.</PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Tools which support this ABI are not required to use these
sections precisely as defined here, and indeed are not required to use
them at all.  The true use of a section is defined by the relocation
information and by the code which refers to it.  However, if tools use
these sections, they are required to give them the types and
attributes specified in the above table.
			</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TOC"
>4.3. TOC</A
></H2
><P
>The Table of Contents, or TOC, is part of the data segment of an
executable program.
		</P
><P
>This sections describes a typical layout of the TOC in an executable
file or shared object.  Particular tools need not follow this layout
as specified here.
		</P
><P
>The TOC typically contains data items within the .got, .toc and
.tocbss sections, which can be addressed with 16-bit signed offsets
from the TOC base.  The TOC base is typically the first address in the
TOC plus 0x8000, thus permitting a full 64 Kbyte TOC.  The .got
section is typically created by the link editor based on @got
relocations.  The .toc and .tocbss sections are typically included
from relocatable object files referenced during the link.
		</P
><P
>The TOC may straddle the boundary between initialized and
uninitialized data in the data segment.  The usual order of sections
in the data segment, some of which may be empty, is:
		</P
><PRE
CLASS="SCREEN"
>    .data
    .got
    .toc
    .tocbss
    .plt</PRE
><P
>The link editor may create multiple TOC sections, as specified in <A
HREF="#TOC-SEC"
>Section 3.5.2</A
>.  In such a case, the .got and .toc sections
will be repeated as necessary, possibly renamed to preserve unique
section names.  Any occurrence of .tocbss in a TOC section other than
the last one will be converted into a .toc section initialized to
contain zero bytes.
		</P
><P
>Compilers may generate "short-form," one-instruction references for
all data items that are in the TOC section for the object file being
compiled.  Such references are relative to the TOC pointer register,
r2, which always holds the base of the TOC section for the object
file.
		</P
><P
>In a shared object, only data items with local (non-global) scope may
be addressed via the TOC pointer.  Global data items must be addressed
via the GOT, even if they appear in a .toc or .tocbss section.
		</P
><P
>A compiler which places some data items in the TOC must provide an
option to avoid doing so in a particular compilation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYM"
>4.4. Symbol Table</A
></H2
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYM-VAL"
>4.4.1. Symbol Values</A
></H3
><P
>If an executable file contains a reference to a function defined in
one of its associated shared objects, the symbol table section for the
file will contain an entry for that symbol.  The st_shndx member of
that symbol table entry contains SHN_UNDEF.  This informs the dynamic
linker that the symbol definition for that function is not contained
in the executable file itself.  If that symbol has been allocated a
procedure linkage table entry in the executable file, and the st_value
member for that symbol table entry is nonzero, the value is the
virtual address of the function descriptor provided by that procedure
linkage table entry.  Otherwise, the st_value member contains zero.
This procedure linkage table entry address is used by the dynamic
linker in resolving references to the address of the function.  See <A
HREF="#FUNC-ADDRESS"
>Section 5.2.3</A
> for details.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="RELOC"
>4.5. Relocation</A
></H2
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RELOC-TYPE"
>4.5.1. Relocation Types</A
></H3
><P
>Relocation entries describe how to alter the instruction and data
relocation fields shown below.  Bit numbers appear in the lower box
corners; little-endian byte numbers appear in the upper right box
corners; big-endian numbers appear in the upper left box corners.
			</P
><PRE
CLASS="SCREEN"
>+-------+-------+-------+-------+-------+-------+-------+-------+
|0     7|1     6|2     5|3     4|4     3|5     2|6     1|7     0|
|                          doubleword64                         |
|0                                                            63|
+---------------------------------------------------------------+

+-------+-------+-------+-------+
|0     3|1     2|2     1|3     0|
|             word32            |
|0                            31|
+-------------------------------+

+-------+-------+-------+--+----+
|0     3|1     2|2     1|3 |   0|
|             word30       |    |
|0                       29|3031|
+--------------------------+----+

+----+--+-------+-------+--+----+
|0   | 3|1     2|2     1|3 |   0|
|    |        low24        |    |
|0  5|6                  29|3031|
+----+---------------------+----+

+-------+-+--+--+-------+--+----+
|0     3|1|  | 2|2     1|3 |   0|
|         |  |  |  low14   |    |
|0        |10|15|16      29|3031|
+---------+--+--+----------+----+


+-------+-------+
|0     1|1     0|
|    half16     |
|0            15|
+---------------+

+-------+------+--+
|0     1|1     | 0|
|    half16ds  |  |
|0           13|15|
+--------------+--+

doubleword64   This specifies a 64-bit field occupying 8 bytes, the
               alignment of which is 8 bytes unless otherwise
               specified.

word32         This specifies a 32-bit field occupying 4 bytes, the
               alignment of which is 4 bytes unless otherwise
               specified.

word30         This specifies a 30-bit field contained within bits
               0-29 of a word with 4-byte alignment. The two least
               significant bits of the word are unchanged.

low24          This specifies a 24-bit field contained within a word
               with 4-byte alignment.  The six most significant and
               the two least significant bits of the word are ignored
               and unchanged (for example, "Branch" instruction).

low14          This specifies a 14-bit field contained within a word
               with 4-byte alignment, comprising a conditional branch
               instruction.  The 14-bit relative displacement in bits
               16-29, and possibly the "branch prediction bit" (bit
               10), are altered; all other bits remain unchanged.

half16         This specifies a 16-bit field occupying 2 bytes with
               2-byte alignment (for example, the immediate field of
               an "Add Immediate" instruction).

half16ds       Similar to half16, but really just 14 bits since the
               two least significant bits must be zero, and are not really
               part of the field.  (Used by for example the ldu instruction.)</PRE
><P
>Calculations in the relocation table assume the actions are
transforming a relocatable file into either an executable or a shared
object file.  Conceptually, the link editor merges one or more
relocatable files to form the output.  It first determines how to
combine and locate the input files, next it updates the symbol values,
and then it performs relocations.
			</P
><P
>Some relocations use high adjusted values.  These are the most
significant bits, adjusted so that adding the low 16 bits will perform
the correct calculation of the address accounting for signed
arithmetic.  This is to support using the low 16 bits as a signed
offset when loading the value.  For example, a value could be loaded
from an absolute 64 bit address SYM as follows:
			</P
><PRE
CLASS="PROGRAMLISTING"
>    lis   r3,SYM@highesta
    ori   r3,SYM@highera
    sldi  r3,r3,32
    oris  r3,r3,SYM@ha
    ld    r4,SYM@l(r3)</PRE
><P
>The adjusted forms mean that this will work correctly even if SYM@l is
negative when interpreted as a signed 16 bit number.  Compare this to
building the same 64 bit address using ori, in which case the adjusted
forms are not used:
			</P
><PRE
CLASS="PROGRAMLISTING"
>    lis   r3,SYM@highest
    ori   r3,SYM@higher
    sldi  r3,r3,32
    oris  r3,r3,SYM@h
    ori   r3,r3,SYM@l
    ld    r4,0(r3)</PRE
><P
>These code samples are not meant to encourage people to write code
which builds absolute 64 bit addresses in this manner.  It is normally
better to use position independent code.  However, this ABI does make
this usage possible when it is required.
			</P
><P
>Relocations applied to executable or shared object files are similar
and accomplish the same result.  The following notations are used in
the relocation table:
			</P
><PRE
CLASS="SCREEN"
>A    Represents the addend used to compute the value of the
     relocatable field.

B    Represents the base address at which a shared object has been
     loaded into memory during execution.  Generally, a shared object
     file is built with a 0 base virtual address, but the execution
     address will be different.  See Program Header in the System V
     ABI for more information about the base address.

G    Represents the offset into the global offset table, relative to
     the TOC base, at which the address of the relocation entry's symbol
     plus addend will reside during execution.  See Coding Examples in
     Chapter 3 and Global Offset Table in Chapter 5 for more information.

L    Represents the section offset or address of the procedure linkage
     table entry for the symbol plus addend.  A procedure linkage table
     entry redirects a function call to the proper destination.  The
     link editor builds the initial procedure linkage table, and the
     dynamic linker modifies the entries during execution.  See
     Procedure Linkage Table in Chapter 5 for more information.

M    Similar to G, except that the address which is stored may be the
     address of the procedure linkage table entry for the symbol.

P    Represents the place (section offset or address) of the storage
     unit being relocated (computed using r_offset).

R    Represents the offset of the symbol within the section in which
     the symbol is defined (its section-relative address).

S    Represents the value of the symbol whose index resides in the
     relocation entry.</PRE
><P
>The following notations are used for relocations used with thread-local 
symbols.</P
><PRE
CLASS="SCREEN"
>@dtpmod
     Computes the load module index of the load module that contains
     the definition of sym.  The addend, if present, is ignored.

@dtprel
     Computes a dtv-relative displacement, the difference between the
     value of S + A and the base address of the thread-local storage
     block that contains the definition of the symbol, minus 0x8000.

@tprel
     Computes a tp-relative displacement, the difference between the
     value of S + A and the value of the thread pointer (r13).

@got@tlsgd
     Allocates two contiguous entries in the GOT to hold a tls_index
     structure, with values @dtpmod and @dtprel, and computes the
     offset to the first entry relative to the TOC base (r2).

@got@tlsld
     Allocates two contiguous entries in the GOT to hold a tls_index
     structure, with values @dtpmod and zero, and computes the offset
     to the first entry relative to the TOC base (r2).

@got@dtprel
     Allocates an entry in the GOT with value @dtprel, and computes
     the offset to the entry relative to the TOC base (r2).

@got@tprel
     Allocates an entry in the GOT with value @tprel, and computes the
     offset to the entry relative to the TOC base (r2).</PRE
><P
>Relocation entries apply to halfwords, words, or doublewords.  In all
cases, the r_offset value designates the offset or virtual address of
the first byte of the affected storage unit.  The relocation type
specifies which bits to change and how to calculate their values.  The
64-bit PowerPC family uses only the Elf32_Rela relocation entries with
explicit addends.  For the relocation entries, the r_addend member
serves as the relocation addend.  In all cases, the offset, addend,
and the computed result use the byte order specified in the ELF
header.
			</P
><P
>The following general rules apply to the interpretation of the
relocation types in the relocation table:
			</P
><P
></P
><UL
><LI
><P
>"+" and "-" denote 64-bit modulus addition and subtraction,
  respectively.  "&gt;&gt;" denotes arithmetic right-shifting (shifting with
  sign copying) of the value of the left operand by the number of bits
  given by the right operand.</P
></LI
><LI
><P
>For relocation types in which the names contain "32", the upper 32
  bits of the value computed must be the same.  For relocation types
  in which the names contain "14" or "16," the upper 49 bits of the
  value computed before shifting must all be the same.  For relocation
  types whose names contain "24," the upper 39 bits of the value
  computed before shifting must all be the same.  For relocation types
  whose names contain "14" or "24," the low 2 bits of the value
  computed before shifting must all be zero.</P
></LI
><LI
><P
>#lo(value) denotes the least significant 16 bits of the indicated
  value:
						</P
><PRE
CLASS="PROGRAMLISTING"
>    #lo(x) = (x &amp; 0xffff).
						</PRE
></LI
><LI
><P
>#hi(value) denotes bits 16 through 31 of the indicated value:</P
><PRE
CLASS="PROGRAMLISTING"
>    #hi(x) = ((x &gt;&gt; 16) &amp; 0xffff).
						</PRE
></LI
><LI
><P
>#ha(value) denotes the high adjusted value: bits 16 through 31 of
  the indicated value, compensating for #lo() being treated as a
  signed number.</P
><PRE
CLASS="PROGRAMLISTING"
>				
    #ha(x) = (((x &gt;&gt; 16) + ((x &amp; 0x8000) ? 1 : 0)) &amp; 0xffff)
					</PRE
></LI
><LI
><P
>#higher(value) denotes bits 32 through 47 of the indicated value.</P
><PRE
CLASS="PROGRAMLISTING"
>    #higher(x) = ((x &gt;&gt; 32) &amp; 0xffff)
						</PRE
></LI
><LI
><P
>#highera(value) denotes bits 32 through 47 of the indicated value,
  compensating for #lo() being treated as a signed number:</P
><PRE
CLASS="PROGRAMLISTING"
>    #highera(x) =
      (((x &gt;&gt; 32) + (((x &amp; 0xffff8000) == 0xffff8000) ? 1 : 0)) &amp; 0xffff)
						</PRE
></LI
><LI
><P
>#highest(value) denotes bits 48 through 63 of the indicated value:</P
><PRE
CLASS="PROGRAMLISTING"
>    #highest(x) = ((x &gt;&gt; 48) &amp; 0xffff)
						</PRE
></LI
><LI
><P
>#highesta(value) denotes bits 48 through 63 of the indicated value,
  compensating for #lo being treated as a signed number:</P
><PRE
CLASS="PROGRAMLISTING"
>    #highesta(value) =
      (((x &gt;&gt; 48) + (((x &amp; 0xffffffff8000) == 0xffffffff8000) ? 1 : 0)) &amp; 0xffff)
						</PRE
></LI
><LI
><P
>Reference in a calculation to the value G implicitly creates a GOT
  entry for the indicated symbol.</P
></LI
><LI
><P
>.TOC. refers to the TOC base of the TOC section for the object being
  relocated.  See <A
HREF="#TOC"
>Section 4.3</A
> for additional information.  The dynamic linker does not
  have this information, and hence relocation types that refer to
  .TOC. may only appear in relocatable object files, not in
  executables or shared objects.</P
></LI
></UL
><DIV
CLASS="FIGURE"
><A
NAME="AEN832"
></A
><P
><B
>Figure 4-1. Relocation Table</B
></P
><PRE
CLASS="SCREEN"
>Name                      Value    Field         Calculation

R_PPC64_NONE              0        none          none
R_PPC64_ADDR32            1        word32*       S + A
R_PPC64_ADDR24            2        low24*        (S + A) &gt;&gt; 2
R_PPC64_ADDR16            3        half16*       S + A
R_PPC64_ADDR16_LO         4        half16        #lo(S + A)
R_PPC64_ADDR16_HI         5        half16        #hi(S + A)
R_PPC64_ADDR16_HA         6        half16        #ha(S + A)
R_PPC64_ADDR14            7        low14*        (S + A) &gt;&gt; 2
R_PPC64_ADDR14_BRTAKEN    8        low14*        (S + A) &gt;&gt; 2
R_PPC64_ADDR14_BRNTAKEN   9        low14*        (S + A) &gt;&gt; 2
R_PPC64_REL24             10       low24*        (S + A - P) &gt;&gt; 2
R_PPC64_REL14             11       low14*        (S + A - P) &gt;&gt; 2
R_PPC64_REL14_BRTAKEN     12       low14*        (S + A - P) &gt;&gt; 2
R_PPC64_REL14_BRNTAKEN    13       low14*        (S + A - P) &gt;&gt; 2
R_PPC64_GOT16             14     	 half16*       G
R_PPC64_GOT16_LO          15     	 half16        #lo(G)
R_PPC64_GOT16_HI          16     	 half16        #hi(G)
R_PPC64_GOT16_HA          17     	 half16        #ha(G)
R_PPC64_COPY              19       none          none
R_PPC64_GLOB_DAT          20       doubleword64  S + A
R_PPC64_JMP_SLOT          21       none          see below
R_PPC64_RELATIVE          22       doubleword64  B + A
R_PPC64_UADDR32           24       word32*       S + A
R_PPC64_UADDR16           25       half16*       S + A
R_PPC64_REL32             26       word32*       S + A - P
R_PPC64_PLT32             27     	 word32*       L
R_PPC64_PLTREL32          28     	 word32*       L - P
R_PPC64_PLT16_LO          29     	 half16        #lo(L)
R_PPC64_PLT16_HI          30     	 half16        #hi(L)
R_PPC64_PLT16_HA          31     	 half16        #ha(L)
R_PPC64_SECTOFF           33       half16*       R + A
R_PPC64_SECTOFF_LO        34       half16        #lo(R + A)
R_PPC64_SECTOFF_HI        35       half16        #hi(R + A)
R_PPC64_SECTOFF_HA        36       half16        #ha(R + A)
R_PPC64_ADDR30            37       word30        (S + A - P) &gt;&gt; 2
R_PPC64_ADDR64            38       doubleword64  S + A
R_PPC64_ADDR16_HIGHER     39       half16        #higher(S + A)
R_PPC64_ADDR16_HIGHERA    40       half16        #highera(S + A)
R_PPC64_ADDR16_HIGHEST    41       half16        #highest(S + A)
R_PPC64_ADDR16_HIGHESTA   42       half16        #highesta(S + A)
R_PPC64_UADDR64           43       doubleword64  S + A
R_PPC64_REL64             44       doubleword64  S + A - P
R_PPC64_PLT64             45     	 doubleword64  L
R_PPC64_PLTREL64          46     	 doubleword64  L - P
R_PPC64_TOC16             47       half16*       S + A - .TOC.
R_PPC64_TOC16_LO          48       half16        #lo(S + A - .TOC.)
R_PPC64_TOC16_HI          49       half16        #hi(S + A - .TOC.)
R_PPC64_TOC16_HA          50       half16        #ha(S + A - .TOC.)
R_PPC64_TOC               51       doubleword64  .TOC.
R_PPC64_PLTGOT16          52     	 half16*       M
R_PPC64_PLTGOT16_LO       53     	 half16        #lo(M)
R_PPC64_PLTGOT16_HI       54     	 half16        #hi(M)
R_PPC64_PLTGOT16_HA       55     	 half16        #ha(M)
R_PPC64_ADDR16_DS         56       half16ds*     (S + A) &gt;&gt; 2
R_PPC64_ADDR16_LO_DS      57       half16ds      #lo(S + A) &gt;&gt; 2
R_PPC64_GOT16_DS          58     	 half16ds*     G &gt;&gt; 2
R_PPC64_GOT16_LO_DS       59     	 half16ds      #lo(G) &gt;&gt; 2
R_PPC64_PLT16_LO_DS       60     	 half16ds      #lo(L) &gt;&gt; 2
R_PPC64_SECTOFF_DS        61       half16ds*     (R + A) &gt;&gt; 2
R_PPC64_SECTOFF_LO_DS     62       half16ds      #lo(R + A) &gt;&gt; 2
R_PPC64_TOC16_DS          63       half16ds*     (S + A - .TOC.) &gt;&gt; 2
R_PPC64_TOC16_LO_DS       64       half16ds      #lo(S + A - .TOC.) &gt;&gt; 2
R_PPC64_PLTGOT16_DS       65     	 half16ds*     M &gt;&gt; 2
R_PPC64_PLTGOT16_LO_DS    66     	 half16ds      #lo(M) &gt;&gt; 2
R_PPC64_TLS               67     	 none          none
R_PPC64_DTPMOD64          68     	 doubleword64  @dtpmod
R_PPC64_TPREL16           69     	 half16*       @tprel
R_PPC64_TPREL16_LO        60     	 half16        #lo(@tprel)
R_PPC64_TPREL16_HI        71     	 half16        #hi(@tprel)
R_PPC64_TPREL16_HA        72     	 half16        #ha(@tprel)
R_PPC64_TPREL64           73     	 doubleword64  @tprel
R_PPC64_DTPREL16          74     	 half16*       @dtprel
R_PPC64_DTPREL16_LO       75     	 half16        #lo(@dtprel)
R_PPC64_DTPREL16_HI       76     	 half16        #hi(@dtprel)
R_PPC64_DTPREL16_HA       77     	 half16        #ha(@dtprel)
R_PPC64_DTPREL64          78     	 doubleword64  @dtprel
R_PPC64_GOT_TLSGD16       79     	 half16*       @got@tlsgd
R_PPC64_GOT_TLSGD16_LO    80     	 half16        #lo(@got@tlsgd)
R_PPC64_GOT_TLSGD16_HI    81     	 half16        #hi(@got@tlsgd)
R_PPC64_GOT_TLSGD16_HA    82     	 half16        #ha(@got@tlsgd)
R_PPC64_GOT_TLSLD16       83     	 half16*       @got@tlsld
R_PPC64_GOT_TLSLD16_LO    84     	 half16        #lo(@got@tlsld)
R_PPC64_GOT_TLSLD16_HI    85     	 half16        #hi(@got@tlsld)
R_PPC64_GOT_TLSLD16_HA    86     	 half16        #ha(@got@tlsld)
R_PPC64_GOT_TPREL16_DS    87     	 half16ds*     @got@tprel
R_PPC64_GOT_TPREL16_LO_DS 88     	 half16ds      #lo(@got@tprel)
R_PPC64_GOT_TPREL16_HI    89     	 half16        #hi(@got@tprel)
R_PPC64_GOT_TPREL16_HA    90     	 half16        #ha(@got@tprel)
R_PPC64_GOT_DTPREL16_DS   91     	 half16ds*     @got@dtprel
R_PPC64_GOT_DTPREL16_LO_DS92     	 half16ds      #lo(@got@dtprel)
R_PPC64_GOT_DTPREL16_HI   93     	 half16        #hi(@got@dtprel)
R_PPC64_GOT_DTPREL16_HA   94     	 half16        #ha(@got@dtprel)
R_PPC64_TPREL16_DS        95     	 half16ds*     @tprel
R_PPC64_TPREL16_LO_DS     96     	 half16ds      #lo(@tprel)
R_PPC64_TPREL16_HIGHER    97     	 half16        #higher(@tprel)
R_PPC64_TPREL16_HIGHERA   98     	 half16        #highera(@tprel)
R_PPC64_TPREL16_HIGHEST   99     	 half16        #highest(@tprel)
R_PPC64_TPREL16_HIGHESTA  100      half16        #highesta(@tprel)
R_PPC64_DTPREL16_DS       101      half16ds*     @dtprel
R_PPC64_DTPREL16_LO_DS    102      half16ds      #lo(@dtprel)
R_PPC64_DTPREL16_HIGHER   103      half16        #higher(@dtprel)
R_PPC64_DTPREL16_HIGHERA  104      half16        #highera(@dtprel)
R_PPC64_DTPREL16_HIGHEST  105      half16        #highest(@dtprel)
R_PPC64_DTPREL16_HIGHESTA 106      half16        #highesta(@dtprel)</PRE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Relocation values 18, 23 and 32 are not used.  This is to
maintain a correspondence to the relocation values used by the <I
CLASS="CITETITLE"
>32-bit
PowerPC ELF ABI</I
>.
			</P
></TD
></TR
></TABLE
></DIV
><P
>The relocation types whose Field column entry contains an asterisk (*)
are subject to failure if the value computed does not fit in the
allocated bits.
		</P
><P
>The relocation types in which the names include _BRTAKEN or _BRNTAKEN
specify whether the branch prediction bit (bit 10) should indicate
that the branch will be taken or not taken, respectively.  For an
unconditional branch, the branch prediction bit must be 0.
		</P
><P
>Relocations 56-66 are to be used for instructions with a DS offset
field (ld, ldu, lwa, std, stdu).  ABI conformant tools should give an
error for attempts to relocate an address to a value that is not
divisible by 4.
		</P
><P
>Relocation types with special semantics are described below.
		</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>R_PPC64_GOT16*</DT
><DD
><P
>These relocation types resemble the corresponding
                R_PPC64_ADDR16* types, except that they refer to the
                address of the symbol's global offset table entry and
                additionally instruct the link editor to build a
                global offset table.</P
></DD
><DT
>R_PPC64_PLTGOT16*</DT
><DD
><P
>These relocation types resemble the corresponding
                R_PPC64_GOT16* types, except that the address stored
                in the global offset table entry may be the address of
                an entry in the procedure linkage table.  If the link
                editor can determine the actual value of the symbol,
                it may store that in the corresponding GOT entry.
                Otherwise, it may create an entry in the procedure
                linkage table, and store that address in the GOT
                entry; this permits lazy resolution of function
                symbols at run time.  Otherwise, the link editor may
                generate a R_PPC64_GLOB_DAT relocation as usual.</P
></DD
><DT
>R_PPC64_COPY</DT
><DD
><P
>The link editor creates this relocation type for
                dynamic linking.  Its offset member refers to a
                location in a writable segment.  The symbol table
                index specifies a symbol that should exist both in the
                current object file and in a shared object.  During
                execution, the dynamic linker copies data associated
                with the shared object's symbol to the location
                specified by the offset.</P
></DD
><DT
>R_PPC64_GLOB_DAT</DT
><DD
><P
>This relocation type resembles R_PPC64_ADDR64, except
                that it sets a global offset table entry to the
                address of the specified symbol.  This special
                relocation type allows one to determine the
                correspondence between symbols and global offset table
                entries.</P
></DD
><DT
>R_PPC64_JMP_SLOT</DT
><DD
><P
>The link editor creates this relocation type for
                dynamic linking.  Its offset member gives the location
                of a procedure linkage table entry.  The dynamic
                linker modifies the procedure linkage table entry to
                transfer control to the designated symbol's address
                (see <A
HREF="#PROC-LINK"
>Section 5.2.4</A
>).</P
></DD
><DT
>R_PPC64_RELATIVE</DT
><DD
><P
>The link editor creates this relocation type for
                dynamic linking.  Its offset member gives a location
                within a shared object that contains a value
                representing a relative address.  The dynamic linker
                computes the corresponding virtual address by adding
                the virtual address at which the shared object was
                loaded to the relative address.  Relocation entries
                for this type must specify 0 for the symbol table
                index.</P
></DD
><DT
>R_PPC64_UADDR*</DT
><DD
><P
>These relocation types are the same as the
                corresponding R_PPC64_ADDR* types, except that the
                datum to be relocated is allowed to be unaligned.</P
></DD
></DL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PROG-LOAD-DL"
></A
>Chapter 5. Program Loading and Dynamic Linking</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="PROG-DL"
>5.1. Program Loading</A
></H2
><P
>As the system creates or augments a process image, it logically copies
a file's segment to a virtual memory segment.  When--and if--the
system physically reads the file depends on the program's execution
behavior, system load, and so on.  A process does not require a
physical page unless it references the logical page during execution,
and processes commonly leave many pages unreferenced.  Therefore,
delaying physical reads frequently obviates them, improving system
performance.  To obtain this efficiency in practice, executable and
shared object files must have segment images whose offsets and virtual
addresses are congruent, modulo the page size.
		</P
><P
>Virtual addresses and file offsets for the 64-bit PowerPC processor
family segments are congruent modulo 64 Kbytes (0x10000) or larger
powers of 2.  Although 4096 bytes is currently the 64-bit PowerPC page
size, this allows files to be suitable for paging even if
implementations appear with larger page sizes.  The value of the
p_align member of each program header in a shared object file must be
0x10000.
		</P
><P
>It is normally desirable to put segments with different
characteristics in separate 256 Mbyte portions of the address space,
to give the operating system full paging flexibility in the 64-bit
address space.
		</P
><P
>Here is an example of an executable file assuming an executable
program linked with a base address of 0x10000000.
		</P
><PRE
CLASS="SCREEN"
>File Offset                             Virtual Address

0
            ELF header
            Program header table
            Other information
0x100                                   0x10000100
            Text segment
            . . .
            0x2be00 bytes
                                        0x1002beff
0x2bf00                                 0x2003bf00
            Data segment
            . . .
            0x4e00 bytes
                                        0x20040cff
0x30d00
            Other information</PRE
><P
>Here are possible corresponding program header segments:
		</P
><PRE
CLASS="SCREEN"
>Member      Text            Data

p_type      PT_LOAD         PT_LOAD
p_offset    0x100           0x2bf00
p_vaddr     0x10000100      0x2003bf00
p_paddr     unspecified     unspecified
p_filesz    0x2be00         0x4e00
p_memsz     0x2be00         0x5e24
p_flags     PF_R+PF_X       PF_R+PF_W
p_align     0x10000         0x10000</PRE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/stylesheet/dsssl/modular/images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The example addresses for the text and data segments are chosen
for compatibility with AIX, and it is suggested, though not required,
that tools supporting this ABI use similar addresses.
			</P
></TD
></TR
></TABLE
></DIV
><P
>Although the file offsets and virtual addresses are congruent modulo
64 Kbytes for both text and data, up to four file pages can hold
impure text or data (depending on page size and file system block
size).
		</P
><P
></P
><UL
><LI
><P
>The first text page contains the ELF header, the program header
  table, and other information.</P
></LI
><LI
><P
>The last text page may hold a copy of the beginning of data.</P
></LI
><LI
><P
>The first data page may have a copy of the end of text.</P
></LI
><LI
><P
>The last data page may contain file information not relevant to the
  running process.</P
></LI
></UL
><P
>Logically, the system enforces memory permissions as if each segment
were complete and separate; segment addresses are adjusted to ensure
that each logical page in the address space has a single set of
permissions.  In the example above, the file region holding the end of
text and the beginning of data is mapped twice; at one virtual address
for text and at a different virtual address for data.
		</P
><P
>The end of the data segment requires special handling for
uninitialized data, which the system defines to begin with zero
values.  Thus if the last data page of a file includes information not
in the logical memory page, the extraneous data must be set to zero,
rather than to the unknown contents of the executable file.
"Impurities" in the other three pages are not logically part of the
process image; whether the system expunges them is unspecified.  The
memory image for the program above is shown here, assuming 4096
(0x1000) byte pages.
		</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN899"
></A
><P
><B
>Figure 5-1. Virtual Address</B
></P
><PRE
CLASS="SCREEN"
>Text segment:
0x02000000
            Header padding
            0x100 bytes
0x02000100
            Text segment
            ...
            0x2be00 bytes
0x0202bf00
            Data padding
            0x100 bytes

Data segment:
0x0203b000
            Text padding
            0xf00 bytes
0x0203bf00
            Data segment
            ...
            0x4e00 bytes
0x02040d00
            Uninitialized data
            0x1024 bytes
0x02041d24
            Page padding
            0x2dc zero bytes</PRE
></DIV
><P
>One aspect of segment loading differs between executable files and
shared objects.  Executable file segments may contain absolute code.
For the process to execute correctly, the segments must reside at the
virtual addresses assigned when building the executable file, with the
system using the p_vaddr values unchanged as virtual addresses.
		</P
><P
>On the other hand, shared object segments typically contain
position-independent code.  This allows a segment's virtual address to
change from one process to another, without invalidating execution
behavior.
		</P
><P
>Though the system chooses virtual addresses for individual processes,
most systems will maintain the "relative positions" of the segments.
Any use of relative addressing between segments should be indicated by
an appropriate dynamic relocation.  If the dynamic linker does not
maintain the relative position of segments at load time, it must be
careful in its handling of R_PPC64_RELATIVE relocations, examining the
relative address in order to determine the appropriate base address to
use.
		</P
><P
>The following table shows possible shared object virtual address
assignments for several processes, illustrating constant relative
positioning.  The table also illustrates the base address
computations.
		</P
><PRE
CLASS="SCREEN"
>Source       Text        Data       Base Address
File         0x000200    0x02a400
Process 1    0x100200    0x12a400    0x100000
Process 2    0x200200    0x22a400    0x200000
Process 3    0x300200    0x32a400    0x300000
Process 4    0x400200    0x42a400    0x400000</PRE
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROG-INT"
>5.1.1. Program Interpreter</A
></H3
><P
>The standard program interpreter is /usr/lib/ld.so.1.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DYNAM-LINK"
>5.2. Dynamic Linking</A
></H2
><P
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DYNAM-SECT"
>5.2.1. Dynamic Section</A
></H3
><P
>Dynamic section entries give information to the dynamic linker.  Some
of this information is processor-specific, including the
interpretation of some entries in the dynamic structure.
			</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>DT_PLTGOT</DT
><DD
><P
>This entry's d_ptr member gives the address of the first
              byte in the procedure linkage table.</P
></DD
><DT
>DT_JMPREL</DT
><DD
><P
>As explained in the System V ABI, this entry is
              associated with a table of relocation entries for the
              procedure linkage table.  For the 64-bit PowerPC, this
              entry is mandatory both for executable and shared object
              files.  Moreover, the relocation table's entries must
              have a one-to-one correspondence with the procedure
              linkage table.  The table of DT_JMPREL relocation
              entries is wholly contained within the DT_RELA
              referenced table.  See <A
HREF="#PROC-LINK"
>Section 5.2.4</A
> later in
              this chapter for more information.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="GLOBAL"
>5.2.2. Global Offset Table</A
></H3
><P
>Position-independent code cannot, in general, contain absolute virtual
addresses.  The global offset table, which is part of the TOC section,
holds absolute addresses in private data, thus making the addresses
available without compromising the position-independence and
sharability of a program's text.  A program references its TOC using
position-independent addressing and extracts absolute values, thus
redirecting position-independent references to absolute locations.
			</P
><P
>When the dynamic linker creates memory segments for a loadable object
file, it processes the relocation entries, some of which will be of
type R_PPC64_GLOB_DAT, referring to the global offset table within the
TOC.  The dynamic linker determines the associated symbol values,
calculates their absolute addresses, and sets the global offset table
entries to the proper values.  Although the absolute addresses are
unknown when the link editor builds an object file, the dynamic linker
knows the addresses of all memory segments and can thus calculate the
absolute addresses of the symbols contained therein.
			</P
><P
>A global offset table entry provides direct access to the absolute
address of a symbol without compromising position-independence and
sharability.  Because the executable file and shared objects have
separate global offset tables, a symbol may appear in several tables.
The dynamic linker processes all the global offset table relocations
before giving control to any code in the process image, thus ensuring
the absolute addresses are available during execution.
			</P
><P
>The global offset table is part of the TOC section.  Since different
functions in a single executable or shared object may have different
TOC sections, the global offset table may also be replicated, in whole
or in part.  Each instance of the global offset table will have its
own set of relocations.  The dynamic linker need not know about the
replication; it simply processes all the relocations it is given.
			</P
><P
>The dynamic linker may choose different memory segment addresses for
the same shared object in different programs; it may even choose
different library addresses for different executions of the same
program.  Nonetheless, memory segments do not change addresses once
the process image is established.  As long as a process exists, its
memory segments reside at fixed virtual addresses.
			</P
><P
>The global offset table normally resides in the ELF .got section in an
executable or shared object.
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FUNC-ADDRESS"
>5.2.3. Function Addresses</A
></H3
><P
>References to the address of a function from an executable file and
the shared objects associated with it need to resolve to the same
value.
			</P
><P
>In this ABI, the address of a function is actually the address of a
function descriptor.  A reference to a function, other than a function
call, will normally load the address of the function descriptor from
the global offset table.  The dynamic linker will ensure that for a
given function, the same address is used for all references to the
function from any global offset table.  Thus, function address
comparisons will work as expected.
			</P
><P
>When making a call to the function, the code may refer to the
procedure linkage table entry, in order to permit lazy symbol
resolution at run time.  In order to support correct function address
comparisons, the compiler should be careful to only generate
references to the procedure linkage table entry for function calls.
For any other use of a function, the compiler should use the real
address.
			</P
><P
>When using the ELF assembler syntax, this means that the compiler
should use the @got syntax, rather than the @got@plt syntax, if the
function address is going to be used without being called.	
			</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROC-LINK"
>5.2.4. Procedure Linkage Table</A
></H3
><P
>The procedure linkage table may be used to redirect function calls
between the executable and a shared object or between different shared
objects.  Because all function calls on the 64-bit PowerPC are done via
function descriptors, the procedure linkage table is simply a special
case of a function descriptor which is filled in by the dynamic linker
rather than the link editor.
			</P
><P
>The procedure linkage table is purely an optimization designed to
permit lazy symbol resolution at run time.  The link editor may
generate R_PPC64_GLOB_DAT relocations for all function descriptors
defined in other shared objects, and avoid generating a procedure
linkage table at all.
			</P
><P
>The procedure linkage table is normally found in the .plt section in
an executable or shared object.  Its contents are not initialized in
the executable or shared object file.  Instead, the link editor simply
reserves space for it, and the dynamic linker initializes it and
manages it according to its own, possibly implementation-dependent
needs, subject to the following constraint:
			</P
><P
></P
><UL
><LI
><P
>If the executable or shared object requires N procedure linkage table
  entries, the link editor shall reserve 3*(N+1) doublewords (24*(N+1)
  bytes).  These doublewords will be used to hold function descriptors.
  When calling function i, the link editor arranges to use the function
  descriptor at byte 24 * i.  The first procedure linkage table entry
  is reserved for use by the dynamic linker.</P
></LI
></UL
><P
>As mentioned before, a relocation table is associated with the
procedure linkage table.  The DT_JMPREL entry in the dynamic section
gives the location of the first relocation entry.  The relocation
table's entries parallel the procedure linkage table entries in a
one-to-one correspondence.  That is, relocation table entry 1 applies
to procedure linkage table entry 1, and so on.  The relocation type
for each entry shall be R_PPC64_JMP_SLOT, the relocation offset shall
specify the address of the first byte of the associated procedure
linkage table entry, and the symbol table index shall reference the
appropriate symbol.
			</P
><P
>The dynamic linker will locate the symbol referenced by the
R_PPC64_JMP_SLOT relocation.  The value of the symbol will be the
address of the function descriptor.  The dynamic linker will copy
these 24 bytes into the procedure linkage table entry.
			</P
><P
>The dynamic linker can resolve the procedure linkage table relocations
lazily, resolving them only when they are needed.  This can speed up
program startup time.
			</P
><P
>The following code shows how the dynamic linker might initialize the
procedure linkage table in order to provide lazy resolution:
			</P
><PRE
CLASS="PROGRAMLISTING"
>.GLINK:
.GLINK0:
    ld      r2, 40(r1)
    addis   r12,r2,.PLT0@toc@ha
    addi    r12,r12,.PLT0@toc@l
    ld      r11,0(r12)
    ld      r2, 8(r12)
    mtctr   r11
    ld      r11,16(r12)
    bctr
.GLINK1:
    li      r0,0
    b       .GLINK0
.GLINKi:			# i &lt;= 32768
    li      r0,i - 1
    b       .GLINK0
.GLINKN:			# N &gt; 32768
    lis     r0,(N - 1) &gt;&gt; 16
    ori     r0,r0,(N - 1) &amp; 0xffff
    b       .GLINK0

...

.PLT:
.PLT0:
    .quad   ld_so_fixup_func
    .quad   ld_so_toc
    .quad   ld_so_ident
.PLT1:
    .quad   .GLINK1
    .quad   0
    .quad   0
    ...
.PLTi:
    .quad   .GLINKi
    .quad   0
    .quad   0
    ...
.PLTN:
    .quad   .GLINKN
    .quad   0
    .quad   0</PRE
><P
>Following the steps below, the dynamic linker and the program
cooperate to resolve symbolic references through the procedure linkage
table.  Again, the steps described below are for explanation only.
The precise execution-time behavior of the dynamic linker is not
specified.
		</P
><P
></P
><OL
TYPE="1"
><LI
><P
>As shown above, each procedure linkage table entry I, as initialized by
the link editor, transfers control to the corresponding glink entry I at
.GLINKI.  The instructions at .GLINKI loads a relocation index into r0 and
branches to the common .GLINK0 code, the first entry in the GLINK table.
For example, assume the program calls NAME, which uses the function
descriptor at the label .PLTi.  The function descriptor causes the program
to branch to .GLINKi which loads i - 1 into r0 and branches to .GLINK0.</P
></LI
><LI
><P
>.GLINK0 loads three values from the PLT Reserve area allocated by the
link editor and initialized by the dynamic linker.  The first doubleword
is the dynamic linker's lazy binding entry point.  The second doubleword
is the dynamic linker's own TOC anchor value.  The third doubleword is an
8-byte identifier unique to the calling module which must be placed into
r11 (normally the static chain), so that the dynamic linker can identify
the object from which the call originated, and thereby located that
object's relocation table.  .GLINK0 then calls into the dynamic linker
with the PLT index copied into r0 and the identifying information copied
into r11.</P
></LI
><LI
><P
>The dynamic linker finds relocation entry i corresponding to the
index in r0.  It will have type R_PPC_JMP_SLOT, its offset will
specify the address of .PLTi, and its symbol table index will
reference NAME.</P
></LI
><LI
><P
>Knowing this, the dynamic linker finds the symbol's "real" value.
It then copies the function descriptor into the code at .PLTi.</P
></LI
><LI
><P
>Subsequent executions of the procedure linkage table entry will
transfer control directly to the function via the function descriptor
at .PLTi, without invoking the dynamic linker.</P
></LI
></OL
><P
>The LD_BIND_NOW environment variable can change dynamic linking
behavior.  If its value is non-null, the dynamic linker resolves the
function call binding at load time, before transferring control to the
program.  That is, the dynamic linker processes relocation entries of
type R_PPC_JMP_SLOT during process initialization.  Otherwise, the
dynamic linker evaluates procedure linkage table entries lazily,
delaying symbol resolution and relocation until the first execution of
a table entry.
			</P
><P
>Lazy binding generally improves overall application performance
because unused symbols do not incur the dynamic linking overhead.
Nevertheless, two situations make lazy binding undesirable for some
applications:
			</P
><P
></P
><UL
><LI
><P
>The initial reference to a shared object function takes longer than
subsequent calls because the dynamic linker intercepts the call to
resolve the symbol, and some applications cannot tolerate this
unpredictability.</P
></LI
><LI
><P
>If an error occurs and the dynamic linker cannot resolve the
symbol, the dynamic linker will terminate the program.  Under lazy
binding, this might occur at arbitrary times.  Once again, some
applications cannot tolerate this unpredictability.  By turning off
lazy binding, the dynamic linker forces the failure to occur during
process initialization, before the application receives control.</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LIB"
></A
>Chapter 6. Libraries</H1
><P
>This document does not specify any library interfaces.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="GFDL"
></A
>Appendix A. GNU Free Documentation License</H1
><P
>Version 1.1, March 2000</P
><A
NAME="AEN978"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-0"
>A.1. PREAMBLE</A
></H2
><P
>The purpose of this License is to make a manual, textbook,
    or other written document "free" in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others.</P
><P
>This License is a kind of "copyleft", which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software.</P
><P
>We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-1"
>A.2. APPLICABILITY AND DEFINITIONS</A
></H2
><P
>This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The "Document",
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as "you".</P
><P
>A "Modified Version" of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language.</P
><P
>A "Secondary Section" is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them.</P
><P
>The "Invariant Sections" are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License.</P
><P
>The "Cover Texts" are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License.</P
><P
>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    "Title Page" means the text near the most prominent appearance of
    the work's title, preceding the beginning of the body of the
    text.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-2"
>A.3. VERBATIM COPYING</A
></H2
><P
>You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated
    above, and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-3"
>A.4. COPYING IN QUANTITY</A
></H2
><P
>If you publish printed copies of the Document numbering more
    than 100, and the Document's license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects.</P
><P
>If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-4"
>A.5. MODIFICATIONS</A
></H2
><P
>You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission.</P
></LI
><LI
><P
>List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five).</P
></LI
><LI
><P
>State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher.</P
></LI
><LI
><P
>Preserve all the
      copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices.</P
></LI
><LI
><P
>Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below.</P
></LI
><LI
><P
>Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document's license notice.</P
></LI
><LI
><P
>Include an unaltered
      copy of this License.</P
></LI
><LI
><P
>Preserve the section
      entitled "History", and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled "History" in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the "History" section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.</P
></LI
><LI
><P
>In any section entitled
      "Acknowledgements" or "Dedications", preserve the section's
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein.</P
></LI
><LI
><P
>Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.</P
></LI
><LI
><P
>Delete any section
      entitled "Endorsements".  Such a section may not be included in
      the Modified Version.</P
></LI
><LI
><P
>Do not retitle any
      existing section as "Endorsements" or to conflict in title with
      any Invariant Section.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version's license notice.  These titles must be distinct from any
    other section titles.</P
><P
>You may add a section entitled "Endorsements", provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-5"
>A.6. COMBINING DOCUMENTS</A
></H2
><P
>You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice.</P
><P
>The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work.</P
><P
>In the combination, you must combine any sections entitled
    "History" in the various original documents, forming one section
    entitled "History"; likewise combine any sections entitled
    "Acknowledgements", and any sections entitled "Dedications".  You
    must delete all sections entitled "Endorsements."</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-6"
>A.7. COLLECTIONS OF DOCUMENTS</A
></H2
><P
>You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects.</P
><P
>You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-7"
>A.8. AGGREGATION WITH INDEPENDENT WORKS</A
></H2
><P
>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an "aggregate", and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document's Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-8"
>A.9. TRANSLATION</A
></H2
><P
>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-9"
>A.10. TERMINATION</A
></H2
><P
>You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-10"
>A.11. FUTURE REVISIONS OF THIS LICENSE</A
></H2
><P
>The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See <A
HREF="http://www.gnu.org/copyleft/"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.</P
><P
>Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License "or any later version" applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL-11"
>A.12. How to use this License for your documents</A
></H2
><P
>To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page:</P
><A
NAME="AEN1068"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have no Invariant Sections, write "with no Invariant
    Sections" instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write "no Front-Cover Texts" instead of
    "Front-Cover Texts being LIST"; likewise for Back-Cover
    Texts.</P
><P
>If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>