<PART ID="tocobjformat">
<TITLE>Object Format</TITLE>

<CHAPTER ID=objfmt>
<TITLE>Object Files</TITLE>
<PARA>
LSB-conforming implementations shall support the object file Executable and Linking Format (ELF), which is defined by the following documents:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
<XREF LINKEND="std.gABI41">
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
<XREF LINKEND="std.ABIupdate">
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
this document
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
an architecture-specific LSB specification
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
Conforming implementations may also support other unspecified object file formats.
</PARA>
</CHAPTER>

<CHAPTER ID=Sections>
<TITLE>Sections</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
As described in <XREF LINKEND="std.gABI41">,
an ELF object file contains a number of <emphasis>sections</emphasis>.
</PARA>
</SECT1>
<SECT1 ID="elftypes">
<TITLE>Sections Types</TITLE>
<PARA>
The section header table is an array of 
<STRUCTNAME>Elf32_Shdr</STRUCTNAME> or 
<STRUCTNAME>Elf64_Shdr</STRUCTNAME> structures as 
described in <XREF LINKEND=STD.gABI41>. The 
<STRUCTFIELD>sh_type</STRUCTFIELD> member shall be either a value from
<XREF LINKEND=tbl.ABIUpdate>, drawn from the System V 
ABI, or one of the additional values specified in <XREF LINKEND=tbl.LSB>.
</PARA>
<PARA>
A section header's <STRUCTFIELD>sh_type</STRUCTFIELD> member specifies the sections's semantics.
</PARA>
<SECT2>
<TITLE>ELF Section Types</TITLE>
<PARA>
The following section types are defined in the 
<XREF LINKEND="std.gABI41">
and the
<XREF LINKEND="std.ABIupdate">.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksecttypestable,v 1.9 2004/09/16 00:14:03 nick Exp 0 -->
<!--    at Sun May  1 18:33:01 2005 -->
<TABLE ID=tbl.ABIUpdate>
<TITLE>ELF Section Types</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Value</ENTRY><ENTRY ALIGN=center>Description</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>SHT_DYNAMIC</ENTRY><ENTRY>0x6</ENTRY><ENTRY>The section holds information for dynamic linking. Currently, an object file shall have only one dynamic section, but this restriction may be relaxed in the future. See `Dynamic Section' in Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_DYNSYM</ENTRY><ENTRY>0xb</ENTRY><ENTRY>This section holds a minimal set of symbols adequate for dynamic linking. See 
also SHT_SYMTAB. Currently, an object file may have either a section of 
SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This restriction 
may be relaxed in the future.</ENTRY></ROW>
<ROW><ENTRY>SHT_FINI_ARRAY</ENTRY><ENTRY>0xf</ENTRY><ENTRY>This section contains an array of pointers to termination functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_HASH</ENTRY><ENTRY>0x5</ENTRY><ENTRY>The section holds a symbol hash table. Currently, an object file shall have only one hash table, but this restriction may be relaxed in the future. See `Hash Table' in the Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_HIPROC</ENTRY><ENTRY>0x7fffffff</ENTRY><ENTRY>Values in this inclusive range are reserved for processor-specific semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_HIUSER</ENTRY><ENTRY>0xffffffff</ENTRY><ENTRY>This value specifies the upper bound of the range of indexes reserved for application programs. Section types between SHT_LOUSER and SHT_HIUSER can be used by the application, without conflicting with current or future system-defined section types.</ENTRY></ROW>
<ROW><ENTRY>SHT_INIT_ARRAY</ENTRY><ENTRY>0xe</ENTRY><ENTRY>This section contains an array of pointers to initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_LOPROC</ENTRY><ENTRY>0x70000000</ENTRY><ENTRY>Values in this inclusive range are reserved for processor-specific semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_LOUSER</ENTRY><ENTRY>0x80000000</ENTRY><ENTRY>This value specifies the lower bound of the range of indexes reserved for application programs.</ENTRY></ROW>
<ROW><ENTRY>SHT_NOBITS</ENTRY><ENTRY>0x8</ENTRY><ENTRY>A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</ENTRY></ROW>
<ROW><ENTRY>SHT_NOTE</ENTRY><ENTRY>0x7</ENTRY><ENTRY>The section holds information that marks the file in some way. See `Note Section' in Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_NULL</ENTRY><ENTRY>0x0</ENTRY><ENTRY>This value marks the section header as inactive; it does not have an associated section. Other members of the section header have undefined values.</ENTRY></ROW>
<ROW><ENTRY>SHT_PREINIT_ARRAY</ENTRY><ENTRY>0x10</ENTRY><ENTRY>This section contains an array of pointers to functions that are invoked before all other initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless proceure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0x1</ENTRY><ENTRY>The section holds information defined by the program, whose format and meaning are determined solely by the program.</ENTRY></ROW>
<ROW><ENTRY>SHT_REL</ENTRY><ENTRY>0x9</ENTRY><ENTRY>The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files or type Elf64_Rel for the 64-bit class of object files. An object file may have multiple relocation sections. See "Relocation"</ENTRY></ROW>
<ROW><ENTRY>SHT_RELA</ENTRY><ENTRY>0x4</ENTRY><ENTRY>The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files or type Elf64_Rela for the 64-bit class of object files. An object file may have multiple relocation sections. `Relocation' b</ENTRY></ROW>
<ROW><ENTRY>SHT_SHLIB</ENTRY><ENTRY>0xa</ENTRY><ENTRY>This section type is reserved but has unspecified semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_STRTAB</ENTRY><ENTRY>0x3</ENTRY><ENTRY>The section holds a string table. An object file may have multiple string table sections. See `String Table' below for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_SYMTAB</ENTRY><ENTRY>0x2</ENTRY><ENTRY>This section holds a symbol table. Currently, an object file may have either a 
section of SHT_SYMTAB type or a section of SHT_DYNSYM type, but not both. This 
restriction may be relaxed in the future. Typically, SHT_SYMTAB provides 
symbols for link editing, though it may also be used for dynamic linking. As a 
complete symbol table, it may contain many symbols unnecessary for dynamic 
linking.</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksecttypestable,v 1.9 2004/09/16 00:14:03 nick Exp 0 -->

</PARA>
</SECT2>
<SECT2>
<TITLE>Additional Section Types</TITLE>
<PARA>
The following additional section types are defined here.

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksecttypestable,v 1.9 2004/09/16 00:14:03 nick Exp 0 -->
<!--    at Sun May  1 18:33:01 2005 -->
<TABLE ID=tbl.LSB>
<TITLE>Additional Section Types</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Value</ENTRY><ENTRY ALIGN=center>Description</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>SHT_GNU_verdef</ENTRY><ENTRY>0x6ffffffd</ENTRY><ENTRY>This section contains the symbol versions that are provided.</ENTRY></ROW>
<ROW><ENTRY>SHT_GNU_verneed</ENTRY><ENTRY>0x6ffffffe</ENTRY><ENTRY>This section contains the symbol versions that are required.</ENTRY></ROW>
<ROW><ENTRY>SHT_GNU_versym</ENTRY><ENTRY>0x6fffffff</ENTRY><ENTRY>This section contains the Symbol Version Table.</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksecttypestable,v 1.9 2004/09/16 00:14:03 nick Exp 0 -->

</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID=SpecialSections>
<TITLE>Special Sections</TITLE>
<SECT1 ID="elfspecial">
<TITLE>Special Sections</TITLE>
<PARA>
Various sections hold program and control information. Sections in the lists below are used by the system and have the indicated types and attributes.
</PARA>
<SECT2>
<TITLE>ELF Special Sections</TITLE>
<PARA>
The following sections are defined in the
<XREF LINKEND="std.gABI41">
and the
<XREF LINKEND="std.ABIupdate">.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksectiontable,v 1.10 2002/06/20 20:35:42 anderson Exp 0 -->
<!--    at Sun May  1 18:33:01 2005 -->
<TABLE>
<TITLE>ELF Special Sections</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Type</ENTRY><ENTRY ALIGN=center>Attributes</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>.bss</ENTRY><ENTRY>SHT_NOBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.comment</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.data</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.data1</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.debug</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.dynamic</ENTRY><ENTRY>SHT_DYNAMIC</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.dynstr</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.dynsym</ENTRY><ENTRY>SHT_DYNSYM</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.fini</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
<ROW><ENTRY>.fini_array</ENTRY><ENTRY>SHT_FINI_ARRAY</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.hash</ENTRY><ENTRY>SHT_HASH</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.init</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
<ROW><ENTRY>.init_array</ENTRY><ENTRY>SHT_INIT_ARRAY</ENTRY><ENTRY> SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.interp</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.line</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.note</ENTRY><ENTRY>SHT_NOTE</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.preinit_array</ENTRY><ENTRY>SHT_PREINIT_ARRAY</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.rodata</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.rodata1</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.shstrtab</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.strtab</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.symtab</ENTRY><ENTRY>SHT_SYMTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.tbss</ENTRY><ENTRY>SHT_NOBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE+SHF_TLS</ENTRY></ROW>
<ROW><ENTRY>.tdata</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE+SHF_TLS</ENTRY></ROW>
<ROW><ENTRY>.text</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<VARIABLELIST>
<VARLISTENTRY><TERM>.bss</TERM><LISTITEM><PARA>This section holds data that contributes to the program's memory image. The 
program may treat this data as uninitialized. However, the system shall 
initialize this data with zeroes when the program begins to run.
The section occupies no file space, as indicated by the section type, SHT_NOBITS</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.comment</TERM><LISTITEM><PARA>This section holds version control information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.data</TERM><LISTITEM><PARA>This section holds initialized data that contribute to the program's memory image.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.data1</TERM><LISTITEM><PARA>This section holds initialized data that contribute to the program's memory image.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.debug</TERM><LISTITEM><PARA>This section holds information for symbolic debugging. The contents are unspecified. All section names with the prefix .debug hold information for symbolic debugging. The contents of these sections are unspecified.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynamic</TERM><LISTITEM><PARA>This section holds dynamic linking information. The section's attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit is set is processor specific. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynstr</TERM><LISTITEM><PARA>This section holds strings needed for dynamic linking, most commonly the strings that represent the names associated with symbol table entries. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynsym</TERM><LISTITEM><PARA>This section holds the dynamic linking symbol table, as described in `Symbol Table'. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.fini</TERM><LISTITEM><PARA>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.fini_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.hash</TERM><LISTITEM><PARA>This section holds a symbol hash table. See `Hash Table' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.init</TERM><LISTITEM><PARA>This section holds executable instructions that contribute to the process initialization code. When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs)</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.init_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single initialization array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.interp</TERM><LISTITEM><PARA>This section holds the path name of a program interpreter. If the file has a loadable segment that includes relocation, the sections' attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.line</TERM><LISTITEM><PARA>This section holds line number information for symbolic debugging, which describes the correspondence between the source program and the machine code. The contents are unspecified.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.note</TERM><LISTITEM><PARA>This section holds information in the format that `Note Section' in Chapter 5 describes of the System V Application Binary Interface, Edition 4.1.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.preinit_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single pre-initialization array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.rodata</TERM><LISTITEM><PARA>This section holds read-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.rodata1</TERM><LISTITEM><PARA>This section hold sread-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.shstrtab</TERM><LISTITEM><PARA>This section holds section names.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.strtab</TERM><LISTITEM><PARA>This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If the file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwi</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.symtab</TERM><LISTITEM><PARA>This section holds a symbol table, as `Symbol Table'. in this chapter describes. If the file has a loadable segment that includes the symbol table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.tbss</TERM><LISTITEM><PARA>This section holds uninitialized thread-local data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the data is instantiated for each new execution flow. The section occupies no file space, as indicated by the section type, SHT_NOBITS. Implementations need not support thread-local storage.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.tdata</TERM><LISTITEM><PARA>This section holds initialized thread-local data that contributes to the program's memory image. A copy of its contents is instantiated by the system for each new execution flow. Implementations need not support thread-local storage.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.text</TERM><LISTITEM><PARA>This section holds the `text,' or executable instructions, of a program.</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksectiontable,v 1.10 2002/06/20 20:35:42 anderson Exp 0 -->

</PARA>
</SECT2>
<SECT2>
<TITLE>Additional Special Sections</TITLE>
<PARA>
Object files in an LSB conforming application may also contain one or more of 
the additional special sections described below.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksectiontable,v 1.10 2002/06/20 20:35:42 anderson Exp 0 -->
<!--    at Sun May  1 18:33:01 2005 -->
<TABLE>
<TITLE>Additional Special Sections</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Type</ENTRY><ENTRY ALIGN=center>Attributes</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>.ctors</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.dtors</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.eh_frame</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.eh_frame_hdr</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.gnu.version</ENTRY><ENTRY>SHT_GNU_versym</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.gnu.version_d</ENTRY><ENTRY>SHT_GNU_verdef</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.gnu.version_r</ENTRY><ENTRY>SHT_GNU_verneed</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.jcr</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.note.ABI-tag</ENTRY><ENTRY>SHT_NOTE</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.stab</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.stabstr</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>0</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<VARIABLELIST>
<VARLISTENTRY><TERM>.ctors</TERM><LISTITEM><PARA>This section contains a list of global constructor function pointers.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dtors</TERM><LISTITEM><PARA>This section contains a list of global destructor function pointers.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.eh_frame</TERM><LISTITEM><PARA>This section contains information necessary for frame unwinding during exception handling.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.eh_frame_hdr</TERM><LISTITEM><PARA>This section contains a pointer to the .eh_frame section which is accessible to the runtime support code of a C++ application. This section may also contain a binary search table which may be used by the runtime support code to more efficiently access records in the .eh_frame section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version</TERM><LISTITEM><PARA>This section contains the Symbol Version Table.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version_d</TERM><LISTITEM><PARA>This section contains the Version Definitions.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version_r</TERM><LISTITEM><PARA>This section contains the Version Requirments.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.jcr</TERM><LISTITEM><PARA>This section contains information necessary for registering compiled
Java classes.  The contents are compiler-specific and used by compiler
initialization functions.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.note.ABI-tag</TERM><LISTITEM><PARA>Specify ABI details.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.stab</TERM><LISTITEM><PARA>This section contains debugging information. The contents are not specified as part of the LSB.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.stabstr</TERM><LISTITEM><PARA>This section contains strings associated with the debugging infomation contained in the .stab section.</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/lsbspec/mksectiontable,v 1.10 2002/06/20 20:35:42 anderson Exp 0 -->

</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID=Symmap>
<TITLE>Symbol Mapping</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. 
</PARA>
<SECT2>
<TITLE>C Language</TITLE>
<PARA>
External C symbols shall be unchanged in an object file's symbol table.
</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID="dwarfextchtp">
<TITLE>DWARF Extensions</TITLE>
<PARA>
The LSB does not specify debugging information, however, some additional
sections contain information which is encoded using the the encoding as
specified by <XREF LINKEND="std.DWARF2"> with extensions defined here.
<NOTE>
<PARA>
The extensions specified here also exist in <XREF LINKEND="std.DWARF3">.
It is expected that future versions of the LSB will reference the final
version of that document, and that the definitions here will be taken
from that document instead of being specified here.
</PARA>
</NOTE>

</PARA>

<SECT1 ID="dwarfehencoding">
<TITLE>DWARF Exception Header Encoding</TITLE>
<PARA>
The DWARF Exception Header Encoding is used to describe the type of data used
in the <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT>  and
<COMPUTEROUTPUT>.eh_frame_hdr</COMPUTEROUTPUT> section. The upper 4
bits indicate how the value is to be applied. The lower 4 bits indicate the
format of the data.
</PARA>
<TABLE>
<TITLE>DWARF Exception Header value format</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY>Name</ENTRY>
<ENTRY>Value</ENTRY>
<ENTRY>Meaning</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW>
<ENTRY>DW_EH_PE_absptr</ENTRY>
<ENTRY>0x00</ENTRY>
<ENTRY>The Value is a literal pointer whose size is determined by the architecture.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_uleb128</ENTRY>
<ENTRY>0x01</ENTRY>
<ENTRY>
Unsigned value is encoded using the Little Endian Base 128 (LEB128)
as defined by <XREF LINKEND="std.DWARF2">.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_udata2</ENTRY>
<ENTRY>0x02</ENTRY>
<ENTRY>A 2 bytes unsigned value.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_udata4</ENTRY>
<ENTRY>0x03</ENTRY>
<ENTRY>A 4 bytes unsigned value.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_udata8</ENTRY>
<ENTRY>0x04</ENTRY>
<ENTRY>An 8 bytes unsigned value.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_sleb128</ENTRY>
<ENTRY>0x09</ENTRY>
<ENTRY>
Signed value is encoded using the Little Endian Base 128 (LEB128)
as defined by <XREF LINKEND="std.DWARF2">.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_sdata2</ENTRY>
<ENTRY>0x0A</ENTRY>
<ENTRY>A 2 bytes signed value.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_sdata4</ENTRY>
<ENTRY>0x0B</ENTRY>
<ENTRY>A 4 bytes signed value.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_sdata8</ENTRY>
<ENTRY>0x0C</ENTRY>
<ENTRY>An 8 bytes signed value.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<TABLE>
<TITLE>DWARF Exception Header application</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY>Name</ENTRY>
<ENTRY>Value</ENTRY>
<ENTRY>Meaning</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW>
<ENTRY>DW_EH_PE_pcrel</ENTRY>
<ENTRY>0x10</ENTRY>
<ENTRY>Value is relative to the current program counter.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_textrel</ENTRY>
<ENTRY>0x20</ENTRY>
<ENTRY>Value is relative to the beginning of the .text section.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_datarel</ENTRY>
<ENTRY>0x30</ENTRY>
<ENTRY>Value is relative to the beginning of the .got or .eh_frame_hdr section.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_funcrel</ENTRY>
<ENTRY>0x40</ENTRY>
<ENTRY>Value is relative to the beginning of the function.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_EH_PE_aligned</ENTRY>
<ENTRY>0x50</ENTRY>
<ENTRY>Value is aligned to an address unit sized boundary.</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
One special encoding, 0xff (DW_EH_PE_omit), shall be used to indicate that no value ispresent.
</PARA>

</SECT1>



<SECT1 ID="dwarfcfiext">
<TITLE>DWARF CFI Extensions</TITLE>
<PARA>
In addition to the Call Frame Instructions defined in section 6.4.2 of <XREF LINKEND="std.DWARF2">,
the following additional Call Frame Instructions may also be used.
</PARA>

<TABLE>
<TITLE>Additional DWARF Call Frame Instructions</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY>Name</ENTRY>
<ENTRY>Value</ENTRY>
<ENTRY>Meaning</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW>
<ENTRY>DW_CFA_expression</ENTRY>
<ENTRY>0x10</ENTRY>
<ENTRY>The DW_CFA_expression instruction takes two operands: an unsigned LEB128 value representing a
register number, and a DW_FORM_block value representing a DWARF expression. The required action is to
establish the DWARF expression as the means by which the address in which the given register contents
are found may be computed. The value of the CFA is pushed on the DWARF evaluation stack prior to
execution of the DWARF expression. The DW_OP_call2, DW_OP_call4, DW_OP_call_ref and
DW_OP_push_object_address DWARF operators (see Section 2.4.1 of <XREF LINKEND="std.DWARF2">) cannot be
used in such a DWARF expression.</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_CFA_offset_extended_sf</ENTRY>
<ENTRY>0x11</ENTRY>
<ENTRY>
The DW_CFA_offset_extended_sf instruction takes two operands: an unsigned LEB128 value representing a
register number and a signed LEB128 factored offset. This instruction is identical to
DW_CFA_offset_extended except that the second operand is signed.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_CFA_def_cfa_sf</ENTRY>
<ENTRY>0x12</ENTRY>
<ENTRY>
The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing a register
number and a signed LEB128 factored offset. This instruction is identical to DW_CFA_def_cfa except that
the second operand is signed and factored.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_CFA_def_cfa_offset_sf</ENTRY>
<ENTRY>0x13</ENTRY>
<ENTRY>
The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand representing a factored offset.
This instruction is identical to DW_CFA_def_cfa_offset except that the operand is signed and factored.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_CFA_GNU_args_size</ENTRY>
<ENTRY>0x2e</ENTRY>
<ENTRY>
The DW_CFA_def_cfa_offset_sf instruction takes an unsigned LEB128 operand representing an argument size.
</ENTRY>
</ROW>
<ROW>
<ENTRY>DW_CFA_GNU_negative_offset_extended</ENTRY>
<ENTRY>0x2f</ENTRY>
<ENTRY>
The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing a register
number and an unsigned LEB128 which represents the magnitude of the offset. This instruction is identical
to DW_CFA_offset_extended_sf except that the operand is subtracted to produce the offset. This
instructions is obsoleted by DW_CFA_offset_extended_sf.
</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>

</SECT1>


</CHAPTER>

<CHAPTER ID="ehframechpt">
<TITLE>Exception Frames</TITLE>
<PARA>
When using languages that support exceptions, such as C++, additional
information must be provided to the runtime environment that describes
the call frames that much be unwound during the processing of an exception.
This information is contained in the special sections
<COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> and
<COMPUTEROUTPUT>.eh_framehdr</COMPUTEROUTPUT>.
<NOTE>
<PARA>
The format of the <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> section is similar
in format and purpose to the <COMPUTEROUTPUT>.debug_frame</COMPUTEROUTPUT>
section which is specified in <XREF LINKEND="std.DWARF3">.
Readers are advised that there are some subtle difference,
and care should be taken when comparing the two sections.
</PARA>
</NOTE>
</PARA>
<SECT1 id="ehframe">
<TITLE>
The <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> section
</TITLE>
<PARA>
The <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> section shall contain 1 or more
Call Frame Information (CFI) records. The number of records present shall be
determined by size of the section as contained in the section header.
Each CFI record contains a Common Information Entry (CIE) record followed by
1 or more Frame Description Entry (FDE) records. Both CIEs and FDEs shall
be aligned to an addressing unit sized boundary.
</PARA>

<TABLE>
<TITLE>Call Frame Information Format</TITLE>
<TGROUP COLS=1>
<TBODY>
<ROW>
<ENTRY>Common Information Entry Record</ENTRY>
</ROW>
<ROW>
<ENTRY>Frame Description Entry Record(s)</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>

<SECT2>
<TITLE>The Common Information Entry Format</TITLE>
<TABLE>
<TITLE>Common Information Entry Format</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Length</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Extended Length</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>CIE ID</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Version</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Augmentation String</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>EH Data</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>Code Alignment Factor</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Data Alignment Factor</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Return Address Register</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Augmentation Data Length</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>Augmentation Data</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>Initial Instructions</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Padding</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>

<VARIABLELIST>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 4 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <STRUCTFIELD>Length</STRUCTFIELD> field itself. If
<STRUCTFIELD>Length</STRUCTFIELD> contains the value 0xffffffff, then the
length is contained in the <STRUCTFIELD>Extended Length</STRUCTFIELD> field.
If <STRUCTFIELD>Length</STRUCTFIELD> contains the value 0, then this CIE shall
be considered a terminator and processing shall end.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Extended Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 8 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <STRUCTFIELD>Length</STRUCTFIELD> and
<STRUCTFIELD>Extended Length</STRUCTFIELD> fields. 
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>CIE ID</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 4 byte unsigned value that is used to distinguish CIE records from FDE
records.  This value shall always be 0, which indicates this record is a CIE.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Version</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version assigned to the call frame information structure. This value shall be 1.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Augmentation String</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
This value is a NUL terminated string that identifies the augmentation to
the CIE or to the FDEs associated with this CIE. A zero length string
indicates that no augmentation data is present.  The augmentation string
is case sensitive and shall be interpreted as described below.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>EH Data</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
On 32 bit architectures, this is a 4 byte value that...
On 64 bit architectures, this is a 8 byte value that...
This field is only present if the Augmentation String
contains the string "eh".
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Code Alignment Factor</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
An unsigned LEB128 encoded value that is factored out of all advance location
instructions that are associated with this CIE or its FDEs. This value shall be
multiplied by the delta argument of an adavance location instruction to obtain
the new location value.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Data Alignment Factor</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A signed LEB128 encoded value that is factored out of all offset instructions
that are associated with this CIE or its FDEs. This value shall be multiplied
by the register offset argument of an offset instruction to obtain
the new offset value.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Augmentation Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
contains the character 'z'.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Augmentation Data</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A block of data whose contents are defined by the contents of the
Augmentation String as described below. This field is only present if the
Augmentation String contains the character 'z'.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Initial Instructions</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Initial set of Call Frame Instructions.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Padding</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Extra bytes to align the CIE structure to an addressing unit size boundary.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>


<SECT3>
<TITLE>Augmentation String Format</TITLE>
<PARA>
The Agumentation String indicates the presence of some optional fields, and
how those fields should be intepreted. This string is case sensitive.  Each
character in the augmentation string in the CIE can be interpreted as below:
</PARA>

<VARIABLELIST>

<VARLISTENTRY>
<TERM>'z'</TERM>
<LISTITEM>
<PARA>
A 'z' may be present as the first character of the string. If present, the
Augmentation Data field shall be present. The contents of the Augmentation Data
shall be intepreted according to other characters in the Augmentation String.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>"eh"</TERM>
<LISTITEM>
<PARA>
If the Augmentation string has the value "eh", then the EH Data field shall
be present.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>'L'</TERM>
<LISTITEM>
<PARA>
A 'L' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of one argument in the Augmentation Data of the CIE,
and a corresponding argument in the Augmentation Data of the FDE.
The argument in the Augmentation Data of the CIE is 1-byte and represents the
pointer encoding used for the argument in the Augmentation Data of the FDE,
which is the address of a language-specific data area (LSDA).
The size of the LSDA pointer is specified by the pointer encoding used.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>'P'</TERM>
<LISTITEM>
<PARA>
A 'P' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, it
indicates the presence of two arguments in the Augmentation Data of the CIE.
The first argument is 1-byte and represents the pointer encoding used for the
second argument, which is the address of a personality routine handler. The
size of the personality routine pointer is specified by the pointer encoding
used.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>'R'</TERM>
<LISTITEM>
<PARA>
A 'R' may be present at any position after the first character of the string.
This character may only be present if 'z' is the first character of the string.
If present, The
Augmentation Data shall include a 1 byte argument that represents the pointer
encoding for the address pointers used in the FDE.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</SECT3>

</SECT2>

<SECT2>
<TITLE>The Frame Description Entry Format</TITLE>
<TABLE>
<TITLE>Frame Description Entry Format</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Length</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Extended Length</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>CIE Pointer</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>PC Begin</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>PC Range</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Augmentation Data Length</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>Augmentation Data</ENTRY>
<ENTRY>Optional</ENTRY>
</ROW>
<ROW>
<ENTRY>Call Frame Instructions</ENTRY>
<ENTRY>Required</ENTRY>
</ROW>
<ROW>
<ENTRY>Padding</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>

<VARIABLELIST>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 4 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <STRUCTFIELD>Length</STRUCTFIELD> field itself. If
<STRUCTFIELD>Length</STRUCTFIELD> contains the value 0xffffffff, then the
length is contained the <STRUCTFIELD>Extended Length</STRUCTFIELD> field.
If <STRUCTFIELD>Length</STRUCTFIELD> contains the value 0, then this CIE shall
be considered a terminator and processing shall end.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Extended Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 8 byte unsigned value indicating the length in bytes of the CIE structure,
not including the <STRUCTFIELD>Length</STRUCTFIELD> field itself. 
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>CIE Pointer</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A 4 byte unsigned value that when subtracted from the offset of the current FDE
yields the offset of the start of the associated CIE.  This value shall never be 0.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>PC Begin</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
An encoded constant that indicates the address of the initial location
associated with this FDE.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>PC Range</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
An encoded constant that indicates the number of bytes of instructions 
associated with this FDE.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Augmentation Length</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
An unsigned LEB128 encoded value indicating the length in bytes of the
Augmentation Data. This field is only present if the Augmentation String
in the associated CIE contains the character 'z'.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Augmentation Data</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A block of data whose contents are defined by the contents of the
Augmentation String in the associated CIE as described above.
This field is only present if the Augmentation String in the associated CIE
contains the character 'z'.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Call Frame Instructions</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
A set of Call Frame Instructions.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM><STRUCTFIELD>Padding</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Extra bytes to align the FDE structure to an addressing unit size boundary.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

</SECT2>
</SECT1>


<SECT1 ID="ehframehdr">
<TITLE>
The <COMPUTEROUTPUT>.eh_frame_hdr</COMPUTEROUTPUT> section
</TITLE>
<PARA>
The <COMPUTEROUTPUT>.eh_frame_hdr</COMPUTEROUTPUT> section contains additional
information about the <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> section.
A pointer to the start of the <COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> data,
and optionally, a binary search table of pointers to the
<COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> records are found in this section.
</PARA>
<PARA>
Data in this section is encoded according to <XREF LINKEND="dwarfehencoding">.
</PARA>
<TABLE>
<TITLE><COMPUTEROUTPUT>.eh_frame_hdr</COMPUTEROUTPUT> Section Format</TITLE>
<TGROUP COLS=2>
<THEAD>
<ROW>
<ENTRY>Encoding</ENTRY>
<ENTRY>Field</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW>
<ENTRY>unsigned byte</ENTRY>
<ENTRY>version</ENTRY>
</ROW>
<ROW>
<ENTRY>unsigned byte</ENTRY>
<ENTRY>eh_frame_ptr_enc</ENTRY>
</ROW>
<ROW>
<ENTRY>unsigned byte</ENTRY>
<ENTRY>fde_count_enc</ENTRY>
</ROW>
<ROW>
<ENTRY>unsigned byte</ENTRY>
<ENTRY>table_enc</ENTRY>
</ROW>
<ROW>
<ENTRY>encoded</ENTRY>
<ENTRY>eh_frame_ptr</ENTRY>
</ROW>
<ROW>
<ENTRY>encoded</ENTRY>
<ENTRY>fde_count</ENTRY>
</ROW>
<ROW>
<ENTRY></ENTRY>
<ENTRY>binary search table</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>version</TERM>
<LISTITEM><PARA>
Version of the <COMPUTEROUTPUT>.eh_frame_hdr</COMPUTEROUTPUT> format. This
value shall be 1.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>eh_frame_ptr_enc</TERM>
<LISTITEM><PARA>
The encoding format of the eh_frame_ptr field.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>fde_count_enc</TERM>
<LISTITEM><PARA>
The encoding format of the fde_count field.
A value of DW_EH_PE_omit indicates the binary search table is not present.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>table_enc</TERM>
<LISTITEM><PARA>
The encoding format of the entries in the binary search table.
A value of DW_EH_PE_omit indicates the binary search table is not present.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>eh_frame_ptr</TERM>
<LISTITEM><PARA>
The encoded value of the pointer to the start of the
<COMPUTEROUTPUT>.eh_frame</COMPUTEROUTPUT> section.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>fde_count</TERM>
<LISTITEM><PARA>
The encoded value of the count of entries in the binary search table.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>binary search table</TERM>
<LISTITEM><PARA>
A binary search table containing fde_count entries. Each entry of the table
consist of two encoded values, the initial location, and the address.
The entries are sorted in an increasing order by the initial location value.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>


</CHAPTER>

<CHAPTER ID=SymVersion>
<TITLE>Symbol Versioning</TITLE>
<SECT1><TITLE>Introduction</TITLE>
<PARA>
This chapter describes the Symbol Versioning mechanism. All ELF objects may
provide or depend on versioned symbols. Symbol Versioning is implemented by 3
section types: 
<SIMPLELIST TYPE="inline">
<MEMBER><SYMBOL>SHT_GNU_versym</SYMBOL></MEMBER> 
<MEMBER><SYMBOL>SHT_GNU_verdef</SYMBOL></MEMBER>
<MEMBER>and <SYMBOL>SHT_GNU_verneed</SYMBOL></MEMBER></SIMPLELIST>.
</PARA>
<PARA>
The prefix <SYMBOL>Elfxx</SYMBOL> in the following descriptions and code fragments stands for 
either "<SYMBOL>Elf32</SYMBOL>" or "<SYMBOL>Elf64</SYMBOL>", depending on the architecture.
</PARA>
<PARA>
Versions are described by strings. The structures that are used for symbol
versions also contain a member that holds the ELF hashing values of the
strings. This allows for more efficient processing.
</PARA>
</SECT1>
<SECT1 ID="symvertbl">
<TITLE>Symbol Version Table</TITLE>
<PARA>
The special section <SYMBOL>.gnu.version</SYMBOL>
which has a section type of <SYMBOL>SHT_GNU_versym</SYMBOL>
shall contain the Symbol Version Table. This section shall have the same number 
of entries as the Dynamic Symbol Table in the <SYMBOL>.dynsym</SYMBOL> section.
</PARA>
<PARA>
The <SYMBOL>.gnu.version</SYMBOL> section shall contain an array of elements of type 
<SYMBOL>Elfxx_Half</SYMBOL>.
Each entry specifies the version defined for or required by the corresponding 
symbol in the Dynamic Symbol Table.
</PARA>
<PARA>
The values in the Symbol Version Table are specific to the object in which they 
are located. These values are identifiers that are provided by the the 
<STRUCTFIELD>vna_other</STRUCTFIELD> member of the 
<STRUCTNAME>Elfxx_Vernaux</STRUCTNAME> structure or the 
<STRUCTFIELD>vd_ndx</STRUCTFIELD> member of the 
<STRUCTNAME>Elfxx_Verdef</STRUCTNAME> structure.
</PARA>
<PARA>
The values 0 and 1 are reserved.
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>0</TERM>
<LISTITEM>
<PARA>
The symbol is local, not available outside the object.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>1</TERM>
<LISTITEM>
<PARA>
The symbol is defined in this object and is globally available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
All other values are used to identify version strings located in one of the
other Symbol Version sections. The value itself is not the version associated
with the symbol. The string identified by the value defines the version of
the symbol.
</PARA>
</SECT1>
<SECT1 ID="symverdefs">
<TITLE>Version Definitions</TITLE>
<PARA>
Symbol definitions are contained in the special section <SYMBOL>
.gnu.version_d</SYMBOL> which has a section type of <SYMBOL>
SHT_GNU_verdef</SYMBOL>. The number of entries in this section
is contained in the <SYMBOL>DT_VERDEFNUM</SYMBOL> entry
of the Dynamic Section.  The <SYMBOL>sh_link</SYMBOL>
member of the section header points to the section that contains the strings
referenced by this section.
</PARA>
<PARA>
The special section <SYMBOL>.gnu.version_d</SYMBOL> which has a section type of 
<SYMBOL>SHT_GNU_verdef </SYMBOL>
shall contain symbol version definitions. The number of entries in this section 
shall be contained in the <SYMBOL>DT_VERDEFNUM</SYMBOL> entry of the Dynamic Section 
<SYMBOL>.dynamic</SYMBOL>. 
The <SYMBOL>sh_link</SYMBOL> member of the section header (see figure 4-8 in the 
<XREF LINKEND="STD.gABI41">) 
shall point to the section that contains the strings referenced by this section.
</PARA>
<PARA>
The section shall contain an array of <SYMBOL>Elfxx_Verdef</SYMBOL> structures, as described in 
<XREF LINKEND="VerDefEntries">, optionally followed by an array of <SYMBOL>Elfxx_Verdaux</SYMBOL> structures, as 
defined in <XREF LINKEND="VerDefExts">.
</PARA>
<FIGURE ID="VerDefEntries">
<TITLE>Version Definition Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Half    vd_version;
	Elfxx_Half    vd_flags;
	Elfxx_Half    vd_ndx;
	Elfxx_Half    vd_cnt;
	Elfxx_Word    vd_hash;
	Elfxx_Word    vd_aux;
	Elfxx_Word    vd_next;
} Elfxx_Verdef;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_version</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version revision. This field shall be set to <literal>1</literal>.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_flags</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version information flag bitmask.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_ndx</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version index numeric value referencing the SHT_GNU_versym section.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_cnt</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Number of associated verdaux array entries.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_hash</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version name hash value (ELF hash function).
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_aux</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset in bytes to a corresponding entry in an array
of <SYMBOL>Elfxx_Verdaux</SYMBOL> structures as defined in
<XREF LINKEND="VerDefExts">
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vd_next</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the next verdef entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<FIGURE ID="VerDefExts">
<TITLE>Version Definition Auxiliary Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Word    vda_name;
	Elfxx_Word    vda_next;
} Elfxx_Verdaux;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vda_name</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the version or dependency name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vda_next</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the next verdaux entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>
<SECT1 ID="symverrqmts">
<TITLE>Version Requirements</TITLE>
<PARA>
The special section <SYMBOL>.gnu.version_r</SYMBOL> which has a section type of 
<SYMBOL>SHT_GNU_verneed</SYMBOL>
shall contain required symbol version definitions. The number of entries in 
this section shall be contained in the <SYMBOL>DT_VERNEEDNUM</SYMBOL> entry of the Dynamic 
Section <SYMBOL>.dynamic</SYMBOL>. 
The <STRUCTFIELD>sh_link</STRUCTFIELD> member of the section header (see figure 4-8 in 
<XREF LINKEND="STD.gABI41">)
shall point to the section that contains the strings referenced by this section.
</PARA>
<PARA>
The section shall contain an array of <SYMBOL>Elfxx_Verneed</SYMBOL> structures, as described in 
<XREF LINKEND="VerNeedFig">, optionally followed by an array of 
<SYMBOL>Elfxx_Vernaux</SYMBOL> structures, as 
defined in <XREF LINKEND="VerNeedExtFig">.
</PARA><FIGURE ID="VerNeedFig">
<TITLE>Version Needed Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Half    vn_version;
	Elfxx_Half    vn_cnt;
	Elfxx_Word    vn_file;
	Elfxx_Word    vn_aux;
	Elfxx_Word    vn_next;
} Elfxx_Verneed;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vn_version</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Version of structure. This value is currently set to 1, and will be reset if the versioning implementation is incompatibly altered.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vn_cnt</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Number of associated verneed array entries.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vn_file</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the file name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vn_aux</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to a corresponding entry in the vernaux array, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vn_next</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the next verneed entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<FIGURE ID="VerNeedExtFig">
<TITLE>Version Needed Auxiliary Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Word    vna_hash;
	Elfxx_Half    vna_flags;
	Elfxx_Half    vna_other;
	Elfxx_Word    vna_name;
	Elfxx_Word    vna_next;
} Elfxx_Vernaux;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vna_hash</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Dependency name hash value (ELF hash function).
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vna_flags</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Dependency information flag bitmask.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vna_other</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Object file version identifier used in the .gnu.version symbol version array. Bit number 15 controls whether or not the object is hidden; if this bit is set, the object cannot be used and the static linker will ignore the symbol's presence in the object.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vna_name</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the dependency name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><STRUCTFIELD>vna_next</STRUCTFIELD></TERM>
<LISTITEM>
<PARA>
Offset to the next vernaux entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>
<SECT1 ID="symstartseq">
<TITLE>Startup Sequence</TITLE>
<PARA>
When loading a sharable object the system shall analyze version definition data 
from the loaded object to assure that it meets the version requirements of the 
calling object. This step is referred to as definition testing. The dynamic 
loader shall retrieve the entries in the caller's <SYMBOL>Elfxx_Verneed</SYMBOL> array and 
attempt to find matching definition information in the loaded <SYMBOL>Elfxx_Verdef</SYMBOL>
table.
</PARA>
<PARA>
Each object and dependency shall be tested in turn. If a symbol definition is 
missing and the <SYMBOL>vna_flags</SYMBOL> bit for <SYMBOL>VER_FLG_WEAK</SYMBOL> is not set, the loader shall 
return an error and exit. If the <SYMBOL>vna_flags</SYMBOL> bit for <SYMBOL>VER_FLG_WEAK</SYMBOL> is set in the 
<SYMBOL>Elfxx_Vernaux</SYMBOL> entry, and the loader shall issue a warning and continue 
operation.
</PARA>
<PARA>
When the versions referenced by undefined symbols in the loaded object are 
found, version availability is certified. The test completes without error and 
the object shall be made available.
</PARA>
</SECT1>
<SECT1 ID="symresolution">
<TITLE>Symbol Resolution</TITLE>
<PARA>
When symbol versioning is used in an object, relocations extend 
definition testing beyond the simple match of symbol
name strings: the version of the reference shall also equal the name of
the definition. 
</PARA>
<PARA>
The same index that is used in the symbol table can be
referenced in the <SYMBOL>SHT_GNU_versym</SYMBOL> section, and the value of this index is
then used to acquire name data. The corresponding requirement string is
retrieved from the <SYMBOL>Elfxx_Verneed</SYMBOL> array, and likewise, the corresponding
definition string from the <SYMBOL>Elfxx_Verdef</SYMBOL> table.
</PARA>
<PARA>
If the high order bit (bit number 15)
of the version symbolis set, the object cannot be used
and the static linker shall ignore the symbol's presence in the object.
</PARA>
<PARA>
When an object with a reference and an object with the definition are being 
linked, the following rules shall govern the result:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
The object with the reference and the object with the definitions both use 
versioning. All described matching is processed in this case. A fatal error 
shall be triggered when no matching definition can be found in the object whose 
name is the one referenced by the <STRUCTFIELD>vn_name</STRUCTFIELD> element in the 
<STRUCTNAME>Elfxx_Verneed</STRUCTNAME> entry.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The object with the reference does not use versioning, while the object with 
the definitions does. In this instance, only the definitions with index numbers 
1 and 2 will be used in the reference match, the same identified by the static 
linker as the base definition. In cases where the static linker was not used, 
such as in calls to <FUNCTION>dlopen</FUNCTION>, a version that does not have the base definition 
index shall be acceptable if it is the only version for which the symbol is 
defined.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The object with the reference uses versioning, but the object with the 
definitions specifies none. A matching symbol shall be accepted in this case. A 
fatal error shall be triggered if a corruption in the required symbols list 
obscures an outdated object file and causes a match on the object filename in 
the <SYMBOL>Elfxx_Verneed</SYMBOL> entry.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
Neither the object with the reference nor the object with the definitions use 
versioning. The behavior in this instance shall default to pre-existing symbol 
rules.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</SECT1>
</CHAPTER>


<chapter id="noteABItag">
<TITLE>ABI note tag</TITLE>
<para>
Every executable shall contain a section named
<computeroutput>.note.ABI-tag</computeroutput> of type
<computeroutput>SHT_NOTE</computeroutput>.  This section is structured
as a note section as documented in the ELF spec.  The section shall
contain at least the following entry.  The
<computeroutput>name</computeroutput> field
(<computeroutput>namesz</computeroutput>/<computeroutput>name</computeroutput>)
contains the string "<computeroutput>GNU</computeroutput>".  The
<computeroutput>type</computeroutput> field shall be 1.  The
<computeroutput>descsz</computeroutput> field shall be at least 16,
and the first 16 bytes of the <computeroutput>desc</computeroutput>
field shall be as follows.
</para>

<para>
The first 32-bit word of the <computeroutput>desc</computeroutput>
field shall be 0 (this signifies a Linux executable).  The second,
third, and fourth 32-bit words of the
<computeroutput>desc</computeroutput> field contain the earliest
compatible kernel version.  For example, if the 3 words are 2, 2, and
5, this signifies a 2.2.5 kernel.
</para>
</chapter>

</PART>
