<PART ID="tocobjformat">
<TITLE>Object Format</TITLE>

<CHAPTER ID=objfmt>
<TITLE>Object Files</TITLE>
<PARA>
LSB-conforming implementations shall support the object file Executable and Linking Format (ELF), which is defined by the following documents:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
System V Application Binary Interface, Edition 4.1
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
System V Application Binary Interface - DRAFT - April 29, 1998
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
this document
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
an architecture-specific LSB specification
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
Conforming implementations may also support other unspecified object file formats.
</PARA>
</CHAPTER>

<CHAPTER ID=Sections>
<TITLE>Sections</TITLE>
<PARA>
</PARA>
<SECT1 ID="elftypes">
<TITLE>Sections Types</TITLE>
<PARA>
A section header's <COMPUTEROUTPUT>sh_type</COMPUTEROUTPUT> member specifies the sections's semantics.
</PARA>
<SECT2>
<TITLE>ELF Section Types</TITLE>
<PARA>
The following section types are defined in the System V Application Binary
Interface, Edition 4.1.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mksecttypestable,v 1.8 2002/06/12 14:19:51 anderson Exp 0 -->
<!--    at Thu Jun 20 16:20:15 2002 -->
<TABLE>
<TITLE>ELF Section Types</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Value</ENTRY><ENTRY ALIGN=center>Description</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>SHT_DYNAMIC</ENTRY><ENTRY>0x6</ENTRY><ENTRY>The section holds information for dynamic linking. Currently, an object file may have only one dynamic section, but this restriction may be relaxed in the future. See `Dynamic Section' in Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_DYNSYM</ENTRY><ENTRY>0xb</ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>SHT_FINI_ARRAY</ENTRY><ENTRY>0xf</ENTRY><ENTRY>This section contains an array of pointers to termination functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_HASH</ENTRY><ENTRY>0x5</ENTRY><ENTRY>The section holds a symbol hash table. Currently, an object file may have only one hash table, but this restriction may be relaxed in the future. See `Hash Table' in the Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_HIPROC</ENTRY><ENTRY>0x7fffffff</ENTRY><ENTRY>Values in this inclusive range are reserved for processor-specific semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_HIUSER</ENTRY><ENTRY>0xffffffff</ENTRY><ENTRY>This value specifies the upper bound of the range of indexes reserved for application programs. Section types between SHT_LOUSER and SHT_HIUSER may be used by the application, without conflicting with current or future system-defined section types.</ENTRY></ROW>
<ROW><ENTRY>SHT_INIT_ARRAY</ENTRY><ENTRY>0xe</ENTRY><ENTRY>This section contains an array of pointers to initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless procedure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_LOPROC</ENTRY><ENTRY>0x70000000</ENTRY><ENTRY>Values in this inclusive range are reserved for processor-specific semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_LOUSER</ENTRY><ENTRY>0x80000000</ENTRY><ENTRY>This value specifies the lower bound of the range of indexes reserved for application programs.</ENTRY></ROW>
<ROW><ENTRY>SHT_NOBITS</ENTRY><ENTRY>0x8</ENTRY><ENTRY>A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</ENTRY></ROW>
<ROW><ENTRY>SHT_NOTE</ENTRY><ENTRY>0x7</ENTRY><ENTRY>The section holds information that marks the file in some way. See `Note Section' in Chapter 5 for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_NULL</ENTRY><ENTRY>0x0</ENTRY><ENTRY>This value marks the section header as inactive; it does not have an associated section. Other members of the section header have undefined values.</ENTRY></ROW>
<ROW><ENTRY>SHT_PREINIT_ARRAY</ENTRY><ENTRY>0x10</ENTRY><ENTRY>This section contains an array of pointers to functions that are invoked before all other initialization functions, as described in `Initialization and Termination Functions' in Chapter 5. Each pointer in the array is taken as a parameterless proceure with a void return.</ENTRY></ROW>
<ROW><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0x1</ENTRY><ENTRY>The section holds information defined by the program, whose format and meaning are determined solely by the program.</ENTRY></ROW>
<ROW><ENTRY>SHT_REL</ENTRY><ENTRY>0x9</ENTRY><ENTRY>The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files or type Elf64_Rel for the 64-bit class of object files. An object file may have multiple relocation sections. See "Relocation"</ENTRY></ROW>
<ROW><ENTRY>SHT_RELA</ENTRY><ENTRY>0x4</ENTRY><ENTRY>The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files or type Elf64_Rela for the 64-bit class of object files. An object file may have multiple relocation sections. `Relocation' b</ENTRY></ROW>
<ROW><ENTRY>SHT_SHLIB</ENTRY><ENTRY>0xa</ENTRY><ENTRY>This section type is reserved but has unspecified semantics.</ENTRY></ROW>
<ROW><ENTRY>SHT_STRTAB</ENTRY><ENTRY>0x3</ENTRY><ENTRY>The section holds a string table. An object file may have multiple string table sections. See `String Table' below for details.</ENTRY></ROW>
<ROW><ENTRY>SHT_SYMTAB</ENTRY><ENTRY>0x2</ENTRY><ENTRY>These sections hold a symbol table. Currently, an object file may have only one section of each type, but this restriction may be relaxed in the future. Typically, SHT_SYMTAB provides symbols for link editing, though it may also be used for dynamic linking.</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mksecttypestable,v 1.8 2002/06/12 14:19:51 anderson Exp 0 -->

</PARA>
</SECT2>
<SECT2>
<TITLE>Additional Section Types</TITLE>
<PARA>
The following additional section types are defined here.

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mksecttypestable,v 1.8 2002/06/12 14:19:51 anderson Exp 0 -->
<!--    at Thu Jun 20 16:20:15 2002 -->
<TABLE>
<TITLE>Additional Section Types</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Value</ENTRY><ENTRY ALIGN=center>Description</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>SHT_GNU_verdef</ENTRY><ENTRY>0x6ffffffd</ENTRY><ENTRY>This section contains the symbol versions that are provided.</ENTRY></ROW>
<ROW><ENTRY>SHT_GNU_verneed</ENTRY><ENTRY>0x6ffffffe</ENTRY><ENTRY>This section contains the symbol versions that are required.</ENTRY></ROW>
<ROW><ENTRY>SHT_GNU_versym</ENTRY><ENTRY>0x6fffffff</ENTRY><ENTRY>This section contains the Symbol Version Table.</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mksecttypestable,v 1.8 2002/06/12 14:19:51 anderson Exp 0 -->

</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID=SpecialSections>
<TITLE>Special Sections</TITLE>
<SECT1 ID="elfspecial">
<TITLE>Special Sections</TITLE>
<PARA>
Various sections hold program and control information. Sections in the lists below are used by the system and have the indicated types and attributes.
</PARA>
<SECT2>
<TITLE>ELF Special Sections</TITLE>
<PARA>
The following sections are defined in the System V Application Binary
Interface, Edition 4.1.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mksectiontable,v 1.9 2002/06/12 14:19:51 anderson Exp 0 -->
<!--    at Thu Jun 20 16:20:15 2002 -->
<TABLE>
<TITLE>ELF Special Sections</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Type</ENTRY><ENTRY ALIGN=center>Attributes</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>.bss</ENTRY><ENTRY>SHT_NOBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.comment</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.data</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.data1</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.debug</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.dynamic</ENTRY><ENTRY>SHT_DYNAMIC</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.dynstr</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.dynsym</ENTRY><ENTRY>SHT_DYNSYM</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.fini</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
<ROW><ENTRY>.fini_array</ENTRY><ENTRY>SHT_FINI_ARRAY</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.hash</ENTRY><ENTRY>SHT_HASH</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.init</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
<ROW><ENTRY>.init_array</ENTRY><ENTRY>SHT_INIT_ARRAY</ENTRY><ENTRY> SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.interp</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.line</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.note</ENTRY><ENTRY>SHT_NOTE</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.preinit_array</ENTRY><ENTRY>SHT_PREINIT_ARRAY</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.rodata</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.rodata1</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.shstrtab</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>0</ENTRY></ROW>
<ROW><ENTRY>.strtab</ENTRY><ENTRY>SHT_STRTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.symtab</ENTRY><ENTRY>SHT_SYMTAB</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.text</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_EXECINSTR</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<VARIABLELIST>
<VARLISTENTRY><TERM>.bss</TERM><LISTITEM><PARA>This section holds uninitialized data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the program begins to run. The section occupies no file space, as indicated by the section type, SHT_NOBITS</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.comment</TERM><LISTITEM><PARA>This section holds version control information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.data</TERM><LISTITEM><PARA>This section holds initialized data that contribute to the program's memory image.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.data1</TERM><LISTITEM><PARA>This section holds initialized data that contribute to the program's memory image.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.debug</TERM><LISTITEM><PARA>This section holds information for symbolic debugging. The contents are unspecified. All section names with the prefix .debug are reserved for future use in the ABI.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynamic</TERM><LISTITEM><PARA>This section holds dynamic linking information. The section's attributes will include the SHF_ALLOC bit. Whether the SHF_WRITE bit is set is processor specific. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynstr</TERM><LISTITEM><PARA>This section holds strings needed for dynamic linking, most commonly the strings that represent the names associated with symbol table entries. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dynsym</TERM><LISTITEM><PARA>This section holds the dynamic linking symbol table, as described in `Symbol Table'. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.fini</TERM><LISTITEM><PARA>This section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.fini_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.hash</TERM><LISTITEM><PARA>This section holds a symbol hash table. See `Hash Table' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.init</TERM><LISTITEM><PARA>This section holds executable instructions that contribute to the process initialization code. When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs)</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.init_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single initialization array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.interp</TERM><LISTITEM><PARA>This section holds the path name of a program interpreter. If the file has a loadable segment that includes relocation, the sections' attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. See Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.line</TERM><LISTITEM><PARA>This section holds line number information for symbolic debugging, which describes the correspondence between the source program and the machine code. The contents are unspecified.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.note</TERM><LISTITEM><PARA>This section holds information in the format that `Note Section' in Chapter 5 describes of the System V Application Binary Interface, Edition 4.1.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.preinit_array</TERM><LISTITEM><PARA>This section holds an array of function pointers that contributes to a single pre-initialization array for the executable or shared object containing the section.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.rodata</TERM><LISTITEM><PARA>This section holds read-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.rodata1</TERM><LISTITEM><PARA>This section hold sread-only data that typically contribute to a non-writable segment in the process image. See `Program Header' in Chapter 5 for more information.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.shstrtab</TERM><LISTITEM><PARA>This section holds section names.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.strtab</TERM><LISTITEM><PARA>This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If the file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwi</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.symtab</TERM><LISTITEM><PARA>This section holds a symbol table, as `Symbol Table'. in this chapter describes. If the file has a loadable segment that includes the symbol table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.text</TERM><LISTITEM><PARA>This section holds the `text,' or executable instructions, of a program.</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mksectiontable,v 1.9 2002/06/12 14:19:51 anderson Exp 0 -->

</PARA>
</SECT2>
<SECT2>
<TITLE>Additional Special Sections</TITLE>
<PARA>
The following additional sections are defined here.
<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mksectiontable,v 1.9 2002/06/12 14:19:51 anderson Exp 0 -->
<!--    at Thu Jun 20 16:20:15 2002 -->
<TABLE>
<TITLE>Additional Special Sections</TITLE>
<TGROUP COLS=3>
<THEAD>
<ROW>
<ENTRY ALIGN=center>Name</ENTRY><ENTRY ALIGN=center>Type</ENTRY><ENTRY ALIGN=center>Attributes</ENTRY></ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>.ctors</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.dtors</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.eh_frame</ENTRY><ENTRY>SHT_PROGBITS</ENTRY><ENTRY>SHF_ALLOC+SHF_WRITE</ENTRY></ROW>
<ROW><ENTRY>.gnu.version</ENTRY><ENTRY>SHT_GNU_versym</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.gnu.version_d</ENTRY><ENTRY>SHT_GNU_verdef</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.gnu.version_r</ENTRY><ENTRY>SHT_GNU_verneed</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
<ROW><ENTRY>.note.ABI-tag</ENTRY><ENTRY>SHT_NOTE</ENTRY><ENTRY>SHF_ALLOC</ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
<VARIABLELIST>
<VARLISTENTRY><TERM>.ctors</TERM><LISTITEM><PARA>This section contains a list of global constructor function pointers.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.dtors</TERM><LISTITEM><PARA>This section contains a list of global destructor function pointers.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.eh_frame</TERM><LISTITEM><PARA>This section contains information necessary for frame unwinding during exception handling. The format is the same as for .debug_frame as described by DWARF2.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version</TERM><LISTITEM><PARA>This section contains the Symbol Version Table.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version_d</TERM><LISTITEM><PARA>This section contains the Version Definitions.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.gnu.version_r</TERM><LISTITEM><PARA>This section contains the Version Requirments.</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>.note.ABI-tag</TERM><LISTITEM><PARA>Specify ABI details.</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mksectiontable,v 1.9 2002/06/12 14:19:51 anderson Exp 0 -->

</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID=Symmap>
<TITLE>Symbol Mapping</TITLE>
<PARA>
This chapter defines how names are mapped from the source symbol to
the object symbol.
</PARA>
<SECT1 ID="symmapping">
<TITLE>Symbol Mapping</TITLE>
<PARA>
Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. The rules for this translation are
defined here.
</PARA>
<SECT2>
<TITLE>C Language</TITLE>
<PARA>
External C symbols have the same names in C and object files' symbol tables.
</PARA>
</SECT2>
<SECT2>
<TITLE>C++ Language</TITLE>
<PARA>
Because of the immaturity of the C++ ABI (for name mangling, exception
handling, and other such issues), we do not standardize any libraries
for C++ in this version of the Linux Standard Base.
<FOOTNOTE ID="static-cplusplus">
<PARA>
It seems to be possible, using existing Linux development tools, to write an
application in C++ which complies with this rule by linking statically 
with libstdc++ and all other libraries containing C++. The following command
illustrates how this may be accomplished:
</PARA>
<PARA>
<COMMAND>
g++ example.cc -Wl,-Bdynamic,-lc,-Bstatic 
</COMMAND>
</PARA>
</FOOTNOTE>
</PARA>
<PARA>
In a future version of this specification, name mangling rules will be
specified so that C++ symbols can be mapped into symbol names in the object
file.
</PARA>
</SECT2>
</SECT1>
</CHAPTER>

<CHAPTER ID=SymVersion>
<TITLE>Symbol Versioning</TITLE>
<PARA>
This chapter describes the Symbol Versioning mechanism. All ELF objects may
provide or depend on versioned symbols. Symbol Versioning is implemented by 3
section types: SHT_GNU_versym, SHT_GNU_verdef, and SHT_GNU_verneed.
</PARA>
<PARA>
The term "Elfxx" means "Elf32" or "Elf64" depending on the architecture.
</PARA>
<PARA>
Versions are described by strings. The structures that are used for symbol
versions also contain a member that holds the ELF hashing values of the
strings. This allows for more efficient processing.
</PARA>
<SECT1 ID="symvertbl">
<TITLE>Symbol Version Table</TITLE>
<PARA>
The Symbol Version Table is contained in the special section <COMPUTEROUTPUT>
.gnu.version</COMPUTEROUTPUT> which has a section type of <COMPUTEROUTPUT>
SHT_GNU_versym</COMPUTEROUTPUT>. This section has the same number of entries
as the Dynamic Symbol Table.
</PARA>
<PARA>
This section contains an array of elements of type Elfxx_Half. Each entry
specifies the version defined for or required by the corresponding symbol in
the Dynamic Symbol Table.
</PARA>
<PARA>
The values in the Symbol Version Table are unique to the object in which
they are located. These values are identifiers that are provided by the
the <COMPUTEROUTPUT>vna_other</COMPUTEROUTPUT> member of the
<COMPUTEROUTPUT>Elfxx_Vernaux</COMPUTEROUTPUT> structure or the
<COMPUTEROUTPUT>vd_ndx</COMPUTEROUTPUT> member of the
<COMPUTEROUTPUT>Elfxx_Verdef</COMPUTEROUTPUT> structure.
</PARA>
<PARA>
The values 0 and 1 are reserved.
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>0</TERM>
<LISTITEM>
<PARA>
The symbol is local, not available outside the object.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM>1</TERM>
<LISTITEM>
<PARA>
The symbol is defined in this object and is globally available.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
All other values are used to identify version strings located in one of the
other Symbol Version sections. The value itself is not the version associated
with the symbol. The string identified by the value defines the version of
the symbol.
</PARA>
</SECT1>
<SECT1 ID="symverdefs">
<TITLE>Version Definitions</TITLE>
<PARA>
Symbol definitions are contained in the special section <COMPUTEROUTPUT>
.gnu.version_d</COMPUTEROUTPUT> which has a section type of <COMPUTEROUTPUT>
SHT_GNU_verdef</COMPUTEROUTPUT>. The number of entries in this section
is contained in the <COMPUTEROUTPUT>DT_VERDEFNUM</COMPUTEROUTPUT> entry
of the Dynamic Section.  The <COMPUTEROUTPUT>sh_link</COMPUTEROUTPUT>
member of the section header points to the section that contains the strings
referenced by this section.
</PARA>
<FIGURE>
<TITLE>Version Definition Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Half    vd_version;
	Elfxx_Half    vd_flags;
	Elfxx_Half    vd_ndx;
	Elfxx_Half    vd_cnt;
	Elfxx_Word    vd_hash;
	Elfxx_Word    vd_aux;
	Elfxx_Word    vd_next;
} Elfxx_Verdef;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_version</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Version revision. This value is currently set to 1, and will be reset if the versioning implementation is incompatibly altered.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_flags</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Version information flag bitmask.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_ndx</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Version index numeric value referencing the SHT_GNU_versym section.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_cnt</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Number of associated verdaux array entries.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_hash</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Version name hash value (ELF hash function).
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_aux</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to a corresponding entry in the verdaux array, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vd_next</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the next verdef entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<FIGURE>
<TITLE>Version Definition Auxiliary Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Word    vda_name;
	Elfxx_Word    vda_next;
} Elfxx_Verdaux;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vda_name</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the version or dependency name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vda_next</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the next verdaux entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>
<SECT1 ID="symverrqmts">
<TITLE>Version Requirements</TITLE>
<PARA>
Symbol definitions are contained in the special section <COMPUTEROUTPUT>
.gnu.version_r</COMPUTEROUTPUT> which has a section type of <COMPUTEROUTPUT>
SHT_GNU_verneed</COMPUTEROUTPUT>. The number of entries in this section
is contained in the <COMPUTEROUTPUT>DT_VERNEEDNUM</COMPUTEROUTPUT> entry
of the Dynamic Section.  The <COMPUTEROUTPUT>sh_link</COMPUTEROUTPUT>
member of the section header points to the section that contains the strings
referenced by this section.
</PARA><FIGURE>
<TITLE>Version Needed Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Half    vn_version;
	Elfxx_Half    vn_cnt;
	Elfxx_Word    vn_file;
	Elfxx_Word    vn_aux;
	Elfxx_Word    vn_next;
} Elfxx_Verneed;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vn_version</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Version of structure. This value is currently set to 1, and will be reset if the versioning implementation is incompatibly altered.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vn_cnt</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Number of associated verneed array entries.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vn_file</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the file name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vn_aux</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to a corresponding entry in the vernaux array, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vn_next</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the next verneed entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<FIGURE>
<TITLE>Version Needed Auxiliary Entries</TITLE>
<PROGRAMLISTING>
typedef struct {
	Elfxx_Word    vna_hash;
	Elfxx_Half    vna_flags;
	Elfxx_Half    vna_other;
	Elfxx_Word    vna_name;
	Elfxx_Word    vna_next;
} Elfxx_Vernaux;
</PROGRAMLISTING>
</FIGURE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vna_hash</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Dependency name hash value (ELF hash function).
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vna_flags</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Dependency information flag bitmask.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vna_other</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Object file version identifier used in the .gnu.version symbol version array. Bit number 15 controls whether or not the object is hidden; if this bit is set, the object cannot be used and the static linker will ignore the symbol's presence in the object.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vna_name</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the dependency name string in the section header, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><COMPUTEROUTPUT>vna_next</COMPUTEROUTPUT></TERM>
<LISTITEM>
<PARA>
Offset to the next vernaux entry, in bytes.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>
<SECT1 ID="symstartseq">
<TITLE>Startup Sequence</TITLE>
<PARA>
When loading a sharable object, version definition data from the loaded object is analyzed to assure that it meets the version requirements of the calling object. The dynamic loader retrieves the entries in the caller's Elfxx_Verneed array and attempts to find matching definition information in the loaded Elfxx_Verdef table.
</PARA>
<PARA>
Each object and dependency is tested in turn. If a symbol definition is missing, the loader returns an error. A warning is issued instead of a hard error when the vna_flags bit for VER_FLG_WEAK is set in the Elfxx_Vernaux entry.
</PARA>
<PARA>
When the versions referenced by undefined symbols in the loaded object are found, version availability is certified. The test completes without error and the object is made available.
</PARA>
</SECT1>
<SECT1 ID="symresolution">
<TITLE>Symbol Resolution</TITLE>
<PARA>
When symbol versioning is used in an object, relocations extend the performance of definition testing beyond the simple match of symbol name strings: the version of the reference must also equal the name of the definition. The same index that is used in the symbol table can be referenced in the SHT_GNU_versym section, and the value of this index is then used to acquire name data. The corresponding requirement string is retrieved from the Elfxx_Verneed array, and likewise, the corresponding definition string from the Elfxx_Verdef table.
</PARA>
<PARA>
Bit number 15 of the version symbol controls whether or not the object is hidden; if this bit is set, the object cannot be used and the static linker will ignore the symbol's presence in the object.
</PARA>
<PARA>
Results differ in the interaction of objects that variously use symbol versioning.
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
The object with the reference and the object with the definitions may both use versioning. All described matching is processed in this case. A fatal error is triggered when no matching definition can be found in the object whose name is the one referenced by the vn_name element in the Elfxx_Verneed entry.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The object with the reference may not use versioning, while the object with the definitions does. In this instance, only the definition with index numbers 1 and 2 will be used in the reference match, the same identified by the static linker as the base definition. In infrequent cases where the static linker was not used, as in calls to dlopen(), a version that does not have the base definition index is acceptable as long as it is the only version for which the symbol is defined.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
The object with the reference may use versioning, but the object with the definitions specifies none. A matching symbol is accepted in this case. A fatal error is triggered in the unlikely event that a corruption in the required symbols list obscured an outdated object file and caused a match on the object filename in the Elfxx_Verneed entry.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
Finally, both the object with the reference and the object with the definitions may not use versioning. The behavior in this instance defaults to pre-existing symbol rules.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</SECT1>
</CHAPTER>

<chapter id="noteABItag">
<TITLE>ABI note tag</TITLE>
<para>
Every executable shall contain a section named
<computeroutput>.note.ABI-tag</computeroutput> of type
<computeroutput>SHT_NOTE</computeroutput>.  This section is structured
as a note section as documented in the ELF spec.  The section must
contain at least the following entry.  The
<computeroutput>name</computeroutput> field
(<computeroutput>namesz</computeroutput>/<computeroutput>name</computeroutput>)
contains the string "<computeroutput>GNU</computeroutput>".  The
<computeroutput>type</computeroutput> field shall be 1.  The
<computeroutput>descsz</computeroutput> field shall be at least 16,
and the first 16 bytes of the <computeroutput>desc</computeroutput>
field shall be as follows.
</para>

<para>
The first 32-bit word of the <computeroutput>desc</computeroutput>
field must be 0 (this signifies a Linux executable).  The second,
third, and fourth 32-bit words of the
<computeroutput>desc</computeroutput> field contain the earliest
compatible kernel version.  For example, if the 3 words are 2, 2, and
5, this signifies a 2.2.5 kernel.
</para>
</chapter>
</PART>
