<PART ID="lowlevel">
<TITLE>Low Level System Information</TITLE>

<CHAPTER id=cxxclasses>
<TITLE>C++ Class Representations</TITLE>

<SECT1 ID="datarepresentation">
<TITLE>C++ Data Representation</TITLE>
<PARA>
Support for the C++ language shall be as specified in
<XREF LINKEND="std.CXXABI">. 
<NOTE><para>This document, although containing a few architecture specific
matters, is written as a generic specification, to be usable by C++
implementations on a variety of architectures.</para></NOTE>
This section provides additional information to
supplement <XREF LINKEND="std.CXXABI">. Many of the definitions
in that document are
made in terms of C++. This section provides addition explanations
using C terms to avoid self-referential problems.
</PARA>
<PARA>
</PARA>

<SECT2 ID="classes">
<TITLE>Class Representation</TITLE>
<PARA>
An object file generated by the compilation process for a C++ program shall
contain several closely related internal objects, or Class Components, to
represent each C++ Class. Such objects are not a visible part of the source
code. <XREF LINKEND="tbl-cxx-classrep">
describes these Class Components at a high level.
<TABLE ID="tbl-cxx-classrep">
<TITLE>Class Components</TITLE>
<TGROUP COLS=2>
<THEAD>
  <ROW>
    <ENTRY>Object</ENTRY>
    <ENTRY>Contains</ENTRY>
  </ROW>
</THEAD>
<TBODY>
  <ROW>
    <ENTRY>Class Data</ENTRY>
    <ENTRY>All non-static Class members</ENTRY>
  </ROW>
  <ROW>
    <ENTRY>Virtual Table</ENTRY>
    <ENTRY>Information needed to dispatch virtual functions, access virtual base class subobjects and to access the RTTI information</ENTRY>
  </ROW>
  <ROW>
    <ENTRY>RTTI</ENTRY>
    <ENTRY>Run-Time Type Information used by the typeid and dynamic_cast operators, and exception handlers</ENTRY>
  </ROW>
  <ROW>
    <ENTRY>Typeinfo Name</ENTRY>
    <ENTRY>String representation of Class name</ENTRY>
  </ROW>
  <ROW>
    <ENTRY>Construction Virtual Table</ENTRY>
    <ENTRY>Information needed during construction and destruction of Classes with non-trivial inheritance relationships.</ENTRY>
  </ROW>
  <ROW>
    <ENTRY>VTT</ENTRY>
    <ENTRY>A table of virtual table pointers which holds the addresses of construction and non-construction virtual tables.</ENTRY>
  </ROW>
</TBODY>
</TGROUP>
</TABLE>
</PARA>

<!-- SECT3 ID="classordering">
<TITLE>Class Ordering</TITLE>
<PARA>
Derived classes have a unique linear ordering of all base classes, referred to
as the Inheritance Graph Order. The ordering on a class object and all its
subobjects obtained by a depth-first traversal of its inheritance graph, from
the most-derived class object to base objects, where: 
</PARA>
<NOTE>
<PARA>
We need some good examples here.
</PARA>
</NOTE>
</SECT3 -->

<!-- SECT3 ID="classdata">
<TITLE>Class Data</TITLE>
<PARA>
Non-static class members are arranged as if in a C structure according to
the following rules.
</PARA>
<NOTE>
<PARA>
Fill in algorithm from Itanium C++ ABI document
</PARA>
</NOTE>
</SECT3 -->

<SECT3 ID="virtualtable">
<TITLE>Virtual Table</TITLE>
<PARA>
Virtual tables are specified in Section 2.5.3 of <XREF LINKEND="std.CXXABI">.
</PARA>
<PARA>
Of the various categories of virtual table described in that specification,
Category 1 (Leaf) is further described in <XREF LINKEND='cxx-virtualtable-cat1'> and
Category 2 (Non-virtual bases only) is further described in
<XREF LINKEND='cxx-virtualtable-cat2'>. 
LSB conforming systems shall support these
categories.
</PARA>
<FIGURE ID="CXX-virtualtable-cat1">
<TITLE>
Category 1 Virtual Table
</TITLE>
<SCREEN>
struct {
        ptrdiff_t       baseobject;
        const char      *typeinfo;
        fptr            virtfuncs[0];
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-virtualtable-cat2">
<TITLE>
Category 2 Virtual Table
</TITLE>
<SCREEN>
struct {
        unsigned long   vcalloffset;
        ptrdiff_t       baseobject;
        const char      *typeinfo;
        fptr            virtfuncs[0];
};
</SCREEN>
</FIGURE>

<para>
This specification describes requirements for virtual tables of C++ classes
using tables of the following form:
</para>

<table id="tbl-cxx-vtable">
<title>Primary vtable for K (example)</title>
<tgroup cols=2>
<!--thead>
</thead-->
<tbody>
<row>
<entry>Base Offset</entry>
<entry>0</entry>
</row>
<row>
<entry>Virtual Base Offset</entry>
<entry>0</entry>
</row>
<row>
<entry>RTTI</entry>
<entry>typeinfo for K</entry>
</row>
<row>
<entry>vfunc[0]:</entry>
<entry>K::~K()</entry>
</row>
<row>
<entry>vfunc[1]:</entry>
<entry>K::~K()</entry>
</row>
<row>
<entry>vfunc[2]:</entry>
<entry>K::m1(int*)</entry>
</row>
<row>
<entry>vfunc[3]:</entry>
<entry>X::m2()</entry>
</row>
<row>
<entry>vfunc[4]:</entry>
<entry><function>__cxa_pure_virtual</function></entry>
</row>
<row>
<entry>vfunc[5]:</entry>
<entry>NULL or X::m4(int)</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Each row starting from 'vfunc[i]:' refers to a vtable entry 'vfunc[i]' of a
class K, which is an entry for a virtual function A::m, where A is a base class
of the class K as described in the <XREF LINKEND="std.CXXABI">.
This specification requires implementations to interpret the vtable
entry information in the following way:
</para>

<orderedlist>
<listitem>
<para>
A conforming implementation shall contain a vtable of the class K
in the specified shared library;
</para>
</listitem>
<listitem>
<para>
The corresponding entry of this vtable 'vfunc[i]'
shall be an entry for the virtual function A::m;
</para>
</listitem>
<listitem>
<para>
If the second column of the row contains <function>__cxa_pure_virtual</function>
the corresponding vtable entry of a LSB-conforming implementation
shall contain <function>__cxa_pure_virtual</function> or 'Y::m',
where Y is the class K, the class A or
a base class of the class K derived from the class A.
<footnote>
<para>
In this case virtual function A::m in class K is considered
to be specified as pure virtual by this specification.
</para>
</footnote>
</para>
</listitem>
<listitem>
<para>
If the second column of the row contains 'X::m'
the corresponding vtable entry of a LSB-conforming implementation
shall contain 'Y::m', where Y is the class K, the class X
or a base class of the class K derived from the class X.
</para>
</listitem>
<listitem>
<para>
If the second column of the row contains 'NULL or X::m'
the corresponding vtable entry of a LSB-conforming implementation
shall contain NULL or 'Y::m', where Y is the class K, the class X
or a base class of the class K derived from the class X.
<footnote>
<para>
In this case virtual function A::m in class K is considered
to be specified as inline by this specification.
</para>
</footnote>
</para>
</listitem>
</orderedlist>

<para>
An application may use any non-pure virtual function
specified in this specification, and can expect the
specified behavior irrespective of which particular
method implements this functionality.
An application may not use inline virtual functions at the
binary level since its vtable entry may be <constant>NULL</constant>.
</para>
</SECT3>
<SECT3 ID="RTTI">
<TITLE>Run-Time Type Information</TITLE>
<PARA>
Each type used in a C++ program has a data structure associated with it that
provide information about the type which is used at runtime. This Run Time
Type Information (RTTI) is defined in section 2.9.5 in
<XREF LINKEND="std.CXXABI">. Additional details about the layout of this
data is provided here.
</PARA>
<FIGURE ID="CXX-RTTI">
<TITLE>
Run-Time Type Information Prefix
</TITLE>
<SCREEN>
struct {
       void      *basevtable;
       char      *name;
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-RTTI-class">
<TITLE>
Run-Time Type Information For Classes with no base class
</TITLE>
<SCREEN>
struct {
       void      *basevtable;
       char      *name;
       void      *basetypeinfo[0];
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-RTTI-siclass">
<TITLE>
Run-Time Type Information for Classes with a single base class
</TITLE>
<SCREEN>
struct {
       void      *basevtable;
       char      *name;
       void      *basetype;
       void      *basetypeinfo[0];
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-RTTI-vmiclass">
<TITLE>
Run-Time Type Information for classes with multiple inheritance
</TITLE>
<SCREEN>
struct base_type_info {
       char    *base_type;
       unsigned long   offset_flags;
};

struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       unsigned int    base_count;
       struct base_type_info base_info[0];
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-RTTI-pointerclass">
<TITLE>
Run-Time Type Information for pointer types
</TITLE>
<SCREEN>
struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       void    *pointee;
       void    *basetypeinfo[0];
};
</SCREEN>
</FIGURE>
<FIGURE ID="CXX-RTTI-ptomemberclass">
<TITLE>
Run-Time Type Information for pointer to member types
</TITLE>
<SCREEN>
struct {
       void    *basevtable;
       char    *name;
       unsigned int    flags;
       void    *pointee;
       void    *context;
       void    *basetypeinfo[0];
};
</SCREEN>
</FIGURE>
</SECT3>
<!--
<SECT3 ID="typeinfoname">
<TITLE>Typeinfo Name</TITLE>
<PARA>
</PARA>
</SECT3>
<SECT3 ID="constructionvirtualtable">
<TITLE>Construction Virtual Table</TITLE>
<PARA>
</PARA>
<FIGURE ID="CXX-CVT">
<TITLE>
Construction Virtual Table Prefix
</TITLE>
<SCREEN>
struct {
       ????
};
</SCREEN>
</FIGURE>
</SECT3>
<SECT3 ID="virtualtypetable">
<TITLE>Virtual Type Tables </TITLE>
<PARA>
</PARA>
<FIGURE ID="CXX-VTT">
<TITLE>
Virtual Type Table Prefix
</TITLE>
<SCREEN>
struct {
       ???
};
</SCREEN>
</FIGURE>
</SECT3>
-->
</SECT2>
</SECT1>

</CHAPTER>
<CHAPTER ID=Symmap.cxx>
<TITLE>Symbol Mapping</TITLE>
<PARA>
This chapter defines how names are mapped from the source symbol to
the object symbol.
</PARA>
<SECT1 ID="symmapping">
<TITLE>Symbol Mapping</TITLE>
<PARA>
Symbols in a source program are translated by the compilation system into
symbols that exist in the object file. The rules for this translation are
defined here.
</PARA>
<SECT2>
<TITLE>C++ Language</TITLE>
<PARA>

External symbol names in a C++ object file shall be encoded according to 
the "name mangling" rules described in the <XREF LINKEND="std.CXXABI">.
</PARA>
</SECT2>
</SECT1>
</CHAPTER>

</PART>
