<TABLE border=1><TR><TH>Function</TH><TH>Include</TH><TH>Standard</TH></TR>
<TR>
<TD>void abort (void)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int abs (int NUMBER)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int accept (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int access (const char *FILENAME, int HOW)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double acosh (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double acos (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int adjtime (const struct timeval *DELTA, struct timeval *OLDDELTA)</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>AF_FILE</TD>
     <TD>sys/socket.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>AF_INET6</TD>
     <TD>sys/socket.h</TD> <TD>(IPv6 Basic API)</TD>
</TR><TR>
<TD>AF_INET</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>AF_UNIX</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>AF_UNSPEC</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned int alarm (unsigned int SECONDS)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void * alloca (size_t SIZE);</TD>
     <TD>stdlib.h</TD> <TD>(GNU, BSD)</TD>
</TR><TR>
<TD>tcflag_t ALTWERASE</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int ARG_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * asctime (const struct tm *BROKENTIME)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double asinh (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double asin (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int asprintf (char **PTR, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void assert (int EXPRESSION)</TD>
     <TD>assert.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void assert_perror (int ERRNUM)</TD>
     <TD>assert.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>double atan2 (double Y, double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double atanh (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double atan (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int atexit (void (*FUNCTION) (void))</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double atof (const char *STRING)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int atoi (const char *STRING)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>long int atol (const char *STRING)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>B0</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B110</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B1200</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B134</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B150</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B1800</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B19200</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B200</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B2400</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B300</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B38400</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B4800</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B50</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B600</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B75</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>B9600</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int BC_BASE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int BC_DIM_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int BC_DIM_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int bcmp (const void *A1, const void *A2, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * bcopy (void *FROM, const void *TO, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int BC_SCALE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int BC_STRING_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int bind (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t BRKINT</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_BSD_SOURCE</TD>
<TD>&nbsp;</TD><TD>(GNU)</TD>
</TR><TR>
<TD>void * bsearch (const void *KEY, const void *ARRAY, size_t COUNT, size_t SIZE,
 comparison_fn_t COMPARE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int BUFSIZ</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void * bzero (void *BLOCK, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double cabs (struct { double real, imag; } Z)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * calloc (size_t COUNT, size_t ELTSIZE)</TD>
     <TD>malloc.h, stdlib.h</TD><TD>(ISO)</TD>
</TR><TR>
<TD>double cbrt (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>cc_t</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CCTS_OFLOW</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double ceil (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>speed_t cfgetispeed (const struct termios *TERMIOS-P)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>speed_t cfgetospeed (const struct termios *TERMIOS-P)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int cfmakeraw (struct termios *TERMIOS-P)</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void cfree (void *PTR)</TD>
     <TD>stdlib.h</TD> <TD>(Sun)</TD>
</TR><TR>
<TD>int cfsetispeed (struct termios *TERMIOS-P, speed_t SPEED)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int cfsetospeed (struct termios *TERMIOS-P, speed_t SPEED)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int cfsetspeed (struct termios *TERMIOS-P, speed_t SPEED)</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>CHAR_BIT</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>CHAR_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>CHAR_MIN</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int chdir (const char *FILENAME)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int CHILD_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int chmod (const char *FILENAME, mode_t MODE)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int chown (const char *FILENAME, uid_t OWNER, gid_t GROUP)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CIGNORE</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void clearerr (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int CLK_TCK</TD>
     <TD>time.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CLOCAL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>clock_t clock (void)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int CLOCKS_PER_SEC</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>clock_t</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int closedir (DIR *DIRSTREAM)</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int close (int FILEDES)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int COLL_WEIGHTS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>size_t confstr (int PARAMETER, char *BUF, size_t LEN)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int connect (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>cookie_close_function</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>cookie_io_functions_t</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>cookie_read_function</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>cookie_seek_function</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>cookie_write_function</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>double copysign (double VALUE, double SIGN)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double cosh (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double cos (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>tcflag_t CREAD</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int creat (const char *FILENAME, mode_t MODE)</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CRTS_IFLOW</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t CS5</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CS6</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CS7</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CS8</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t CSIZE</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_CS_PATH</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>tcflag_t CSTOPB</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * ctermid (char *STRING)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * ctime (const time_t *TIME)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * cuserid (char *STRING)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int daylight</TD>
     <TD>time.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>DBL_DIG</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_EPSILON</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MANT_DIG</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MAX_10_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MAX_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MAX</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MIN_10_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MIN_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DBL_MIN</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>dev_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double difftime (time_t TIME1, time_t TIME0)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>DIR</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>div_t div (int NUMERATOR, int DENOMINATOR)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>div_t</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double drem (double NUMERATOR, double DENOMINATOR)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int dup2 (int OLD, int NEW)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int dup (int OLD)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int E2BIG</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Argument list too long)</TD>
</TR><TR>
<TD>int EACCES</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Permission denied)</TD>
</TR><TR>
<TD>int EADDRINUSE</TD>
     <TD>errno.h</TD> <TD>(BSD: Address already in use)</TD>
</TR><TR>
<TD>int EADDRNOTAVAIL</TD>
     <TD>errno.h</TD> <TD>(BSD: Cannot assign requested address)</TD>
</TR><TR>
<TD>int EADV</TD>
     <TD>errno.h</TD> <TD>(Linux???: Advertise error)</TD>
</TR><TR>
<TD>int EAFNOSUPPORT</TD>
     <TD>errno.h</TD> <TD>(BSD: Address family not supported by protocol)</TD>
</TR><TR>
<TD>int EAGAIN</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Resource temporarily unavailable)</TD>
</TR><TR>
<TD>int EALREADY</TD>
     <TD>errno.h</TD> <TD>(BSD: Operation already in progress)</TD>
</TR><TR>
<TD>int EAUTH</TD>
     <TD>errno.h</TD> <TD>(BSD: Authentication error)</TD>
</TR><TR>
<TD>int EBACKGROUND</TD>
     <TD>errno.h</TD> <TD>(GNU: Inappropriate operation for background process)</TD>
     
</TR><TR>
<TD>int EBADE</TD>
     <TD>errno.h</TD> <TD>(Linux???: Invalid exchange)</TD>
</TR><TR>
<TD>int EBADFD</TD>
     <TD>errno.h</TD> <TD>(Linux???: File descriptor in bad state)</TD>
</TR><TR>
<TD>int EBADF</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Bad file descriptor)</TD>
</TR><TR>
<TD>int EBADMSG</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Bad message)</TD>
</TR><TR>
<TD>int EBADR</TD>
     <TD>errno.h</TD> <TD>(Linux???: Invalid request descriptor)</TD>
</TR><TR>
<TD>int EBADRPC</TD>
     <TD>errno.h</TD> <TD>(BSD: RPC struct is bad)</TD>
</TR><TR>
<TD>int EBADRQC</TD>
     <TD>errno.h</TD> <TD>(Linux???: Invalid request code)</TD>
</TR><TR>
<TD>int EBADSLT</TD>
     <TD>errno.h</TD> <TD>(Linux???: Invalid slot)</TD>
</TR><TR>
<TD>int EBFONT</TD>
     <TD>errno.h</TD> <TD>(Linux???: Bad font file format)</TD>
</TR><TR>
<TD>int EBUSY</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Device or resource busy)</TD>
</TR><TR>
<TD>int ECHILD</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: No child processes)</TD>
</TR><TR>
<TD>tcflag_t ECHOCTL</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t ECHOE</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ECHO</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ECHOKE</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t ECHOK</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ECHONL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ECHOPRT</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int ECHRNG</TD>
     <TD>errno.h</TD> <TD>(Linux???: Channel number out of range)</TD>
</TR><TR>
<TD>int ECOMM</TD>
     <TD>errno.h</TD> <TD>(Linux???: Communication error on send)</TD>
</TR><TR>
<TD>int ECONNABORTED</TD>
     <TD>errno.h</TD> <TD>(BSD: Software caused connection abort)</TD>
</TR><TR>
<TD>int ECONNREFUSED</TD>
     <TD>errno.h</TD> <TD>(BSD: Connection refused)</TD>
</TR><TR>
<TD>int ECONNRESET</TD>
     <TD>errno.h</TD> <TD>(BSD: Connection reset by peer)</TD>
</TR><TR>
<TD>int EDEADLK</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Resource deadlock avoided)</TD>
</TR><TR>
<TD>int EDEADLOCK</TD>
     <TD>errno.h</TD> <TD>(Linux???: File locking deadlock error)</TD>
</TR><TR>
<TD>int EDESTADDRREQ</TD>
     <TD>errno.h</TD> <TD>(BSD: Destination address required)</TD>
</TR><TR>
<TD>int EDIED</TD>
     <TD>errno.h</TD> <TD>(GNU: Translator died)</TD>
</TR><TR>
<TD>int ED</TD>
     <TD>errno.h</TD> <TD>(GNU: ?)</TD>
</TR><TR>
<TD>int EDOM</TD>
     <TD>errno.h</TD> <TD>(ISO: Numerical argument out of domain)</TD>
</TR><TR>
<TD>int EDOTDOT</TD>
     <TD>errno.h</TD> <TD>(Linux???: RFS specific error)</TD>
</TR><TR>
<TD>int EDQUOT</TD>
     <TD>errno.h</TD> <TD>(BSD: Disc quota exceeded)</TD>
</TR><TR>
<TD>int EEXIST</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: File exists)</TD>
</TR><TR>
<TD>int EFAULT</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Bad address)</TD>
</TR><TR>
<TD>int EFBIG</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: File too large)</TD>
</TR><TR>
<TD>int EFTYPE</TD>
     <TD>errno.h</TD> <TD>(BSD: Inappropriate file type or format)</TD>
</TR><TR>
<TD>int EGRATUITOUS</TD>
     <TD>errno.h</TD> <TD>(GNU: Gratuitous error)</TD>
</TR><TR>
<TD>int EGREGIOUS</TD>
     <TD>errno.h</TD> <TD>(GNU: You really blew it this time)</TD>
</TR><TR>
<TD>int EHOSTDOWN</TD>
     <TD>errno.h</TD> <TD>(BSD: Host is down)</TD>
</TR><TR>
<TD>int EHOSTUNREACH</TD>
     <TD>errno.h</TD> <TD>(BSD: No route to host)</TD>
</TR><TR>
<TD>int EIDRM</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Identifier removed)</TD>
</TR><TR>
<TD>int EIEIO</TD>
     <TD>errno.h</TD> <TD>(GNU: Computer bought the farm)</TD>
</TR><TR>
<TD>int EILSEQ</TD>
     <TD>errno.h</TD> <TD>(ISO: Invalid or incomplete multibyte or wide
     character)</TD>
</TR><TR>
<TD>int EINPROGRESS</TD>
     <TD>errno.h</TD> <TD>(BSD: Operation now in progress)</TD>
</TR><TR>
<TD>int EINTR</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Interrupted system call)</TD>
</TR><TR>
<TD>int EINVAL</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Invalid argument)</TD>
</TR><TR>
<TD>int EIO</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Input/output error)</TD>
</TR><TR>
<TD>int EISCONN</TD>
     <TD>errno.h</TD> <TD>(BSD: Transport endpoint is already connected)</TD>
</TR><TR>
<TD>int EISDIR</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Is a directory)</TD>
</TR><TR>
<TD>int EISNAM</TD>
     <TD>errno.h</TD> <TD>(Linux???: Is a named type file)</TD>
</TR><TR>
<TD>int EL2HLT</TD>
     <TD>errno.h</TD> <TD>(Linux???: Level 2 halted)</TD>
</TR><TR>
<TD>int EL2NSYNC</TD>
     <TD>errno.h</TD> <TD>(Linux???: Level 2 not synchronized)</TD>
</TR><TR>
<TD>int EL3HLT</TD>
     <TD>errno.h</TD> <TD>(Linux???: Level 3 halted)</TD>
</TR><TR>
<TD>int EL3RST</TD>
     <TD>errno.h</TD> <TD>(Linux???: Level 3 reset)</TD>
</TR><TR>
<TD>int ELIBACC</TD>
     <TD>errno.h</TD> <TD>(Linux???: Can not access a needed shared library)</TD>
     
</TR><TR>
<TD>int ELIBBAD</TD>
     <TD>errno.h</TD> <TD>(Linux???: Accessing a corrupted shared library)</TD>
</TR><TR>
<TD>int ELIBEXEC</TD>
     <TD>errno.h</TD> <TD>(Linux???: Cannot exec a shared library directly)</TD>
     
</TR><TR>
<TD>int ELIBMAX</TD>
     <TD>errno.h</TD> <TD>(Linux???: Attempting to link in too many shared
     libraries)</TD>
</TR><TR>
<TD>int ELIBSCN</TD>
     <TD>errno.h</TD> <TD>(Linux???: .lib section in a.out corrupted)</TD>
</TR><TR>
<TD>int ELNRNG</TD>
     <TD>errno.h</TD> <TD>(Linux???: Link number out of range)</TD>
</TR><TR>
<TD>int ELOOP</TD>
     <TD>errno.h</TD> <TD>(BSD: Too many levels of symbolic links)</TD>
</TR><TR>
<TD>int EMFILE</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Too many open files)</TD>
</TR><TR>
<TD>int EMLINK</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Too many links)</TD>
</TR><TR>
<TD>int EMSGSIZE</TD>
     <TD>errno.h</TD> <TD>(BSD: Message too long)</TD>
</TR><TR>
<TD>int EMULTIHOP</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Multihop attempted)</TD>
</TR><TR>
<TD>int ENAMETOOLONG</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: File name too long)</TD>
</TR><TR>
<TD>int ENAVAIL</TD>
     <TD>errno.h</TD> <TD>(Linux???: No XENIX semaphores available)</TD>
</TR><TR>
<TD>void endgrent (void)</TD>
     <TD>grp.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>void endhostent ()</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void endnetent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void endnetgrent (void)</TD>
     <TD>netdb.h</TD> <TD>(netdb.h)</TD>
</TR><TR>
<TD>void endprotoent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void endpwent (void)</TD>
     <TD>pwd.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>void endservent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int ENEEDAUTH</TD>
     <TD>errno.h</TD> <TD>(BSD: Need authenticator)</TD>
</TR><TR>
<TD>int ENETDOWN</TD>
     <TD>errno.h</TD> <TD>(BSD: Network is down)</TD>
</TR><TR>
<TD>int ENETRESET</TD>
     <TD>errno.h</TD> <TD>(BSD: Network dropped connection on reset)</TD>
</TR><TR>
<TD>int ENETUNREACH</TD>
     <TD>errno.h</TD> <TD>(BSD: Network is unreachable)</TD>
</TR><TR>
<TD>int ENFILE</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Too many open files in system)</TD>
</TR><TR>
<TD>int ENOANO</TD>
     <TD>errno.h</TD> <TD>(Linux???: No anode)</TD>
</TR><TR>
<TD>int ENOBUFS</TD>
     <TD>errno.h</TD> <TD>(BSD: No buffer space available)</TD>
</TR><TR>
<TD>int ENOCSI</TD>
     <TD>errno.h</TD> <TD>(Linux???: No CSI structure available)</TD>
</TR><TR>
<TD>int ENODATA</TD>
     <TD>errno.h</TD> <TD>(XOPEN: No data available)</TD>
</TR><TR>
<TD>int ENODEV</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Operation not supported by device)</TD>
</TR><TR>
<TD>int ENOENT</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: No such file or directory)</TD>
</TR><TR>
<TD>int ENOEXEC</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Exec format error)</TD>
</TR><TR>
<TD>int ENOLCK</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: No locks available)</TD>
</TR><TR>
<TD>int ENOLINK</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Link has been severed)</TD>
</TR><TR>
<TD>int ENOMEM</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Cannot allocate memory)</TD>
</TR><TR>
<TD>int ENOMSG</TD>
     <TD>errno.h</TD> <TD>(XOPEN: No message of desired type)</TD>
</TR><TR>
<TD>int ENONET</TD>
     <TD>errno.h</TD> <TD>(Linux???: Machine is not on the network)</TD>
</TR><TR>
<TD>int ENOPKG</TD>
     <TD>errno.h</TD> <TD>(Linux???: Package not installed)</TD>
</TR><TR>
<TD>int ENOPROTOOPT</TD>
     <TD>errno.h</TD> <TD>(BSD: Protocol not available)</TD>
</TR><TR>
<TD>int ENOSPC</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: No space left on device)</TD>
</TR><TR>
<TD>int ENOSR</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Out of streams resources)</TD>
</TR><TR>
<TD>int ENOSTR</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Device not a stream)</TD>
</TR><TR>
<TD>int ENOSYS</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Function not implemented)</TD>
</TR><TR>
<TD>int ENOTBLK</TD>
     <TD>errno.h</TD> <TD>(BSD: Block device required)</TD>
</TR><TR>
<TD>int ENOTCONN</TD>
     <TD>errno.h</TD> <TD>(BSD: Transport endpoint is not connected)</TD>
</TR><TR>
<TD>int ENOTDIR</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Not a directory)</TD>
</TR><TR>
<TD>int ENOTEMPTY</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Directory not empty)</TD>
</TR><TR>
<TD>int ENOTNAM</TD>
     <TD>errno.h</TD> <TD>(Linux???: Not a XENIX named type file)</TD>
</TR><TR>
<TD>int ENOTSOCK</TD>
     <TD>errno.h</TD> <TD>(BSD: Socket operation on non-socket)</TD>
</TR><TR>
<TD>int ENOTTY</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Inappropriate ioctl for device)</TD>
</TR><TR>
<TD>int ENOTUNIQ</TD>
     <TD>errno.h</TD> <TD>(Linux???: Name not unique on network)</TD>
</TR><TR>
<TD>char ** environ</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int ENXIO</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Device not configured)</TD>
</TR><TR>
<TD>int EOF</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int EOPNOTSUPP</TD>
     <TD>errno.h</TD> <TD>(BSD: Operation not supported)</TD>
</TR><TR>
<TD>int EOVERFLOW</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Value too large for defined data type)</TD>
</TR><TR>
<TD>int EPERM</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Operation not permitted)</TD>
</TR><TR>
<TD>int EPFNOSUPPORT</TD>
     <TD>errno.h</TD> <TD>(BSD: Protocol family not supported)</TD>
</TR><TR>
<TD>int EPIPE</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Broken pipe)</TD>
</TR><TR>
<TD>int EPROCLIM</TD>
     <TD>errno.h</TD> <TD>(BSD: Too many processes)</TD>
</TR><TR>
<TD>int EPROCUNAVAIL</TD>
     <TD>errno.h</TD> <TD>(BSD: RPC bad procedure for program)</TD>
</TR><TR>
<TD>int EPROGMISMATCH</TD>
     <TD>errno.h</TD> <TD>(BSD: RPC program version wrong)</TD>
</TR><TR>
<TD>int EPROGUNAVAIL</TD>
     <TD>errno.h</TD> <TD>(BSD: RPC program not available)</TD>
</TR><TR>
<TD>int EPROTO</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Protocol error)</TD>
</TR><TR>
<TD>int EPROTONOSUPPORT</TD>
     <TD>errno.h</TD> <TD>(BSD: Protocol not supported)</TD>
</TR><TR>
<TD>int EPROTOTYPE</TD>
     <TD>errno.h</TD> <TD>(BSD: Protocol wrong type for socket)</TD>
</TR><TR>
<TD>int EQUIV_CLASS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int ERANGE</TD>
     <TD>errno.h</TD> <TD>(ISO: Numerical result out of range)</TD>
</TR><TR>
<TD>int EREMCHG</TD>
     <TD>errno.h</TD> <TD>(Linux???: Remote address changed)</TD>
</TR><TR>
<TD>int EREMOTEIO</TD>
     <TD>errno.h</TD> <TD>(Linux???: Remote I/O error)</TD>
</TR><TR>
<TD>int EREMOTE</TD>
     <TD>errno.h</TD> <TD>(BSD: Object is remote)</TD>
</TR><TR>
<TD>int ERESTART</TD>
     <TD>errno.h</TD> <TD>(Linux???: Interrupted system call should be restarted)</TD>
     
</TR><TR>
<TD>int EROFS</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Read-only file system)</TD>
</TR><TR>
<TD>int ERPCMISMATCH</TD>
     <TD>errno.h</TD> <TD>(BSD: RPC version wrong)</TD>
</TR><TR>
<TD>volatile int errno</TD>
     <TD>errno.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int ESHUTDOWN</TD>
     <TD>errno.h</TD> <TD>(BSD: Cannot send after transport endpoint shutdown)</TD>
     
</TR><TR>
<TD>int ESOCKTNOSUPPORT</TD>
     <TD>errno.h</TD> <TD>(BSD: Socket type not supported)</TD>
</TR><TR>
<TD>int ESPIPE</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Illegal seek)</TD>
</TR><TR>
<TD>int ESRCH</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: No such process)</TD>
</TR><TR>
<TD>int ESRMNT</TD>
     <TD>errno.h</TD> <TD>(Linux???: Srmount error)</TD>
</TR><TR>
<TD>int ESTALE</TD>
     <TD>errno.h</TD> <TD>(BSD: Stale NFS file handle)</TD>
</TR><TR>
<TD>int ESTRPIPE</TD>
     <TD>errno.h</TD> <TD>(Linux???: Streams pipe error)</TD>
</TR><TR>
<TD>int ETIMEDOUT</TD>
     <TD>errno.h</TD> <TD>(BSD: Connection timed out)</TD>
</TR><TR>
<TD>int ETIME</TD>
     <TD>errno.h</TD> <TD>(XOPEN: Timer expired)</TD>
</TR><TR>
<TD>int ETOOMANYREFS</TD>
     <TD>errno.h</TD> <TD>(BSD: Too many references: cannot splice)</TD>
</TR><TR>
<TD>int ETXTBSY</TD>
     <TD>errno.h</TD> <TD>(BSD: Text file busy)</TD>
</TR><TR>
<TD>int EUCLEAN</TD>
     <TD>errno.h</TD> <TD>(Linux???: Structure needs cleaning)</TD>
</TR><TR>
<TD>int EUNATCH</TD>
     <TD>errno.h</TD> <TD>(Linux???: Protocol driver not attached)</TD>
</TR><TR>
<TD>int EUSERS</TD>
     <TD>errno.h</TD> <TD>(BSD: Too many users)</TD>
</TR><TR>
<TD>int EWOULDBLOCK</TD>
     <TD>errno.h</TD> <TD>(BSD: Operation would block)</TD>
</TR><TR>
<TD>int EXDEV</TD>
     <TD>errno.h</TD> <TD>(POSIX.1: Invalid cross-device link)</TD>
</TR><TR>
<TD>int execle (const char *FILENAME, const char *ARG0, char *const ENV[], ...)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int execl (const char *FILENAME, const char *ARG0, ...)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int execlp (const char *FILENAME, const char *ARG0, ...)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int execve (const char *FILENAME, char *const ARGV[], char *const ENV[])</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int execv (const char *FILENAME, char *const ARGV[])</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int execvp (const char *FILENAME, char *const ARGV[])</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int EXFULL</TD>
     <TD>errno.h</TD> <TD>(Linux???: Exchange full)</TD>
</TR><TR>
<TD>int EXIT_FAILURE</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void _exit (int STATUS)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void exit (int STATUS)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int EXIT_SUCCESS</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double exp (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double expm1 (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int EXPR_NEST_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>double fabs (double NUMBER)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fchmod (int FILEDES, int MODE)</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int fchown (int FILEDES, int OWNER, int GROUP)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int fclean (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int fcloseall (void)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int fclose (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fcntl (int FILEDES, int COMMAND, ...)</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int FD_CLOEXEC</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void FD_CLR (int FILEDES, fd_set *SET)</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int FD_ISSET (int FILEDES, fd_set *SET)</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FILE * fdopen (int FILEDES, const char *OPENTYPE)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void FD_SET (int FILEDES, fd_set *SET)</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>fd_set</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int FD_SETSIZE</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int F_DUPFD</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void FD_ZERO (fd_set *SET)</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int feof (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int ferror (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fflush (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fgetc (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int F_GETFD</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_GETFL</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct group * fgetgrent (FILE *STREAM)</TD>
     <TD>grp.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int fgetgrent_r (FILE *STREAM, struct group *RESULT_BUF, char *BUFFER, size_t
BUFLEN, struct group **RESULT)</TD>
     <TD>grp.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int F_GETLK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_GETOWN</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int fgetpos (FILE *STREAM, fpos_t *POSITION)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>struct passwd * fgetpwent (FILE *STREAM)</TD>
     <TD>pwd.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int fgetpwent_r (FILE *STREAM, struct passwd *RESULT_BUF, char *BUFFER, size_t
 BUFLEN, struct passwd **RESULT)</TD>
     <TD>pwd.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * fgets (char *S, int COUNT, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FILE</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int FILENAME_MAX</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fileno (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int finite (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double floor (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_DIG</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_EPSILON</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MANT_DIG</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MAX_10_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MAX_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MAX</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MIN_10_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MIN_EXP</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_MIN</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_RADIX</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>FLT_ROUNDS</TD>
     <TD>float.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>tcflag_t FLUSHO</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FILE * fmemopen (void *BUF, size_t SIZE, const char *OPENTYPE)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>double fmod (double NUMERATOR, double DENOMINATOR)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fnmatch (const char *PATTERN, const char *STRING, int FLAGS)</TD>
     <TD>fnmatch.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>FNM_CASEFOLD</TD>
     <TD>fnmatch.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>FNM_FILE_NAME</TD>
     <TD>fnmatch.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>FNM_LEADING_DIR</TD>
     <TD>fnmatch.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>FNM_NOESCAPE</TD>
     <TD>fnmatch.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>FNM_PATHNAME</TD>
     <TD>fnmatch.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>FNM_PERIOD</TD>
     <TD>fnmatch.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int F_OK</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * fopencookie (void *COOKIE, const char *OPENTYPE, cookie_io_functions_t
IO-FUNCTIONS)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>FILE * fopen (const char *FILENAME, const char *OPENTYPE)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int FOPEN_MAX</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>pid_t fork (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>long int fpathconf (int FILEDES, int PARAMETER)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FPE_DECOVF_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTDIV_FAULT</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTDIV_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTOVF_FAULT</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTOVF_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTUND_FAULT</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_FLTUND_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_INTDIV_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_INTOVF_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>FPE_SUBRNG_TRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>fpos_t</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fprintf (FILE *STREAM, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fputc (int C, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fputs (const char *S, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>F_RDLCK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>size_t fread (void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>__free_hook</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void free (void *PTR)</TD>
     <TD>malloc.h, stdlib.h </TD><TD>(ISO)</TD>
</TR><TR>
<TD>FILE * freopen (const char *FILENAME, const char *OPENTYPE, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double frexp (double VALUE, int *EXPONENT)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fscanf (FILE *STREAM, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fseek (FILE *STREAM, long int OFFSET, int WHENCE)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int F_SETFD</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_SETFL</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_SETLK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_SETLKW</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int F_SETOWN</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int fsetpos (FILE *STREAM, const fpos_t POSITION)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int fstat (int FILEDES, struct stat *BUF)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>long int ftell (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>F_UNLCK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>size_t fwrite (const void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>F_WRLCK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getchar (void)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int getc (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * getcwd (char *BUFFER, size_t SIZE)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>ssize_t getdelim (char **LINEPTR, size_t *N, int DELIMITER, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>gid_t getegid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * getenv (const char *NAME)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>uid_t geteuid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>gid_t getgid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct group * getgrent (void)</TD>
     <TD>grp.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int getgrent_r (struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct
group **RESULT)</TD>
     <TD>grp.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct group * getgrgid (gid_t GID)</TD>
     <TD>grp.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getgrgid_r (gid_t GID, struct group *RESULT_BUF, char *BUFFER, size_t BUFL
EN, struct group **RESULT)</TD>
     <TD>grp.h</TD> <TD>(POSIX.1c)</TD>
</TR><TR>
<TD>struct group * getgrnam (const char *NAME)</TD>
     <TD>grp.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int getgrnam_r (const char *NAME, struct group *RESULT_BUF, char *BUFFER, size
_t BUFLEN, struct group **RESULT)</TD>
     <TD>grp.h</TD> <TD>(POSIX.1c)</TD>
</TR><TR>
<TD>int getgroups (int COUNT, gid_t *GROUPS)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct hostent * gethostbyaddr (const char *ADDR, int LENGTH, int FORMAT)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct hostent * gethostbyname2 (const char *NAME, int AF)</TD>
     <TD>netdb.h</TD> <TD>(IPv6 Basic API)</TD>
</TR><TR>
<TD>struct hostent * gethostbyname (const char *NAME)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct hostent * gethostent ()</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>long int gethostid (void)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int gethostname (char *NAME, size_t SIZE)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getitimer (int WHICH, struct itimerval *OLD)</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>ssize_t getline (char **LINEPTR, size_t *N, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * getlogin (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct netent * getnetbyaddr (long NET, int TYPE)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct netent * getnetbyname (const char *NAME)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct netent * getnetent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getnetgrent (char **HOSTP, char **USERP, char **DOMAINP)</TD>
     <TD>netdb.h</TD> <TD>(netdb.h)</TD>
</TR><TR>
<TD>int getnetgrent_r (char **HOSTP, char **USERP, char **DOMAINP, char *BUFFER, i
nt BUFLEN)</TD>
     <TD>netdb.h</TD> <TD>(netdb.h)</TD>
</TR><TR>
<TD>int getopt (int ARGC, char **ARGV, const char *OPTIONS)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int getopt_long (int ARGC, char **ARGV, const char *SHORTOPTS, struct option *
LONGOPTS, int *INDEXPTR)</TD>
     <TD>getopt.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int getpeername (int SOCKET, struct sockaddr *ADDR, size_t *LENGTH-PTR)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t getpgrp (pid_t PID)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t getpgrp (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>pid_t getpid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>pid_t getppid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getpriority (int CLASS, int ID)</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct protoent * getprotobyname (const char *NAME)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct protoent * getprotobynumber (int PROTOCOL)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct protoent * getprotoent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct passwd * getpwent (void)</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getpwent_r (struct passwd *RESULT_BUF, char *BUFFER, int BUFLEN, struct pa
sswd **RESULT)</TD>
     <TD>pwd.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct passwd * getpwnam (const char *NAME)</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getpwnam_r (const char *NAME, struct passwd *RESULT_BUF, char *BUFFER, siz
e_t BUFLEN, struct passwd **RESULT)</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1c)</TD>
</TR><TR>
<TD>struct passwd * getpwuid (uid_t UID)</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int getpwuid_r (uid_t UID, struct passwd *RESULT_BUF, char *BUFFER, size_t BUF
LEN, struct passwd **RESULT)</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1c)</TD>
</TR><TR>
<TD>int getrlimit (int RESOURCE, struct rlimit *RLP)</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getrusage (int PROCESSES, struct rusage *RUSAGE)</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct servent * getservbyname (const char *NAME, const char *PROTO)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct servent * getservbyport (int PORT, const char *PROTO)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct servent * getservent (void)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * gets (char *S)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int getsockname (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void *OPTVAL, socklen_t *O
PTLEN-PTR)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getsubopt (char **OPTIONP, const char* const *TOKENS, char **VALUEP)</TD>
     <TD>stdlib.h</TD> <TD>(stdlib.h)</TD>
</TR><TR>
<TD>int gettimeofday (struct timeval *TP, struct timezone *TZP)</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>uid_t getuid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>mode_t getumask (void)</TD>
     <TD>sys/stat.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * getwd (char *BUFFER)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int getw (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>gid_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>GLOB_ABORTED</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_APPEND</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_DOOFFS</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_ERR</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int glob (const char *PATTERN, int FLAGS, int (*ERRFUNC) (const char *FILENAME
, int ERROR-CODE), glob_t *VECTOR-PTR)</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_MARK</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_NOCHECK</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_NOESCAPE</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_NOMATCH</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_NOSORT</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>GLOB_NOSPACE</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>glob_t</TD>
     <TD>glob.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>struct tm * gmtime (const time_t *TIME)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>_GNU_SOURCE</TD>
<TD>&nbsp;</TD><TD>(GNU)</TD>
</TR><TR>
<TD>int gsignal (int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>HOST_NOT_FOUND</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned long int htonl (unsigned long int HOSTLONG)</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned short int htons (unsigned short int HOSTSHORT)</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>float HUGE_VALf</TD>
     <TD>math.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>double HUGE_VAL</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>long double HUGE_VALl</TD>
     <TD>math.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>tcflag_t HUPCL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double hypot (double X, double Y)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t ICANON</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ICRNL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IEXTEN</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IGNBRK</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IGNCR</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IGNPAR</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IMAXBEL</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct in6_addr in6addr_any</TD>
     <TD>netinet/in.h</TD> <TD>(IPv6 basic API)</TD>
</TR><TR>
<TD>struct in6_addr in6addr_loopback.</TD>
     <TD>netinet/in.h</TD> <TD>(IPv6 basic API)</TD>
</TR><TR>
<TD>unsigned int INADDR_ANY</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned int INADDR_BROADCAST</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned int INADDR_LOOPBACK</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned int INADDR_NONE</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * index (const char *STRING, int C)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned long int inet_addr (const char *NAME)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int inet_aton (const char *NAME, struct in_addr *ADDR)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int inet_lnaof (struct in_addr ADDR)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct in_addr inet_makeaddr (int NET, int LOCAL)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int inet_netof (struct in_addr ADDR)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned long int inet_network (const char *NAME)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * inet_ntoa (struct in_addr ADDR)</TD>
     <TD>arpa/inet.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * inet_ntop (int AF, const void *CP, char *BUF, size_t LEN)</TD>
     <TD>arpa/inet.h</TD> <TD>(IPv6 basic API)</TD>
</TR><TR>
<TD>int inet_pton (int AF, const char *CP, void *BUF)</TD>
     <TD>arpa/inet.h</TD> <TD>(IPv6 basic API)</TD>
</TR><TR>
<TD>double infnan (int ERROR)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int initgroups (const char *USER, gid_t GID)</TD>
     <TD>grp.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * initstate (unsigned int SEED, void *STATE, size_t SIZE)</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t INLCR</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int innetgr (const char *NETGROUP, const char *HOST, const char *USER, const c
har *DOMAIN)</TD>
     <TD>netdb.h</TD> <TD>(netdb.h)</TD>
</TR><TR>
<TD>ino_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t INPCK</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int RLIM_INFINITY</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>INT_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>INT_MIN</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int _IOFBF</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int _IOLBF</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int _IONBF</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int IPPORT_RESERVED</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int IPPORT_USERRESERVED</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int isalnum (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isalpha (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isascii (int C)</TD>
     <TD>ctype.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int isatty (int FILEDES)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int isblank (int C)</TD>
     <TD>ctype.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int iscntrl (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isdigit (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isgraph (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>tcflag_t ISIG</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int isinf (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int islower (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isnan (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int isprint (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int ispunct (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isspace (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>tcflag_t ISTRIP</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int isupper (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int isxdigit (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>ITIMER_PROF</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>ITIMER_REAL</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>ITIMER_VIRTUAL</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t IXANY</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t IXOFF</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t IXON</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>jmp_buf</TD>
     <TD>setjmp.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int kill (pid_t PID, int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int killpg (int PGID, int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>long int labs (long int NUMBER)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LANG</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LC_ALL</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LC_COLLATE</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LC_CTYPE</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LC_MESSAGES</TD>
     <TD>locale.h</TD> <TD>(XOPEN)</TD>
</TR><TR>
<TD>LC_MONETARY</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LC_NUMERIC</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int L_ctermid</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>LC_TIME</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int L_cuserid</TD>
     <TD>stdio.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double ldexp (double VALUE, int EXPONENT)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>ldiv_t ldiv (long int NUMERATOR, long int DENOMINATOR)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>ldiv_t</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>L_INCR</TD>
     <TD>sys/file.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int LINE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int link (const char *OLDNAME, const char *NEWNAME)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int LINK_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int listen (int SOCKET, unsigned int N)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct lconv * localeconv (void)</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>struct tm * localtime (const time_t *TIME)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double log10 (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double log1p (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double logb (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double log (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void longjmp (jmp_buf STATE, int VALUE)</TD>
     <TD>setjmp.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LONG_LONG_MAX</TD>
     <TD>limits.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>LONG_LONG_MIN</TD>
     <TD>limits.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>LONG_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>LONG_MIN</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>off_t lseek (int FILEDES, off_t OFFSET, int WHENCE)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>L_SET</TD>
     <TD>sys/file.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int lstat (const char *FILENAME, struct stat *BUF)</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int L_tmpnam</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>L_XTND</TD>
     <TD>sys/file.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct mallinfo mallinfo (void)</TD>
     <TD>malloc.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>__malloc_hook</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * malloc (size_t SIZE)</TD>
     <TD>malloc.h, `stdlib.h' </TD><TD>(ISO)</TD>
</TR><TR>
<TD>int MAX_CANON</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int MAX_INPUT</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int MAXNAMLEN</TD>
     <TD>dirent.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int MB_CUR_MAX</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int mblen (const char *STRING, size_t SIZE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int MB_LEN_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>size_t mbstowcs (wchar_t *WSTRING, const char *STRING, size_t SIZE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int mbtowc (wchar_t *RESULT, const char *STRING, size_t SIZE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int mcheck (void (*ABORTFN) (enum mcheck_status STATUS))</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>tcflag_t MDMBUF</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * memalign (size_t BOUNDARY, size_t SIZE)</TD>
     <TD>malloc.h, `stdlib.h' </TD><TD>(BSD)</TD>
</TR><TR>
<TD>void * memccpy (void *TO, const void *FROM, int C, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>void * memchr (const void *BLOCK, int C, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int memcmp (const void *A1, const void *A2, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void * memcpy (void *TO, const void *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void * memmem (const void *HAYSTACK, size_t HAYSTACK-LEN,
     const void *NEEDLE, size_t NEEDLE-LEN)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * memmove (void *TO, const void *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void * memset (void *BLOCK, int C, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int mkdir (const char *FILENAME, mode_t MODE)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int mkfifo (const char *FILENAME, mode_t MODE)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int mknod (const char *FILENAME, int MODE, int DEV)</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int mkstemp (char *TEMPLATE)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * mktemp (char *TEMPLATE)</TD>
     <TD>unistd.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>time_t mktime (struct tm *BROKENTIME)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>mode_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double modf (double VALUE, double *INTEGER-PART)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int MSG_DONTROUTE</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int MSG_OOB</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int MSG_PEEK</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int NAME_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double NAN</TD>
     <TD>math.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int NCCS</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int NGROUPS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int nice (int INCREMENT)</TD>
     <TD>dunno.h</TD> <TD>(dunno.h)</TD>
</TR><TR>
<TD>nlink_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>NO_ADDRESS</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>tcflag_t NOFLSH</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t NOKERNINFO</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>NO_RECOVERY</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int NSIG</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned long int ntohl (unsigned long int NETLONG)</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned short int ntohs (unsigned short int NETSHORT)</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * NULL</TD>
     <TD>stddef.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int O_ACCMODE</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_APPEND</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_ASYNC</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char C)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_1grow (struct obstack *OBSTACK-PTR, char C)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_alignment_mask (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_alloc (struct obstack *OBSTACK-PTR, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_base (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_blank_fast (struct obstack *OBSTACK-PTR, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_chunk_size (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_copy0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_copy (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_finish (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_free (struct obstack *OBSTACK-PTR, void *OBJECT)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_grow0 (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_grow (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_init (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_int_grow_fast (struct obstack *OBSTACK-PTR, int DATA)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_int_grow (struct obstack *OBSTACK-PTR, int DATA)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * obstack_next_free (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_object_size (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_object_size (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_printf (struct obstack *OBSTACK, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_ptr_grow_fast (struct obstack *OBSTACK-PTR, void *DATA)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void obstack_ptr_grow (struct obstack *OBSTACK-PTR, void *DATA)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_room (struct obstack *OBSTACK-PTR)</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int obstack_vprintf (struct obstack *OBSTACK, const char *TEMPLATE, va_list AP
)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_CREAT</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_EXCL</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_EXEC</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_EXLOCK</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>size_t offsetof (TYPE, MEMBER)</TD>
     <TD>stddef.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>off_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_FSYNC</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int O_IGNORE_CTTY</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_NDELAY</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int on_exit (void (*FUNCTION)(int STATUS, void *ARG), void *ARG)</TD>
     <TD>stdlib.h</TD> <TD>(SunOS)</TD>
</TR><TR>
<TD>tcflag_t ONLCR</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int O_NOATIME</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_NOCTTY</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t ONOEOT</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int O_NOLINK</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_NONBLOCK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_NONBLOCK</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_NOTRANS</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>DIR * opendir (const char *DIRNAME)</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int open (const char *FILENAME, int FLAGS[, mode_t MODE])</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int OPEN_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * open_memstream (char **PTR, size_t *SIZELOC)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>FILE * open_obstack_stream (struct obstack *OBSTACK)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>tcflag_t OPOST</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * optarg</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int opterr</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int optind</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int optopt</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int O_RDONLY</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_RDWR</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_READ</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_SHLOCK</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int O_SYNC</TD>
     <TD>fcntl.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int O_TRUNC</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int O_WRITE</TD>
     <TD>fcntl.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int O_WRONLY</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t OXTABS</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>PA_CHAR</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_DOUBLE</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLAG_LONG_DOUBLE</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLAG_LONG</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLAG_LONG_LONG</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int PA_FLAG_MASK</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLAG_PTR</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLAG_SHORT</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_FLOAT</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_INT</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_LAST</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_POINTER</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>tcflag_t PARENB</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t PARMRK</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t PARODD</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>size_t parse_printf_format (const char *TEMPLATE, size_t N, int *ARGTYPES)</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>PA_STRING</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>long int pathconf (const char *FILENAME, int PARAMETER)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int PATH_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int pause ()</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_CHOWN_RESTRICTED</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_LINK_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int pclose (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.2, SVID, BSD)</TD>
</TR><TR>
<TD>_PC_MAX_CANON</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_MAX_INPUT</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_NAME_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_NO_TRUNC</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_PATH_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_PIPE_BUF</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_PC_VDISABLE</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t PENDIN</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void perror (const char *MESSAGE)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int PF_FILE</TD>
     <TD>sys/socket.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int PF_INET</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int PF_UNIX</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int PIPE_BUF</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int pipe (int FILEDES[2])</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * popen (const char *COMMAND, const char *MODE)</TD>
     <TD>stdio.h</TD> <TD>(POSIX.2, SVID, BSD)</TD>
</TR><TR>
<TD>_POSIX2_BC_BASE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_BC_DIM_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_BC_SCALE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_BC_STRING_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX2_C_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_COLL_WEIGHTS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>long int _POSIX2_C_VERSION</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_EQUIV_CLASS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_EXPR_NEST_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX2_FORT_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX2_FORT_RUN</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_LINE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX2_LOCALEDEF</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX2_RE_DUP_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX2_SW_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_POSIX_ARG_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_CHILD_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int _POSIX_CHOWN_RESTRICTED</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_C_SOURCE</TD>
<TD>&nbsp;</TD><TD>(POSIX.2)</TD>
</TR><TR>
<TD>int _POSIX_JOB_CONTROL</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_LINK_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_MAX_CANON</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_MAX_INPUT</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_NAME_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_NGROUPS_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int _POSIX_NO_TRUNC</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_OPEN_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_PATH_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_PIPE_BUF</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int _POSIX_SAVED_IDS</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_SOURCE</TD>
<TD>&nbsp;</TD><TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_SSIZE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_STREAM_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_POSIX_TZNAME_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>unsigned char _POSIX_VDISABLE</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>long int _POSIX_VERSION</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>double pow (double BASE, double POWER)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>printf_arginfo_function</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>printf_function</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int printf (const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>PRIO_MAX</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>PRIO_MIN</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>PRIO_PGRP</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>PRIO_PROCESS</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>PRIO_USER</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * program_invocation_name</TD>
     <TD>errno.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * program_invocation_short_name</TD>
     <TD>errno.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void psignal (int SIGNUM, const char *MESSAGE)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * P_tmpdir</TD>
     <TD>stdio.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>ptrdiff_t</TD>
     <TD>stddef.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int putchar (int C)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int putc (int C, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int putenv (const char *STRING)</TD>
     <TD>stdlib.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int putpwent (const struct passwd *P, FILE *STREAM)</TD>
     <TD>pwd.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int puts (const char *S)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int putw (int W, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>void qsort (void *ARRAY, size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int raise (int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void r_alloc_free (void **HANDLEPTR)</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * r_alloc (void **HANDLEPTR, size_t SIZE)</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int rand ()</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int RAND_MAX</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>long int random ()</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct dirent * readdir (DIR *DIRSTREAM)</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int readdir_r (DIR *DIRSTREAM, struct *ENTRY, struct **RESULT)</TD>
     <TD>dirent.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>ssize_t read (int FILEDES, void *BUFFER, size_t SIZE)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int readlink (const char *FILENAME, char *BUFFER, size_t SIZE)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>__realloc_hook</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void * realloc (void *PTR, size_t NEWSIZE)</TD>
     <TD>malloc.h, `stdlib.h'</TD><TD>(ISO)</TD>
</TR><TR>
<TD>int recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS, struct sockadd
r *ADDR, socklen_t *LENGTH-PTR)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int recv (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int recvmsg (int SOCKET, struct msghdr *MESSAGE, int FLAGS)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int RE_DUP_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_REENTRANT</TD>
<TD>&nbsp;</TD><TD>(GNU)</TD>
</TR><TR>
<TD>REG_BADBR</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_BADPAT</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_BADRPT</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int regcomp (regex_t *COMPILED, const char *PATTERN, int CFLAGS)</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_EBRACE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_EBRACK</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ECOLLATE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ECTYPE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_EESCAPE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_EPAREN</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ERANGE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>size_t regerror (int ERRCODE, regex_t *COMPILED, char *BUFFER, size_t LENGTH)</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ESPACE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ESPACE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ESUBREG</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int regexec (regex_t *COMPILED, char *STRING, size_t NMATCH, regmatch_t MATCHP
TR [], int EFLAGS)</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_EXTENDED</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>regex_t</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>void regfree (regex_t *COMPILED)</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_ICASE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int register_printf_function (int SPEC, printf_function HANDLER-FUNCTION, prin
tf_arginfo_function ARGINFO-FUNCTION)</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>regmatch_t</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_NEWLINE</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_NOMATCH</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_NOSUB</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_NOTBOL</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>REG_NOTEOL</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>regoff_t</TD>
     <TD>regex.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int remove (const char *FILENAME)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int rename (const char *OLDNAME, const char *NEWNAME)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void rewinddir (DIR *DIRSTREAM)</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void rewind (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * rindex (const char *STRING, int C)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double rint (double X)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_CORE</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_CPU</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_DATA</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_FSIZE</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_MEMLOCK</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_NOFILE</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_NPROC</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_RSS</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIMIT_STACK</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RLIM_NLIMITS</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int rmdir (const char *FILENAME)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int R_OK</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void * r_re_alloc (void **HANDLEPTR, size_t SIZE)</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>RUSAGE_CHILDREN</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>RUSAGE_SELF</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SA_NOCLDSTOP</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SA_ONSTACK</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SA_RESTART</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>_SC_2_C_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_2_FORT_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_2_FORT_RUN</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_2_LOCALEDEF</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_2_SW_DEV</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_2_VERSION</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>double scalb (double VALUE, int EXPONENT)</TD>
     <TD>math.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int scanf (const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>_SC_ARG_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_BC_BASE_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_BC_DIM_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_BC_SCALE_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_BC_STRING_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_CHILD_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_CLK_TCK</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_COLL_WEIGHTS_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_EQUIV_CLASS_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_EXPR_NEST_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>SCHAR_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>SCHAR_MIN</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>_SC_JOB_CONTROL</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_LINE_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>_SC_NGROUPS_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_OPEN_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_PAGESIZE</TD>
     <TD>unistd.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>_SC_SAVED_IDS</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_STREAM_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_TZNAME_MAX</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_VERSION</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_SC_VERSION</TD>
     <TD>unistd.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>int SEEK_CUR</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void seekdir (DIR *DIRSTREAM, off_t POS)</TD>
     <TD>dirent.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SEEK_END</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int SEEK_SET</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int select (int NFDS, fd_set *READ-FDS, fd_set *WRITE-FDS, fd_set *EXCEPT-FDS,
 struct timeval *TIMEOUT)</TD>
     <TD>sys/types.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int send (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sendmsg (int SOCKET, const struct msghdr *MESSAGE, int FLAGS)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sendto (int SOCKET, void *BUFFER. size_t SIZE, int FLAGS, struct sockaddr
*ADDR, socklen_t LENGTH)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void setbuffer (FILE *STREAM, char *BUF, size_t SIZE)</TD>
     <TD>stdio.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void setbuf (FILE *STREAM, char *BUF)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int setgid (gid_t NEWGID)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void setgrent (void)</TD>
     <TD>grp.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int setgroups (size_t COUNT, gid_t *GROUPS)</TD>
     <TD>grp.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void sethostent (int STAYOPEN)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sethostid (long int ID)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sethostname (const char *NAME, size_t LENGTH)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setitimer (int WHICH, struct itimerval *NEW, struct itimerval *OLD)</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setjmp (jmp_buf STATE)</TD>
     <TD>setjmp.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void setlinebuf (FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * setlocale (int CATEGORY, const char *LOCALE)</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void setnetent (int STAYOPEN)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setnetgrent (const char *NETGROUP)</TD>
     <TD>netdb.h</TD> <TD>(netdb.h)</TD>
</TR><TR>
<TD>int setpgid (pid_t PID, pid_t PGID)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int setpgrp (pid_t PID, pid_t PGID)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setpriority (int CLASS, int ID, int PRIORITY)</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void setprotoent (int STAYOPEN)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void setpwent (void)</TD>
     <TD>pwd.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int setregid (gid_t RGID, fid_t EGID)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setreuid (uid_t RUID, uid_t EUID)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setrlimit (int RESOURCE, struct rlimit *RLP)</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void setservent (int STAYOPEN)</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t setsid (void)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int setsockopt (int SOCKET, int LEVEL, int OPTNAME, void *OPTVAL, socklen_t OP
TLEN)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>void * setstate (void *STATE)</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int settimeofday (const struct timeval *TP, const struct timezone *TZP)</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int setuid (uid_t NEWUID)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int setvbuf (FILE *STREAM, char *BUF, int MODE, size_t SIZE)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>SHRT_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>SHRT_MIN</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int shutdown (int SOCKET, int HOW)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IEXEC</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFBLK</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFCHR</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFDIR</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFIFO</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFLNK</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int S_IFMT</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFREG</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IFSOCK</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGABRT</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int sigaction (int SIGNUM, const struct sigaction *ACTION, struct sigaction *O
LD-ACTION)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigaddset (sigset_t *SET, int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGALRM</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigaltstack (const struct sigaltstack *STACK, struct sigaltstack *OLDSTACK
)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>sig_atomic_t</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>SIG_BLOCK</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigblock (int MASK)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGBUS</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGCHLD</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGCLD</TD>
     <TD>signal.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int SIGCONT</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigdelset (sigset_t *SET, int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigemptyset (sigset_t *SET)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGEMT</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>sighandler_t SIG_ERR</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int sigfillset (sigset_t *SET)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGFPE</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>sighandler_t</TD>
     <TD>signal.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int SIGHUP</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGILL</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int SIGINFO</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int siginterrupt (int SIGNUM, int FAILFLAG)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGINT</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int SIGIO</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGIOT</TD>
     <TD>signal.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>int sigismember (const sigset_t *SET, int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>sigjmp_buf</TD>
     <TD>setjmp.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGKILL</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void siglongjmp (sigjmp_buf STATE, int VALUE)</TD>
     <TD>setjmp.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGLOST</TD>
     <TD>signal.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int sigmask (int SIGNUM)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>sighandler_t signal (int SIGNUM, sighandler_t ACTION)</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int sigpause (int MASK)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sigpending (sigset_t *SET)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGPIPE</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGPOLL</TD>
     <TD>signal.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int sigprocmask (int HOW, const sigset_t *SET, sigset_t *OLDSET)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGPROF</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGQUIT</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGSEGV</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int sigsetjmp (sigjmp_buf STATE, int SAVESIGS)</TD>
     <TD>setjmp.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>SIG_SETMASK</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigsetmask (int MASK)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>sigset_t</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigstack (const struct sigstack *STACK, struct sigstack *OLDSTACK)</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGSTOP</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigsuspend (const sigset_t *SET)</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGSYS</TD>
     <TD>signal.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>int SIGTERM</TD>
     <TD>signal.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int SIGTRAP</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGTSTP</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGTTIN</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGTTOU</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>SIG_UNBLOCK</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGURG</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGUSR1</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int SIGUSR2</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sigvec (int SIGNUM, const struct sigvec *ACTION,struct sigvec *OLD-ACTION)</TD>
</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGVTALRM</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGWINCH</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGXCPU</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SIGXFSZ</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>double sinh (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double sin (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>S_IREAD</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IRGRP</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IROTH</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IRUSR</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IRWXG</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IRWXO</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IRWXU</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int S_ISBLK (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>int S_ISCHR (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>int S_ISDIR (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>int S_ISFIFO (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>S_ISGID</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>int S_ISLNK (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int S_ISREG (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>int S_ISSOCK (mode_t M)</TD>
     <TD>sys/stat.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>S_ISUID</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>S_ISVTX</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IWGRP</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IWOTH</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IWRITE</TD>
     <TD>sys/stat.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>S_IWUSR</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IXGRP</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IXOTH</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>S_IXUSR</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>size_t</TD>
     <TD>stddef.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>unsigned int sleep (unsigned int SECONDS)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int snprintf (char *S, size_t SIZE, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>SO_BROADCAST</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOCK_DGRAM</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int socket (int NAMESPACE, int STYLE, int PROTOCOL)</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int socketpair (int NAMESPACE, int STYLE, int PROTOCOL, int FILEDES[2])</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOCK_RAW</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOCK_RDM</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOCK_SEQPACKET</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOCK_STREAM</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_DEBUG</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_DONTROUTE</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_ERROR</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_KEEPALIVE</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_LINGER</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SOL_SOCKET</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_OOBINLINE</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_RCVBUF</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_REUSEADDR</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_SNDBUF</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>SO_STYLE</TD>
     <TD>sys/socket.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>SO_TYPE</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>speed_t</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int sprintf (char *S, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double sqrt (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void srand (unsigned int SEED)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void srandom (unsigned int SEED)</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int sscanf (const char *S, const char *TEMPLATE, ...)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>sighandler_t ssignal (int SIGNUM, sighandler_t ACTION)</TD>
     <TD>signal.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int SSIZE_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>ssize_t</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int stat (const char *FILENAME, struct stat *BUF)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>STDERR_FILENO</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * stderr</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>STDIN_FILENO</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * stdin</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>STDOUT_FILENO</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>FILE * stdout</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * stpcpy (char *TO, const char *FROM)</TD>
     <TD>string.h</TD> <TD>(Unknown origin)</TD>
</TR><TR>
<TD>char * stpncpy (char *TO, const char *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int strcasecmp (const char *S1, const char *S2)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * strcat (char *TO, const char *FROM)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strchr (const char *STRING, int C)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int strcmp (const char *S1, const char *S2)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int strcoll (const char *S1, const char *S2)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strcpy (char *TO, const char *FROM)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>size_t strcspn (const char *STRING, const char *STOPSET)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strdupa (const char *S)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * strdup (const char *S)</TD>
     <TD>string.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int STREAM_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * strerror (int ERRNUM)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strerror_r (int ERRNUM, char *BUF, size_t N)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>size_t strftime (char *S, size_t SIZE, const char *TEMPLATE, const struct tm *
BROKENTIME)</TD>
     <TD>time.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>size_t strlen (const char *S)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int strncasecmp (const char *S1, const char *S2, size_t N)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * strncat (char *TO, const char *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int strncmp (const char *S1, const char *S2, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strncpy (char *TO, const char *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strndupa (const char *S, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * strndup (const char *S, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * strpbrk (const char *STRING, const char *STOPSET)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strrchr (const char *STRING, int C)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strsep (char **STRING_PTR, const char *DELIMITER)</TD>
     <TD>string.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * strsignal (int SIGNUM)</TD>
     <TD>string.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>size_t strspn (const char *STRING, const char *SKIPSET)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strstr (const char *HAYSTACK, const char *NEEDLE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double strtod (const char *STRING, char **TAILPTR)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>float strtof (const char *STRING, char **TAILPTR)</TD>
     <TD>stdlib.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * strtok (char *NEWSTRING, const char *DELIMITERS)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * strtok_r (char *NEWSTRING, const char *DELIMITERS, char **SAVE_PTR)</TD>
     <TD>string.h</TD> <TD>(POSIX)</TD>
</TR><TR>
<TD>long double strtold (const char *STRING, char **TAILPTR)</TD>
     <TD>stdlib.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>long int strtol (const char *STRING, char **TAILPTR, int BASE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>long long int strtoll (const char *STRING, char **TAILPTR, int BASE)</TD>
     <TD>stdlib.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>long long int strtoq (const char *STRING, char **TAILPTR, int BASE)</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>unsigned long int strtoul (const char *STRING, char **TAILPTR, int BASE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>unsigned long long int strtoull (const char *STRING, char **TAILPTR, int BASE)</TD>
</TD>
     <TD>stdlib.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>unsigned long long int strtouq (const char *STRING, char **TAILPTR, int BASE)</TD>
     <TD>stdlib.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct dirent</TD>
     <TD>dirent.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct flock</TD>
     <TD>fcntl.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct group</TD>
     <TD>grp.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct hostent</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct in6_addr</TD>
     <TD>netinet/in.h</TD> <TD>(IPv6 basic API)</TD>
</TR><TR>
<TD>struct in_addr</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct itimerval</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct lconv</TD>
     <TD>locale.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>struct linger</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct mallinfo</TD>
     <TD>malloc.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct msghdr</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct netent</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct obstack</TD>
     <TD>obstack.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct option</TD>
     <TD>getopt.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct passwd</TD>
     <TD>pwd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct printf_info</TD>
     <TD>printf.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>struct protoent</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct rlimit</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct rusage</TD>
     <TD>sys/resource.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct servent</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sigaction</TD>
     <TD>signal.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct sigaltstack</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sigstack</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sigvec</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sockaddr</TD>
     <TD>sys/socket.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sockaddr_in</TD>
     <TD>netinet/in.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct sockaddr_un</TD>
     <TD>sys/un.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct stat</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct termios</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct timeval</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct timezone</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>struct tm</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>struct tms</TD>
     <TD>sys/times.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct utimbuf</TD>
     <TD>time.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>struct utsname</TD>
     <TD>sys/utsname.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>size_t strxfrm (char *TO, const char *FROM, size_t SIZE)</TD>
     <TD>string.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>_SVID_SOURCE</TD>
<TD>&nbsp;</TD><TD>(GNU)</TD>
</TR><TR>
<TD>int SV_INTERRUPT</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SV_ONSTACK</TD>
     <TD>signal.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int SV_RESETHAND</TD>
     <TD>signal.h</TD> <TD>(Sun)</TD>
</TR><TR>
<TD>int symlink (const char *OLDNAME, const char *NEWNAME)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>long int sysconf (int PARAMETER)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int system (const char *COMMAND)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double tanh (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>double tan (double X)</TD>
     <TD>math.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int tcdrain (int FILEDES)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>tcflag_t</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int tcflow (int FILEDES, int ACTION)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int tcflush (int FILEDES, int QUEUE)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int tcgetattr (int FILEDES, struct termios *TERMIOS-P)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>pid_t tcgetpgrp (int FILEDES)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>TCSADRAIN</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>TCSAFLUSH</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>TCSANOW</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>TCSASOFT</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int tcsendbreak (int FILEDES, int DURATION)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int tcsetattr (int FILEDES, int WHEN, const struct termios *TERMIOS-P)</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int tcsetpgrp (int FILEDES, pid_t PGID)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>off_t telldir (DIR *DIRSTREAM)</TD>
     <TD>dirent.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>TEMP_FAILURE_RETRY (EXPRESSION)</TD>
     <TD>unistd.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>char * tempnam (const char *DIR, const char *PREFIX)</TD>
     <TD>stdio.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>time_t time (time_t *RESULT)</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>clock_t times (struct tms *BUFFER)</TD>
     <TD>sys/times.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>time_t</TD>
     <TD>time.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>long int timezone</TD>
     <TD>time.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>FILE * tmpfile (void)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int TMP_MAX</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * tmpnam (char *RESULT)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>char * tmpnam_r (char *RESULT)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int toascii (int C)</TD>
     <TD>ctype.h</TD> <TD>(SVID, BSD)</TD>
</TR><TR>
<TD>int _tolower (int C)</TD>
     <TD>ctype.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int tolower (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>tcflag_t TOSTOP</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int _toupper (int C)</TD>
     <TD>ctype.h</TD> <TD>(SVID)</TD>
</TR><TR>
<TD>int toupper (int C)</TD>
     <TD>ctype.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>TRY_AGAIN</TD>
     <TD>netdb.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>char * ttyname (int FILEDES)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>char * tzname [2]</TD>
     <TD>time.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int TZNAME_MAX</TD>
     <TD>limits.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>void tzset (void)</TD>
     <TD>time.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>UCHAR_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>uid_t</TD>
     <TD>sys/types.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>UINT_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>ULONG_LONG_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>ULONG_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>mode_t umask (mode_t MASK)</TD>
     <TD>sys/stat.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int uname (struct utsname *INFO)</TD>
     <TD>sys/utsname.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int ungetc (int C, FILE *STREAM)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>union wait</TD>
     <TD>sys/wait.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int unlink (const char *FILENAME)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>USHRT_MAX</TD>
     <TD>limits.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int utime (const char *FILENAME, const struct utimbuf *TIMES)</TD>
     <TD>time.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int utimes (const char *FILENAME, struct timeval TVP[2])</TD>
     <TD>sys/time.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>va_alist</TD>
     <TD>varargs.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>TYPE va_arg (va_list AP, TYPE)</TD>
     <TD>stdarg.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>va_dcl</TD>
     <TD>varargs.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>void va_end (va_list AP)</TD>
     <TD>stdarg.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>va_list</TD>
     <TD>stdarg.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>void * valloc (size_t SIZE)</TD>
     <TD>malloc.h, `stdlib.h' </TD><TD>(BSD)</TD>
</TR><TR>
<TD>int vasprintf (char **PTR, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>void va_start (va_list AP)</TD>
     <TD>varargs.h</TD> <TD>(Unix)</TD>
</TR><TR>
<TD>void va_start (va_list AP, LAST-REQUIRED)</TD>
     <TD>stdarg.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int VDISCARD</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int VDSUSP</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int VEOF</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VEOL2</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int VEOL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VERASE</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>pid_t vfork (void)</TD>
     <TD>unistd.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int vfprintf (FILE *STREAM, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int vfscanf (FILE *STREAM, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int VINTR</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VKILL</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VLNEXT</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int VMIN</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int vprintf (const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int VQUIT</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VREPRINT</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int vscanf (const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int vsnprintf (char *S, size_t SIZE, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int vsprintf (char *S, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int vsscanf (const char *S, const char *TEMPLATE, va_list AP)</TD>
     <TD>stdio.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>int VSTART</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VSTATUS</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>int VSTOP</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VSUSP</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VTIME</TD>
     <TD>termios.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int VWERASE</TD>
     <TD>termios.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t wait3 (union wait *STATUS-PTR, int OPTIONS, struct rusage *USAGE)</TD>
     <TD>sys/wait.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t wait4 (pid_t PID, int *STATUS-PTR, int OPTIONS, struct rusage *USAGE)</TD>
     <TD>sys/wait.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>pid_t wait (int *STATUS-PTR)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>pid_t waitpid (pid_t PID, int *STATUS-PTR, int OPTIONS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>WCHAR_MAX</TD>
     <TD>limits.h</TD> <TD>(GNU)</TD>
</TR><TR>
<TD>wchar_t</TD>
     <TD>stddef.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int WCOREDUMP (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(BSD)</TD>
</TR><TR>
<TD>size_t wcstombs (char *STRING, const wchar_t WSTRING, size_t SIZE)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int wctomb (char *STRING, wchar_t WCHAR)</TD>
     <TD>stdlib.h</TD> <TD>(ISO)</TD>
</TR><TR>
<TD>int WEXITSTATUS (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int WIFEXITED (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int WIFSIGNALED (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int WIFSTOPPED (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int W_OK</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int wordexp (const char *WORDS, wordexp_t *WORD-VECTOR-PTR, int FLAGS)</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>wordexp_t</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>void wordfree (wordexp_t *WORD-VECTOR-PTR)</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_APPEND</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_BADCHAR</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_BADVAL</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_CMDSUB</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_DOOFFS</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_NOCMD</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_NOSPACE</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_REUSE</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_SHOWERR</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_SYNTAX</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>WRDE_UNDEF</TD>
     <TD>wordexp.h</TD> <TD>(POSIX.2)</TD>
</TR><TR>
<TD>ssize_t write (int FILEDES, const void *BUFFER, size_t SIZE)</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int WSTOPSIG (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int WTERMSIG (int STATUS)</TD>
     <TD>sys/wait.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>int X_OK</TD>
     <TD>unistd.h</TD> <TD>(POSIX.1)</TD>
</TR><TR>
<TD>_XOPEN_SOURCE</TD>
<TD>&nbsp;</TD> <TD>(XOPEN)</TD>
</TR>
</TABLE>

