<REFENTRY id="grep">
<REFMETA><REFENTRYTITLE>
grep
</REFENTRYTITLE></REFMETA>
<REFNAMEDIV>
<REFNAME>grep</REFNAME>
<REFPURPOSE>
print lines matching a pattern
</REFPURPOSE>
</REFNAMEDIV>

<REFSECT1>
<TITLE>Description</TITLE>
<PARA>
The specification for "grep" is as specified in the SUS but with the
following differences as listed below.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Differences</TITLE>

<VARIABLELIST>

<VARLISTENTRY>
<TERM>-A NUM, --after-context=NUM</TERM>
<LISTITEM>
<PARA>
Print NUM lines of trailing context after matching lines.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-a, --text</TERM>
<LISTITEM>
<PARA>
Process a binary file as if it were text; this is equivalent to the
--binary-files=text option.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-B NUM, --before-context=NUM</TERM>
<LISTITEM>
<PARA>
Print NUM lines of leading context before matching lines.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-C [NUM], -NUM, --context[=NUM]</TERM>
<LISTITEM>
<PARA>
Print NUM lines (default 2) of output context.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-b, --byte-offset</TERM>
<LISTITEM>
<PARA>
Print  the byte offset within the input file before
each line of output.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--binary-files=TYPE</TERM>
<LISTITEM>
<PARA>
If the first few bytes of a file indicate that the file contains
binary data, assume that the file is of type TYPE.  By default, TYPE
is binary, and grep normally outputs either a one-line message saying
that a binary file matches, or no message if there is no match.  If
TYPE is without-match, grep assumes that a binary file does not match;
this is equivalent to the -I option.  If TYPE is text, grep processes
a binary file as if it were text; this is equivalent to the -a option.
Warning: grep --binary-files=text might output binary garbage, which
can have nasty side effects if the output is a terminal and if the
terminal driver interprets some of it as commands.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-c, --count</TERM>
<LISTITEM>
<PARA>
Suppress normal output; instead print a count of matching lines for
each input file.  With the -v, --invert-match option (see below),
count non-matching lines.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-d ACTION, --directories=ACTION</TERM>
<LISTITEM>
<PARA>
If an input file is a directory, use ACTION to process it.  By
default, ACTION is read, which means that directories are read just as
if they were ordinary files.  If ACTION is skip, directories are
silently skipped.  If ACTION is recurse, grep reads all files under
each directory, recursively; this is equivalent to the -r option.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-G, --basic-regexp</TERM>
<LISTITEM>
<PARA>
Interpret PATTERN as a basic regular expression (see below).  This is
the default.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-H, --with-filename</TERM>
<LISTITEM>
<PARA>
Print the filename for each match.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-h, --no-filename</TERM>
<LISTITEM>
<PARA>
Suppress the prefixing of filenames on output when multiple files are
searched.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-I</TERM>
<LISTITEM>
<PARA>
Process a binary file as if it did not contain matching data; this is
equivalent to the --binary-files=without-match option.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--ignore-case</TERM>
<LISTITEM>
<PARA>
Equivalent to -i
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-L, --files-without-match</TERM>
<LISTITEM>
<PARA>
Suppress normal output; instead print the name of each input file from
which no output would normally have been printed.  The scanning will
stop on the first match.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--files-with-matches</TERM>
<LISTITEM>
<PARA>
Equivalent to -l
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--map</TERM>
<LISTITEM>
<PARA>
If possible, use the mmap(2) system call to read input, instead of the
default read(2) system call.  In some situations, --mmap yields better
perfor- mance.  However, --mmap can cause undefined behav- ior
(including core dumps) if an input file shrinks while grep is
operating, or if an I/O error occurs.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--line-number</TERM>
<LISTITEM>
<PARA>
Equivalent to -n
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--quiet</TERM>
<LISTITEM>
<PARA>
Equivalent to -q
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-r, --recursive</TERM>
<LISTITEM>
<PARA>
Read all files under each directory, recursively; this is equivalent
 to the -d recurse option.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--no-messages</TERM>
<LISTITEM>
<PARA>
Equivalent to -s
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-U, --binary</TERM>
<LISTITEM>
<PARA>
Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows,
grep guesses the file type by looking at the contents of the first
32KB read from the file.  If grep decides the file is a text file, it
strips the CR characters from the original file contents (to make
regular expressions with ^ and $ work correctly).  Specifying -U
overrules this guesswork, causing all files to be read and passed to
the matching mechanism verbatim; if the file is a text file with CR/LF
pairs at the end of each line, this will cause some regular
expressions to fail.  This option has no effect on platforms other
than MS-DOS and MS-Windows.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-u, --unix-byte-offsets</TERM>
<LISTITEM>
<PARA>
Report Unix-style byte offsets.  This switch causes grep to report
byte offsets as if the file were Unix-style text file, i.e.  with CR
characters stripped off.  This will produce results identical to
running grep on a Unix machine.  This option has no effect unless -b
option is also used; it has no effect on platforms other than MS-DOS
and MS-Windows.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-V, --version</TERM>
<LISTITEM>
<PARA>
Print the version number of grep to standard error.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--invert-match</TERM>
<LISTITEM>
<PARA>
Equivalent to -v
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-w, --word-regexp</TERM>
<LISTITEM>
<PARA>
Select only those lines containing matches that form whole words.  The
test is that the matching substring must either be at the beginning of
the line, or preceded by a non-word constituent character.  Similarly,
it must be either at the end of the line or followed by a non-word
constituent character.  Word-constituent characters are letters,
digits, and the underscore.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>--line-regexp</TERM>
<LISTITEM>
<PARA>
Equivalent to -x
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>-Z, --null</TERM>
<LISTITEM>
<PARA>
Output a zero byte (the ASCII NUL character) instead of the character
that normally follows a file name. 
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

</REFSECT1>
</REFENTRY>
