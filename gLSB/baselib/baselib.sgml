<PART ID=tocbaselib>
<TITLE>Base Libraries</TITLE>

<CHAPTER id=baselib>
<TITLE>Libraries</TITLE>

<PARA>
An LSB-conforming implementation shall support some base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
</PARA>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:13:46 2001 -->
<SECT1 ID=libc>
<TITLE>libc</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libc</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libc.so.6</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-131-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Large File Support<FOOTNOTE ID="std-131-35">
<PARA>
Large File Support</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-131-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]<FOOTNOTE ID="std-131-3">
<PARA>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, February 1997, Networking Services (XNS), Issue 5
(ISBN: 1-85912-165-9, C523)<FOOTNOTE ID="std-131-15">
<PARA>
CAE Specification, February 1997, Networking Services (XNS), Issue 5
(ISBN: 1-85912-165-9, C523)</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-131-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>RPC Interfaces</TITLE>
<PARA>
</PARA>
</SECT2>
<SECT2>
<TITLE>System Calls</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__fxstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fchown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getwd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setrlimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__getpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fcntl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>initgroups(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>pwrite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__lxstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fdatasync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ioctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>read(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__xmknod(GLIBC_2.0)</ENTRY><ENTRY>fdetach(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>kill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__xstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>flock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>killpg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>statfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>access(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fork(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lchown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>statvfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>acct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fstatfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>link(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rename(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>symlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>alarm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fsync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lockf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rmdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>brk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lseek(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sysconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftruncate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mkdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_get_priority_max(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>time(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chmod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getcontext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mkfifo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sched_get_priority_min(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>times(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chown(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getegid(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_getparam(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>truncate(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chroot(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>geteuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mlockall(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_getscheduler(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ulimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>clock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mmap(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_rr_get_interval(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>umask(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>close(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgroups(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mprotect(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_setparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>uname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>closedir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getitimer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_setscheduler(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>unlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>creat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getloadavg<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>munlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_yield(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>utime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>dup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>munlockall(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>select(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>utimes(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>dup2(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpagesize(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>munmap(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setcontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vfork(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nanosleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setegid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execle(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nice(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seteuid(GLIBC_2.0)</ENTRY><ENTRY>wait3(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execlp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>open(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wait4(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>execv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getppid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>opendir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setitimer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>waitid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execve(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpriority(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pathconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>waitpid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execvp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getrlimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pause(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>write(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getrusage(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pipe(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpriority(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>writev(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fchdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>poll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setregid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>fchmod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pread(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setreuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>errno<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Standard I/O</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_IO_feof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fgetpos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fstatvfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putc_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_getc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fgets(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftell(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putchar(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sscanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_putc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fileno(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftello(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putchar_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>telldir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_puts(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>flockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fwrite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>puts(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tempnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>alphasort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ungetc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>clearerr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getc_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>remove(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vasprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>ctermid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fputc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getchar(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rewind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vdprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>fclose(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fputs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getchar_unlocked(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rewinddir(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vfprintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fdopen(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fread(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gets(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>scanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vprintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>feof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>freopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seekdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vsnprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>ferror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fscanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setbuf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vsprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fflush(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fseek(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>popen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setbuffer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>fflush_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fseeko(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>printf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setvbuf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>fgetc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fsetpos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>snprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_IO_2_1_stderr_<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_IO_2_1_stdout_</ENTRY><ENTRY>stdin</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>_IO_2_1_stdin_<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stderr</ENTRY><ENTRY>stdout</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Signal Handling</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__libc_current_sigrtmax(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaction(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>siggetmask(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigorset(GLIBC_2.1)</ENTRY><ENTRY>sigstack(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__libc_current_sigrtmin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaddset(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sighold(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigpause(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigsuspend(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sigpause(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaltstack(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigignore(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigpending(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigtimedwait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sigsetjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigandset(GLIBC_2.0)</ENTRY><ENTRY>siginterrupt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigprocmask(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigwait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sysv_signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigblock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigisemptyset(GLIBC_2.0)</ENTRY><ENTRY>sigqueue(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigwaitinfo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bsd_signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigdelset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigismember(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigrelse(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>psignal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigemptyset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>siglongjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigreturn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>raise(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigfillset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_sys_siglist<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Standard Library</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_Exit(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>erand48(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>grantpt(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lldiv(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>sethostname(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__assert_fail(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>err(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>hcreate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>longjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__bzero(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>error(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>hdestroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__errno_location(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>errx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>hsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__secure_getenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fcvt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>htonl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>makecontext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srandom(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fmtmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>htons(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>malloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_longjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fnmatch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>imaxabs<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>memmem(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strtol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_setjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fpathconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>imaxdiv<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>mkstemp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoul(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>a64l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>free(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_addr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>mktemp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>swapcontext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>abort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftrylockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_aton(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>mrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>syslog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>abs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_ntoa(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>nftw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>system(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atexit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>funlockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>initstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>textdomain(GLIBC_2.0)</ENTRY></ROW>
<ROW><ENTRY>atof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gcvt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>insque(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ntohl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>tfind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atoi(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getcwd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isatty(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ntohs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>tmpfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getdate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isblank(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>openlog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tmpnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>basename(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isinf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>perror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getlogin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isinfl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>ptsname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ttyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>calloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isnan(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>putenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ttyname_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>closelog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt_long(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>isnanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>qsort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>twalk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>confstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt_long_only(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>isnanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>rand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>unlockpt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>cuserid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getsubopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>jrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>random(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>usleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>daemon(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>gettimeofday(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>l64a(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>realloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>verrx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>dirname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>glob(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>labs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>realpath(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>warn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>div(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>glob64(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ldiv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>remque(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>warnx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>drand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>globfree(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lfind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seed48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wordexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>ecvt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>globfree64(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>llabs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>sethostid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wordfree(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_sys_errlist</ENTRY><ENTRY>optarg</ENTRY><ENTRY>optind</ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>_environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>environ</ENTRY><ENTRY>opterr</ENTRY><ENTRY>optopt</ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Localization Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__dcgettext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>catgets(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>dcgettext(GLIBC_2.0)</ENTRY><ENTRY>iconv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nl_langinfo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>catclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>catopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gettext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>localeconv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setlocale(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_nl_msg_cat_cntr</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Socket Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_h_errno(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gethostid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>listen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>sendmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>socketpair(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>accept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>gethostname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>sendto(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getpeername(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recvfrom(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>setsockopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bindresvport(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getsockname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recvmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>shutdown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>connect(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getsockopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>send(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>socket(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>h_errno<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Wide Characters</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__mbrlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbrlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsnlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstoumax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__wcstod_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbrtowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcsnrtombs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstouq(GLIBC_2.0)</ENTRY></ROW>
<ROW><ENTRY>__wcstof_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsinit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcpncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcspbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcswcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstol_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsnrtowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcrtomb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsrchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcswidth(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstold_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsrtowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcsrtombs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsxfrm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoll_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbstowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctob(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoul_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbtowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcschr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctomb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoull_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>putwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctrans(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>btowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putwchar<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wctype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fgetws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>swprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscpy()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoimax()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcwidth()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fputwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>swscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscspn()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstok()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemchr()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fputws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towctrans()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsdup()<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstol()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemcmp()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwide<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towlower()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsftime<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcstold()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wmemcpy()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towupper()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcslen()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoll()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wmemmove()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>ungetwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncasecmp()<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstombs()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemset()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>iconv_close(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vfwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncat(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoq(GLIBC_2.1)</ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>iconv_open(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vswscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncmp(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoul(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>mblen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoull(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>String Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__rawmemchr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ffs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strchr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncmp(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtok_r(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__stpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY><FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtold(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strdup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memccpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strndup(GLIBC_2.0)</ENTRY><ENTRY>strtoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtod_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strnlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strtoq(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strtof_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strpbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoull(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtok_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strdup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strptime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoumax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtol_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memmove(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strrchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtouq(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strtold_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strerror_r(GLIBC_2.0)</ENTRY><ENTRY>strsep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strverscmp(GLIBC_2.0)</ENTRY></ROW>
<ROW><ENTRY>__strtoll_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>rindex(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strfmon(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strsignal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strxfrm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__strtoul_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strfry(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>swab(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__strtoull_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stpncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bcopy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcasestr(GLIBC_2.0)</ENTRY><ENTRY>strncasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoimax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bzero(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtok(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>IPC Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>ftok(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msgrcv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>msgctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msgsnd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semop(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmdt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>msgget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Regular Expressions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>advance(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>re_exec(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regfree(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>re_comp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regcomp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regexec(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>step(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>loc1<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>loc2</ENTRY><ENTRY>rexecoptions</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Character Type Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__ctype_get_mb_cur_max(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>isdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswalnum(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswlower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>toascii(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_tolower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isgraph(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswalpha(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswprint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tolower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_toupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>islower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswblank(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>iswpunct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>toupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>isalnum(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isprint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswcntrl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswspace(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>isalpha(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ispunct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswctype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>iswupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>isascii(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isspace(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswxdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>iscntrl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswgraph(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isxdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__ctype_b<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>__ctype_tolower</ENTRY><ENTRY>__ctype_toupper</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Time Function</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>adjtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ctime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gmtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>stime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ualarm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>adjtimex(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>daylight(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>localtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tzname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>asctime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>difftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mktime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tzset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>timezone<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Terminal Interface Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>cfgetispeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>cfsetispeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcdrain(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetattr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsendbreak(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>cfgetospeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>cfsetospeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcflow(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsetattr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>cfmakeraw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>cfsetspeed(GLIBC_2.0)</ENTRY><ENTRY>tcflush(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsetpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>System Database Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>endhostent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getgrgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getutxid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>endnetent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>gethostbyaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getservbyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getutxline(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>endprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>gethostbyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getservbyport(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>pututxline(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setspent(GLIBC_2.0)</ENTRY></ROW>
<ROW><ENTRY>endservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getnetbyaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sethostent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>setutent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>endutent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotobyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getutent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>setmntent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>setutxent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>endutxent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotobynumber(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getutxent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setnetent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>User/Group Management</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>endgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpwnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>endpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpwuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>ELF Magic</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__mempcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_obstack_begin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_obstack_newchunk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Large File Support</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__fxstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fopen64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftello64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>mkstemp64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>tmpfile64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY></ROW>
<ROW><ENTRY>__lxstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>freopen64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftruncate64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>mmap64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>truncate64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY></ROW>
<ROW><ENTRY>__xstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fseeko64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftw64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>nftw64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>alphasort64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fsetpos64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>getrlimit64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>open64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>creat64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>fstatfs64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>lockf64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>pwrite64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>fgetpos64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>fstatvfs64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>lseek64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>readdir64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libc-ddefs>
<TITLE> Data Definitions for libc</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>assert.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void __assert_fail(char *, char *, unsigned int, char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>

unsigned short *__ctype_b;
__int32_t *__ctype_tolower;
__int32_t *__ctype_toupper;
int _tolower(int);
int _toupper(int);
int isalnum(int);
int isalpha(int);
int isascii(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int toascii(int);
int tolower(int);
int toupper(int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>dirent.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void rewinddir(DIR *);
void seekdir(DIR *, long);
long telldir(DIR *);
int closedir(DIR *);
DIR *opendir(char *);
dirent *readdir(DIR *);
dirent64 *readdir64(DIR *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fcntl.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int creat(char *, __mode_t);
int creat64(char *, __mode_t);
int fcntl(int, int, ...);
int open(char *, int, ...);
int open64(char *, int, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>fnmatch.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int fnmatch(char *, char *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ftw.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef int __ftw_func_t;

typedef int __ftw64_func_t;

typedef int __nftw_func_t;

typedef int __nftw64_func_t;


int ftw(char *, __ftw_func_t, int);
int ftw64(char *, __ftw64_func_t, int);
int nftw(char *, __nftw_func_t, int, int);
int nftw64(char *, __nftw64_func_t, int, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>glob.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int glob(char *, int, int, glob_t *);
int glob64(char *, int, int, glob64_t *);
void globfree(glob_t *);
void globfree64(glob64_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>grp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void endgrent(void);
group *getgrent(void);
group *getgrgid(__gid_t);
void setgrent(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>iconv.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef *void void *iconv_t;


size_t iconv(iconv_t, char **, size_t *, char **, size_t *);
int iconv_close(iconv_t);
iconv_t iconv_open(char *, char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>inttypes.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef typedef struct {

    long quot;
    long rem;
} lldiv_t;

imaxdiv_t;


intmax_t strtoimax(char *, char **, int);
uintmax_t strtoumax(char *, char **, int);
intmax_t wcstoimax(wchar_t *, wchar_t * *, int);
uintmax_t wcstoumax(wchar_t *, wchar_t * *, int);
intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>langinfo.h</TITLE>
<PARA>
</PARA>
<SCREEN>

char *nl_langinfo();
</SCREEN>
</SECT2>
<SECT2>
<TITLE>locale.h</TITLE>
<PARA>
</PARA>
<SCREEN>

lconv *localeconv(void);
char *setlocale(int, char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>monetary.h</TITLE>
<PARA>
</PARA>
<SCREEN>
</SCREEN>
</SECT2>
<SECT2>
<TITLE>nl_types.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef *void void *nl_catd;


int catclose(nl_catd);
char *catgets(nl_catd, int, int, char *);
nl_catd catopen(char *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>pwd.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void endpwent(void);
passwd *getpwent(void);
passwd *getpwnam(char *);
passwd *getpwuid(__uid_t);
void setpwent(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>regex.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct {

    regoff_t rm_so;
    regoff_t rm_eo;
} regmatch_t;


int regcomp(regex_t *, char *, int);
size_t regerror(int, regex_t *, char *, size_t);
int regexec(regex_t *, char *, size_t, regmatch_t, int);
void regfree(regex_t *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>regexp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

char *loc1;
char *loc2;
char *locs;
int advance(char *, char *);
int step(char *, char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sched.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int sched_get_priority_max(int);
int sched_get_priority_min(int);
int sched_getparam(__pid_t, sched_param *);
int sched_getscheduler(__pid_t);
int sched_rr_get_interval(__pid_t, timespec *);
int sched_setparam(__pid_t, sched_param *);
int sched_setscheduler(__pid_t, int, sched_param *);
int sched_yield(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>search.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef Unknown Type:"" unknown ACTION;

typedef struct entry {

    char *key;
    void *data;
} ENTRY;

typedef void __action_fn_t;


int hcreate(size_t);
ENTRY *hsearch(ENTRY, ACTION);
void insque(void *, void *);
void *lfind(void *, void *, size_t *, size_t);
void *lsearch(void *, void *, size_t *, size_t);
void remque(void *);
void hdestroy(void);
void *tfind(void *, void **);
void *tsearch(void *, void **);
void twalk(void *, __action_fn_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>setjmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct __jmp_buf_tag {

    Unknown Type:"" unknown __jmpbuf;
    int __mask_was_saved;
    Unknown Type:"" unknown __saved_mask;
} jmp_buf;

typedef typedef struct __jmp_buf_tag {

    Unknown Type:"" unknown __jmpbuf;
    int __mask_was_saved;
    Unknown Type:"" unknown __saved_mask;
} jmp_buf;

sigjmp_buf;


int __sigsetjmp(jmp_buf, int);
void longjmp(jmp_buf, int);
void siglongjmp(sigjmp_buf, int);
void _longjmp(jmp_buf, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>signal.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef void __sighandler_t;


int __libc_current_sigrtmax(void);
int __libc_current_sigrtmin(void);
int __sigpause(int, int);
__sighandler_t __sysv_signal(int, __sighandler_t);
int killpg(__pid_t, int);
int raise(int);
int sigaddset(sigset_t *, int);
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(sigset_t *, int);
int sigpending(sigset_t *);
int sigrelse(int);
__sighandler_t sigset(int, __sighandler_t);
int sigstack(sigstack *, sigstack *);
int sigaction(int, sigaction *, sigaction *);
int sigwait(sigset_t *, int *);
int kill(__pid_t, int);
int sigaltstack(sigaltstack *, sigaltstack *);
__sighandler_t signal(int, __sighandler_t);
int sigprocmask(int, sigset_t *, sigset_t *);
int sigsuspend(sigset_t *);
int sigqueue(__pid_t, int,, enum sigval);
int sigwaitinfo(sigset_t *, siginfo_t *);
int sigtimedwait(sigset_t *, siginfo_t *, timespec *);
__sighandler_t bsd_signal(int, __sighandler_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void clearerr(FILE *);
int fclose(FILE *);
FILE *fdopen(int, char *);
int fileno(FILE *);
FILE *fopen(char *, char *);
int fprintf(FILE *, char *, ...);
int fputc(int, FILE *);
FILE *freopen(char *, char *, FILE *);
FILE *freopen64(char *, char *, FILE *);
int fscanf(FILE *, char *, ...);
int fseek(FILE *, long, int);
int fseeko(FILE *, __off_t, int);
int fseeko64(FILE *, __off64_t, int);
__off_t ftello(FILE *);
__off64_t ftello64(FILE *);
int getchar(void);
int getchar_unlocked(void);
int getw(FILE *);
int pclose(FILE *);
void perror(char *);
FILE *popen(char *, char *);
int printf(char *, ...);
int putc_unlocked(int, FILE *);
int putchar(int);
int putchar_unlocked(int);
int putw(int, FILE *);
int remove(char *);
void rewind(FILE *);
int scanf(char *, ...);
void setbuf(FILE *, char *);
int sprintf(char *, char *, ...);
int sscanf(char *, char *, ...);
FILE *stderr;
FILE *stdin;
FILE *stdout;
char *tempnam(char *, char *);
FILE *tmpfile64(void);
FILE *tmpfile(void);
char *tmpnam(char *);
int vfprintf(FILE *, char *, __gnuc_va_list);
int vprintf(char *, __gnuc_va_list);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
int fputs(char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
int fsetpos(FILE *, fpos_t *);
long ftell(FILE *);
size_t fwrite(void *, size_t, size_t, FILE *);
int getc(FILE *);
char *gets(char *);
int putc(int, FILE *);
int puts(char *);
int setvbuf(FILE *, char *, int, size_t);
int snprintf(char *, size_t, char *, ...);
int ungetc(int, FILE *);
int vsnprintf(char *, size_t, char *, __gnuc_va_list);
int vsprintf(char *, char *, __gnuc_va_list);
void flockfile(FILE *);
int fgetpos64(FILE *, fpos64_t *);
FILE *fopen64(char *, char *);
int fsetpos64(FILE *, fpos64_t *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct {

    long quot;
    long rem;
} lldiv_t;

typedef struct {

    int quot;
    int rem;
} div_t;

typedef struct {

    long quot;
    long rem;
} ldiv_t;

typedef int __compar_fn_t;


char *__secure_getenv(char *);
double __strtod_internal(char *, char **, int);
float __strtof_internal(char *, char **, int);
long __strtol_internal(char *, char **, int, int);
long double __strtold_internal(char *, char **, int);
long long __strtoll_internal(char *, char **, int, int);
unsigned long __strtoul_internal(char *, char **, int, int);
unsigned long long __strtoull_internal(char *, char **, int, int);
long a64l(char *);
void abort(void);
int abs(int);
int atexit(void);
double atof(char *);
int atoi(char *);
long atol(char *);
void *bsearch(void *, void *, size_t, size_t, __compar_fn_t);
div_t div(int, int);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short);
void exit(int);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
char *getenv(char *);
int getsubopt(char **, char **, char **);
int grantpt(int);
long jrand48(unsigned short);
char *l64a(long);
long labs(long);
ldiv_t ldiv(long, long);
long long llabs(long long);
lldiv_t lldiv(long long, long long);
long lrand48(void);
int mblen(char *, size_t);
size_t mbstowcs(wchar_t *, char *, size_t);
int mbtowc(wchar_t *, char *, size_t);
int mkstemp(char *);
char *mktemp(char *);
long mrand48(void);
long nrand48(unsigned short);
char *ptsname(int);
int putenv(char *);
void qsort(void *, size_t, size_t, __compar_fn_t);
int rand(void);
unsigned short *seed48(unsigned short);
void srand48(long);
int unlockpt(int);
size_t wcstombs(char *, wchar_t *, size_t);
int wctomb(char *, wchar_t);
int system(char *);
void *calloc(size_t, size_t);
void free(void *);
void *initstate(unsigned int, void *, size_t);
void *malloc(size_t);
void *realloc(void *, size_t);
void *setstate(void *);
void srand(unsigned int);
void srandom(unsigned int);
double strtod(char *, char **);
float strtof(char *, char **);
long strtol(char *, char **, int);
long double strtold(char *, char **);
long long strtoll(char *, char **, int);
unsigned long strtoul(char *, char **, int);
unsigned long long strtoull(char *, char **, int);
void _Exit(int);
size_t __ctype_get_mb_cur_max(void);
char *realpath(char *, char *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>string.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void __bzero(void *, size_t);
char *__strdup(char *);
char *__strtok_r(char *, char *, char **);
void bcopy(void *, void *, size_t);
void *memchr(void *, int, size_t);
int memcmp(void *, void *, size_t);
void *memcpy(void *, void *, size_t);
void *memmove(void *, void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, char *);
char *strchr(char *, int);
int strcmp(char *, char *);
int strcoll(char *, char *);
char *strcpy(char *, char *);
size_t strcspn(char *, char *);
char *strerror(int);
size_t strlen(char *);
char *strncat(char *, char *, size_t);
int strncmp(char *, char *, size_t);
char *strncpy(char *, char *, size_t);
char *strpbrk(char *, char *);
char *strrchr(char *, int);
size_t strspn(char *, char *);
char *strstr(char *, char *);
char *strtok(char *, char *);
size_t strxfrm(char *, char *, size_t);
int bcmp(void *, void *, size_t);
void bzero(void *, size_t);
int ffs(int);
char *-1;
void *memccpy(void *, void *, int, size_t);
char *rindex(char *, int);
int strcasecmp(char *, char *);
char *strdup(char *);
int strncasecmp(char *, char *, size_t);
char *strtok_r(char *, char *, char **);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/ipc.h</TITLE>
<PARA>
</PARA>
<SCREEN>
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/mman.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int msync(void *, size_t, int);
int mlock(void *, size_t);
int mlockall(int);
void *mmap(void *, size_t, int, int, int, __off_t);
int mprotect(void *, size_t, int);
int munlock(void *, size_t);
int munlockall(void);
int munmap(void *, size_t);
void *mmap64(void *, size_t, int, int, int, __off64_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/msg.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int msgctl(int, int, msqid_ds *);
int msgget(int);
int msgrcv(int, void *, size_t, long, int);
int msgsnd(int, void *, size_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/resource.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int getpriority(enum, enum __priority_which, int);
int getrlimit64(enum, enum __rlimit_resource, rlimit64 *);
int setpriority(enum, enum __priority_which, int, int);
int setrlimit(enum, enum __rlimit_resource, rlimit *);
int getrlimit(enum, enum __rlimit_resource, rlimit *);
int getrusage(enum, enum __rusage_who, rusage *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/sem.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int semctl(int, int, int, ...);
int semget(int, int);
int semop(int, sembuf *, unsigned int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/shm.h</TITLE>
<PARA>
</PARA>
<SCREEN>

void *shmat(int, void *, int);
int shmctl(int, int, shmid_ds *);
int shmdt(void *);
int shmget(size_t, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/socket.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef union {

    sockaddr *__sockaddr__;
    sockaddr_at *__sockaddr_at__;
    sockaddr_ax25 *__sockaddr_ax25__;
    sockaddr_dl *__sockaddr_dl__;
    sockaddr_eon *__sockaddr_eon__;
    sockaddr_in *__sockaddr_in__;
    sockaddr_in6 *__sockaddr_in6__;
    sockaddr_inarp *__sockaddr_inarp__;
    sockaddr_ipx *__sockaddr_ipx__;
    sockaddr_iso *__sockaddr_iso__;
    sockaddr_ns *__sockaddr_ns__;
    sockaddr_un *__sockaddr_un__;
    sockaddr_x25 *__sockaddr_x25__;
} __SOCKADDR_ARG;

typedef union {

    sockaddr *__sockaddr__;
    sockaddr_at *__sockaddr_at__;
    sockaddr_ax25 *__sockaddr_ax25__;
    sockaddr_dl *__sockaddr_dl__;
    sockaddr_eon *__sockaddr_eon__;
    sockaddr_in *__sockaddr_in__;
    sockaddr_in6 *__sockaddr_in6__;
    sockaddr_inarp *__sockaddr_inarp__;
    sockaddr_ipx *__sockaddr_ipx__;
    sockaddr_iso *__sockaddr_iso__;
    sockaddr_ns *__sockaddr_ns__;
    sockaddr_un *__sockaddr_un__;
    sockaddr_x25 *__sockaddr_x25__;
} __CONST_SOCKADDR_ARG;


int bind(int, __CONST_SOCKADDR_ARG, socklen_t);
int getsockname(int, __SOCKADDR_ARG, socklen_t *);
int listen(int, unsigned int);
int setsockopt(int, int, int, void *, socklen_t);
int accept(int, __SOCKADDR_ARG, socklen_t *);
int connect(int, __CONST_SOCKADDR_ARG, socklen_t);
int recv(int, void *, size_t, int);
int recvfrom(int, void *, size_t, int, __SOCKADDR_ARG, socklen_t *);
int recvmsg(int, msghdr *, int);
int send(int, void *, size_t, int);
int sendmsg(int, msghdr *, int);
int sendto(int, void *, size_t, int, __CONST_SOCKADDR_ARG, socklen_t);
int getpeername(int, __SOCKADDR_ARG, socklen_t *);
int getsockopt(int, int, int, void *, socklen_t *);
int shutdown(int, int);
int socket(int, int, int);
int socketpair(int, int, int, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/stat.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int __fxstat(int, int, stat *);
int __fxstat64(int, int, stat64 *);
int __lxstat(int, char *, stat *);
int __lxstat64(int, char *, stat64 *);
int __xmknod(int, char *, __mode_t, __dev_t *);
int __xstat(int, char *, stat *);
int __xstat64(int, char *, stat64 *);
int mkfifo(char *, __mode_t);
int chmod(char *, __mode_t);
int fchmod(int, __mode_t);
int mkdir(char *, __mode_t);
__mode_t umask(__mode_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/times.h</TITLE>
<PARA>
</PARA>
<SCREEN>
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/utsname.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int uname(utsname *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/wait.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef Unknown Type:"" unknown idtype_t;


int waitid(idtype_t, __id_t, siginfo_t *, int);
__pid_t wait(int *);
__pid_t waitpid(__pid_t, int *, int);
__pid_t wait3(int *, int, rusage *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>termios.h</TITLE>
<PARA>
</PARA>
<SCREEN>

speed_t cfgetispeed(termios *);
speed_t cfgetospeed(termios *);
int cfsetispeed(termios *, speed_t);
int cfsetospeed(termios *, speed_t);
int tcflow(int, int);
int tcflush(int, int);
__pid_t tcgetsid(int);
int tcsendbreak(int, int);
int tcsetattr(int, int, termios *);
int tcdrain(int);
int tcgetattr(int, termios *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>time.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef Unknown Type:"" unknown clock_t;

typedef Unknown Type:"" unknown time_t;


char *asctime(tm *);
clock_t clock(void);
char *ctime(time_t *);
double difftime(time_t, time_t);
tm *getdate(char *);
int getdate_err;
tm *gmtime(time_t *);
tm *localtime(time_t *);
time_t mktime(tm *);
size_t strftime(char *, size_t, char *, tm *);
char *strptime(char *, char *, tm *);
time_t time(time_t *);
int nanosleep(timespec *, timespec *);
int daylight();
long timezone;
char *tzname();
void tzset(void);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ulimit.h</TITLE>
<PARA>
</PARA>
<SCREEN>

long ulimit(int, ...);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef Unknown Type:"" unknown ssize_t;


char **__environ;
__pid_t __getpgid(__pid_t);
void _exit(int);
int acct(char *);
unsigned int alarm(unsigned int);
int chown(char *, __uid_t, __gid_t);
int chroot(char *);
size_t confstr(int, char *, size_t);
char *ctermid(char *);
char *cuserid(char *);
int daemon(int, int);
int execl(char *, char *, ...);
int execle(char *, char *, ...);
int execlp(char *, char *, ...);
int execv(char *, char *);
int execvp(char *, char *);
int fdatasync(int);
int ftruncate64(int, __off64_t);
long gethostid(void);
char *getlogin(void);
__pid_t getpgrp(void);
__pid_t getsid(__pid_t);
char *getwd(char *);
int lockf(int, int, __off_t);
int lockf64(int, int, __off64_t);
int nice(int);
int rename(char *, char *);
int sethostid(long);
int sethostname(char *, size_t);
int setpgrp(void);
void swab(void *, void *, ssize_t);
int sync(void);
__pid_t tcgetpgrp(int);
int tcsetpgrp(int, __pid_t);
int truncate(char *, __off_t);
int truncate64(char *, __off64_t);
char *ttyname(int);
unsigned int ualarm(unsigned int, unsigned int);
void usleep(unsigned int);
int close(int);
int fsync(int);
__off_t lseek(int, __off_t, int);
int pause(void);
ssize_t read(int, void *, size_t);
ssize_t write(int, void *, size_t);
char *crypt(char *, char *);
void encrypt(char *, int);
void setkey(char *);
int access(char *, int);
int brk(void *);
int chdir(char *);
int dup(int);
int dup2(int, int);
int execve(char *, char *, char *);
int fchdir(int);
int fchown(int, __uid_t, __gid_t);
__pid_t fork(void);
__gid_t getegid(void);
__uid_t geteuid(void);
__gid_t getgid(void);
int getgroups(int, __gid_t);
int gethostname(char *, size_t);
__pid_t getpgid(__pid_t);
__pid_t getpid(void);
__uid_t getuid(void);
int lchown(char *, __uid_t, __gid_t);
int link(char *, char *);
long pathconf(char *, int);
int pipe(int);
int readlink(char *, char *, size_t);
int rmdir(char *);
void *sbrk(ptrdiff_t);
int setgid(__gid_t);
int setpgid(__pid_t, __pid_t);
int setregid(__gid_t, __gid_t);
int setreuid(__uid_t, __uid_t);
__pid_t setsid(void);
int setuid(__uid_t);
unsigned int sleep(unsigned int);
int symlink(char *, char *);
long sysconf(int);
int unlink(char *);
__pid_t vfork(void);
ssize_t pread(int, void *, size_t, __off_t);
ssize_t pwrite(int, void *, size_t, __off_t);
long fpathconf(int, int);
int ftruncate(int, __off_t);
char *getcwd(char *, size_t);
int getpagesize(void);
__pid_t getppid(void);
int isatty(int);
__off64_t lseek64(int, __off64_t, int);
ssize_t pwrite64(int, void *, size_t, __off64_t);
int ttyname_r(int, char *, size_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utime.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int utime(char *, utimbuf *);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned long wctype_t;

typedef *Unknown Type:"" unknown __int32_t * wctrans_t;


wint_t towlower(wint_t);
wint_t towupper(wint_t);
wctrans_t wctrans(char *);
int iswalnum(wint_t);
int iswalpha(wint_t);
int iswcntrl(wint_t);
int iswctype(wint_t, wctype_t);
int iswdigit(wint_t);
int iswgraph(wint_t);
int iswlower(wint_t);
int iswprint(wint_t);
int iswpunct(wint_t);
int iswspace(wint_t);
int iswupper(wint_t);
int iswxdigit(wint_t);
wctype_t wctype(char *);
wint_t towctrans(wint_t, wctrans_t);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wordexp.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int wordexp(char *, wordexp_t *, int);
void wordfree(wordexp_t *);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->

<SECT1 ID=libcman>
<TITLE>Interface Definitions for libc</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib-assert-fail-1"> <REFMETA>
<REFENTRYTITLE>__assert_fail</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__assert_fail
</REFNAME>
<REFPURPOSE>Abort the program after false assertion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 January 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
void
__assert_fail (const char *<REPLACEABLE CLASS="PARAMETER">assertion</REPLACEABLE>,
               const char *<REPLACEABLE CLASS="PARAMETER">file</REPLACEABLE>,
               unsigned int <REPLACEABLE CLASS="PARAMETER">line</REPLACEABLE>,
               const char *<REPLACEABLE CLASS="PARAMETER">function</REPLACEABLE>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>30 January 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function, when passed a string containing an asserted
expression, a filename, and a line number, prints a message
on the standard error stream such as:
<BLOCKQUOTE>
<PARA>
a.c:10: foobar: Assertion a == b failed.
</PARA>
</BLOCKQUOTE>
It then aborts program execution via a call to <FUNCTION>abort</FUNCTION>.  The
exact form of the message is up to the implementation.
</PARA>

<PARA>
If FUNCTION is NULL, then omit information about the function.
FILE, LINE, and ASSERTION must be non-NULL.
</PARA>

<PARA>
This function is part of the ABI, and not the API.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-errno-location-1"> <REFMETA>
<REFENTRYTITLE>__errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__errno_location
</REFNAME>
<REFPURPOSE>address of errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int *__errno_location (void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Return the address of the errno variable.  Only in the binary
standard, not the source standard.  Note that errno itself is only in
the source standard, not the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---getpgid-1"> <REFMETA>
<REFENTRYTITLE>__getpgid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpgid</REFNAME>
<REFPURPOSE>
get the process group id
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
pid_t __getpgid(pid_t pid);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__getpgid(pid) has the same specification as getpgid(pid).
</PARA>
<PARA>
__getpgid is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stderr--1"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stderr_</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stderr_</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_2_1_stderr_(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stdin--1"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stdin_</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stdin_</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_2_1_stdin_(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stdout--1"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stdout_</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stdout_</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_2_1_stdout_(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-feof-1"> <REFMETA>
<REFENTRYTITLE>_IO_feof</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_feof</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_feof(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-getc-1"> <REFMETA>
<REFENTRYTITLE>_IO_getc</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_getc</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_getc(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-putc-1"> <REFMETA>
<REFENTRYTITLE>_IO_putc</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_putc</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_putc(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-puts-1"> <REFMETA>
<REFENTRYTITLE>_IO_puts</REFENTRYTITLE>
<REFMISCINFO>What Section??</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_puts</REFNAME>
<REFPURPOSE>What is this?
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE> 8 Feb 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>return_type _IO_puts(parameters) </SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE> 8 Feb 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtod-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtod_internal
</REFNAME>
<REFPURPOSE>mangle of strtod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
double __strtod_internal (const char *<REPLACEABLE CLASS="PARAMETER">__nptr</REPLACEABLE>,
                          char **<REPLACEABLE CLASS="PARAMETER">__endptr</REPLACEABLE>,
                          int <REPLACEABLE CLASS="PARAMETER">__group</REPLACEABLE>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __GROUP argument must be 0 or the behavior is undefined.
Otherwise the same as

<BLOCKQUOTE>
<PARA>
strtod (__nptr, __endptr).
</PARA>
</BLOCKQUOTE>

Only in the binary standard, not the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtol-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtol_internal
</REFNAME>
<REFPURPOSE>mangle of strtol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
long int __strtol_internal (const char *__nptr, char **__endptr,
                            int __base, int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__GROUP must be 0 or the behavior is undefined.  Otherwise the same as
strtol (__nptr, __endptr, __base).  Only in the binary standard, not the
source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---xmknod-1"> <REFMETA>
<REFENTRYTITLE>__xmknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xmknod</REFNAME>
<REFPURPOSE>
make block or character special file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __xmknod(int ver,
            __const char *path,
            __mode_t mode,
            __dev_t *dev);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
ver must be 1 or the behavior is undefined.
</PARA>
<PARA>
__xmknod(1, path, mode, dev) has the same specification as mknod(path, mode, dev).
</PARA>
<PARA>
Note that the  of dev_t is not the same as the argument that the kernel syscall uses (TODO: need to document what dev_t is).
</PARA>
<PARA>
__xmknod is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-acct-3"> <REFMETA>
<REFENTRYTITLE>acct</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>acct</REFNAME>
<REFPURPOSE>
switch process accounting on or off
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

     int acct(const char *filename);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When called with the name of an existing file as argument,
accounting is turned on, records for each terminating process  
are appended to filename as it terminates.  An argument of 
NULL causes accounting to be turned off.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
On success, zero is returned.  On error, -1  is  returned,
and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
BSD  process  accounting  has not been enabled when
the operating system kernel was compiled.  The kernel  
configuration  parameter controlling this feature is CONFIG_BSD_PROCESS_ACCT.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process has  no  permission  to  enable
       process accounting.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
The argument filename is not a regular file.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
Error writing to the file filename.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EUSERS 
</TERM>
<LISTITEM>
<PARA>
There  are  no  more free file structures or we run
              out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-adjtime-2"> <REFMETA>
<REFENTRYTITLE>adjtime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtime
</REFNAME>
<REFPURPOSE>
correct the time to allow synchronization of the system clock
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>23 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
 #include &lt;time.h>

     int adjtime(const struct timeval *delta, struct timeval *olddelta);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>23 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     Adjtime() makes small adjustments to the system time, as returned by
     gettimeofday(2),  advancing or retarding it by the time specified by the
     timeval delta. If delta is negative, the clock is slowed down by incrementing 
	it more slowly than normal until the correction is complete.  If
     delta is positive, a larger increment than normal is used.  The skew used
     to perform the correction is generally a fraction of one percent.  Thus,
     the time is always a monotonically increasing function.  A time correction 
	from an earlier call to adjtime() may not be finished when adjtime()
     is called again.  If olddelta is non-nil, the structure pointed to will
     contain, upon return, the number of microseconds still to be corrected
     from the earlier call.
</PARA><PARA>

     This call may be used by time servers that synchronize the clocks of computers 
	in a local area network.  Such time servers would slow down the
     clocks of some machines and speed up the clocks of others to bring them
     to the average network time.
</PARA><PARA>

     The call adjtime() is restricted to the super-user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUES
</TITLE>
<PARA>
     A return value of 0 indicates that the call succeeded.  A return value of
     -1 indicates that an error occurred, and in this case an error code is
     stored in the global variable errno.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
     Adjtime() will fail if:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
     [EFAULT]   
</TERM>
<LISTITEM>
<PARA>
An argument points outside the process's allocated address space.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
     [EPERM]       
</TERM>
<LISTITEM>
<PARA>
The process's effective user ID is not that of the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-adjtimex-3"> <REFMETA>
<REFENTRYTITLE>adjtimex</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtimex</REFNAME>
<REFPURPOSE>
tune kernel clock
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/timex.h>

int adjtimex(struct timex *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Linux uses David L. Mills' clock adjustment algorithm (see
RFC 1305).  The system call adjtimex reads and  optionally
sets adjustment parameters for this algorithm.  It takes a
pointer to a timex structure,  updates  kernel  parameters
from  field  values,  and  returns the same structure with
current kernel values.  This structure is declared as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct timex {
</TERM>
<LISTITEM>
<PARA>
                  int modes;           /* mode selector */
</PARA><PARA>
                  long offset;         /* time offset (usec) */
</PARA><PARA>
                  long freq;           /* frequency offset (scaled ppm) */
</PARA><PARA>
                  long maxerror;       /* maximum error (usec) */
</PARA><PARA>
                  long esterror;       /* estimated error (usec) */
</PARA><PARA>
                  int status;          /* clock command/status */
</PARA><PARA>
                  long constant;       /* pll time constant */
</PARA><PARA>
                  long precision;      /* clock precision (usec) (read only) */
</PARA><PARA>
                  long tolerance;      /* clock frequency tolerance (ppm)
                                          (read only) */
</PARA><PARA>
                  struct timeval time; /* current time (read only) */
</PARA><PARA>
                  long tick;           /* usecs between clock ticks */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
The  modes  field  determines which parameters, if any, to
set.  It may contain a bitwise-or combination of  zero  or
more of the following bits:
</PARA><PARA>
              #define ADJ_OFFSET            0x0001 /* time offset */
</PARA><PARA>
              #define ADJ_FREQUENCY         0x0002 /* frequency offset */
</PARA><PARA>
              #define ADJ_MAXERROR          0x0004 /* maximum time error */
</PARA><PARA>
              #define ADJ_ESTERROR          0x0008 /* estimated time error */
</PARA><PARA>
              #define ADJ_STATUS            0x0010 /* clock status */
</PARA><PARA>
              #define ADJ_TIMECONST         0x0020 /* pll time constant */
</PARA><PARA>
              #define ADJ_TICK              0x4000 /* tick value */
</PARA><PARA>
              #define ADJ_OFFSET_SINGLESHOT 0x8001 /* old-fashioned adjtime */
</PARA><PARA>
Ordinary  users  are  restricted to a zero value for mode.
Only the superuser may set any parameters.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
On success, adjtimex returns the clock state:
</PARA><PARA>

              #define TIME_OK   0 /* clock synchronized */
</PARA><PARA>
              #define TIME_INS  1 /* insert leap second */
</PARA><PARA>
              #define TIME_DEL  2 /* delete leap second */
</PARA><PARA>
              #define TIME_OOP  3 /* leap second in progress */
</PARA><PARA>
              #define TIME_WAIT 4 /* leap second has occurred */
</PARA><PARA>
              #define TIME_BAD  5 /* clock not synchronized */
</PARA><PARA>

On failure, adjtimex returns -1 and sets errno.
</PARA>

</REFSECT1><REFSECT1>
<TITLE>ERRORS
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
buf does not point to writable memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
buf.mode is non-zero and the  user  is  not  super-
       user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
An attempt is made to set buf.offset to a value
       outside the range -131071 to  +131071,  or  to  set
       buf.status  to  a  value  other  than  those listed
       above, or to set buf.tick to a  value  outside  the
       range 900000/HZ to 1100000/HZ, where HZ is the sys-
       tem timer interrupt frequency.

</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-alphasort-3"> <REFMETA>
<REFENTRYTITLE>alphasort</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>alphasort</REFNAME>
<REFPURPOSE>
Scan a directory for matching entries
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

int alphasort(const struct dirent **a, const struct dirent **b);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The alphasort() function can be  used  as  the  comparison
function  for the scandir() function to sort the directory
entries into alphabetical order.  Its parameters  are  the
two directory entries, a and b, to compare.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The alphasort() function returns  an  integer  less  than,
equal  to,  or  greater than zero if the first argument is
considered to be respectively  less  than,  equal  to,  or
greater than the second.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<PARA>
ENOMEM Insufficient memory to complete the operation.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-cfmakeraw-3"> <REFMETA>
<REFENTRYTITLE>cfmakeraw</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfmakeraw</REFNAME>
<REFPURPOSE>
get and set  terminal attributes
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;termios.h>

int cfmakeraw ( struct termios *termios_p );
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
cfmakeraw sets the terminal attributes as follows:
</TERM>
<LISTITEM>
<PARA>
 termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);
</PARA><PARA>
 termios_p->c_oflag &= ~OPOST;
</PARA><PARA>
 termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
</PARA><PARA>
 termios_p->c_cflag &= ~(CSIZE|PARENB);
</PARA><PARA>
 termios_p->c_cflag |= CS8;
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
termios_p  is a pointer to a termios structure.  This
structure contains the following members:
</PARA><PARA>
              tcflag_t c_iflag;      /* input modes */
</PARA><PARA>
              tcflag_t c_oflag;      /* output modes */
</PARA><PARA>
              tcflag_t c_cflag;      /* control modes */
</PARA><PARA>
              tcflag_t c_lflag;      /* local modes */
</PARA><PARA>
              cc_t c_cc[NCCS];       /* control chars */

</PARA>
</REFSECT1><REFSECT1>
<TITLE>RETURN VALUE
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
0      
</TERM>
<LISTITEM>
<PARA>
on success.
</PARA>
</LISTITEM>
</VARLISTENTRY><VARLISTENTRY>
<TERM>
-1     
</TERM>
<LISTITEM>
<PARA>
on failure and set errno to indicate the error.
</PARA>
</LISTITEM>
</VARLISTENTRY></VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-cfsetspeed-3"> <REFMETA>
<REFENTRYTITLE>cfsetspeed</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfsetspeed
</REFNAME>
<REFPURPOSE>
manipulating the termios structure
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     #include &lt;termios.h>

     int cfsetspeed(struct termios *t, speedt speed);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     The cfsetspeed function is provided for setting the baud rate values in
     the termios structure.  The effects of the function on the terminal as
     described below do not become effective, nor are all errors detected, until 
     the tcsetattr function is called.  Certain values for baud rates set
     in the termios structure and passed to tcsetattr have special meanings.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
GETTING AND SETTING THE BAUD RATE
</TITLE>
<PARA>
     The input and output baud rates are found in the termios structure.  The
     unsigned integer speed_t is typdef'd in the include file &lt;termios.h>. The
     value of the integer corresponds directly to the baud rate being represented, 
     however, the following symbolic values are defined.
</PARA><PARA>
     #define B0      0
</PARA><PARA>
     #define B50     50
</PARA><PARA>
     #define B75     75
</PARA><PARA>
     #define B110    110
</PARA><PARA>
     #define B134    134
</PARA><PARA>
     #define B150    150
</PARA><PARA>
     #define B200    200
</PARA><PARA>
     #define B300    300
</PARA><PARA>
     #define B600    600
</PARA><PARA>
     #define B1200   1200
</PARA><PARA>
     #define B1800   1800
</PARA><PARA>
     #define B2400   2400
</PARA><PARA>
     #define B4800   4800
</PARA><PARA>
     #define B9600   9600
</PARA><PARA>
     #define B19200  19200
</PARA><PARA>
     #define B38400  38400
</PARA><PARA>
     #ifndef _POSIX_SOURCE
</PARA><PARA>
     #define EXTA    19200
</PARA><PARA>
     #define EXTB    38400
</PARA><PARA>
     #endif  /*_POSIX_SOURCE */
</PARA><PARA>
     The cfsetspeed function sets both the input and output baud rate in the
     termios structure referenced by tp to speed.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
     Upon successful completion, cfsetspeed returns a value of 0.  
     Otherwise, a value of -1 is returned and
     the global variable errno is set to indicate the error.
</PARA>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-daemon-3"> <REFMETA>
<REFENTRYTITLE>daemon</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>daemon</REFNAME>
<REFPURPOSE>
Run in the background
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int daemon (int nochdir, int noclose);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  daemon()  function  is for programs wishing to detach
themselves from the controlling terminal and  run  in  the
background as system daemons.

Unless  the argument nochdir is non-zero, daemon() changes
the current working directory to the root (`/').

Unless the argument noclose  is  non-zero,  daemon()  will
redirect  standard  input,  standard  output  and standard
error to /dev/null.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<PARA>
If an error occurs,  daemon()  returns  -1  and  sets  the
global  variable  errno to any of the errors specified for
the library functions fork(2) and setsid(2).
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-dladdr-3"> <REFMETA>
<REFENTRYTITLE>dladdr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dladdr
</REFNAME>
<REFPURPOSE>
library routine for dynamic linking of object files
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     cc ... -ldl ...

     #include &lt;dlfcn.h>

     typedef struct {
             const char      *dli_fname;
             void            *dli_fbase;
             const char      *dli_sname;
             void            *dli_saddr;
     } Dl_info;

     int dladdr(void *address, Dlinfo *dlip);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     This function implements the System V dynamic linking routines.
</PARA><PARA>

The dladdr() function is the inverse of the dlsym() function.  If the
     given address is successfully located inside a module, dladdr() returns
     nonzero, otherwise 0.  On a successful return, the fields of dlip are
     filled in as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
     dlifname   
</TERM>
<LISTITEM>
<PARA>
the pathname of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
     dlifbase   
</TERM>
<LISTITEM>
<PARA>
the base address of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
     dlisname   
</TERM>
<LISTITEM>
<PARA>
the name of the highest addressed symbol whose address precedes the given address 
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
     dlifaddr   
</TERM>
<LISTITEM>
<PARA>
the address of that symbol
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
     Shared objects must be linked using the -shared option to the linker
     ld(1).  The linker flag -rpath may be used to add a directory to the default 
     search path for shared objects and shared libraries.  The linker
     flag -E or the C compiler flag -rdynamic should be used to cause the application 
     to export its symbols to the shared objects. 
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ENVIRONMENT
</TITLE>
<PARA>
     LD_LIBRARY_PATH        directory search-path for object files
</PARA>
</REFSECT1>
<!--      BSDI BSD/OS                    February 9, 1998    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-endutent-3"> <REFMETA>
<REFENTRYTITLE>endutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>endutent</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

void endutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
endutent() closes the utmp file.  It should be called when
the user code is done accessing the file  with  the  other
functions
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-error-n"> <REFMETA>
<REFENTRYTITLE>error</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>error</REFNAME>
<REFPURPOSE>
Generate an error
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
error message ?info? ?code?
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Returns a TCL_ERROR code, which causes command interpretation
to be unwound.  Message is a string that is  returned
to the application to indicate what went wrong.

If  the  info argument is provided and is non-empty, it is
used to initialize the global variable errorInfo.   erroInfo 
is  used  to accumulate a stack trace of what was in
progress  when  an  error  occurred;  as  nested  commands
unwind, the Tcl interpreter adds information to errorInfo.
If the info argument is present, it is used to  initialize
errorInfo  and  the  first increment of unwind information
will not be added by the Tcl interpreter.  In other words,
the  command  containing the error command will not appear
in errorInfo; in its place will be info.  This feature  is
most  useful  in  conjunction with the catch command: if a
caught error cannot be handled successfully, info  can  be
used to return a stack trace reflecting the original point
of occurrence of the error:
              catch {...} errMsg
              set savedInfo $errorInfo
              ...
              error $errMsg $savedInfo

If the code argument is present, then its value is  stored
in  the  errorCode  global  variable.   This  variable  is
intended to hold a  machine-readable  description  of  the
error  in  cases  where such information is available; see   
the tclvars manual page for information on the proper 
for  the  variable.  If the code argument is not present
then errorCode is automatically reset to `NONE' by
the Tcl interpreter as part of processing the error generated
by the command.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-flock-2"> <REFMETA>
<REFENTRYTITLE>flock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>flock</REFNAME>
<REFPURPOSE>
apply or remove an advisory lock on an open file.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int flock(int fd, int operation)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Apply or  remove  an  advisory lock on an open file.  The file is specified  by  fd.   Valid  operations  are  given below:
</PARA>
<PARA>
              LOCK_SH   Shared  lock.   More than one process may
                        hold a shared lock for a given file at  a
                        given time.
</PARA>
<PARA>
              LOCK_EX   Exclusive  lock.   Only  one  process may
                        hold an exclusive lock for a  given  file
                        at a given time.
</PARA>
<PARA>
             LOCK_UN   Unlock.
</PARA>
<PARA>
              LOCK_NB   Don't  block when locking.  May be speci-
                        fied (by or'ing) along with  one  of  the
                        other operations.
</PARA>
<PARA>
       A  single file may not simultaneously have both shared and
       exclusive locks.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
      On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<PARA>
EWOULDBLOCK
              The  file  is  locked  and  the  LOCK_NB  flag  was
              selected.

</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-fstatfs-2"> <REFMETA>
<REFENTRYTITLE>fstatfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fstatfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int fstatfs(int fd, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>
Description
</TITLE>
<PARA>
fstatfs  returns  information  about a mounted file system.  fd is the open file descriptor of any file within the mounted filesystem.   buf  is  a  pointer  to  a  statfs structure defined as follows:

</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
On success, zero is returned.  On error, -1  is  returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
fd is not a valid open file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
 buf points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS
</TERM>
<LISTITEM>
<PARA>
The  filesystem  fd  is  open  on  does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-fwprintf-3"> <REFMETA>
<REFENTRYTITLE>fwprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fwprintf
</REFNAME>
<REFPURPOSE>
formatted wide character output conversion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>3 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int fwprintf (FILE* stream, const wchar_t* , ...);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The specification for "fwprintf" is as specified in the SUSv2 but with 
the following differences as listed below.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
Wide-character Conversion:
</TITLE>
<PARA>
The following wide-character are not specificed in GNU:
</PARA><PARA>
d,i, o, u, x, X, f, e,E , g,G , c, s, p, n, C, S, %
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
The following error types are not specified in GNU:
</PARA><PARA>
EILSEQ, EINVAL, ENOMEM
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-gethostbyname-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname</REFNAME>
<REFPURPOSE>
get network host entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>
extern int h_errno;

struct hostent *gethostbyname(const char *name);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The gethostbyname() function returns a structure  of  type
hostent  for  the  given host name.  Here name is either a
host name, or an IPv4 address in standard dot notation, or
an IPv6 address in colon (and possibly dot) notation. (See
RFC 1884 for the description of IPv6 addresses.)  If  name
is  an  IPv4  or  IPv6 address, no lookup is performed and
gethostbyname() simply copies name into the  h_name  field
and  its struct in_addr equivalent into the h_addr_list[0]
field of the returned hostent structure.  If name  doesn't
end  in  a dot and the environment variable HOSTALIASES is
set, the alias file pointed to by HOSTALIASES  will  first
be  searched  for  name (see hostname(7) for the file for-
mat).  The current domain and  its  parents  are  searched
unless name ends in a dot.
</PARA><PARA>

The domain name queries carried out by gethostbyname()
use  a  combination  of any or all of the name server
named(8), a broken out line  from  /etc/hosts, and the 
Network Information Service (NIS or YP), depending upon
the contents of the  order  line  in  /etc/host.conf.
(See   resolv+(8)).    The  default  action  is  to  query
named(8), followed by /etc/hosts.
</PARA><PARA>
The hostent structure is defined in &lt;netdb.h> as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct hostent {
</TERM>
<LISTITEM>
<PARA>
       char    *h_name;        /* official name of host */
</PARA><PARA>
       char    **h_aliases;    /* alias list */
</PARA><PARA>
       int     h_addrtype;     /* host address type */
</PARA><PARA>
       int     h_length;       /* length of address */
</PARA><PARA>
       char    **h_addr_list;  /* list of addresses */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
#define h_addr  h_addr_list[0]  /* for backward compatibility */
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  gethostbyname()) functions return the hostent
structure  or  a  NULL  pointer  if  an  error occurs.  
On  error,  the  h_errno variable holds an error
number
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<PARA>
ENOMEM Insufficient memory to complete the operation. 
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-getloadavg-3"> <REFMETA>
<REFENTRYTITLE>getloadavg</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getloadavg
</REFNAME>
<REFPURPOSE>
get system load averages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getloadavg(double loadavg[], int nelem);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
 The getloadavg() function returns the number of processes in the system
     run queue averaged over various periods of time.  Up to nelem samples are
     retrieved and assigned to successive elements of loadavg[]. The system
     imposes a maximum of 3 samples, representing averages over the last 1, 5,
     and 15 minutes, respectively.
</PARA>
</REFSECT1>
<!--     BSDI BSD/OS                      June 4, 1993       -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-getopt-long-3"> <REFMETA>
<REFENTRYTITLE>getopt_long</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long</REFNAME>
<REFPURPOSE>
Parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt_long() function works like getopt() except that
it  also  accepts long options, started out by two dashes.
Long option names may be abbreviated if  the  abbreviation
is unique or is an exact match for some defined option.  A
long option may take a parameter, of the form  --arg=param
or --arg param.
</PARA><PARA>

longopts  is a pointer to the first element of an array of
       struct option declared in &lt;getopt.h> as
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
          struct option {
</TERM>
<LISTITEM>
<PARA>
              const char *name;
</PARA><PARA>
              int *flag;
</PARA><PARA>
              int has_arg;
</PARA><PARA>
              int val;
</PARA><PARA>
          };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The getopt_long() function returns the option character if the
option  was found successfully, : if there was a missing
parameter for one of  the  options,  ?  for  an  unknow
option character, or -1 for the end of the option list.

</PARA><PARA>
getopt_long() also  returns  the option character when a
short option is recognized.  For a long option, 
they return val if flag is NULL, and 0 otherwise.
Error and -1 returns are the same as for  getopt(),
plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-getopt-long-only-3"> <REFMETA>
<REFENTRYTITLE>getopt_long_only</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long_only</REFNAME>
<REFPURPOSE>
Parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long_only(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getopt_long_only() is like getopt_long(), but - as  well
as  --  can  indicate  a long option.  If an option that
starts with - (not --) doesn't match  a  long  option,
but  does  match  a  short option, it is parsed as a short
option instead.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The function getopt_long_only() returns the option character 
if the option  was found successfully, : if there was a 
missing parameter for one of  the  options,  ?  for  an 
unknown option character, or -1 for the end of the option list.
getopt_long_only() also returns the option character when a
short option is recognized.  For a long option, 
they return val if flag is NULL, and 0 otherwise.
Error and -1 returns are the same as for getopt(),
plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-getprotobyname-3"> <REFMETA>
<REFENTRYTITLE>getprotobyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotobyname
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotobynumber(int proto);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getprotobyname() function returns a protoent structure
       for the line from /etc/protocols that matches the protocol
       name name.
</PARA>
<PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
The getprotobyname() function returns the protoent structure, or a NULL pointer if an 
error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
/etc/protocols
              protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getprotoent-3"> <REFMETA>
<REFENTRYTITLE>getprotoent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotoent
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotoent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
 The getprotoent() function reads the next  line  from  the
       file  /etc/protocols and returns a structure protoent con-
       taining  the  broken  out  fields  from  the  line.    The
       /etc/protocols file is opened if necessary.
</PARA><PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
The getprotoent() function returns the protoent structure, or a NULL pointer if an 
error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
/etc/protocols
              protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getservbyname-3"> <REFMETA>
<REFENTRYTITLE>getservbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservbyname
</REFNAME>
<REFPURPOSE>
 get service entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

       struct servent *getservbyname(const char *name, const char *proto);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  getservbyname()  function returns a servent structure
       for the line from /etc/services that matches  the  service
       name using protocol proto.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       getservbyname() returns the servent structure, or a NULL  pointer
       if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /etc/services
              services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getservent-3"> <REFMETA>
<REFENTRYTITLE>getservent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservent
</REFNAME>
<REFPURPOSE>
 get service entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
 #include &lt;netdb.h>

       struct servent *getservent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getservent() function reads the  next  line  from  the
       file  /etc/services  and  returns a structure servent con-
       taining  the  broken  out  fields  from  the  line.    The
       /etc/services file is opened if necessary.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       getservent() returns the servent structure, or a NULL  pointer
       if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /etc/services
              services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-gettext"> <REFMETA>
<REFENTRYTITLE>gettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gettext</REFNAME>
<REFPURPOSE>
Used to look up MSGID in the current default message catalog for the current
LC_MESSAGES locale.  
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *gettext  ((const char *msgid));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used to Look up the MSGID in the DOMAINNAME message catalog for the current
CATEGORY locale.  If not found, returns MSGID itself (the default text). 
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-getutent-3"> <REFMETA>
<REFENTRYTITLE>getutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent
</REFNAME>
<REFPURPOSE>
 access utmp file entries	
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

       struct utmp *getutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getutent()  reads a line from the current file position in
       the utmp file.  It returns a pointer to a  structure  con-
       taining the fields of the line.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ETURN VALUE
</TITLE>
<PARA>
       getutent() returns a pointer to a static struct utmp.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
       On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /var/run/utmp  database of currently logged-in users
</PARA><PARA>
       /var/log/wtmp  database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-htons-3"> <REFMETA>
<REFENTRYTITLE>htons</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>htons</REFNAME>
<REFPURPOSE>Converts host byte order to network byte order.
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netinet/in.h>

unsigned short int htons(unsigned short int hostshort);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The htons() function converts the short integer hostshort
from host byte order to network byte order
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-inet-aton-3"> <REFMETA>
<REFENTRYTITLE>inet_aton</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inet_aton
</REFNAME>
<REFPURPOSE>
Internet  address manipulation routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;sys/socket.h>
        #include &lt;netinet/in.h>
        #include &lt;arpa/inet.h>

       int inet_aton(const char *cp, struct in_addr *inp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
inet_aton() converts the Internet host address cp from the
       standard numbers-and-dots notation into  binary  data  and
       stores  it  in the structure that inp points to. inet_aton
       returns nonzero if the address is valid, zero if not.
</PARA><PARA>
 The   structure   in_addr is defined in netinet/in.h as:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct in_addr {
</TERM>
<LISTITEM>
<PARA>
                      unsigned long int s_addr;
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Note that on the i80x86 the host byte order is Least  Significant  Byte  first,  whereas the network byte order, as used on the Internet, is Most Significant Byte first.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-inet-ntoa-3"> <REFMETA>
<REFENTRYTITLE>inet_ntoa</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inet_ntoa
</REFNAME>
<REFPURPOSE>
Internet  address manipulation routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;sys/socket.h>
        #include &lt;netinet/in.h>
        #include &lt;arpa/inet.h>

 char *inet_ntoa(struct in_addr in);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The   inet_ntoa()  function  converts  the  Internet  host
       address in given in network byte  order  to  a  string  in
       standard   numbers-and-dots   notation.    The  string  is
       returned in a statically allocated  buffer,  which  subse-
       quent calls will overwrite.
</PARA><PARA>
 The   structure   in_addr is defined in netinet/in.h as:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct in_addr {
</TERM>
<LISTITEM>
<PARA>
                      unsigned long int s_addr;
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Note that on the i80x86 the host byte order is Least  Significant  Byte  first,  whereas the network byte order, as used on the Internet, is Most Significant Byte first.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-initgroups-3"> <REFMETA>
<REFENTRYTITLE>initgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>initgroups
</REFNAME>
<REFPURPOSE>
nitialize  the  supplementary group access list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;grp.h>
        #include &lt;sys/types.h>

       int initgroups(const char *user, gid_t group);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The initgroups() function  initializes  the  group  access
       list  by  reading  the group database /etc/group and using
       all groups of which user  is  a  member.   The  additional
       group group is also added to the list.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The  initgroups()  function returns 0 on success, or -1 if
       an error occurs.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process does not have sufficient privileges.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient  memory  to allocate group information
              structure.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /etc/group          group database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-ioperm-2"> <REFMETA>
<REFENTRYTITLE>ioperm</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ioperm
</REFNAME>
<REFPURPOSE>
set port input/output permissions
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;unistd.h> /* for libc5 */
        #include &lt;sys/io.h> /* for glibc */

       int  ioperm(unsigned  long  from,  unsigned  long num, int turn_on);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>

Ioperm sets the port access permission bits for  the  pro-
       cess  for num bytes starting from port address from to the
       value turn_on.  The use of  ioperm  requires  root  privi-
       leges.

</PARA><PARA>
       Only  the  first  0x3ff I/O ports can be specified in this
       manner.  For more ports, the iopl function must  be  used.
       Permissions  are  not  inherited on fork, but on exec they
       are. This is useful for giving port access permissions  to
       non-privileged tasks.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       On  success,  zero is returned.  On error, -1 is returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       Libc5  treats  it  as a system call and has a prototype in
       &lt;unistd.h>.  Glibc1 does not have a prototype. Glibc2  has
       a prototype both in &lt;sys/io.h> and in &lt;sys/perm.h>.  Avoid
       the latter, it is available on i386 only.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-iopl-2"> <REFMETA>
<REFENTRYTITLE>iopl</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iopl
</REFNAME>
<REFPURPOSE>
change I/O privilege level
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;unistd.h> /* for libc5 */
        #include &lt;sys/io.h> /* for glibc */

       int iopl(int level);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
 iopl  changes  the I/O privilege level of the current pro-
       cess, as specified in level.

</PARA><PARA>
       This call is necessary to allow 8514-compatible X  servers
       to  run under Linux.  Since these X servers require access
       to all 65536 I/O ports, the ioperm call is not sufficient.

</PARA><PARA>
       In addition to granting unrestricted I/O port access, run-
       ning at a higher I/O privilege level also allows the  pro-
       cess  to disable interrupts.  This will probably crash the
       system, and is not recommended.
</PARA><PARA>
       rmissions are inherited by fork and exec.

</PARA><PARA>
       The I/O privilege level for a normal process is 0.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
       EINVAL 
</TERM>
<LISTITEM>
<PARA>
level is greater than 3.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       EPERM  
</TERM>
<LISTITEM>
<PARA>
The current user is not the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES FROM THE KERNEL SOURCE
</TITLE>
<PARA>
       iopl  has to be used when you want to access the I/O ports
       beyond the 0x3ff  range:  to  get  the  full  65536  ports
       bitmapped  you'd  need  8kB of bitmaps/process, which is a
       bit excessive.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       Libc5  treats  it  as a system call and has a prototype in
       &lt;unistd.h>.  Glibc1 does not have a prototype. Glibc2  has
       a prototype both in &lt;sys/io.h> and in &lt;sys/perm.h>.  Avoid
       the latter, it is available on i386 only.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-isblank-3"> <REFMETA>
<REFENTRYTITLE>isblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>isblank
</REFNAME>
<REFPURPOSE>
character classification routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>

#include &lt;ctype.h>

       int isblank (int c);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
 This functions checks whether c, which must have the value
       of an unsigned char or EOF, falls into a certain character
       class according to the current locale.
</PARA><PARA>
 isblank()
              checks for a blank character; that is, a space or a
              tab.  This function is a GNU extension.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The values returned are nonzero if the character  c  falls
       into the tested class, and a zero value if not.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTE
</TITLE>
<PARA>
       The details of what characters  belong  into  which  class
       depend on the current locale.  For example, isupper() will
       not recognize an A - umlaut as an uppercase letter in  the
       default C locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-isinf-3"> <REFMETA>
<REFENTRYTITLE>isinf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>isinf
</REFNAME>
<REFPURPOSE>
test for infinity or not-a-number  (NaN).
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;math.h>

       int isinf(double value);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
  The isinf() function returns -1 if value represents  negative  infinity,  1  if value represents positive infinity,  and 0 otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-iswblank-3"> <REFMETA>
<REFENTRYTITLE>iswblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswblank
</REFNAME>
<REFPURPOSE>
test for whitespace wide character
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;wctype.h>

       int iswblank (wint_t wc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  iswblank function is the wide-character equivalent of
       the isblank function. It tests whether wc is a wide  char-
       acter belonging to the wide character class "blank".

</PARA><PARA>
       The wide character class "blank" is a subclass of the wide
       character class "space".

</PARA><PARA>
       Being a subclass of the wide character class "space",  the
       wide  character  class  "blank"  is disjoint from the wide
       character class "graph" and therefore also  disjoint  from
       its   subclasses   "alnum",   "alpha",  "upper",  "lower",
       "digit", "xdigit", "punct".

</PARA><PARA>
       The wide character class "blank" always contains at  least
       the space character and the control character '\t'.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ETURN VALUE
</TITLE>
<PARA>
       The  iswblank  function  returns  non-zero if wc is a wide
       character belonging to the wide character  class  "blank".
       Otherwise it returns zero.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       The behaviour of iswblank depends on the LC_CTYPE category
       of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-iswctype-3"> <REFMETA>
<REFENTRYTITLE>iswctype</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswctype
</REFNAME>
<REFPURPOSE>
 wide character classification
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
	#include &lt;wctype.h>

       int iswctype (wint_t wc, wctype_t desc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       If  wc  is  a wide character having the character property
       designated by desc (or in  other  words:  belongs  to  the
       character class designated by desc), the iswctype function
       returns non-zero. Otherwise it  returns  zero.  If  wc  is
       WEOF, zero is returned.

</PARA><PARA>
       desc  must  be a character property descriptor returned by
       the wctype function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ETURN VALUE
</TITLE>
<PARA>
       The iswctype function returns non-zero if the wc  has  the
       designated property. Otherwise it returns 0.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       The behaviour of iswctype depends on the LC_CTYPE category
       of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-llabs-3"> <REFMETA>
<REFENTRYTITLE>llabs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>llabs
</REFNAME>
<REFPURPOSE>
 compute the absolute value of an integer.
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;stdlib.h>
       
	long long int llabs(long long int j);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       llabs() computes the absolute value of the argument j  of
       the appropriate integer type for the function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       Returns the absolute value of the integer argument, of the
       appropriate integer type for the function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       Trying to take the absolute value  of  the  most  negative
       integer is not defined.

</PARA><PARA>
       The  llabs()  function  is included in glibc since version
       2.0, but is not in libc5 or libc4.

</PARA><PARA>
       For  llabs() to be declared, it may be necessary to define
       _ISOC99_SOURCE or _ISOC9X_SOURCE (depending on the version
       of glibc) before including any standard headers.

</PARA><PARA>
       GCC 3.0 also handles llabs() as builtin.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-logwtmp-3"> <REFMETA>
<REFENTRYTITLE>logwtmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logwtmp
</REFNAME>
<REFPURPOSE>
 append an entry to the wtmp file
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;utmp.h>

       void logwtmp(const char *line, const char *name, const char *host);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       logwtmp() constructs an utmp structure using  line,  name,
       host,  current time and current process id.  Then it calls
       updwtmp() to append the structure to the utmp file.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
AVAILABILITY
</TITLE>
<PARA>
       Both functions are available under glibc2, but  not  under
       libc5.  However, logwtmp occurs in the old libbsd.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /var/log/wtmp
              database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-mbsnrtowcs-3"> <REFMETA>
<REFENTRYTITLE>mbsnrtowcs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mbsnrtowcs
</REFNAME>
<REFPURPOSE>
convert a multibyte string to a wide character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;wchar.h>

       size_t mbsnrtowcs (wchar_t *dest, const char **src,
                          size_t nms, size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       The mbsnrtowcs function is like  the  mbsrtowcs  function,
       except  that the number of bytes to be converted, starting
       at *src, is limited to nms.

</PARA><PARA>
       If dest is not a NULL  pointer,  the  mbsnrtowcs  function
       converts  at most nms bytes from the multibyte string *src
       to a wide-character string starting at dest.  At most  len
       wide  characters  are written to dest. The  state *ps
       is updated. The conversion  is  effectively  performed  by
       repeatedly calling mbrtowc(dest,*src,n,ps) where n is some
       positive number, as long as this call succeeds,  and  then
       incrementing  dest  by one and *src by the number of bytes
       consumed. The conversion can stop for three reasons:

</PARA><PARA>
       1. An invalid multibyte sequence has been encountered.  In
       this  case  *src is left pointing to the invalid multibyte
       sequence, (size_t)(-1) is returned, and errno  is  set  to
       EILSEQ.

</PARA><PARA>
       2.  The  nms  limit  forces  a stop, or len non-L'\0' wide
       characters have been stored at dest. In this case *src  is
       left  pointing  to  the next multibyte sequence to be con-
       verted, and the number of wide characters written to  dest
       is returned.

</PARA><PARA>
 3.  The  multibyte  string  has been completely converted,
       including the terminating '\0' (which has the side  effect
       of  bringing  back *ps to the initial state). In this case
       *src is set to NULL, and the  number  of  wide  characters
       written  to  dest, excluding the terminating L'\0' charac-
       ter, is returned.

</PARA><PARA>
       If dest is NULL, len is ignored, and the  conversion  pro-
       ceeds  as above, except that the converted wide characters
       are not written out to memory,  and  that  no  destination
       length limit exists.

</PARA><PARA>
       In  both  of  the  above cases, if ps is a NULL pointer, a
       static anonymous state only known to the mbsnrtowcs  func-
       tion is used instead.

</PARA><PARA>
       The programmer must ensure that there is room for at least
       len wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The mbsnrtowcs function returns the number of wide charac-
       ters that make up the converted part of the wide character
       string, not including the terminating null wide character.
       If   an   invalid   multibyte  sequence  was  encountered,
       (size_t)(-1) is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       The behaviour of mbsnrtowcs depends on the LC_CTYPE  cate-
       gory of the current locale.

</PARA><PARA>
       Passing NULL as ps is not multi-thread safe.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-memmem-3"> <REFMETA>
<REFENTRYTITLE>memmem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memmem</REFNAME>
<REFPURPOSE>
locate a substring
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

void *memmem(const void *haystack, size_t haystacklen,
       const void *needle, size_t needlelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  memmem() function finds the start of the first occur-
rence of the substring needle of length needlelen  in  the
memory area haystack of length haystacklen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  memmem()  function returns a pointer to the beginning
of the substring, or NULL if the substring is not found.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
This function was broken in  Linux  libraries  up  to  and
including  libc  5.0.9;  there the needle and haystack
arguments were interchanged, and a pointer to the  end  of
the  first  occurrence of needle was returned.  Since libc
5.0.9 is still widely used, this is a  dangerous  function
to use.
Both  old  and  new  libc's have the bug that if needle is
empty haystack-1 (instead of haystack) is  returned.   And
glibc  2.0  makes  it  worse, and returns a pointer to the
last byte of haystack. This is fixed in glibc 2.1.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-ntohs-3"> <REFMETA>
<REFENTRYTITLE>ntohs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ntohs</REFNAME>
<REFPURPOSE>convert values between host and network byte order
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netinet/in.h>

unsigned short int ntohs(unsigned short int netshort);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  ntohs()  function converts the short integer netshort
from network byte order to host byte order.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-psignal-3"> <REFMETA>
<REFENTRYTITLE>psignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>psignal</REFNAME>
<REFPURPOSE>
print signal message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

void psignal(int sig, const char *s);

extern const char *const sys_siglist[]
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  psignal()  function displays a message on stderr consisting of the 
string s, a colon, a space,  and  a  string
describing  the signal number sig.  If sig is invalid, the
message displayed will indicate an unknown signal.

The array sys_siglist holds the signal description strings
indexed by signal number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The psignal() function returns no value.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-putwchar--3"> <REFMETA>
<REFENTRYTITLE>putwchar</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>putwchar</REFNAME>
<REFPURPOSE>
write a wide character to standard output
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wint_t putwchar (wchar_t wc);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  putwchar function is the wide-character equivalent of
the putchar function. It writes the wide character  wc  to
stdout.   If ferror(stdout) becomes true, it returns WEOF.
If a wide character conversion error occurs, it sets errno
to EILSEQ and returns WEOF.  Otherwise it returns wc.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  putwchar function returns wc if no error occurred, or
WEOF to indicate an error
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The behaviour of putwchar depends on the LC_CTYPE category
of the current locale.

It  is  reasonable  to  expect that putwchar will actually
write the multibyte sequence  corresponding  to  the  wide
character wc.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>










<REFENTRY ID="baselib-setbuffer-3"> <REFMETA>
<REFENTRYTITLE>setbuffer</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setbuffer
</REFNAME>
<REFPURPOSE>
 stream buffering operation
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;stdio.h>

       void setbuffer(FILE *stream, char *buf, size_tsize);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       setbuffer is an  aliase for call to setvbuf.  It works the
       same, except that  the  size
       of  the  buffer  is  up  to  the caller, rather than being
       determined by the default BUFSIZ.  
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setegid-2"> <REFMETA>
<REFENTRYTITLE>setegid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setegid
</REFNAME>
<REFPURPOSE>
 set real and / or effective group ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;sys/types.h>
       #include &lt;unistd.h>

       int setegid(gid_t egid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       setegid sets real and effective group ID's of the current
       process.  Un-privileged users may change the real group ID
       to the effective group ID and vice-versa.

</PARA><PARA>
       Prior  to  Linux  1.1.38, the saved ID paradigm, when used
       with setegid was broken.  Starting at  1.1.38,
       it is also possible to set the effective group ID from the
       saved group ID.

</PARA><PARA>
       Only the super-user may make other changes.

</PARA><PARA>
       Supplying a value of -1 for either the real  or  effective
       group ID forces the system to leave that ID unchanged.

</PARA><PARA>
       Currently   (libc-4.x.x),  setegid(egid)  is  functionally
       equivalent to setregid(-1, egid).

</PARA><PARA>
       If the real group ID is changed or the effective group  ID
       is set to a value not equal to the previous real group ID,
       the saved group ID will be set to the new effective  group
       ID.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       On  success,  zero is returned.  On error, -1 is returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
       EPERM 
</PARA>
<BLOCKQUOTE>
<PARA>
	      The current  process  is  not  the  super-user  and
              changes other than (i) swapping the effective group
              ID with the real group ID or (ii)  setting  one  to
              the  value of the other or (iii) setting the effec
              tive group ID to the value of the  saved  group  ID
              was specified.
</PARA>
</BLOCKQUOTE>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>


<REFENTRY ID="baselib-setuid-2"> <REFMETA>
<REFENTRYTITLE>setuid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setuid
</REFNAME>
<REFPURPOSE>
set real and / or effective user ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;sys/types.h>
       #include &lt;unistd.h>

       int seteuid(uid_t euid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       seteuid  sets real and effective user ID's of the current
       process.  Un-privileged users may change the real user  ID
       to the effective user ID and vice-versa.

</PARA><PARA>
       Prior  to  Linux  1.1.37, the saved ID paradigm, when used
       with seteuid was broken.

</PARA><PARA>
       Starting at 1.1.37, it is also possible to set the  effec-
       tive user ID from the saved user ID.

</PARA><PARA>
       Only the super-user may make other changes.

</PARA><PARA>
       Supplying  a  value of -1 for either the real or effective
       user ID forces the system to leave that ID unchanged.

</PARA><PARA>
       Currently  seteuid(euid)  is  functionally  equivalent  to
       setreuid(-1, euid).

</PARA><PARA>
       If the real user ID is changed or the effective user ID is
       set to a value not equal to the previous real user ID, the
       saved user ID will be set to the new effective user ID.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       On  success,  zero is returned.  On error, -1 is returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
       EPERM  
</PARA>
<BLOCKQUOTE>
<PARA>
	      The current  process  is  not  the  super-user  and
              changes  other than (i) swapping the effective user
              ID with the real user ID or (ii) setting one to the
              value  of  the other or (iii) setting the effective
              user ID to the value of the saved user ID was specified.
</PARA>
</BLOCKQUOTE>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sethostid-2"> <REFMETA>
<REFENTRYTITLE>sethostid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostid
</REFNAME>
<REFPURPOSE>
set the unique identifier of the current host
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;unistd.h>

       int sethostid(long int hostid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       Set a unique  32-bit  identifier  for  the  current
       machine.   The  32-bit identifier is intended to be unique
       among all UNIX systems in existence. This normally  resem-
       bles  the  Internet  address  for  the  local  machine, as
       returned by gethostbyname(3), and thus usually never needs
       to be set.

</PARA><PARA>
       The sethostid call is restricted to the superuser.

</PARA><PARA>
       The hostid argument is stored in the file /etc/hostid.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       gethostid  returns  the  32-bit identifier for the current
       host as set by sethostid(2).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /etc/hostid
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sethostname-2"> <REFMETA>
<REFENTRYTITLE>sethostname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostname
</REFNAME>
<REFPURPOSE>
set host name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;unistd.h>

       int sethostname(const char *name, size_t len);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       This  function  is used to change the host
       name of the current processor.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       On success, zero is returned.  On error, -1  is  returned,
       and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
       EINVAL 
</TERM>
<LISTITEM>
<PARA>
	      len  is negative or len is larger than the maximum allowed size.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       EPERM  
</TERM>
<LISTITEM>
<PARA>
 	      the caller was not the  superuser.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       EFAULT 
</TERM>
<LISTITEM>
<PARA>
	      name is an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       SUSv2 guarantees that Host names are limited to 255 bytes.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setmntent-3"> <REFMETA>
<REFENTRYTITLE>setmntent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setmntent
</REFNAME>
<REFPURPOSE>
get file system descriptor file entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;stdio.h>
       #include &lt;mntent.h>

       FILE *setmntent(const char *filename, const char *type);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       This routine is used to access the file system description  file /etc/fstab 
	and the mounted file system description file /etc/mtab.

</PARA><PARA>
       The setmntent() function opens the file system description
       file filep and returns a file pointer which can be used by
       getmntent().  The argument type  is  the  type  of  access
       required and can take the same values as the mode argument
       of fopen(3).
</PARA><PARA>
 The mntent structure is defined in &lt;mntent.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct mntent {
</TERM>
<LISTITEM>
<PARA>
                      char    *mnt_fsname;    /* name of mounted file system */
</PARA><PARA>
                      char    *mnt_dir;       /* file system path prefix */
</PARA><PARA>
                      char    *mnt_type;      /* mount type (see mntent.h) */
</PARA><PARA>
                      char    *mnt_opts;      /* mount options (see mntent.h) */
</PARA><PARA>
                      int     mnt_freq;       /* dump frequency in days */
</PARA><PARA>
                      int     mnt_passno;     /* pass number on parallel fsck */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /etc/fstab          file system description file
       /etc/mtab           mounted file system description file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setutent-3"> <REFMETA>
<REFENTRYTITLE>setutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setutent
</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;utmp.h>

       void setutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       setutent()  rewinds  the  file pointer to the beginning of
       the utmp file.  It is generally a Good  Idea  to  call  it
       before any of the other functions.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
       On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
       /var/run/utmp  database of currently logged-in users
       /var/log/wtmp  database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigblock-2"> <REFMETA>
<REFENTRYTITLE>sigblock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigblock
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;signal.h>

       int sigblock(int mask);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       This interface is made obsolete by sigprocmask(2).

</PARA><PARA>
       The sigblock system call adds  the  signals  specified  in
       mask  to  the  set of signals currently being blocked from
       delivery.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       Prototype  for  this  function  is  only  available if
       _BSD_SOURCE is defined before the inclusion of any  system
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-siggetmask-2"> <REFMETA>
<REFENTRYTITLE>siggetmask</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>siggetmask
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;signal.h>

       int siggetmask(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
       siggetmask returns the current set of masked signals.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       Prototype  for  this  function  is  only  available if
       _BSD_SOURCE is defined before the inclusion of any  system
       header file.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigreturn-2"> <REFMETA>
<REFENTRYTITLE>sigreturn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigreturn
</REFNAME>
<REFPURPOSE>
return from signal handler and cleanup stack frame
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int sigreturn(unsigned long __unused);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
 When the Linux kernel creates the stack frame for a signal
       handler,  a  call  to sigreturn is inserted into the stack
       frame so that the the signal handler will  call  sigreturn
       upon return. This inserted call to sigreturn cleans up the
       stack so that the process can restart from  where  it  was
       interrupted by the signal.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
sigreturn never returns.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>WARNING
</TITLE>
<PARA>
sigreturn call is used by the kernel to implement sig-
       nal handlers. It should never be called  directly.  Better
       yet,  the  specific  use  of  the __unused argument varies
       depending on the architecture.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>FILES
</TITLE>
<PARA>
/usr/src/linux/arch/i386/kernel/signal.c
</PARA><PARA>
/usr/src/linux/arch/alpha/kernel/entry.s
</PARA>
</REFSECT1>

<!-- LDP GENERAL PUBLIC LICENSE  -->
<!-- Version 1a, November 1998   -->

</REFENTRY>

<REFENTRY ID="baselib-sigsetmask-2"> <REFMETA>
<REFENTRYTITLE>sigsetmask</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigsetmask
</REFNAME>
<REFPURPOSE>manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>11 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int sigsetmask(int mask);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>11 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
The sigsetmask system call replaces  the  set  of  blocked
       signals totally with a new set specified in mask.  Signals
       are blocked if the corresponding bit in mask is a 1.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
sigsetmask returns the previous set of  masked signals.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
Prototype  for  this  function  is  only  available if _BSD_SOURCE is defined before the inclusion of any  system  header file.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigvec-2"> <REFMETA>
<REFENTRYTITLE>sigvec</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigvec
</REFNAME>
<REFPURPOSE>BSD software signal facilities
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;bsd/signal.h>
int sigvec(int sig, struct sigvec *vec, struct sigvec *ovec);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>

This interface is made obsolete by sigaction(2).
</PARA><PARA>
Under Linux sigvec is #define'd to sigaction, and provides
       at best a rough approximation of the BSD sigvec interface.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-statfs-2"> <REFMETA>
<REFENTRYTITLE>statfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int statfs(const char *path, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
statfs  returns  information  about a mounted file system. path is the path name of any file within the  mounted filesystem.
</PARA><PARA>
buf is a pointer to a statfs structure defined as follow:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
truct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
 On success,zero is returned.  On error, -1  is  returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
ENOTDIR
</TERM>
<LISTITEM>
<PARA>
              A  component  of  the  path prefix of path is not a directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENAMETOOLONG
</TERM>
<LISTITEM>
<PARA>
              path is too long.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOENT 
</TERM>
<LISTITEM>
<PARA>
The file referred to by path does not exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
Search permission is denied for a component of  the
              path prefix of path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ELOOP  
</TERM>
<LISTITEM>
<PARA>
Too  many symbolic links were encountered in trans-
              lating path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
Buf or path points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing
              to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient kernel memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
The  filesystem path is on does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-stime-2"> <REFMETA>
<REFENTRYTITLE>stime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stime</REFNAME>
<REFPURPOSE>
set time
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _SVID_SOURCE /* glibc2 needs this */
#include &lt;time.h>

int stime(time_t *t);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
stime  sets the system's idea of the time and date.  Time,
pointed to by t, is measured in seconds from 00:00:00  GMT
January  1,  1970.   stime()  may  only be executed by the
super user.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
On success, zero is returned.  On error, -1  is  returned,
and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>ERRORS
</TITLE>
<PARA>
EPERM  The caller is not the super-user.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
Under  glibc2,  &lt;time.h>  only  provides  a prototype when
_SVID_SOURCE is defined.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-stpcpy-3"> <REFMETA>
<REFENTRYTITLE>stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpcpy</REFNAME>
<REFPURPOSE>
copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpcpy(char *dest, const char *src);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  stpcpy()  function copies the string pointed to by src
(including the terminating \0 character)  to  the  array
pointed  to by dest.  The strings may not overlap, and the
destination string dest must be large  enough  to  receive
the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
stpcpy()  returns  a pointer to the end of the string dest
(that is, the address of the terminating  null  character)
rather than the beginning.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>EXAMPLE
</TITLE>
<PARA>
For  example,  this program uses stpcpy to concatenate foo
and bar to produce foobar, which it then prints.

                 #include &lt;string.h>

                 int
                 main (void)
                 {
                   char *to = buffer;
                   to = stpcpy (to, "foo");
                   to = stpcpy (to, "bar");
                   printf ("%s\n", buffer);
                 }
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-stpncpy-3"> <REFMETA>
<REFENTRYTITLE>stpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpncpy</REFNAME>
<REFPURPOSE>
copy a fixed-size string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpncpy (char *dest, const char *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The stpncpy function copies at most n characters from  the
string  pointed  to by src, including the terminating '\0'
character, to the array pointed  to  by  dest.  Exactly  n
characters  are written at dest. If the length strlen(src)
is smaller than n, the remaining characters in  the  array
pointed to by dest are filled with '\0' characters. If the
length strlen(src) is greater or equal to  n,  the  string
pointed to by dest will not be '\0' terminated.

The strings may not overlap.

The programmer must ensure that there is room for at least
n characters at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
stpncpy returns a pointer to the terminating null in dest,
or, if dest is not null-terminated, dest + n.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strfry-3"> <REFMETA>
<REFENTRYTITLE>strfry</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strfry</REFNAME>
<REFPURPOSE>
randomize a string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strfry(char *string);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strfry() function randomizes the contents of string by
using rand(3) to randomly swap characters in  the  string.
The result is an anagram of string
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The strfry() functions returns a pointer to the randomized
string.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strnlen-3"> <REFMETA>
<REFENTRYTITLE>strnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

size_t strnlen (const char *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  strnlen  function returns the number of characters in
the string pointed to by s, not including the  terminating
'\0' character, but at most maxlen. In doing this, strnlen
looks only at the first maxlen characters at s  and  never
beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  strnlen  function  returns strlen(s), if that is less
than maxlen, or maxlen if there is no '\0' character among
the first maxlen characters pointed to by s.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strsep-3"> <REFMETA>
<REFENTRYTITLE>strsep</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsep</REFNAME>
<REFPURPOSE>
extract token from string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strsep(char **stringp, const char *delim);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If  *stringp  is  NULL, the strsep() function returns NULL
and does nothing else. Otherwise, this function finds  the
first  token  in  the  string  *stringp,  where tokens are
delimited by symbols in the string delim.  This  token  is
terminated  with  a  \0  character  (by  overwriting the
delimiter) and *stringp  is  updated  to  point  past  the
token.  In case no delimiter was found, the token is taken
to be the entire string *stringp,  and  *stringp  is  made
NULL.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The strsep() function returns a pointer to the token, that
is, it returns the original value of *stringp.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The strsep() function was introduced as a replacement  for
strtok(),  since  the  latter  cannot handle empty fields.
However, strtok() conforms to ANSI-C  and  hence  is  more
portable.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>BUGS
</TITLE>
<PARA>
This  function suffers from the same problems as strtok().
In particular, it modifies the original string. Avoid  it.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strsignal-3"> <REFMETA>
<REFENTRYTITLE>strsignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsignal</REFNAME>
<REFPURPOSE>
return string describing signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

char *strsignal(int sig);

extern const char * const sys_siglist[];
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  strsignal()  function returns a string describing the
signal number passed in the argument sig.  The string  can
only be used until the next call to strsignal().
</PARA><PARA>
The array sys_siglist holds the signal description strings
indexed by signal number.  The strsignal() function should
be used if possible instead of this array.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  strsignal() function returns the appropriate descrip-
tion string, or an unknown signal message  if  the  signal
number  is invalid.  On some systems (but not on Linux), a
NULL pointer may be returned instead for an invalid signal
number.
</PARA>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strtok-r-3"> <REFMETA>
<REFENTRYTITLE>strtok_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtok_r
</REFNAME>
<REFPURPOSE>
extract tokens from strings
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;string.h>

       char *strtok_r(char *s, const char *delim, char **ptrptr);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       A token is a nonempty string of characters not occurring
       in the string delim, followed by  \0  or  by  a  character
       occurring in delim.
</PARA><PARA>

       The  strtok_r()  function  can be used to parse the string s
       into tokens. The first call to strtok_r() should have  s  as
       its first argument. Subsequent calls should have the first
       argument set to NULL. Each call returns a pointer  to  the
       next token, or NULL when no more tokens are found.
</PARA><PARA>

       If  a token ends with a delimiter, this delimiting charac-
       ter is overwritten with a \0 and a  pointer  to  the  next
       character  is  saved  for  the next call to strtok_r().  The
       delimiter string delim may be different for each call.
</PARA><PARA>

       ptrptr is a user allocated char* pointer.  It must be the same while parsing the
       same string.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
BUGS
</TITLE>
<PARA>
       Never use this function. If you do, note that:

</PARA><PARA>
              It modifies its first argument.

</PARA><PARA>
              The identity of the delimiting character is lost.

</PARA><PARA>
              This function cannot be used on constant strings.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The strtok_r() function returns a pointer to the next token,
       or NULL if there are no more tokens.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-strtoq-3"> <REFMETA>
<REFENTRYTITLE>strtoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtoq
</REFNAME>
<REFPURPOSE>
convert string value to a long or quad_t integer
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     #include &lt;sys/types.h>
     #include &lt;stdlib.h>
     #include &lt;limits.h>

     quadt  strtoq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     The strtoq() function converts the string in nptr to a quadt value.  The
     conversion is done according to the given base, which must be between 2
     and 36 inclusive, or be the special value 0.

</PARA><PARA>
     The string may begin with an arbitrary amount of white space (as determined 
     by isspace(3))  followed by a single optional + or - sign.  If
     base is zero or 16, the string may then include a 0x prefix, and the
     number will be read in base 16; otherwise, a zero base is taken as 10
     (decimal) unless the next character is 0, in which case it is taken as
     8 (octal).

</PARA><PARA>
     The remainder of the string is converted to a long value in the obvious
     manner, stopping at the first character which is not a valid digit in the
     given base.  (In bases above 10, the letter A in either upper or lower
     case represents 10, B represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUES
</TITLE>
<PARA>
     strtoq() function returns the result of the conversion,
     unless the value would underflow or overflow.  If an underflow occurs,
     strtoq() returns QUAD_MIN. If an overflow
     occurs, strtoq() returns QUAD_MAX. In both cases, errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
     [ERANGE]  The given string was out of range; the value converted has been
               clamped.
</PARA>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strtouq-3"> <REFMETA>
<REFENTRYTITLE>strtouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtouq
</REFNAME>
<REFPURPOSE>
  convert a string to an uquad_t
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     #include &lt;sys/types.h>
     #include &lt;stdlib.h>
     #include &lt;limits.h>

     uquadt  strtouq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     The strtouq() function converts the string in nptr to a uquadt
     value.  The conversion is done according to the given base, which must be
     between 2 and 36 inclusive, or be the special value 0.

</PARA><PARA>
     The string may begin with an arbitrary amount of white space (as determined 
     by isspace(3))  followed by a single optional + or - sign.  If
     base is zero or 16, the string may then include a 0x prefix, and the
     number will be read in base 16; otherwise, a zero base is taken as 10
     (decimal) unless the next character is 0, in which case it is taken as
     8 (octal).

</PARA><PARA>
     The remainder of the string is converted to an unsigned long value in the
     obvious manner, stopping at the end of the string or at the first character 
     that does not produce a valid digit in the given base.  (In bases
     above 10, the letter A in either upper or lower case represents 10, B
     represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUES
</TITLE>
<PARA>
     Upon success the strtouq() function returns either the result 
     of the conversion or, if there was a leading minus sign, the negation of 
     the result of the conversion, unless the original (non-negated)
     value would overflow.  In the case of an overflow the function returns
     UQUAD_MAX and the global variable errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<PARA>
     [ERANGE]  The given string was out of range; the value converted has been
               clamped.
</PARA>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-system-3"> <REFMETA>
<REFENTRYTITLE>system</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>system
</REFNAME>
<REFPURPOSE>
execute a shell command
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;stdlib.h>

       int system (const char * string);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       system() executes a command specified in string by calling
       /bin/sh -c string, and returns after the command has  been
       completed.   During execution of the command, SIGCHLD will
       be blocked, and SIGINT and SIGQUIT will be ignored.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The value returned is 127 if the execve() call for /bin/sh
       fails,  -1  if there was another error and the return code
       of the command otherwise.

</PARA><PARA>
       If the value of string is NULL, system()  returns  nonzero
       if the shell is available, and zero if not.

</PARA><PARA>
       system()  does  not  affect  the  wait status of any other
       children.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
BUGS
</TITLE>
<PARA>
       It is extremely unfortunate that the libc version of  sys-
       tem()  ignores  interrupts.  This makes programs that call
       it from a loop uninterruptable.  This means that for  such
       purposes one should not use system() but a private version
       like (warning: untested code!)
</PARA><PARA>
       Do not use system() from a program with suid or sgid priv-
       ileges,  because strange values for some environment vari-
       ables might be used to subvert system integrity.  Use  the
       exec(3)  family of functions instead, but not execlp(3) or
       execvp(3).  system() will not, in fact, work properly from
       programs  with suid or sgid privileges on systems on which
       /bin/sh is bash version 2, since bash 2  drops  privileges
       on  startup.   (Debian uses a modified bash which does not
       do this when invoked as sh.)

</PARA><PARA>
       The check for the availability of /bin/sh is not  actually
       performed;  it  is  always assumed to be available.  ISO C
       specifies the check, but POSIX.2 specifies that the return
       shall always be non-zero, since a system without the shell
       is not conforming, and it is this that is implemented.

</PARA><PARA>
       It is possible for the shell command  to  return  127,  so
       that  code is not a sure indication that the execve() call
       failed; check errno to make sure.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wait4-2"> <REFMETA>
<REFENTRYTITLE>wait4</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wait4
</REFNAME>
<REFPURPOSE>
wait for process termination, BSD style
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #define _USE_BSD
       #include &lt;sys/types.h>
       #include &lt;sys/resource.h>
       #include &lt;sys/wait.h>

       pid_t wait4(pid_t pid, int *status, int options,
             struct rusage *rusage)
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  wait4 function suspends execution of the current process 
until a child as specified by the  pid  argument  has
exited,  or until a signal is delivered whose action is to
terminate the current process or to call a signal handling
function.   If  a  child  as  requested by pid has already
exited by the time of the call (a so-called "zombie"  process),  
the  function  returns  immediately.   Any  system
resources used by the child are freed.

</PARA><PARA>
The value of pid can be one of:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
 &lt; -1   
</TERM>
<LISTITEM>
<PARA>
which means to wait for  any  child  process  whose
process  group ID is equal to the absolute value of
pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       -1     
</TERM>
<LISTITEM>
<PARA>
which means to wait for any child process; this  is
              equivalent to calling wait3.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       0      
</TERM>
<LISTITEM>
<PARA>
which  means  to  wait  for any child process whose
              process group ID is equal to that  of  the  calling
              process.
</PARA>
</LISTITEM>
</VARLISTENTRY>


<VARLISTENTRY>
<TERM>
       &gt; 0    
</TERM>
<LISTITEM>
<PARA>
which  means to wait for the child whose process ID
              is equal to the value of pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
       The value of options is a bitwise OR of zero  or  more  of
       the following constants:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
 WNOHANG
</TERM>
<LISTITEM>
<PARA>
              which  means  to  return immediately if no child is
              there to be waited for.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       WUNTRACED
</TERM>
<LISTITEM>
<PARA>
which means to also return for children  which  are
stopped, and whose status has not been reported.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If  status is not NULL, wait4 stores status infor mation in the location 
pointed to by status.
</PARA><PARA>
This status can be evaluated  with  the  following  macros
(these macros take the stat buffer (an int) as an argument
-- not a pointer to the buffer!):
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
       WIFEXITED(status)
</TERM>
<LISTITEM>
<PARA>
is non-zero if the child exited normally.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       WEXITSTATUS(status)
</TERM>
<LISTITEM>
<PARA>
evaluates to the least significant  eight  bits  of
the  return  code  of  the  child which terminated,
which may have been set as the argument to  a  call
to exit() or as the argument for a return statement
in the main program.  This macro can only be evaluated if WIFEXITED 
returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       WIFSIGNALED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process exited because of
a signal which was not caught.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       WTERMSIG(status)
</TERM>
<LISTITEM>
<PARA>
returns the number of the signal  that  caused  the
child  process to terminate. This macro can only be
evaluated if WIFSIGNALED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
 WIFSTOPPED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process which caused  the
return  is currently stopped; this is only possible
if the call was done using WUNTRACED.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       WSTOPSIG(status)
</TERM>

<LISTITEM>
<PARA>
returns the number of the signal which  caused  the
child to stop.  This macro can only be evaluated if
WIFSTOPPED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If rusage is not NULL, the struct  rusage  as  defined  in
&lt;sys/resource.h> it points to will be filled with accounting information.  
See getrusage(2) for details.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
The process ID of the child which exited, -1 on error  (in
particular,  when  no  unwaited-for child processes of the
specified kind exist) or zero if WNOHANG was used  and  no
child  was  available  yet.  In the latter two cases errno
will be set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
      ECHILD 
</TERM>
<LISTITEM>
<PARA>
No unwaited-for child  process  as  specified  does
              exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
       ERESTARTSYS
</TERM>
<LISTITEM>
<PARA>
if WNOHANG was not set and an unblocked signal or a
SIGCHLD was caught. This error is returned  by  the
system  call.  The library interface is not allowed
to return ERESTARTSYS, but will return EINTR.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-warn-3"> <REFMETA>
<REFENTRYTITLE>warn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warn
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     #include &lt;err.h>

     void  warn(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     The warn() function displays a formatted error message on the 
     standard error output.  The last component of the program name, a colon 
     character, and a space are output.  If the fmt
     argument is not NULL, the formatted error message, a colon character, and
     a space are output.  The error message string affiliated with the current
     value of the global variable errno is output.  The output
     is followed by a newline character.
</PARA>
</REFSECT1>

<!-- 4th Berkeley Distribution        June 9, 1993  -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-warnx-3"> <REFMETA>
<REFENTRYTITLE>warnx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warnx
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
     #include &lt;err.h>

     void warnx(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
     The warnx() function displays a formatted error message on the standard 
     error output.  The last component of the program name, a colon character, 
     and a space are output.  If the fmt
     argument is not NULL, the formatted error message, a colon character, and
     a space are output.  The output is followed by a newline character.
</PARA>
</REFSECT1>
<!--        4th Berkeley Distribution        June 9, 1993    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-wcpcpy-3"> <REFMETA>
<REFENTRYTITLE>wcpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpcpy
</REFNAME>
<REFPURPOSE>
copy a wide character string, returning a pointer
       to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;wchar.h>

       wchar_t *wcpcpy (wchar_t *dest, const wchar_t *src);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       The wcpcpy function is the  wide-character  equivalent  of
       the  stpcpy  function. It copies the wide character string
       pointed to by src, including the terminating L'\0' charac-
       ter, to the array pointed to by dest.

</PARA><PARA>
       The strings may not overlap.
</PARA><PARA>

       The programmer must ensure that there is room for at least
       wcslen(src)+1 wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       wcpcpy returns a pointer to the end of the  wide-character
       string  dest,  that is, a pointer to the terminating L'\0'
       character.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcpncpy-3"> <REFMETA>
<REFENTRYTITLE>wcpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpncpy
</REFNAME>
<REFPURPOSE>
copy  a  fixed-size string of wide characters,
       returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;wchar.h>

       wchar_t *wcpncpy (wchar_t *dest, const wchar_t *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       The wcpncpy function is the wide-character  equivalent  of
       the  stpncpy function. It copies at most n wide characters
       from the wide-character string pointed to by src,  includ
       ing  the terminating L'\0' character, to the array pointed
       to by dest. Exactly n wide characters are written at dest.
       If the length wcslen(src) is smaller than n, the remaining
       wide characters in the array pointed to by dest are filled
       with  L'\0'  characters.  If  the  length  wcslen(src)  is
       greater or equal to n, the string pointed to by dest  will
       not be L'\0' terminated.

</PARA><PARA>
       The strings may not overlap.

</PARA><PARA>
       The programmer must ensure that there is room for at least
       n wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       wcpncpy returns a pointer to the last wide character written, i.e.  dest + n - 1.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcscasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcscasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcscasecmp
</REFNAME>
<REFPURPOSE>
compare two wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;wchar.h>

       int wcscasecmp (const wchar_t *s1, const wchar_t *s2);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       The wcscasecmp function is the  wide-character  equivalent
       of the strcasecmp function. It compares the wide-character
       string pointed to by  s1  and  the  wide-character  string
       pointed  to  by  s2,  ignoring case differences (towupper,
       towlower).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The wcscasecmp function returns zero if the wide-character
       strings  at  s1  and s2 are equal except for case distinc
       tions. It returns a positive integer if s1 is greater than
       s2,  ignoring case. It returns a negative integer if s1 is
       smaller than s2, ignoring case.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
NOTES
</TITLE>
<PARA>
       The behaviour of wcscasecmp depends on the LC_CTYPE  cate
       gory of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsdup-3"> <REFMETA>
<REFENTRYTITLE>wcsdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsdup
</REFNAME>
<REFPURPOSE>
duplicate a wide-character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
       #include &lt;wchar.h>

       wchar_t *wcsdup (const wchar_t *s);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       The  wcsdup  function  is the wide-character equivalent of
       the strdup function. It allocates and returns a new  wide-
       character  string whose initial contents is a duplicate of
       the wide-character string pointed to by s.

</PARA><PARA>
       Memory for the new wide-character string is obtained  with
       malloc(3), and can be freed with free(3).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
       The  wcsdup  function  returns  a pointer to the new wide-
       character string, or NULL if  sufficient  memory  was  not
       available.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsncasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcsncasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsncasecmp</REFNAME>
<REFPURPOSE>
compare  two  fixed-size  wide-character
strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

int wcsncasecmp (const wchar_t *s1, const wchar_t *s2, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsncasecmp function is the wide-character  equivalent
of  the strncasecmp function. It compares the wide-charac-
ter string pointed to by s1 and the wide-character  string
pointed  to by s2, but at most n wide characters from each
string, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The wcsncasecmp function returns zero if the  wide-charac-
ter  strings  at s1 and s2, truncated to at most length n,
are equal except for case distinctions. It returns a posi-
tive integer if truncated s1 is greater than truncated s2,
ignoring case. It returns a negative integer if  truncated
s1 is smaller than truncated s2, ignoring case.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The behaviour of wcsncasecmp depends on the LC_CTYPE cate-
gory of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-wcsnlen-3"> <REFMETA>
<REFENTRYTITLE>wcsnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size wide-char-
acter string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnlen (const wchar_t *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnlen function is the wide-character  equivalent  of
the  strnlen function. It returns the number of wide-char-
acters in the string pointed to by s,  not  including  the
terminating  L'\0' character, but at most maxlen. In doing
this, wcsnlen looks only at the first maxlen  wide-charac-
ters at s and never beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  wcsnlen  function  returns wcslen(s), if that is less
than maxlen, or maxlen if  there  is  no  L'\0'  character
among the first maxlen wide characters pointed to by s.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The behaviour of wcsncasecmp depends on the LC_CTYPE cate-
gory of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-wcsnrtombs-3"> <REFMETA>
<REFENTRYTITLE>wcsnrtombs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnrtombs</REFNAME>
<REFPURPOSE>
convert a wide character string to a multi-byte string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnrtombs (char *dest, const wchar_t **src, size_t nwc,
                   size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnrtombs function is like  the  wcsrtombs  function,
except that the number of wide characters to be converted,
starting at *src, is limited to nwc.

</PARA><PARA>
If dest is not a NULL  pointer,  the  wcsnrtombs  function
converts at most nwc wide characters from the wide-character string *src 
to a multibyte string starting at dest. At
most len bytes are written to dest. The  state *ps is
updated.  The  conversion  is  effectively  performed   by
repeatedly  calling wcrtomb(dest,*src,ps), as long as this
call succeeds, and then incrementing dest by the number of
bytes written and *src by one. The conversion can stop for
three reasons:

</PARA><PARA>
1. A wide character has been encountered that can  not  be
represented as a multibyte sequence (according to the current locale). 
In this case *src is left  pointing  to  the
invalid  wide  character,  (size_t)(-1)  is  returned, and
errno is set to EILSEQ.

</PARA><PARA>
2. nwc wide characters have been converted without encountering a L'\0', 
or the length limit forces a stop. In this
case *src is left pointing to the next wide  character  to
be  converted,  and the number of bytes written to dest is
returned.

</PARA><PARA>
3. The wide-character  string  has  been  completely  converted,  
including  the  terminating  L'\0' (which has the
side effect of bringing back *ps to the initial state). In
this  case  *src  is  set to NULL, and the number of bytes
written to dest, excluding the terminating '\0'  byte,  is
returned.

</PARA><PARA>
If  dest  is NULL, len is ignored, and the conversion proceeds 
as above, except that the converted  bytes  are  not
written  out  to  memory,  and  that no destination length
limit exists.

</PARA><PARA>
In both of the above cases, if ps is  a  NULL  pointer,  a
static  anonymous state only known to the wcsnrtombs function 
is used instead.

</PARA><PARA>
The programmer must ensure that there is room for at least
len bytes at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  wcsnrtombs  function returns the number of bytes that
make up the converted  part  of  multibyte  sequence,  not
including  the terminating null byte.  If a wide character
was encountered which could not be converted, (size_t)(-1)
is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The  behaviour of wcsnrtombs depends on the LC_CTYPE category 
of the current locale.

Passing NULL as ps is not multi-thread safe
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









</SECT1>


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:14:20 2001 -->
<SECT1 ID=libm>
<TITLE>libm</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libm</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libm.so.6</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-13-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-13-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Math</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>acos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ceilf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remquof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ceill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>exp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>remquol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>expm1(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>rint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>acoshf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cexpf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>rintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acoshl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cexpl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabsf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>rintl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cimag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabsl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexpf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>round(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cimagf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdim(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexpl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>roundf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cimagl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdimf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgamma(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>roundl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>clog10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdiml(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgamma_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>asinhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clog10f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feclearexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammaf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clog10l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammaf_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clogf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetexceptflag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbln(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>clogl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammal_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalblnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>conj(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feholdexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalblnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>conjf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feraiseexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>conjl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrintl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>copysign(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetexceptflag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>copysignf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llroundf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>significand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>copysignl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fetestexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llroundl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>significandf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>feupdateenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>log(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>significandl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cosf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>finite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>log10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cabs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>finitef(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>log1p(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sincos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cabsf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>coshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>finitel(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>logb(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sincosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cabsl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>coshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floor(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>lrint(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sincosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floorf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lrintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpow(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floorl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lrintl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cacosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpowf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lround(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacoshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpowl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lroundf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacoshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cproj(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lroundl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cprojf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmax(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>matherr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sqrt(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>carg(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cprojl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaxf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sqrtf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cargf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>creal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaxl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modff(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sqrtl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cargl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>creall(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modfl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>casin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fminf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fminl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>casinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmod(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmodf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nearbyint(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmodl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nearbyintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexp(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nearbyintl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tgamma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrt(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexpf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nextafter(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>tgammaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrtf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexpl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nextafterf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tgammal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrtl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gamma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nextafterl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>trunc(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gammaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nexttoward(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>truncf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gammal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nexttowardf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>truncl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypot(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nexttowardl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y0(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cbrt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ctanhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypotf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>y0f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cbrtf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypotl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y0l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cbrtl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>pow10f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>ccos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>dremf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogbf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow10l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1f(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>dreml(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogbl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>powf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>j0(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>powl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>yn(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>ccoshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfc(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>j0f(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remainder(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ynf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccoshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfcf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j0l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remainderf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ynl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfcl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>remainderl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>ceil(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>erff(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remquo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>clog<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>signgam</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libm-ddefs>
<TITLE> Data Definitions for libm</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>math.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int signgam;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:14:43 2001 -->
<SECT1 ID=libpthread>
<TITLE>libpthread</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libpthread</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libpthread.so.0</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
LSB systems support POSIX threads with the following exceptions.
This list is intended to match the behavior of historical Linux
implementations.  Applications should be written to deal with either
POSIX threads or the thread behaviors described here.
</PARA>

<PARA>
POSIX specifies a concept of per-process rather than per-thread
signals.  The LSB does not require this behavior; traditional Linux
implementations have had per-thread signals only.  A related issue is
that applications cannot (using legacy Linux implementations, at
least) rely on getpid() returning the same value in different threads.
</PARA>

<PARA>
Note: one implication of per-thread signals is that a core dump (for
example) may not stop all threads in a given process.  This may be an
issue when designing ways to stop/start applications.
</PARA>

<PARA>
Applications which create child processes (using fork() and the like)
must then wait for them (using waitpid() family of functions) in the
same thread as they created them.  Note that coding applications this
way will work both with full POSIX threads and legacy Linux thread
implementations.
</PARA>

<PARA>
POSIX specifies that changing the user or group id instantly affects
the behavior of all threads.  This behavior is not specified;
applications must use their own lock if they need this behavior.
Rationale: it seems unnecessary and it is a performance hit (an SMP
kernel must lock the user id).  (FIXME: is this our current
understanding?  It was discussed on lsb-spec on January 2000 but I'm
not sure we reached a consensus).
</PARA>

<PARA>
Although this standard doesn't have a way to list processes (/proc or
"ps" command line isn't in, right?), it is our intention to not
specify one way or the other whether multiple threads appear as
separate processes or as a single process.
</PARA>

<PARA>
Applications cannot rely on resource limits (getrusage and setrusage)
being maintained per-process rather than per-thread.
</PARA>

<PARA>
Applications must disconnect from the controlling tty before
pthread_create (FIXME: have I summarized this correctly?).
</PARA>

<PARA>
times() doesn't account for all threads, just the caller.
</PARA>

<PARA>
Applications must not call pthread_cancel if they call any system
libraries (most notably X windows), as system libraries are not
guaranteed to be thread safe.  Likewise, for such libraries, only one
thread per process may call them.
</PARA>

<PARA>
Applications cannot rely on fcntl/lockf locks being visible
per-process rather than per-thread.  Likewise for mandatory file
locks.
</PARA>

<PARA>
Threaded applications cannot use SIGUSR1 or SIGUSR2.
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-132-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>pthread_attr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_once(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstackaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setspecific(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getspecific(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_sigmask(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_join(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_rdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_testcancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_broadcast(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_create(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_tryrdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_close(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_delete(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_trywrlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_kill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_unlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_getvalue(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstackaddr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_signal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_wrlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_timedwait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_open(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_wait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_lock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_getpshared(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_post(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_trylock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_timedwait</ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_unlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_setpshared(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_trywait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_self(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_unlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_detach(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_gettype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcancelstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_wait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_equal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_settype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcanceltype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE> Data Definitions for libpthread</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>pthread.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(pthread_attr_t *, int *);
int pthread_attr_getinheritsched(pthread_attr_t *, int *);
int pthread_attr_getschedparam(pthread_attr_t *, sched_param *);
int pthread_attr_getschedpolicy(pthread_attr_t *, int *);
int pthread_attr_getscope(pthread_attr_t *, int *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_attr_setschedparam(pthread_attr_t *, sched_param *);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_cancel(pthread_t);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t *, pthread_condattr_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *,

			   timespec *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_create(pthread_t *, pthread_attr_t *, void *, void *);
int pthread_detach(pthread_t);
int pthread_equal(pthread_t, pthread_t);
void pthread_exit(void *);
int pthread_getschedparam(pthread_t, int *, sched_param *);
void *pthread_getspecific(pthread_key_t);
int pthread_join(pthread_t, void **);
int pthread_key_create(pthread_key_t *, void);
int pthread_key_delete(pthread_key_t);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_init(pthread_mutex_t *, pthread_mutexattr_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_once(pthread_once_t *, void);
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_init(pthread_rwlock_t *, pthread_rwlockattr_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *, int *);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
pthread_t pthread_self(void);
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
int pthread_setschedparam(pthread_t, int, sched_param *);
int pthread_setspecific(pthread_key_t, void *);
void pthread_testcancel(void);
int pthread_attr_getguardsize(pthread_attr_t *, size_t *);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
int pthread_attr_getstackaddr(pthread_attr_t *, void **);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_getstacksize(pthread_attr_t *, size_t *);
int pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int sem_close(sem_t *);
int sem_destroy(sem_t *);
int sem_getvalue(sem_t *, int *);
int sem_init(sem_t *, int, unsigned int);
sem_t *sem_open(char *, int, ...);
int sem_post(sem_t *);
int sem_trywait(sem_t *);
int sem_unlink(char *);
int sem_wait(sem_t *);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:15:28 2001 -->
<SECT1 ID=libdl>
<TITLE>libdl</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libdl</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libdl.so.2</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-27-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-27-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Dynamic Loader</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>dladdr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-10"></ENTRY><ENTRY>dlclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlsym(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libdl-ddefs>
<TITLE> Data Definitions for libdl</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>dlfcn.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int dlclose(void *);
char *dlerror(void);
void *dlopen(char *, int);
void *dlsym(void *, char *);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:16:14 2001 -->
<SECT1 ID=libcrypt>
<TITLE>libcrypt</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libcrypt</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libcrypt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-29-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Encryption</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>crypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY>encrypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY>setkey(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libcrypt-ddefs>
<TITLE> Data Definitions for libcrypt</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef Unknown Type:"" unknown ssize_t;


char **__environ;
__pid_t __getpgid(__pid_t);
void _exit(int);
int acct(char *);
unsigned int alarm(unsigned int);
int chown(char *, __uid_t, __gid_t);
int chroot(char *);
size_t confstr(int, char *, size_t);
char *ctermid(char *);
char *cuserid(char *);
int daemon(int, int);
int execl(char *, char *, ...);
int execle(char *, char *, ...);
int execlp(char *, char *, ...);
int execv(char *, char *);
int execvp(char *, char *);
int fdatasync(int);
int ftruncate64(int, __off64_t);
long gethostid(void);
char *getlogin(void);
__pid_t getpgrp(void);
__pid_t getsid(__pid_t);
char *getwd(char *);
int lockf(int, int, __off_t);
int lockf64(int, int, __off64_t);
int nice(int);
int rename(char *, char *);
int sethostid(long);
int sethostname(char *, size_t);
int setpgrp(void);
void swab(void *, void *, ssize_t);
int sync(void);
__pid_t tcgetpgrp(int);
int tcsetpgrp(int, __pid_t);
int truncate(char *, __off_t);
int truncate64(char *, __off64_t);
char *ttyname(int);
unsigned int ualarm(unsigned int, unsigned int);
void usleep(unsigned int);
int close(int);
int fsync(int);
__off_t lseek(int, __off_t, int);
int pause(void);
ssize_t read(int, void *, size_t);
ssize_t write(int, void *, size_t);
char *crypt(char *, char *);
void encrypt(char *, int);
void setkey(char *);
int access(char *, int);
int brk(void *);
int chdir(char *);
int dup(int);
int dup2(int, int);
int execve(char *, char *, char *);
int fchdir(int);
int fchown(int, __uid_t, __gid_t);
__pid_t fork(void);
__gid_t getegid(void);
__uid_t geteuid(void);
__gid_t getgid(void);
int getgroups(int, __gid_t);
int gethostname(char *, size_t);
__pid_t getpgid(__pid_t);
__pid_t getpid(void);
__uid_t getuid(void);
int lchown(char *, __uid_t, __gid_t);
int link(char *, char *);
long pathconf(char *, int);
int pipe(int);
int readlink(char *, char *, size_t);
int rmdir(char *);
void *sbrk(ptrdiff_t);
int setgid(__gid_t);
int setpgid(__pid_t, __pid_t);
int setregid(__gid_t, __gid_t);
int setreuid(__uid_t, __uid_t);
__pid_t setsid(void);
int setuid(__uid_t);
unsigned int sleep(unsigned int);
int symlink(char *, char *);
long sysconf(int);
int unlink(char *);
__pid_t vfork(void);
ssize_t pread(int, void *, size_t, __off_t);
ssize_t pwrite(int, void *, size_t, __off_t);
long fpathconf(int, int);
int ftruncate(int, __off_t);
char *getcwd(char *, size_t);
int getpagesize(void);
__pid_t getppid(void);
int isatty(int);
__off64_t lseek64(int, __off64_t, int);
ssize_t pwrite64(int, void *, size_t, __off64_t);
int ttyname_r(int, char *, size_t);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->
<!--    at Tue Apr 24 21:15:51 2001 -->
<SECT1 ID=librt>
<TITLE>librt</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>librt</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>librt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Large File Support<FOOTNOTE ID="std-223-35">
<PARA>
Large File Support</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-223-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Asynchronous I/O</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>aio_cancel(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_fsync64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_suspend(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>clock_getres<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>lio_listio64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY></ROW>
<ROW><ENTRY>aio_cancel64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_read(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_suspend64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_gettime(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>shm_open<FOOTNOTEREF LINKEND="std-223-5"></ENTRY></ROW>
<ROW><ENTRY>aio_error(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_read64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_write(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>clock_nanosleep<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>shm_unlink<FOOTNOTEREF LINKEND="std-223-5"></ENTRY></ROW>
<ROW><ENTRY>aio_error64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_return(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_write64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_settime<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>aio_fsync(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_return64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_getcpuclockid<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>lio_listio(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=librt-ddefs>
<TITLE> Data Definitions for librt</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>aio.h</TITLE>
<PARA>
</PARA>
<SCREEN>

int aio_read(aiocb *);
int aio_write(aiocb *);
int lio_listio(int, aiocb *, int, sigevent *);
int aio_error(aiocb *);
__ssize_t aio_return(aiocb *);
int aio_cancel(int, aiocb *);
int aio_suspend(aiocb *, int, timespec *);
int aio_fsync(int, aiocb *);
int aio_cancel64(int, aiocb64 *);
int aio_error64(aiocb64 *);
int aio_fsync64(int, aiocb64 *);
int aio_read64(aiocb64 *);
__ssize_t aio_return64(aiocb64 *);
int aio_suspend64(aiocb64 *, int, timespec *);
int aio_write64(aiocb64 *);
int lio_listio64(int, aiocb64 *, int, sigevent *);
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/baselib/Attic/baselib.sgml,v 1.24 2001-04-25 02:08:01 anderson Exp $ -->


</CHAPTER>

</PART>
