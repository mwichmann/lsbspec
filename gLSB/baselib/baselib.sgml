<PART ID=tocbaselib>
<TITLE>Base Libraries</TITLE>

<CHAPTER id=baselib>
<TITLE>Libraries</TITLE>

<PARA>
An LSB-conforming implementation shall support some base libraries which
provide interfaces for accessing the operating system, processor and other
hardware in the system.
</PARA>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:08 2001 -->
<SECT1 ID=libc>
<TITLE></TITLE>
<PARA>
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-131-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Large File Support<FOOTNOTE ID="std-131-35">
<PARA>
Large File Support</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-131-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]<FOOTNOTE ID="std-131-3">
<PARA>
IEEE Std POSIX.1-1996 [ISO/IEC 9945-1:1996]</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, February 1997, Networking Services (XNS), Issue 5
(ISBN: 1-85912-165-9, C523)<FOOTNOTE ID="std-131-15">
<PARA>
CAE Specification, February 1997, Networking Services (XNS), Issue 5
(ISBN: 1-85912-165-9, C523)</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-131-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>System Calls</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - System Calls Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__fxstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fchown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getwd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setrlimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__getpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fcntl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>initgroups(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>pwrite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__lxstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fdatasync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ioctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>read(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__xmknod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fdetach(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>kill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__xstat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>flock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>killpg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>statfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>access(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fork(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lchown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>readv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>statvfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>acct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fstatfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>link(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rename(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>stime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>alarm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fsync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lockf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rmdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>symlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>brk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lseek(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftruncate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mkdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_get_priority_max(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sysconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chmod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getcontext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mkfifo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sched_get_priority_min(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>time(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chown(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getegid(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_getparam(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>times(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>chroot(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>geteuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mlockall(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_getscheduler(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>truncate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>clock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mmap(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_rr_get_interval(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ulimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>close(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgroups(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mprotect(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_setparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>umask(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>closedir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getitimer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msync(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_setscheduler(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>uname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>creat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getloadavg<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>munlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sched_yield(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>unlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>dup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>munlockall(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>select(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>utime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>dup2(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpagesize(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>munmap(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setcontext<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>utimes(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nanosleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setegid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>vfork(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execle(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nice(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seteuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execlp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>open(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wait3(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getppid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>opendir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setitimer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wait4(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>execve(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpriority(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pathconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>waitid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>execvp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getrlimit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pause(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>waitpid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getrusage(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pipe(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpriority(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>write(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fchdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>poll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setregid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>writev(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fchmod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pread(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setreuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - System Calls Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>errno<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Standard I/O</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard I/O Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_IO_feof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fgetpos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fstatvfs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putc_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_getc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fgets(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftell(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putchar(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sscanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_putc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fileno(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftello(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putchar_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>telldir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_IO_puts(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>flockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fwrite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>puts(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tempnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>alphasort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ungetc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>clearerr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getc_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>remove(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vasprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>ctermid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fputc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getchar(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rewind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vdprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>fclose(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fputs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getchar_unlocked(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>rewinddir(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vfprintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fdopen(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fread(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gets(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>scanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vprintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>feof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>freopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seekdir(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vsnprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>ferror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fscanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setbuf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vsprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fflush(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fseek(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>popen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setbuffer(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>fflush_unlocked(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fseeko(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>printf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setvbuf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>fgetc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fsetpos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>snprintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard I/O Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_IO_2_1_stderr_<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_IO_2_1_stdout_<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stdin<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>_IO_2_1_stdin_<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stderr<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>stdout<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Signal Handling</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Signal Handling Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__libc_current_sigrtmax(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaction(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>siggetmask(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigorset(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigstack(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__libc_current_sigrtmin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaddset(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sighold(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigpause(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigsuspend(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sigpause(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigaltstack(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigignore(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigpending(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigtimedwait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sigsetjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigandset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>siginterrupt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigprocmask(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigwait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sysv_signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigblock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigisemptyset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigqueue(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigwaitinfo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bsd_signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigdelset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigismember(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigrelse(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>psignal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>sigemptyset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>siglongjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigreturn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>raise(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigfillset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>signal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sigset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Signal Handling Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_sys_siglist<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Standard Library</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard Library Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_Exit(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>div(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>globfree(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>llabs(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>sethostname(GLIBC_2.1.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__assert_fail(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>drand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>globfree64(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>lldiv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>setstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__bzero(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ecvt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>grantpt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>longjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__cxa_atexit(GLIBC_2.1.3)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>erand48(GLIBC_2.1.3)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>hcreate(GLIBC_2.1.3)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lrand48(GLIBC_2.1.3)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srand48(GLIBC_2.1.3)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__errno_location(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>err(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>hdestroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>lsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>srandom(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__fpending(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>error(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>hsearch(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>makecontext(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtod(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__secure_getenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>errx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>htonl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>malloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__sysconf<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fcvt()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>htons()<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>memmem()<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strtoul()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fmtmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>imaxabs<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>mkstemp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>swapcontext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_longjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fnmatch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>imaxdiv<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>mktemp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>syslog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_setjmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>fpathconf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_addr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>mrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>system(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>a64l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>free(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_aton(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>nftw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>textdomain(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>abort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftrylockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>inet_ntoa(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>nrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tfind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>abs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ftw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>initstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ntohl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>tmpfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atexit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>funlockfile(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>insque(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ntohs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>tmpnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gcvt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isatty(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>openlog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atoi(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getcwd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isblank(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>perror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ttyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>atol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getdate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isinf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>ptsname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ttyname_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>basename(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isinfl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>putenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>twalk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bindtextdomain(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getlogin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isnan(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>qsort(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>unlockpt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bsearch(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isnanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>rand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>usleep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>calloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt_long(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>isnanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>random(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>verrx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>closelog(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getopt_long_only(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>jrand48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>realloc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>warn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>confstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getsubopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>l64a(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>realpath(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>warnx(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>cuserid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gettimeofday(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>labs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>remque(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wordexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>daemon(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>glob(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ldiv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>seed48(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wordfree(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>dirname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>glob64(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>lfind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>sethostid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Standard Library Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_sys_errlist<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getdate_err<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>opterr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>optopt<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>_environ<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>environ<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>optarg<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>optind<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Localization Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Localization Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__dcgettext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>catgets(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>dcgettext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>iconv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>nl_langinfo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>catclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>catopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gettext(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>localeconv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setlocale(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Localization Functions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_nl_msg_cat_cntr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Socket Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Socket Interface Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_h_errno(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gethostid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>listen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>sendmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>socketpair(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>accept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>gethostname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>sendto(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bind(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getpeername(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recvfrom(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>setsockopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bindresvport(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getsockname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>recvmsg(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>shutdown(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>connect(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getsockopt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>send(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>socket(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Socket Interface Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>h_errno<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Wide Characters</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Wide Characters Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__mbrlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbrlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsnlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstoumax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__wcstod_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbrtowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcsnrtombs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstouq(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__wcstof_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsinit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcpncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcspbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcswcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstol_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsnrtowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcrtomb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsrchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcswidth(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstold_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbsrtowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcsrtombs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsxfrm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoll_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbstowcs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctob(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoul_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>mbtowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcschr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctomb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__wcstoull_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>putwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstod(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wctrans(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>btowc(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>putwchar<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wctype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fgetws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>swprintf<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcscpy()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoimax()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcwidth()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fputwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>swscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcscspn()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstok()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemchr()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fputws<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towctrans()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcsdup()<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstol()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemcmp()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwide<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towlower()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsftime<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcstold()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wmemcpy()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>towupper()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcslen()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoll()<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wmemmove()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>fwscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>ungetwc<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncasecmp()<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>wcstombs()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wmemset()<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>iconv_close(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vfwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncat(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoq(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>iconv_open(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vswscanf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncmp(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoul(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>mblen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>vwprintf<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY>wcsncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>wcstoull(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>String Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - String Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__mempcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>bzero(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcasestr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strncasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoimax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__rawmemchr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ffs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcat(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncat(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtok(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__stpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>index(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtok_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strdup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memccpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtold(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtod_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strndup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strtoll(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtof_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strnlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strtoq(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strtok_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strpbrk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoull(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtol_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memmove(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strdup(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strptime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtoumax(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY></ROW>
<ROW><ENTRY>__strtold_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memrchr<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strrchr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtouq(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strtoll_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>memset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strerror_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strsep(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strverscmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>__strtoul_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>rindex(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strfmon(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strsignal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strxfrm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>__strtoull_internal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>stpcpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strfry(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strspn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>swab(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>bcmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>stpncpy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>strftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strstr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>bcopy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strcasecmp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strlen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>strtof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-25"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>IPC Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - IPC Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>ftok(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msgrcv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>msgctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>msgsnd(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semop(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmdt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>msgget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>semctl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmat(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>shmget(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Regular Expressions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Regular Expressions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>advance(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>re_exec(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regfree(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>re_comp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regcomp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>regexec(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>step(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Regular Expressions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>loc1<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>loc2<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>locs<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Character Type Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Character Type Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__ctype_get_mb_cur_max(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>isdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswalnum(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswlower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>toascii(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_tolower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isgraph(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswalpha(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswprint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tolower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>_toupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>islower(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswblank(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>iswpunct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>toupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>isalnum(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isprint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswcntrl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswspace(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>isalpha(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ispunct(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswctype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>iswupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>isascii(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isspace(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswxdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>iscntrl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isupper(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>iswgraph(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>isxdigit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Character Type Functions Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__ctype_b<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>__ctype_tolower<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>__ctype_toupper<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Time Manipulation</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Time Manipulation Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>adjtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>ctime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gmtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tzname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>adjtimex(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>daylight(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>localtime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tzset(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>asctime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>difftime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>mktime(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>ualarm(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Time Manipulation Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>timezone<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Terminal Interface Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Terminal Interface Functions Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>cfgetispeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>cfsetispeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcdrain(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetattr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsendbreak(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>cfgetospeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>cfsetospeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcflow(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsetattr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>cfmakeraw(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>cfsetspeed(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>tcflush(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcgetsid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>tcsetpgrp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>System Database Interface</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - System Database Interface Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>endgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getutxent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>endhostent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getgrgid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getutxid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>endnetent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getgrnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getpwnam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getutxline(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY></ROW>
<ROW><ENTRY>endprotoent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>gethostbyaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getpwuid(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>pututxline(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setutent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY></ROW>
<ROW><ENTRY>endpwent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>gethostbyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getservbyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>setgrent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>setutxent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY></ROW>
<ROW><ENTRY>endservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getnetbyaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getservbyport(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>sethostent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>endutent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotobyname(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>getservent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>setmntent(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>endutxent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-5"></ENTRY><ENTRY>getprotobynumber(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY>getutent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>setnetent(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-15"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Language Support</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Language Support Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>_obstack_begin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>_obstack_newchunk(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>obstack_free<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Large File Support</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libc - Large File Support Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>__fxstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fopen64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftello64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>mkstemp64<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>tmpfile64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY></ROW>
<ROW><ENTRY>__lxstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>freopen64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftruncate64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>mmap64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>truncate64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY></ROW>
<ROW><ENTRY>__xstat64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fseeko64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>ftw64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>nftw64(GLIBC_2.2)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>alphasort64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-10"></ENTRY><ENTRY>fsetpos64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>getrlimit64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>open64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>creat64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>fstatfs64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>lockf64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>pwrite64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>fgetpos64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>fstatvfs64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>lseek64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY>readdir64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-131-35"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libc-ddefs>
<TITLE> Data Definitions for libc</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>dirent.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct __dirstream DIR;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>ftw.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef int (*__ftw_func_t) (char *__filename, struct stat * __status,
			     int __flag);

typedef int (*__ftw64_func_t) (char *__filename, struct stat64 * __status,
			       int __flag);

typedef int (*__nftw_func_t) (char *__filename, struct stat * __status,
			      int __flag, struct FTW * __info);

typedef int (*__nftw64_func_t) (char *__filename, struct stat64 * __status,
				int __flag, struct FTW * __info);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>glob.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct
{
  __size_t gl_pathc;
  char **gl_pathv;
  __size_t gl_offs;
  int gl_flags;
  void (*gl_closedir) ();
  struct dirent64 *(*gl_readdir) ();
  void *(*gl_opendir) ();
  int (*gl_lstat) ();
  int (*gl_stat) ();
}
glob_t;

typedef struct
{
  __size_t gl_pathc;
  char **gl_pathv;
  __size_t gl_offs;
  int gl_flags;
  void (*gl_closedir) ();
  struct dirent64 *(*gl_readdir) ();
  void *(*gl_opendir) ();
  int (*gl_lstat) ();
  int (*gl_stat) ();
}
glob64_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>grp.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct group
{
  char *gr_name;
  char *gr_passwd;
  __gid_t gr_gid;
  char **gr_mem;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>iconv.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef void *iconv_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>inttypes.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef lldiv_t imaxdiv_t;

typedef long long intmax_t;

typedef unsigned long long uintmax_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>locale.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>nl_types.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef void *nl_catd;

typedef int nl_item;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>pwd.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>regex.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned long reg_syntax_t;

typedef struct re_pattern_buffer
{
  unsigned char *buffer;
  unsigned long allocated;
  unsigned long used;
  reg_syntax_t syntax;
  char *fastmap;
  char *translate;
  size_t re_nsub;
  unsigned int can_be_null;
  unsigned int regs_allocated;
  unsigned int fastmap_accurate;
  unsigned int no_sub;
  unsigned int not_bol;
  unsigned int not_eol;
  unsigned int newline_anchor;
}
regex_t;

typedef int regoff_t;

typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
}
regmatch_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>search.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef enum
{
  FIND,
  ENTER
}
ACTION;

typedef enum
{
  preorder,
  postorder,
  endorder,
  leaf
}
VISIT;

typedef struct entry
{
  char *key;
  void *data;
}
ENTRY;

typedef void (*__action_fn_t) (void *__nodep, VISIT __value, int __level);
</SCREEN>
</SECT2>
<SECT2>
<TITLE>setjmp.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef int __jmp_buf;

typedef struct __jmp_buf_tag
{
  __jmp_buf __jmpbuf;
  int __mask_was_saved;
  __sigset_t __saved_mask;
}
jmp_buf;

typedef jmp_buf sigjmp_buf;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>signal.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef union sigval
{
  int sival_int;
  void *sival_ptr;
}
sigval_t;

typedef void (*__sighandler_t) ();

struct sigevent
{
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
}
 ;

typedef struct
{
  unsigned long __val[1];
}
__sigset_t;

typedef __sigset_t sigset_t;

struct sigaction;

typedef struct
{
  int si_band;
  int si_fd;
  struct _sifields;
  struct _sigpoll;
}
siginfo_t;

struct sigaltstack
{
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
}
 ;

struct sigstack
{
  void *ss_sp;
  int ss_onstack;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdio.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct _IO_FILE FILE;

typedef __off_t fpos_t;

typedef __off64_t fpos64_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>stdlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct
{
  long quot;
  long rem;
}
lldiv_t;

typedef struct
{
  int quot;
  int rem;
}
div_t;

typedef struct
{
  long quot;
  long rem;
}
ldiv_t;

typedef int (*__compar_fn_t) ();
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/sem.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct sembuf
{
  short sem_num;
  short sem_op;
  short sem_flg;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/socket.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned short sa_family_t;

typedef unsigned int socklen_t;

struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[1];
}
 ;

struct msghdr
{
  void *msg_name;
  socklen_t msg_namelen;
  struct iovec *msg_iov;
  size_t msg_iovlen;
  void *msg_control;
  size_t msg_controllen;
  int msg_flags;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/times.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct tms
{
  clock_t tms_utime;
  clock_t tms_stime;
  clock_t tms_cutime;
  clock_t tms_cstime;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/utsname.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct utsname
{
  char sysname[1];
  char nodename[1];
  char release[1];
  char version[1];
  char machine[1];
  char __domainname[1];
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>sys/wait.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
}
idtype_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>time.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef long __clock_t;

struct timespec
{
  long tv_sec;
  long tv_nsec;
}
 ;

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long __tm_gmtoff;
  char *__tm_zone;
}
 ;

typedef __clock_t clock_t;

typedef __time_t time_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef __ssize_t ssize_t;

typedef __pid_t pid_t;

typedef __off_t off_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>utime.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct utimbuf
{
  __time_t actime;
  __time_t modtime;
}
 ;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wchar.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef long wchar_t;

typedef unsigned int wint_t;

typedef struct
{
  int count;
  wint_t value;
}
mbstate_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wctype.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned long wctype_t;

typedef __int32_t *wctrans_t;
</SCREEN>
</SECT2>
<SECT2>
<TITLE>wordexp.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct
{
  int we_wordc;
  char **we_wordv;
  int we_offs;
}
wordexp_t;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->

<SECT1 ID=libcman>
<TITLE>Interface Definitions for libc</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib-acct-3"> <REFMETA>
<REFENTRYTITLE>acct</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>acct</REFNAME>
<REFPURPOSE>
switch process accounting on or off
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

int acct(const char *filename);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When called with the name of an existing file as argument, accounting is turned on, records for each terminating process are appended to filename as it terminates. An argument of NULL causes accounting to be turned off.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
BSD process accounting has not been enabled when the operating system kernel was compiled.  The kernel configuration parameter controlling this feature is CONFIG_BSD_PROCESS_ACCT.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process has no permission to enable process accounting.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
The argument filename is not a regular file.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
Error writing to the file filename.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EUSERS 
</TERM>
<LISTITEM>
<PARA>
There are no more free file structures or we run out of memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-adjtime-2"> <REFMETA>
<REFENTRYTITLE>adjtime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtime
</REFNAME>
<REFPURPOSE>
correct the time to allow synchronization of the system clock
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>23 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;time.h>

int adjtime(const struct timeval *delta, struct timeval *olddelta);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>23 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Adjtime() makes small adjustments to the system time, as returned by gettimeofday(2), advancing or retarding it by the time specified by the timeval delta. If delta is negative, the clock is slowed down by incrementing it more slowly than normal until the correction is complete. If delta is positive, a larger increment than normal is used. The skew used to perform the correction is generally a fraction of one percent. Thus, the time is always a monotonically increasing function. A time correction from an earlier call to adjtime() may not be finished when adjtime() is called again. If olddelta is non-nil, the structure pointed to will contain, upon return, the number of microseconds still to be corrected from the earlier call.
</PARA><PARA>
This call may be used by time servers that synchronize the clocks of computers in a local area network.  Such time servers would slow down the clocks of some machines and speed up the clocks of others to bring them to the average network time.
</PARA><PARA>
The call adjtime() is restricted to the super-user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
ERRORS
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
An argument points outside the process's allocated address space.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The process's effective user ID is not that of the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-adjtimex-3"> <REFMETA>
<REFENTRYTITLE>adjtimex</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>adjtimex</REFNAME>
<REFPURPOSE>
tune kernel clock
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/timex.h>

int adjtimex(struct timex *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Linux uses David L. Mills' clock adjustment algorithm (see RFC 1305). The system call adjtimex reads and optionally sets adjustment parameters for this algorithm. It takes a pointer to a timex structure, updates kernel parameters from field values, and returns the same structure with current kernel values. This structure is declared as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct timex {
</TERM>
<LISTITEM>
<PARA>
                  int modes;           /* mode selector */
</PARA><PARA>
                  long offset;         /* time offset (usec) */
</PARA><PARA>
                  long freq;           /* frequency offset (scaled ppm) */
</PARA><PARA>
                  long maxerror;       /* maximum error (usec) */
</PARA><PARA>
                  long esterror;       /* estimated error (usec) */
</PARA><PARA>
                  int status;          /* clock command/status */
</PARA><PARA>
                  long constant;       /* pll time constant */
</PARA><PARA>
                  long precision;      /* clock precision (usec) (read only) */
</PARA><PARA>
                  long tolerance;      /* clock frequency tolerance (ppm)
                                          (read only) */
</PARA><PARA>
                  struct timeval time; /* current time (read only) */
</PARA><PARA>
                  long tick;           /* usecs between clock ticks */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
The modes field determines which parameters, if any, to set. It may contain a bitwise-or combination of zero or more of the following bits:
</PARA><PARA>
              #define ADJ_OFFSET            0x0001 /* time offset */
</PARA><PARA>
              #define ADJ_FREQUENCY         0x0002 /* frequency offset */
</PARA><PARA>
              #define ADJ_MAXERROR          0x0004 /* maximum time error */
</PARA><PARA>
              #define ADJ_ESTERROR          0x0008 /* estimated time error */
</PARA><PARA>
              #define ADJ_STATUS            0x0010 /* clock status */
</PARA><PARA>
              #define ADJ_TIMECONST         0x0020 /* pll time constant */
</PARA><PARA>
              #define ADJ_TICK              0x4000 /* tick value */
</PARA><PARA>
              #define ADJ_OFFSET_SINGLESHOT 0x8001 /* old-fashioned adjtime */
</PARA><PARA>
Ordinary users are restricted to a zero value for mode. Only the superuser may set any parameters.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, adjtimex returns the clock state:
</PARA><PARA>

              #define TIME_OK   0 /* clock synchronized */
</PARA><PARA>
              #define TIME_INS  1 /* insert leap second */
</PARA><PARA>
              #define TIME_DEL  2 /* delete leap second */
</PARA><PARA>
              #define TIME_OOP  3 /* leap second in progress */
</PARA><PARA>
              #define TIME_WAIT 4 /* leap second has occurred */
</PARA><PARA>
              #define TIME_BAD  5 /* clock not synchronized */
</PARA><PARA>

On error, -1 is returned, and errno is set appropriately.
</PARA>

</REFSECT1><REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
buf does not point to writable memory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
buf.mode is non-zero and the user is not super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
An attempt is made to set buf.offset to a value outside the range -131071 to +131071, or to set buf.status to a value other than those listed above, or to set buf.tick to a value outside the range 900000/HZ to 1100000/HZ, where HZ is the system timer interrupt frequency.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-alphasort-3"> <REFMETA>
<REFENTRYTITLE>alphasort</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>alphasort</REFNAME>
<REFPURPOSE>
scan a directory for matching entries
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

int alphasort(const struct dirent **a, const struct dirent **b);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The alphasort() function can be used as the comparison function for the scandir() function to sort the directory entries into alphabetical order. Its parameters are the two directory entries, a and b, to compare.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The alphasort() function returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to complete the operation.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-alphasort64"> <REFMETA>
<REFENTRYTITLE>alphasort64</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>alphasort64</REFNAME>
<REFPURPOSE>
compare two struct dirents alphabetically
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;dirent.h>

int alphasort64(const struct dirent **a, const struct dirent **b);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Function to compare two struct dirents alphabetically. This function is like alphasort but it uses the 64bit dirent structure.
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-assert-fail-1"> <REFMETA>
<REFENTRYTITLE>__assert_fail</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__assert_fail
</REFNAME>
<REFPURPOSE>abort the program after false assertion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>30 January 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
void
__assert_fail(const char *<REPLACEABLE CLASS="PARAMETER">assertion</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">file</REPLACEABLE>,
              unsigned int <REPLACEABLE CLASS="PARAMETER">line</REPLACEABLE>,
              const char *<REPLACEABLE CLASS="PARAMETER">function</REPLACEABLE>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>30 January 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function, when passed a string containing an asserted expression, a filename, and a line number, prints a message on the standard error stream such as:
<BLOCKQUOTE>
<PARA>
a.c:10: foobar: Assertion a == b failed.
</PARA>
</BLOCKQUOTE>
It then aborts program execution via a call to <FUNCTION>abort</FUNCTION>. The exact form of the message is up to the implementation.
</PARA>
<PARA>
If FUNCTION is NULL, then omit information about the function.
</PARA><PARA>
FILE, LINE, and ASSERTION must be non-NULL.
</PARA>
<PARA>
This function is part of the ABI, and not the API.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-bindtextdomain"> <REFMETA>
<REFENTRYTITLE>bindtextdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>bindtextdomain</REFNAME>
<REFPURPOSE>
specify that the DOMAINNAME message catalog will be found in DIRNAME rather than in the system locale data base
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

extern char *bindtextdomain(const char *domainname,
                            const char *dirname);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Specify that the DOMAINNAME message catalog will be found in DIRNAME rather than in the system locale data base.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-cfmakeraw-3"> <REFMETA>
<REFENTRYTITLE>cfmakeraw</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfmakeraw</REFNAME>
<REFPURPOSE>
get and set terminal attributes
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;termios.h>

int cfmakeraw(struct termios *termios_p);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
cfmakeraw sets the terminal attributes as follows:
</TERM>
<LISTITEM>
<PARA>
 termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);
</PARA><PARA>
 termios_p->c_oflag &= ~OPOST;
</PARA><PARA>
 termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
</PARA><PARA>
 termios_p->c_cflag &= ~(CSIZE|PARENB);
</PARA><PARA>
 termios_p->c_cflag |= CS8;
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
termios_p is a pointer to a termios structure. This structure contains the following members:
</PARA><PARA>
              tcflag_t c_iflag;      /* input modes */
</PARA><PARA>
              tcflag_t c_oflag;      /* output modes */
</PARA><PARA>
              tcflag_t c_cflag;      /* control modes */
</PARA><PARA>
              tcflag_t c_lflag;      /* local modes */
</PARA><PARA>
              cc_t c_cc[NCCS];       /* control chars */
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On failure, -1 is returned, and errno is set appropriately.
</PARA>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-cfsetspeed-3"> <REFMETA>
<REFENTRYTITLE>cfsetspeed</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>cfsetspeed
</REFNAME>
<REFPURPOSE>
manipulate the termios structure
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;termios.h>

int cfsetspeed(struct termios *t, speedt speed);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The cfsetspeed function is provided for setting the baud rate values in the termios structure. The effects of the function on the terminal as described below do not become effective, nor are all errors detected, until the tcsetattr function is called.  Certain values for baud rates set in the termios structure and passed to tcsetattr have special meanings.
</PARA>

<REFSECT2>
<TITLE>Getting and Setting the Baud Rate
</TITLE>
<PARA>
The input and output baud rates are found in the termios structure. The unsigned integer speed_t is typdef'd in the include file &lt;termios.h>. The value of the integer corresponds directly to the baud rate being represented, however, the following symbolic values are defined.
</PARA><PARA>
     #define B0      0
</PARA><PARA>
     #define B50     50
</PARA><PARA>
     #define B75     75
</PARA><PARA>
     #define B110    110
</PARA><PARA>
     #define B134    134
</PARA><PARA>
     #define B150    150
</PARA><PARA>
     #define B200    200
</PARA><PARA>
     #define B300    300
</PARA><PARA>
     #define B600    600
</PARA><PARA>
     #define B1200   1200
</PARA><PARA>
     #define B1800   1800
</PARA><PARA>
     #define B2400   2400
</PARA><PARA>
     #define B4800   4800
</PARA><PARA>
     #define B9600   9600
</PARA><PARA>
     #define B19200  19200
</PARA><PARA>
     #define B38400  38400
</PARA><PARA>
     #ifndef _POSIX_SOURCE
</PARA><PARA>
     #define EXTA    19200
</PARA><PARA>
     #define EXTB    38400
</PARA><PARA>
     #endif  /*_POSIX_SOURCE */
</PARA><PARA>
The cfsetspeed function sets both the input and output baud rate in the termios structure referenced by tp to speed.
</PARA>
</REFSECT2>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib---ctype-b"> <REFMETA>
<REFENTRYTITLE>__ctype_b</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_c</REFNAME>
<REFPURPOSE>
array index for ctype functions
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

extern const unsigned short int *ctype_b;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Array index for ctype functions.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="libutil---ctype-tolower-2"> <REFMETA>
<REFENTRYTITLE>__ctype_tolower</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_tolower
</REFNAME>
<REFPURPOSE>convert uppercase letter to lowercase letter
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __ctype_tolower(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __ctype_tolower() function converts an uppercase letter to the corresponding lowercase letter. If the argument is an uppercase letter, the __ctype_tolower() function returns the corresponding lowercase letter if there is one; otherwise, the argument is returned unchanged.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil---ctype-toupper-2"> <REFMETA>
<REFENTRYTITLE>__ctype_toupper</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__ctype_toupper
</REFNAME>
<REFPURPOSE>convert lowercase letter to uppercase letter
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __ctype_toupper(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __ctype_toupper() function converts a lowercase letter to the corresponding uppercase letter. If the argument is a lowercase letter, the __ctype_toupper() function returns the corresponding uppercase letter if there is one; otherwise, the argument is returned unchanged.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---cxa-atexit"> <REFMETA>
<REFENTRYTITLE>__cxa_atexit</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__cxa_atexit</REFNAME>
<REFPURPOSE>
register a function to be called by exit or when a shared library is unloaded
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __cxa_atexit(void (*func) (void *), void *arg, void *d);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Register a function to be called by exit or when a shared library is unloaded. This function is only called from code generated by the C++ compiler. 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-daemon-3"> <REFMETA>
<REFENTRYTITLE>daemon</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>daemon</REFNAME>
<REFPURPOSE>
run in the background
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int daemon(int nochdir, int noclose);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The daemon() function is for programs wishing to detach themselves from the controlling terminal and run in the background as system daemons. Unless the argument nochdir is non-zero, daemon() changes the current working directory to the root (`/'). Unless the argument noclose is non-zero, daemon() will redirect standard input, standard output and standard error to /dev/null.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error occurs, -1 is returned, and errno is set to any of the errors specified for the library functions fork(2) and setsid(2).
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-dcgettext"> <REFMETA>
<REFENTRYTITLE>dcgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dcgettext</REFNAME>
<REFPURPOSE>
look up the MSGID in the DOMAINNAME message catalog for the current CATEGORY locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *dcgettext(const char *domainname,
                       const char *msgid, int category);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used to look up the MSGID in the DOMAINNAME message catalog for the current
CATEGORY locale.  
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib---dcgettext"> <REFMETA>
<REFENTRYTITLE>__dcgettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__dcgettext</REFNAME>
<REFPURPOSE>
used by dcgettext in the translation to look up the MSGID in the DOMAINNAME message catalog for the current locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *__dcgettext(const char *domainname,
                         const char *msgid, int category);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used by dcgettext in the translation to look up the MSGID in the DOMAINNAME message catalog for the current locale. CATEGORY locale.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---divdi3-3"> <REFMETA>
<REFENTRYTITLE>__divdi3</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__divdi3
</REFNAME>
<REFPURPOSE>
mathematic operation
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
DItype
__divdi3(DItype u, DItype v);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__divdi3() divides two DItypes(unsigned ints).
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-endutent-3"> <REFMETA>
<REFENTRYTITLE>endutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>endutent</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

void endutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
endutent() closes the utmp file. It should be called when the user code is done accessing the file with the other functions.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--environ"> <REFMETA>
<REFENTRYTITLE>_environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char **_environ;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Alias for environ - user environment.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---environ"> <REFMETA>
<REFENTRYTITLE>__environ</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__environ</REFNAME>
<REFPURPOSE>
alias for environ - user environment 
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern char **__environ;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Alias for environ - user environment.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-err-3"> <REFMETA>
<REFENTRYTITLE>err</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>err
</REFNAME>
<REFPURPOSE>display formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void err(int eval, const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The err() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The error message string affiliated with the current value of the global variable errno is output. The output is followed by a newline character.
</PARA><PARA>
The err() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-errno-location-1"> <REFMETA>
<REFENTRYTITLE>__errno_location</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__errno_location
</REFNAME>
<REFPURPOSE>address of errno variable
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int *__errno_location(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Return the address of the errno variable.
</PARA><PARA>
__errno_location is not in the source standard; it is only in the binary standard.
</PARA><PARA>
errno is not in the binary standard; it is only in the source standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-error-n"> <REFMETA>
<REFENTRYTITLE>error</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>error</REFNAME>
<REFPURPOSE>
generate an error
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
error message ?info? ?code?
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Returns a TCL_ERROR code, which causes command interpretation to be unwound. Message is a string that is returned to the application to indicate what went wrong. If the info argument is provided and is non-empty, it is used to initialize the global variable errorInfo. erroInfo is used to accumulate a stack trace of what was in progress when an error occurred; as nested commands unwind, the Tcl interpreter adds information to errorInfo. If the info argument is present, it is used to initialize errorInfo and the first increment of unwind information will not be added by the Tcl interpreter. In other words, the command containing the error command will not appear in errorInfo; in its place will be info. This feature is most useful in conjunction with the catch command: if a caught error cannot be handled successfully, info can be used to return a stack trace reflecting the original point of occurrence of the error:
              catch {...} errMsg
              set savedInfo $errorInfo
              ...
              error $errMsg $savedInfo

If the code argument is present, then its value is stored in the errorCode global variable. This variable is intended to hold a machine-readable description of the error in cases where such information is available; see the tclvars manual page for information on the proper  for the variable. If the code argument is not present then errorCode is automatically reset to `NONE' by the Tcl interpreter as part of processing the error generated by the command.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-errx-3"> <REFMETA>
<REFENTRYTITLE>errx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>errx
</REFNAME>
<REFPURPOSE> error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void errx(int eval, const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The errx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA><PARA>
The errx() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-flock-2"> <REFMETA>
<REFENTRYTITLE>flock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>flock</REFNAME>
<REFPURPOSE>
apply or remove an advisory lock on an open file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int flock(int fd, int operation);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Apply or remove an advisory lock on an open file. The file is specified by fd. Valid operations are given below:
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
LOCK_SH
</TERM>
<LISTITEM>
<PARA>
Shared lock. More than one process may hold a shared lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_EX
</TERM>
<LISTITEM>
<PARA>
Exclusive lock. Only one process may hold an exclusive lock for a given file at a given time.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_UN
</TERM>
<LISTITEM>
<PARA>
Unlock.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
LOCK_NB
</TERM>
<LISTITEM>
<PARA>
Don't block when locking. May be specified (by or'ing) along with one of the other operations.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
A single file may not simultaneously have both shared and exclusive locks.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EWOULDBLOCK
</TERM>
<LISTITEM>
<PARA>
The file is locked and the LOCK_NB flag was selected.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib---fpending"> <REFMETA>
<REFENTRYTITLE>__fpending</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__fpending</REFNAME>
<REFPURPOSE>
returns in bytes the amount of output pending on a stream
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio_ext.h>

size_t __fpending(FILE *stream);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __fpending function returns the amount of output in bytes pending on a stream.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-fstatfs-2"> <REFMETA>
<REFENTRYTITLE>fstatfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fstatfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int fstatfs(int fd, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>
Description
</TITLE>
<PARA>
fstatfs returns information about a mounted file system. fd is the open file descriptor of any file within the mounted filesystem. buf is a pointer to a statfs structure defined as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EBADF
</TERM>
<LISTITEM>
<PARA>
fd is not a valid open file descriptor.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT
</TERM>
<LISTITEM>
<PARA>
buf points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS
</TERM>
<LISTITEM>
<PARA>
The filesystem fd is open on does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-fwprintf-3"> <REFMETA>
<REFENTRYTITLE>fwprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>fwprintf
</REFNAME>
<REFPURPOSE>
formatted wide character output conversion
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>3 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int fwprintf(FILE* stream, const wchar_t* , ...);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The specification for "fwprintf" is as specified in the SUSv2 but with the following differences as listed below.
</PARA>

<REFSECT2>
<TITLE>Wide-character Conversion:
</TITLE>
<PARA>
The following wide-character are not specified in GNU:
</PARA><PARA>
d,i, o, u, x, X, f, e,E , g,G , c, s, p, n, C, S, %
</PARA>
</REFSECT2>

<REFSECT2>
<TITLE>Errors
</TITLE>
<PARA>
The following error types are not specified in GNU:
</PARA><PARA>
EILSEQ
</PARA><PARA>
EINVAL
</PARA><PARA>
ENOMEM
</PARA>
</REFSECT2>

</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-gethostbyname-3"> <REFMETA>
<REFENTRYTITLE>gethostbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gethostbyname</REFNAME>
<REFPURPOSE>
get network host entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>
extern int h_errno;

struct hostent *gethostbyname(const char *name);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The gethostbyname() function returns a structure of type hostent for the given host name. Here name is either a host name, or an IPv4 address in standard dot notation, or an IPv6 address in colon (and possibly dot) notation. (See RFC 1884 for the description of IPv6 addresses.) If name is an IPv4 or IPv6 address, no lookup is performed and gethostbyname() simply copies name into the h_name field and its struct in_addr equivalent into the h_addr_list[0] field of the returned hostent structure. If name doesn't end in a dot and the environment variable HOSTALIASES is set, the alias file pointed to by HOSTALIASES will first be searched for name (see hostname(7) for the file ). The current domain and its parents are searched unless name ends in a dot.
</PARA><PARA>
The domain name queries carried out by gethostbyname() use a combination of any or all of the name server named(8), a broken out line from /etc/hosts, and the Network Information Service (NIS or YP), depending upon the contents of the order line in /etc/host.conf. (See resolv+(8)). The default action is to query named(8), followed by /etc/hosts.
</PARA><PARA>
The hostent structure is defined in &lt;netdb.h> as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct hostent {
</TERM>
<LISTITEM>
<PARA>
       char    *h_name;        /* official name of host */
</PARA><PARA>
       char    **h_aliases;    /* alias list */
</PARA><PARA>
       int     h_addrtype;     /* host address type */
</PARA><PARA>
       int     h_length;       /* length of address */
</PARA><PARA>
       char    **h_addr_list;  /* list of addresses */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
#define h_addr  h_addr_list[0]  /* for backward compatibility */
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The gethostbyname()) functions return the hostent structure or a NULL pointer if an error occurs. On error, the h_errno variable holds an error number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ENOMEM
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to complete the operation. 
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getloadavg-3"> <REFMETA>
<REFENTRYTITLE>getloadavg</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getloadavg
</REFNAME>
<REFPURPOSE>
get system load averages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdlib.h>

int getloadavg(double loadavg[], int nelem);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getloadavg() function returns the number of processes in the system run queue averaged over various periods of time. Up to nelem samples are retrieved and assigned to successive elements of loadavg[]. The system imposes a maximum of 3 samples, representing averages over the last 1, 5, and 15 minutes, respectively.
</PARA>
</REFSECT1>
<!--     BSDI BSD/OS                      June 4, 1993       -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-getopt-long-3"> <REFMETA>
<REFENTRYTITLE>getopt_long</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt_long() function works like getopt() except that it also accepts long options, started out by two dashes. Long option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option. A long option may take a parameter, of the form --arg=param or --arg param.
</PARA><PARA>
longopts  is a pointer to the first element of an array of struct option declared in &lt;getopt.h> as
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
          struct option {
</TERM>
<LISTITEM>
<PARA>
              const char *name;
</PARA><PARA>
              int *flag;
</PARA><PARA>
              int has_arg;
</PARA><PARA>
              int val;
</PARA><PARA>
          };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The getopt_long() function returns the option character if the option was found successfully, : if there was a missing parameter for one of the options, ?  for an unknown option character, or -1 for the end of the option list.
</PARA><PARA>
getopt_long() also returns the option character when a short option is recognized. For a long option, they return val if flag is NULL, and 0 otherwise. Error and -1 returns are the same as for getopt(), plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getopt-long-only-3"> <REFMETA>
<REFENTRYTITLE>getopt_long_only</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt_long_only</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;getopt.h>

int getopt_long_only(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getopt_long_only() is like getopt_long(), but - as well as -- can indicate a long option. If an option that starts with - (not --) doesn't match a long option, but does match a short option, it is parsed as a short option instead.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The function getopt_long_only() returns the option character if the option was found successfully, : if there was a missing parameter for one of the options, ? for an unknown option character, or -1 for the end of the option list. getopt_long_only() also returns the option character when a short option is recognized. For a long option, they return val if flag is NULL, and 0 otherwise. Error and -1 returns are the same as for getopt(), plus ? for an ambiguous match or an extraneous parameter.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---getpgid-1"> <REFMETA>
<REFENTRYTITLE>__getpgid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__getpgid</REFNAME>
<REFPURPOSE>
get the process group id
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>16 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
pid_t __getpgid(pid_t pid);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__getpgid(pid) has the same specification as getpgid(pid).
</PARA>
<PARA>
__getpgid is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-getprotobyname-3"> <REFMETA>
<REFENTRYTITLE>getprotobyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotobyname
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotobynumber(int proto);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getprotobyname() function returns a protoent structure for the line from /etc/protocols that matches the protocol name name.
</PARA>
<PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The getprotobyname() function returns the protoent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/protocols protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getprotoent-3"> <REFMETA>
<REFENTRYTITLE>getprotoent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getprotoent
</REFNAME>
<REFPURPOSE>
get protocol entry
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 Arpil 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
struct protoent *getprotoent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getprotoent() function reads the next line from the file /etc/protocols and returns a structure protoent containing the broken out fields from the line. The /etc/protocols file is opened if necessary.
</PARA><PARA>
The protoent structure is defined in &lt;netdb.h&gt; as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct protoent {
</TERM>
<LISTITEM>
<PARA>
                      char    *p_name;        /* official protocol name */
</PARA><PARA>
                      char    **p_aliases;    /* alias list */
</PARA><PARA>
                      int     p_proto;        /* protocol number */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>
RETURN VALUE
</TITLE>
<PARA>
The getprotoent() function returns the protoent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
/etc/protocols protocol database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getservbyname-3"> <REFMETA>
<REFENTRYTITLE>getservbyname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservbyname
</REFNAME>
<REFPURPOSE>
get service entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

struct servent *getservbyname(const char *name, const char *proto);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getservbyname() function returns a servent structure for the line from /etc/services that matches the service name using protocol proto.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getservbyname() returns the servent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
/etc/services services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-getservent-3"> <REFMETA>
<REFENTRYTITLE>getservent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getservent
</REFNAME>
<REFPURPOSE>
get service entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netdb.h>

struct servent *getservent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getservent() function reads the next line from the file /etc/services and returns a structure servent containing the broken out fields from the line. The /etc/services file is opened if necessary.
</PARA><PARA>
The servent structure is defined in &lt;netdb.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct servent {
</TERM>
<LISTITEM>
<PARA>
                      char    *s_name;        /* official service name */
</PARA><PARA>
                      char    **s_aliases;    /* alias list */
</PARA><PARA>
                      int     s_port;         /* port number */
</PARA><PARA>
                      char    *s_proto;       /* protocol to use */
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getservent() returns the servent structure, or a NULL pointer if an error occurs or the end of the file is reached.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
FILES
</TITLE>
<PARA>
/etc/services services database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-gettext"> <REFMETA>
<REFENTRYTITLE>gettext</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>gettext</REFNAME>
<REFPURPOSE>
look up MSGID in the current default message catalog for the current LC_MESSAGES locale
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *gettext((const char *msgid));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used to look up the MSGID in the DOMAINNAME message catalog for the current CATEGORY locale. If not found, returns MSGID itself (the default text). 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-getutent-3"> <REFMETA>
<REFENTRYTITLE>getutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent
</REFNAME>
<REFPURPOSE>
access utmp file entries	
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

struct utmp *getutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
getutent() reads a line from the current file position in the utmp file. It returns a pointer to a structure containing the fields of the line.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
getutent() returns a pointer to a static struct utmp.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/var/run/utmp database of currently logged-in users
</PARA><PARA>
/var/log/wtmp database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-htons-3"> <REFMETA>
<REFENTRYTITLE>htons</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>htons</REFNAME>
<REFPURPOSE>converts host byte order to network byte order
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netinet/in.h>

unsigned short int htons(unsigned short int hostshort);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The htons() function converts the short integer hostshort from host byte order to network byte order.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-inet-aton-3"> <REFMETA>
<REFENTRYTITLE>inet_aton</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inet_aton
</REFNAME>
<REFPURPOSE>
Internet address manipulation routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>

int inet_aton(const char *cp, struct in_addr *inp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
inet_aton() converts the Internet host address cp from the standard numbers-and-dots notation into binary data and stores it in the structure that inp points to. inet_aton returns nonzero if the address is valid, zero if not.
</PARA><PARA>
The structure in_addr is defined in netinet/in.h as:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct in_addr {
</TERM>
<LISTITEM>
<PARA>
                      unsigned long int s_addr;
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Note that on the i80x86 the host byte order is Least Significant Byte first, whereas the network byte order, as used on the Internet, is Most Significant Byte first.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-inet-ntoa-3"> <REFMETA>
<REFENTRYTITLE>inet_ntoa</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>inet_ntoa
</REFNAME>
<REFPURPOSE>
Internet address manipulation routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>

char *inet_ntoa(struct in_addr in);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  inet_ntoa() function converts the Internet host address in given in network byte order to a string in standard numbers-and-dots notation. The string is returned in a statically allocated buffer, which subsequent calls will overwrite.
</PARA><PARA>
The structure in_addr is defined in netinet/in.h as:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct in_addr {
</TERM>
<LISTITEM>
<PARA>
                      unsigned long int s_addr;
</PARA><PARA>
              }
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Note that on the i80x86 the host byte order is Least Significant Byte first, whereas the network byte order, as used on the Internet, is Most Significant Byte first.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-initgroups-3"> <REFMETA>
<REFENTRYTITLE>initgroups</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>initgroups
</REFNAME>
<REFPURPOSE>
initialize the supplementary group access list
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;grp.h>
#include &lt;sys/types.h>

int initgroups(const char *user, gid_t group);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The initgroups() function initializes the group access list by reading the group database /etc/group and using all groups of which user is a member. The additional group group is also added to the list.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
The calling process does not have sufficient privileges.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient memory to allocate group information structure.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/group group database file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stderr--"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stderr_</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stderr_
</REFNAME>
<REFPURPOSE>
standard I/O stream
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libio.h>

extern struct _IO_FILE_plus _IO_2_1_stderr_;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_2_1_stderr is an object whose address becomes stderr.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stdin--"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stdin_</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stdin_
</REFNAME>
<REFPURPOSE>
standard I/O stream
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libio.h>

extern struct _IO_FILE_plus _IO_2_1_stdin_;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_2_1_stdin is an object whose address becomes stdin.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-2-1-stdout--"> <REFMETA>
<REFENTRYTITLE>_IO_2_1_stdout_</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_2_1_stdout_
</REFNAME>
<REFPURPOSE>
standard I/O stream
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libio.h>

extern struct _IO_FILE_plus _IO_2_1_stdout_;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_2_1_stdout is an object whose address becomes stdout.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-feof-3"> <REFMETA>
<REFENTRYTITLE>_IO_feof</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_feof
</REFNAME>
<REFPURPOSE>
alias for feof
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_feof(_IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The function _IO_feof() tests the end-of-file indicator for the stream pointed to by __fp, returning non-zero if it is set.  
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-getc-3"> <REFMETA>
<REFENTRYTITLE>_IO_getc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_getc
</REFNAME>
<REFPURPOSE>
alias for getc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_getc(_IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_getc() reads the next character from __fp and returns it as an unsigned char
cast to an int, or EOF on end of file or error.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-putc-3"> <REFMETA>
<REFENTRYTITLE>_IO_putc</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_putc
</REFNAME>
<REFPURPOSE>
alias for putc
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_putc(int __c, _IO_FILE *__fp);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_putc() writes the character __c, cast to an unsigned char, to __fp.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib--IO-puts-3"> <REFMETA>
<REFENTRYTITLE>_IO_puts</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_IO_puts
</REFNAME>
<REFPURPOSE>
alias for puts
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int _IO_puts(const char *__c);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
_IO_puts() writes the string __s and a trailing newline to stdout.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-isblank-3"> <REFMETA>
<REFENTRYTITLE>isblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>isblank
</REFNAME>
<REFPURPOSE>
character classification routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int isblank(int c);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This functions checks whether c, which must have the value of an unsigned char or EOF, falls into a certain character class according to the current locale.
</PARA><PARA>
isblank() checks for a blank character; that is, a space or a tab. This function is a GNU extension.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The values returned are nonzero if the character c falls into the tested class, and a zero value if not.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The details of what characters belong into which class depend on the current locale. For example, isupper() will not recognize an A - umlaut as an uppercase letter in the default C locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-isinf-3"> <REFMETA>
<REFENTRYTITLE>isinf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>isinf
</REFNAME>
<REFPURPOSE>
test for infinity or not-a-number (NaN)
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;math.h>

int isinf(double value);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The isinf() function returns -1 if value represents negative infinity, 1 if value represents positive infinity, and 0 otherwise.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-iswblank-3"> <REFMETA>
<REFENTRYTITLE>iswblank</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswblank
</REFNAME>
<REFPURPOSE>
test for whitespace wide character
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wctype.h>

int iswblank(wint_t wc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The iswblank function is the wide-character equivalent of the isblank function. It tests whether wc is a wide character belonging to the wide character class "blank".
</PARA><PARA>
The wide character class "blank" is a subclass of the wide character class "space".
</PARA><PARA>
Being a subclass of the wide character class "space", the wide character class "blank" is disjoint from the wide character class "graph" and therefore also disjoint from its subclasses "alnum", "alpha", "upper", "lower", "digit", "xdigit", "punct".
</PARA><PARA>
The wide character class "blank" always contains at least the space character and the control character '\t'.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The iswblank function returns non-zero if wc is a wide character belonging to the wide character class "blank". Otherwise it returns zero.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behaviour of iswblank depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-iswctype-3"> <REFMETA>
<REFENTRYTITLE>iswctype</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>iswctype
</REFNAME>
<REFPURPOSE>
wide character classification
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wctype.h>

int iswctype(wint_t wc, wctype_t desc);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If wc is a wide character having the character property designated by desc (or in other words: belongs to the character class designated by desc), the iswctype function returns non-zero. Otherwise it returns zero. If wc is WEOF, zero is returned.
</PARA><PARA>
desc must be a character property descriptor returned by the wctype function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
iswctype returns non-zero if the wc has the designated property. Otherwise it returns 0.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of iswctype depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib---libc-start-main-"> <REFMETA>
<REFENTRYTITLE>__libc_start_main</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__libc_start_main
</REFNAME>
<REFPURPOSE>
initialization routine
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
BP_SYM __libc_start_main (int (*main) (int, char**, char**),
    int argc, char *__unbounded *__unbounded ubp_av,
    void (*init) (void), void (*fini) (void),
    void (*rtld_fini) (void), void (*__unbounded stack_end);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Initialize glibc.
</PARA>
</REFSECT1>

</REFENTRY>

<REFENTRY ID="baselib-llabs-3"> <REFMETA>
<REFENTRYTITLE>llabs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>llabs
</REFNAME>
<REFPURPOSE>
compute the absolute value of an integer
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdlib.h>
       
long long int llabs(long long int j);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
llabs() computes the absolute value of the argument j of the appropriate integer type for the function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
Returns the absolute value of the integer argument, of the appropriate integer type for the function.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Trying to take the absolute value of the most negative integer is not defined.
</PARA><PARA>
The llabs() function is included in glibc since version 2.0, but is not in libc5 or libc4.
</PARA><PARA>
For llabs() to be declared, it may be necessary to define _ISOC99_SOURCE or _ISOC9X_SOURCE (depending on the version of glibc) before including any standard headers.
</PARA><PARA>
GCC 3.0 also handles llabs() as builtin.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-logwtmp-3"> <REFMETA>
<REFENTRYTITLE>logwtmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logwtmp
</REFNAME>
<REFPURPOSE>
append an entry to the wtmp file
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

void logwtmp(const char *line, const char *name, const char *host);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
logwtmp() constructs an utmp structure using line, name, host, current time and current process id. Then it calls updwtmp() to append the structure to the utmp file.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Availability
</TITLE>
<PARA>
Both functions are available under glibc2, but not under libc5. However, logwtmp occurs in the old libbsd.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Files
</TITLE>
<PARA>
/var/log/wtmp database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="libutil---lxstat-2"> <REFMETA>
<REFENTRYTITLE>__lxstat</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__lxstat
</REFNAME>
<REFPURPOSE>inline wrapper around call to lxstat
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;ctype.h>

int __lxstat(int version, char *__path, struct stat *__statbuf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Inline wrapper around call to lxstat.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-mbsnrtowcs-3"> <REFMETA>
<REFENTRYTITLE>mbsnrtowcs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mbsnrtowcs
</REFNAME>
<REFPURPOSE>
convert a multibyte string to a wide character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t mbsnrtowcs(wchar_t *dest, const char **src,
                  size_t nms, size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mbsnrtowcs function is like the mbsrtowcs function, except that the number of bytes to be converted, starting at *src, is limited to nms.
</PARA><PARA>
If dest is not a NULL pointer, the mbsnrtowcs function converts at most nms bytes from the multibyte string *src to a wide-character string starting at dest. At most len wide characters are written to dest. The  state *ps is updated. The conversion is effectively performed by repeatedly calling mbrtowc(dest,*src,n,ps) where n is some positive number, as long as this call succeeds, and then incrementing dest by one and *src by the number of bytes consumed. The conversion can stop for three reasons:
</PARA><PARA>
1. An invalid multibyte sequence has been encountered. In this case *src is left pointing to the invalid multibyte sequence, (size_t)(-1) is returned, and errno is set to EILSEQ.
</PARA><PARA>
2. The nms limit forces a stop, or len non-L'\0' wide characters have been stored at dest. In this case *src is left pointing to the next multibyte sequence to be converted, and the number of wide characters written to dest is returned.
</PARA><PARA>
3. The multibyte string has been completely converted, including the terminating '\0' (which has the side effect of bringing back *ps to the initial state). In this case *src is set to NULL, and the number of wide characters written to dest, excluding the terminating L'\0' character, is returned.
</PARA><PARA>
If dest is NULL, len is ignored, and the conversion proceeds as above, except that the converted wide characters are not written out to memory, and that no destination length limit exists.
</PARA><PARA>
In both of the above cases, if ps is a NULL pointer, a static anonymous state only known to the mbsnrtowcs function is used instead.
</PARA><PARA>
The programmer must ensure that there is room for at least len wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The mbsnrtowcs function returns the number of wide characters that make up the converted part of the wide character string, not including the terminating null wide character. If an invalid multibyte sequence was encountered, (size_t)(-1) is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of mbsnrtowcs depends on the LC_CTYPE category of the current locale.
</PARA><PARA>
Passing NULL as ps is not multi-thread safe.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-memmem-3"> <REFMETA>
<REFENTRYTITLE>memmem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memmem</REFNAME>
<REFPURPOSE>
locate a substring
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

void *memmem(const void *haystack, size_t haystacklen,
             const void *needle, size_t needlelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  memmem() function finds the start of the first occurrence of the substring needle of length needlelen in the memory area haystack of length haystacklen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The memmem() function returns a pointer to the beginning of the substring, or NULL if the substring is not found.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
This function was broken in Linux libraries up to and including libc 5.0.9; there the needle and haystack arguments were interchanged, and a pointer to the end of the first occurrence of needle was returned. Since libc 5.0.9 is still widely used, this is a dangerous function to use.
</PARA>
<PARA>
Both old and new libc's have the bug that if needle is empty haystack-1 (instead of haystack) is returned. And glibc 2.0 makes it worse, and returns a pointer to the last byte of haystack. This is fixed in glibc 2.1.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---mempcpy"> <REFMETA>
<REFENTRYTITLE>__mempcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__mempcpy</REFNAME>
<REFPURPOSE>
copy N bytes of SRC to DEST
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern ptr_t __mempcpy(ptr_t restrict dest,
                       const ptr_t restrict src, size_t n));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Copy N bytes of SRC to DEST, return pointer to bytes after the last written byte.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-memrchr"> <REFMETA>
<REFENTRYTITLE>memrchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memrchr</REFNAME>
<REFPURPOSE>
scan memory for a character
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

void *memrchr(const void *s, int c, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The memrchr() function returns a pointer to the last occurrence of the character "c" in the first "n" characters of string "s".
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--nl-msg-cat-cntr"> <REFMETA>
<REFENTRYTITLE>_nl_msg_cat_cntr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_nl_msg_cat_cntr</REFNAME>
<REFPURPOSE>
variable defined in loadmsgcat.c which gets incremented every time a new catalog is loaded
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern int _nl_msg_cat_cntr;
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Used by Message catalogs for internationalization. A variable defined which gets incremented every time a new catalog is loaded.  
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-ntohs-3"> <REFMETA>
<REFENTRYTITLE>ntohs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>ntohs</REFNAME>
<REFPURPOSE>convert values between host and network byte order
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;netinet/in.h>

unsigned short int ntohs(unsigned short int netshort);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The ntohs() function converts the short integer netshort from network byte order to host byte order.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--obstack-begin"> <REFMETA>
<REFENTRYTITLE>_obstack_begin</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_obstack_begin</REFNAME>
<REFPURPOSE>
initialize an obstack for use
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

extern int _obstack_begin(struct obstack *, int, int,
                          void *(*) (long), void (*) (void *));
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Initialize an obstack for use.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-obstack-free"> <REFMETA>
<REFENTRYTITLE>obstack_free</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>obstack_free</REFNAME>
<REFPURPOSE>
free an object in the obstack
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

void obstack_free(struct obstack *obstack, void *block);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Free an object in the obstack.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--obstack-newchunk"> <REFMETA>
<REFENTRYTITLE>_obstack_newchunk</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_obstack_newchunk</REFNAME>
<REFPURPOSE>
allocate a new current chunk of memory for the obstack
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;obstack.h>

extern void _obstack_newchunk(struct obstack *, int);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Allocate a new current chunk of memory for the obstack. 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-opterr-3"> <REFMETA>
<REFENTRYTITLE>opterr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>opterr
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int opterr;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
opterr is used as a flag to suppress error message generated by getopt(). When opterr is set to 0; it suppresses the error message generated by getopt() when getopt() does not recognize an option character.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-optind-3"> <REFMETA>
<REFENTRYTITLE>optind</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>optind
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int optind;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
optind holds the current index of the array argr[] which contains the command line options being parsed by getopt().
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-optopt-3"> <REFMETA>
<REFENTRYTITLE>optopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>optopt
</REFNAME>
<REFPURPOSE>
external variable used in getopt()
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
extern int optopt;
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
optopt holds the unknown option character when that option character is not recognized by getopt() 
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-psignal-3"> <REFMETA>
<REFENTRYTITLE>psignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>psignal</REFNAME>
<REFPURPOSE>
print signal message
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

void psignal(int sig, const char *s);

extern const char *const sys_siglist[]
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The psignal() function displays a message on stderr consisting of the string s, a colon, a space, and a string describing the signal number sig. If sig is invalid, the message displayed will indicate an unknown signal.
</PARA>
<PARA>
The array sys_siglist holds the signal description strings indexed by signal number.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
psignal() returns no value.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-putwchar--3"> <REFMETA>
<REFENTRYTITLE>putwchar</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>putwchar</REFNAME>
<REFPURPOSE>
write a wide character to standard output
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wint_t putwchar(wchar_t wc);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The putwchar function is the wide-character equivalent of the putchar function. It writes the wide character wc to stdout. If ferror(stdout) becomes true, it returns WEOF. If a wide character conversion error occurs, it sets errno to EILSEQ and returns WEOF. Otherwise it returns wc.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The putwchar function returns wc if no error occurred, or WEOF to indicate an error.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of putwchar depends on the LC_CTYPE category of the current locale.
</PARA>
<PARA>
It is reasonable to expect that putwchar will actually write the multibyte sequence corresponding to the wide character wc.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---rawmemchr"> <REFMETA>
<REFENTRYTITLE>__rawmemchr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__rawmemchr</REFNAME>
<REFPURPOSE>
scan memory
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern ptr_t __rawmemchr(const ptr_t s, int c);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This is a weak alias to rawmemchr. Search in S for C.
</PARA><PARA>
Similar to memchr, but there is no length limit. 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sem-timedwait-3"> <REFMETA>
<REFENTRYTITLE>sem_timedwait</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sem_timedwait
</REFNAME>
<REFPURPOSE>
operation on semaphore
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;semaphore.h>
int sem_timedwait(sem_t *__restrict __sem, 
		  __const struct timespec *__restrict __abstime);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
sem_timedwait() waits for semaphore object SEM being posted. It is a new function from IEEE Std. 1003.1-200x that is similar to sem_wait but waits only until ABSTIME.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-setbuffer-3"> <REFMETA>
<REFENTRYTITLE>setbuffer</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setbuffer
</REFNAME>
<REFPURPOSE>
stream buffering operation
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

void setbuffer(FILE *stream, char *buf, size_tsize);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
setbuffer is an alias for call to setvbuf. It works the same, except that the size of the buffer is up to the caller, rather than being determined by the default BUFSIZ.  
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setegid-2"> <REFMETA>
<REFENTRYTITLE>setegid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setegid
</REFNAME>
<REFPURPOSE>
set real and / or effective group ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;unistd.h>

int setegid(gid_t egid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
       setegid sets real and effective group ID's of the current
       process.  Un-privileged users may change the real group ID
       to the effective group ID and vice-versa.

</PARA><PARA>
Prior to Linux 1.1.38, the saved ID paradigm, when used with setegid was broken. Starting at 1.1.38, it is also possible to set the effective group ID from the saved group ID.
</PARA><PARA>
Only the super-user may make other changes.
</PARA><PARA>
Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged.
</PARA><PARA>
Currently (libc-4.x.x), setegid(egid) is functionally equivalent to setregid(-1, egid).
</PARA><PARA>
If the real group ID is changed or the effective group ID is set to a value not equal to the previous real group ID, the saved group ID will be set to the new effective group ID.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
EPERM 
</PARA>
<BLOCKQUOTE>
<PARA>
The current process is not the super-user and changes other than (i) swapping the effective group ID with the real group ID or (ii) setting one to the value of the other or (iii) setting the effective group ID to the value of the saved group ID was specified.
</PARA>
</BLOCKQUOTE>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-seteuid-2"> <REFMETA>
<REFENTRYTITLE>seteuid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>seteuid
</REFNAME>
<REFPURPOSE>
set real and/or effective user ID
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;unistd.h>

int seteuid(uid_t euid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
seteuid sets real and effective user ID's of the current process. Un-privileged users may change the real user ID to the effective user ID and vice-versa.
</PARA><PARA>
Prior to Linux 1.1.37, the saved ID paradigm, when used with seteuid was broken.
</PARA><PARA>
Starting at 1.1.37, it is also possible to set the effective user ID from the saved user ID.
</PARA><PARA>
Only the super-user may make other changes.
</PARA><PARA>
Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged.
</PARA><PARA>
Currently seteuid(euid) is functionally equivalent to setreuid(-1, euid).
</PARA><PARA>
If the real user ID is changed or the effective user ID is set to a value not equal to the previous real user ID, the saved user ID will be set to the new effective user ID.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
EPERM  
</PARA>
<BLOCKQUOTE>
<PARA>
The current process is not the super-user and changes other than (i) swapping the effective user ID with the real user ID or (ii) setting one to the value of the other or (iii) setting the effective user ID to the value of the saved user ID was specified.
</PARA>
</BLOCKQUOTE>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sethostid-2"> <REFMETA>
<REFENTRYTITLE>sethostid</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostid
</REFNAME>
<REFPURPOSE>
set the unique identifier of the current host
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int sethostid(long int hostid);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Set a unique 32-bit identifier for the current machine. The 32-bit identifier is intended to be unique among all UNIX systems in existence. This normally resembles the Internet address for the local machine, as returned by gethostbyname(3), and thus usually never needs to be set.
</PARA><PARA>
The sethostid call is restricted to the superuser.
</PARA><PARA>
The hostid argument is stored in the file /etc/hostid.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
gethostid returns the 32-bit identifier for the current host as set by sethostid(2).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/hostid
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sethostname-2"> <REFMETA>
<REFENTRYTITLE>sethostname</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sethostname
</REFNAME>
<REFPURPOSE>
set host name
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

int sethostname(const char *name, size_t len);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function is used to change the host name of the current processor.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EINVAL 
</TERM>
<LISTITEM>
<PARA>
len is negative or len is larger than the maximum allowed size.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EPERM  
</TERM>
<LISTITEM>
<PARA>
the caller was not the superuser.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
name is an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
SUSv2 guarantees that Host names are limited to 255 bytes.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setmntent-3"> <REFMETA>
<REFENTRYTITLE>setmntent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setmntent
</REFNAME>
<REFPURPOSE>
get file system descriptor file entry
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>
#include &lt;mntent.h>

FILE *setmntent(const char *filename, const char *type);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This routine is used to access the file system description file /etc/fstab and the mounted file system description file /etc/mtab.
</PARA><PARA>
The setmntent() function opens the file system description file filep and returns a file pointer which can be used by getmntent(). The argument type is the type of access required and can take the same values as the mode argument of fopen(3).
</PARA><PARA>
The mntent structure is defined in &lt;mntent.h> as follows:
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
              struct mntent {
</TERM>
<LISTITEM>
<PARA>
                      char    *mnt_fsname;    /* name of mounted file system */
</PARA><PARA>
                      char    *mnt_dir;       /* file system path prefix */
</PARA><PARA>
                      char    *mnt_type;      /* mount type (see mntent.h) */
</PARA><PARA>
                      char    *mnt_opts;      /* mount options (see mntent.h) */
</PARA><PARA>
                      int     mnt_freq;       /* dump frequency in days */
</PARA><PARA>
                      int     mnt_passno;     /* pass number on parallel fsck */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/etc/fstab file system description file
/etc/mtab mounted file system description file
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-setutent-3"> <REFMETA>
<REFENTRYTITLE>setutent</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>setutent
</REFNAME>
<REFPURPOSE>
access utmp file entries
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;utmp.h>

void setutent(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
setutent() rewinds the file pointer to the beginning of the utmp file. It is generally a Good Idea to call it before any of the other functions.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<PARA>
On error, (struct utmp*)0 will be returned.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/var/run/utmp database of currently logged-in users
/var/log/wtmp database of past user logins
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigandset"> <REFMETA>
<REFENTRYTITLE>sigandset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigandset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical AND
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

extern int sigandset(sigset_t *set, const sigset_t *left,
                     const sigset_t *right);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A signal function that builds a new signal set by combining the two input sets using logical AND.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigblock-2"> <REFMETA>
<REFENTRYTITLE>sigblock</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigblock
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

int sigblock(int mask);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
The sigblock system call adds the signals specified in mask to the set of signals currently being blocked from delivery.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Prototype for this function is only available if _BSD_SOURCE is defined before the inclusion of any system.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-siggetmask-2"> <REFMETA>
<REFENTRYTITLE>siggetmask</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>siggetmask
</REFNAME>
<REFPURPOSE>
manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

int siggetmask(void);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
siggetmask returns the current set of masked signals.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Prototype for this function is only available if _BSD_SOURCE is defined before the inclusion of any system header file.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigisemptyset"> <REFMETA>
<REFENTRYTITLE>sigisemptyset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigisemptyset</REFNAME>
<REFPURPOSE>
signal function - check for empty SET
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

extern int sigisemptyset(const sigset_t *set);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Signal function - Check for empty SET. Returns non-empty value if SET is not empty.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigorset"> <REFMETA>
<REFENTRYTITLE>sigorset</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigorset</REFNAME>
<REFPURPOSE>
build a new signal set by combining the two input sets using logical OR
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt:signal.h>

extern int sigorset((sigset_t *set, const sigset_t *left,
                     const sigset_t *right));

</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A signal function that builds a new signal set by combining the two input sets using logical OR.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-sigreturn-2"> <REFMETA>
<REFENTRYTITLE>sigreturn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigreturn
</REFNAME>
<REFPURPOSE>
return from signal handler and cleanup stack frame
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int sigreturn(unsigned long __unused);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
When the Linux kernel creates the stack frame for a signal handler, a call to sigreturn is inserted into the stack frame so that the the signal handler will call sigreturn upon return. This inserted call to sigreturn cleans up the stack so that the process can restart from where it was interrupted by the signal.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
sigreturn never returns.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Warning
</TITLE>
<PARA>
sigreturn call is used by the kernel to implement signal handlers. It should never be called directly. Better yet, the specific use of the __unused argument varies depending on the architecture.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Files
</TITLE>
<PARA>
/usr/src/linux/arch/i386/kernel/signal.c
</PARA><PARA>
/usr/src/linux/arch/alpha/kernel/entry.s
</PARA>
</REFSECT1>

<!-- LDP GENERAL PUBLIC LICENSE  -->
<!-- Version 1a, November 1998   -->

</REFENTRY>

<REFENTRY ID="baselib-sigsetmask-2"> <REFMETA>
<REFENTRYTITLE>sigsetmask</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigsetmask
</REFNAME>
<REFPURPOSE>manipulate the signal mask
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>11 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int sigsetmask(int mask);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>11 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigprocmask(2).
</PARA><PARA>
The sigsetmask system call replaces the set of blocked signals totally with a new set specified in mask. Signals are blocked if the corresponding bit in mask is a 1.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
sigsetmask returns the previous set of masked signals.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Prototype for this function is only available if _BSD_SOURCE is defined before the inclusion of any system header file.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-sigvec-2"> <REFMETA>
<REFENTRYTITLE>sigvec</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>sigvec
</REFNAME>
<REFPURPOSE>BSD software signal facilities
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;bsd/signal.h>
int sigvec(int sig, struct sigvec *vec, struct sigvec *ovec);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This interface is made obsolete by sigaction(2).
</PARA><PARA>
Under Linux sigvec is #define'd to sigaction, and provides at best a rough approximation of the BSD sigvec interface.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-statfs-2"> <REFMETA>
<REFENTRYTITLE>statfs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>statfs
</REFNAME>
<REFPURPOSE>get file system statistics
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/vfs.h>

int statfs(const char *path, struct statfs *buf);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>4 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
statfs returns information about a mounted file system. path is the path name of any file within the mounted filesystem.
</PARA><PARA>
buf is a pointer to a statfs structure defined as follow:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
struct statfs {
</TERM>
<LISTITEM>
<PARA>
                 long    f_type;     /* type of filesystem (see below) */
</PARA><PARA>
                 long    f_bsize;    /* optimal transfer block size */
</PARA><PARA>
                 long    f_blocks;   /* total data blocks in file system */
</PARA><PARA>
                 long    f_bfree;    /* free blocks in fs */
</PARA><PARA>
                 long    f_bavail;   /* free blocks avail to non-superuser */
</PARA><PARA>
                 long    f_files;    /* total file nodes in file system */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 long    f_ffree;    /* free file nodes in fs */
</PARA><PARA>
                 fsid_t  f_fsid;     /* file system id */
</PARA><PARA>
                 long    f_namelen;  /* maximum length of filenames */
</PARA><PARA>
                 long    f_spare[6]; /* spare for later */
</PARA><PARA>
              };
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
Fields that are undefined for a particular file system are set to 0.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>
ENOTDIR
</TERM>
<LISTITEM>
<PARA>
A component of the path prefix of path is not a directory.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENAMETOOLONG
</TERM>
<LISTITEM>
<PARA>
path is too long.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOENT 
</TERM>
<LISTITEM>
<PARA>
The file referred to by path does not exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EACCES 
</TERM>
<LISTITEM>
<PARA>
Search permission is denied for a component of the path prefix of path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ELOOP
</TERM>
<LISTITEM>
<PARA>
Too many symbolic links were encountered in translating path.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EFAULT 
</TERM>
<LISTITEM>
<PARA>
Buf or path points to an invalid address.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
EIO    
</TERM>
<LISTITEM>
<PARA>
An I/O error occurred while reading from or writing to the file system.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOMEM 
</TERM>
<LISTITEM>
<PARA>
Insufficient kernel memory was available.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ENOSYS 
</TERM>
<LISTITEM>
<PARA>
The filesystem path is on does not support statfs.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-stime-2"> <REFMETA>
<REFENTRYTITLE>stime</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stime
</REFNAME>
<REFPURPOSE>
set time
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _SVID_SOURCE /* glibc2 needs this */
#include &lt;time.h>

int stime(time_t *t);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
stime sets the system's idea of the time and date. Time, pointed to by t, is measured in seconds from 00:00:00 GMT January 1, 1970. stime() may only be executed by the super user.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
On success, zero is returned. On error, -1 is returned, and errno is set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
EPERM
</TERM>
<LISTITEM>
<PARA>
The caller is not the super-user.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
Under glibc2, &lt;time.h> only provides a prototype when _SVID_SOURCE is defined.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--      Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-stpcpy-3"> <REFMETA>
<REFENTRYTITLE>stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpcpy</REFNAME>
<REFPURPOSE>
copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpcpy(char *dest, const char *src);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The stpcpy() function copies the string pointed to by src (including the terminating \0 character) to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
stpcpy() returns a pointer to the end of the string dest (that is, the address of the terminating null character) rather than the beginning.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Example
</TITLE>
<PARA>
For example, this program uses stpcpy to concatenate foo and bar to produce foobar, which it then prints.
</PARA><PARA>
#include &lt;string.h>
</PARA><PARA>
int
main (void)
{
  char *to = buffer;
  to = stpcpy (to, "foo");
  to = stpcpy (to, "bar");
  printf ("%s\n", buffer);
}
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="libutil---stpcpy-2"> <REFMETA>
<REFENTRYTITLE>__stpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__stpcpy
</REFNAME>
<REFPURPOSE>copy a string returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char * __stpcpy(char *dest, const char *src);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __stpcpy() function copies the string pointed to by src (including the terminating /0 character) to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
__stpcpy() returns a pointer to the end of the string dest (that is, the address of the terminating null character) rather than the beginning.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-stpncpy-3"> <REFMETA>
<REFENTRYTITLE>stpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>stpncpy</REFNAME>
<REFPURPOSE>
copy a fixed-size string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *stpncpy (char *dest, const char *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The stpncpy function copies at most n characters from  the
string  pointed  to by src, including the terminating '\0'
character, to the array pointed  to  by  dest.  Exactly  n
characters  are written at dest. If the length strlen(src)
is smaller than n, the remaining characters in  the  array
pointed to by dest are filled with '\0' characters. If the
length strlen(src) is greater or equal to  n,  the  string
pointed to by dest will not be '\0' terminated.

The strings may not overlap.

The programmer must ensure that there is room for at least
n characters at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
stpncpy returns a pointer to the terminating null in dest,
or, if dest is not null-terminated, dest + n.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strcasestr"> <REFMETA>
<REFENTRYTITLE>strcasestr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strcasestr</REFNAME>
<REFPURPOSE>
locate a substring - ignores the case of both strings
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strcasestr(const char *haystack, const char *needle);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Similar to strstr but this function ignores the case of both strings.
</PARA>

</REFSECT1>
</REFENTRY>









<REFENTRY ID="baselib-strerror-r"> <REFMETA>
<REFENTRYTITLE>strerror_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strerror_r</REFNAME>
<REFPURPOSE>
reentrant version of strerror
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern char *strerror_r(int errnum, char *buf, size_t buflen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Reentrant version of strerror. If a temporary buffer is required, at most BUFLEN bytes of BUF will be used.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strfry-3"> <REFMETA>
<REFENTRYTITLE>strfry</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strfry</REFNAME>
<REFPURPOSE>
randomize a string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strfry(char *string);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strfry() function randomizes the contents of string by using rand(3) to randomly swap characters in the string. The result is an anagram of string.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strfry() functions returns a pointer to the randomized string.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strndup"> <REFMETA>
<REFENTRYTITLE>strndup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strndup</REFNAME>
<REFPURPOSE>
return a malloc'd copy of at most N bytes of STRING
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern char *strndup(const char *string, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Return a malloc'd copy of at most N bytes of STRING. The resultant string is terminated even if no null terminator appears before STRING[N].
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strnlen-3"> <REFMETA>
<REFENTRYTITLE>strnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

size_t strnlen(const char *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strnlen function returns the number of characters in the string pointed to by s, not including the terminating '\0' character, but at most maxlen. In doing this, strnlen looks only at the first maxlen characters at s and never beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strnlen function returns strlen(s), if that is less than maxlen, or maxlen if there is no '\0' character among the first maxlen characters pointed to by s.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strsep-3"> <REFMETA>
<REFENTRYTITLE>strsep</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsep</REFNAME>
<REFPURPOSE>
extract token from string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strsep(char **stringp, const char *delim);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
If *stringp is NULL, the strsep() function returns NULL and does nothing else. Otherwise, this function finds the first token in the string *stringp, where tokens are delimited by symbols in the string delim. This token is terminated with a \0 character (by overwriting the delimiter) and *stringp is updated to point past the token. In case no delimiter was found, the token is taken to be the entire string *stringp, and *stringp is made NULL.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strsep() function returns a pointer to the token, that is, it returns the original value of *stringp.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The strsep() function was introduced as a replacement for strtok(), since the latter cannot handle empty fields. However, strtok() conforms to ANSI-C and hence is more portable.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
This function suffers from the same problems as strtok(). In particular, it modifies the original string. Avoid it.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strsignal-3"> <REFMETA>
<REFENTRYTITLE>strsignal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strsignal</REFNAME>
<REFPURPOSE>
return string describing signal
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

char *strsignal(int sig);

extern const char * const sys_siglist[];
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strsignal() function returns a string describing the signal number passed in the argument sig. The string can only be used until the next call to strsignal().
</PARA><PARA>
The array sys_siglist holds the signal description strings indexed by signal number. The strsignal() function should be used if possible instead of this array.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strsignal() function returns the appropriate description string, or an unknown signal message if the signal number is invalid. On some systems (but not on Linux), a NULL pointer may be returned instead for an invalid signal number.
</PARA>


<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-strtod-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtod_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtod_internal
</REFNAME>
<REFPURPOSE>alias for strtod
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
double __strtod_internal(const char *<REPLACEABLE CLASS="PARAMETER">__nptr</REPLACEABLE>,
                         char **<REPLACEABLE CLASS="PARAMETER">__endptr</REPLACEABLE>,
                         int <REPLACEABLE CLASS="PARAMETER">__group</REPLACEABLE>);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The __GROUP argument must be 0 or the behavior is undefined. Otherwise the same as
<BLOCKQUOTE>
<PARA>
strtod(__nptr, __endptr).
</PARA>
</BLOCKQUOTE>
__strtod_internal is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtok-r-3"> <REFMETA>
<REFENTRYTITLE>strtok_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtok_r
</REFNAME>
<REFPURPOSE>
extract tokens from strings
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

char *strtok_r(char *s, const char *delim, char **ptrptr);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
A token is a nonempty string of characters not occurring in the string delim, followed by \0 or by a character occurring in delim.
</PARA><PARA>

The strtok_r() function can be used to parse the string s into tokens. The first call to strtok_r() should have s as its first argument. Subsequent calls should have the first argument set to NULL. Each call returns a pointer to the next token, or NULL when no more tokens are found.
</PARA><PARA>
If a token ends with a delimiter, this delimiting character is overwritten with a \0 and a pointer to the next character is saved for the next call to strtok_r(). The delimiter string delim may be different for each call.
</PARA><PARA>
ptrptr is a user allocated char* pointer. It must be the same while parsing the same string.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
Never use this function. If you do, note that:
</PARA><PARA>
It modifies its first argument.
</PARA><PARA>
The identity of the delimiting character is lost.
</PARA><PARA>
This function cannot be used on constant strings.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The strtok_r() function returns a pointer to the next token, or NULL if there are no more tokens.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-strtol-internal-1"> <REFMETA>
<REFENTRYTITLE>__strtol_internal</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__strtol_internal
</REFNAME>
<REFPURPOSE>alias for strtol
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>15 February 2000</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
long int __strtol_internal(const char *__nptr, char **__endptr,
                           int __base, int __group);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>15 February 2000</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
__GROUP must be 0 or the behavior is undefined.  Otherwise the same as strtol(__nptr, __endptr, __base).
</PARA><PARA>
__strtol_internal is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="baselib-strtoq-3"> <REFMETA>
<REFENTRYTITLE>strtoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtoq
</REFNAME>
<REFPURPOSE>
convert string value to a long or quad_t integer
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;stdlib.h>
#include &lt;limits.h>

quadt strtoq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strtoq() function converts the string in nptr to a quadt value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.
</PARA><PARA>
The string may begin with an arbitrary amount of white space (as determine by isspace(3)) followed by a single optional + or - sign. If base is zero or 16, the string may then include a 0x prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is 0, in which case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to a long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter A in either upper or lower case represents 10, B represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
strtoq() function returns the result of the conversion, unless the value would underflow or overflow. If an underflow occurs, strtoq() returns QUAD_MIN. If an overflow occurs, strtoq() returns QUAD_MAX. In both cases, errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strtouq-3"> <REFMETA>
<REFENTRYTITLE>strtouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strtouq
</REFNAME>
<REFPURPOSE>
convert a string to an uquad_t
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;sys/types.h>
#include &lt;stdlib.h>
#include &lt;limits.h>

uquadt strtouq(const char *nptr, char **endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The strtouq() function converts the string in nptr to a uquadt value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.
</PARA><PARA>
The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional + or - sign. If base is zero or 16, the string may then include a 0x prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is 0, in which case it is taken as 8 (octal).
</PARA><PARA>
The remainder of the string is converted to an unsigned long value in the obvious manner, stopping at the end of the string or at the first character that does not produce a valid digit in the given base. (In bases above 10, the letter A in either upper or lower case represents 10, B represents 11, and so forth, with Z representing 35.)
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Return Value
</TITLE>
<PARA>
Upon success the strtouq() function returns either the result of the conversion or, if there was a leading minus sign, the negation of the result of the conversion, unless the original (non-negated) value would overflow. In the case of an overflow the function returns UQUAD_MAX and the global variable errno is set to ERANGE.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ERANGE
</TERM>
<LISTITEM>
<PARA>
The given string was out of range; the value converted has been clamped.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-strverscmp"> <REFMETA>
<REFENTRYTITLE>strverscmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>strverscmp</REFNAME>
<REFPURPOSE>
compare S1 and S2 as strings holding name and indices/version numbers
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;string.h>

extern int strverscmp(const char *s1, const char *s2);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Compare S1 and S2 as strings holding name and indices/version numbers.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---sysconf"> <REFMETA>
<REFENTRYTITLE>__sysconf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__sysconf</REFNAME>
<REFPURPOSE>
get configuration information at runtime
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;unistd.h>

long __sysconf(int name);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Get configuration information at runtime.
</PARA><PARA>
This is weak alias to sysconf.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-system-3"> <REFMETA>
<REFENTRYTITLE>system</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>system
</REFNAME>
<REFPURPOSE>
execute a shell command
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdlib.h>

int system (const char * string);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
system() executes a command specified in string by calling /bin/sh -c string, and returns after the command has been completed. During execution of the command, SIGCHLD will be blocked, and SIGINT and SIGQUIT will be ignored.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The value returned is 127 if the execve() call for /bin/sh fails, -1 if there was another error and the return code of the command otherwise.
</PARA><PARA>
If the value of string is NULL, system() returns nonzero if the shell is available, and zero if not.
</PARA><PARA>
system() does not affect the wait status of any other children.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Bugs
</TITLE>
<PARA>
It is extremely unfortunate that the libc version of system() ignores interrupts. This makes programs that call it from a loop uninterruptable. This means that for such purposes one should not use system() but a private version like (warning: untested code!)
</PARA><PARA>
Do not use system() from a program with suid or sgid privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with suid or sgid privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)
</PARA><PARA>
The check for the availability of /bin/sh is not actually performed; it is always assumed to be available. ISO C specifies the check, but POSIX.2 specifies that the return shall always be non-zero, since a system without the shell is not conforming, and it is this that is implemented.
</PARA><PARA>
It is possible for the shell command to return 127, so that code is not a sure indication that the execve() call failed; check errno to make sure.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib--sys-errlist"> <REFMETA>
<REFENTRYTITLE>_sys_errlist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_errlist</REFNAME>
<REFPURPOSE>
array containing the "C" locale strings used by strerror()
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern const char *const _sys_errlist[];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
An array containing the "C" locale strings used by strerror(). This normally should not be used directly. The strerror function provides all the needed functionality.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib--sys-siglist"> <REFMETA>
<REFENTRYTITLE>_sys_siglist</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_sys_siglist</REFNAME>
<REFPURPOSE>
array containing the names of the signal names
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;signal.h>

extern const char *const _sys_siglist[NSIG];
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
An array containing the names of the signal names.
</PARA><PARA>
This exists only for compatibility. Use strsignal instead (see &lt;string.h>).
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-textdomain"> <REFMETA>
<REFENTRYTITLE>textdomain</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>textdomain</REFNAME>
<REFPURPOSE>
set the current default message catalog to DOMAINNAME
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;libintl.h>

extern char *textdomain(const char *domainname);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Set the current default message catalog to DOMAINNAME.
</PARA><PARA>
If DOMAINNAME is null, return the current default.
</PARA><PARA>
If DOMAINNAME is "", reset to the default of "messages". 
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-vasprintf"> <REFMETA>
<REFENTRYTITLE>vasprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vasprintf</REFNAME>
<REFPURPOSE>
write formatted output to a string dynamically allocated with malloc and store the address of the string in *PTR
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern int vasprintf(char **restrict ptr, const char *restrict f,
                     G_va_list arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Write formatted output to a string dynamically allocated with malloc.
</PARA><PARA>
Store the address of the string in *PTR.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-vdprintf"> <REFMETA>
<REFENTRYTITLE>vdprintf</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>vdprintf</REFNAME>
<REFPURPOSE>
write formatted output to a file descriptor
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;stdio.h>

extern int vdprintf(int fd, const char *restrict fmt,
                    G_va_list arg);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Write formatted output to a file descriptor.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-verrx-3"> <REFMETA>
<REFENTRYTITLE>verrx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>verrx
</REFNAME>
<REFPURPOSE>display formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void verrx(int eval, const char *fmt, valist args);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The verrx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA><PARA>
The verrx() function does not return, but exits with the value of the argument eval.
</PARA>
</REFSECT1>
<!--      4th Berkeley Distribution        June 9, 1993           -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-wait4-2"> <REFMETA>
<REFENTRYTITLE>wait4</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wait4
</REFNAME>
<REFPURPOSE>
wait for process termination, BSD style
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _USE_BSD
#include &lt;sys/types.h>
#include &lt;sys/resource.h>
#include &lt;sys/wait.h>

pid_t wait4(pid_t pid, int *status, int options,
            struct rusage *rusage);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wait4 function suspends execution of the current process until a child as specified by the pid argument has exited, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function. If a child as requested by pid has already exited by the time of the call (a so-called "zombie" process), the function returns immediately. Any system resources used by the child are freed.
</PARA><PARA>
The value of pid can be one of:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
&lt; -1   
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to the absolute value of pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
-1     
</TERM>
<LISTITEM>
<PARA>
wait for any child process; this is equivalent to calling wait3.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
0      
</TERM>
<LISTITEM>
<PARA>
wait for any child process whose process group ID is equal to that of the calling process.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
&gt; 0    
</TERM>
<LISTITEM>
<PARA>
wait for the child whose process ID is equal to the value of pid.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
The value of options is a bitwise OR of zero or more of the following constants:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WNOHANG
</TERM>
<LISTITEM>
<PARA>
return immediately if no child is there to be waited for.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WUNTRACED
</TERM>
<LISTITEM>
<PARA>
return for children which are stopped, and whose status has not been reported.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If status is not NULL, wait4 stores status information in the location pointed to by status.
</PARA><PARA>
This status can be evaluated with the following macros (these macros take the stat buffer (an int) as an argument -- not a pointer to the buffer!):
</PARA>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
WIFEXITED(status)
</TERM>
<LISTITEM>
<PARA>
is non-zero if the child exited normally.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WEXITSTATUS(status)
</TERM>
<LISTITEM>
<PARA>
evaluates to the least significant eight bits of the return code of the child which terminated, which may have been set as the argument to a call to exit() or as the argument for a return statement in the main program. This macro can only be evaluated if WIFEXITED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSIGNALED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process exited because of a signal which was not caught.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WTERMSIG(status)
</TERM>
<LISTITEM>
<PARA>
returns the number of the signal that caused the child process to terminate. This macro can only be evaluated if WIFSIGNALED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WIFSTOPPED(status)
</TERM>
<LISTITEM>
<PARA>
returns true if the child process which caused the return is currently stopped; this is only possible if the call was done using WUNTRACED.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
WSTOPSIG(status)
</TERM>

<LISTITEM>
<PARA>
returns the number of the signal which caused the child to stop. This macro can only be evaluated if WIFSTOPPED returned non-zero.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
<PARA>
If rusage is not NULL, the struct rusage as defined in &lt;sys/resource.h> it points to will be filled with accounting information. See getrusage(2) for details.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The process ID of the child which exited, -1 on error (in particular, when no unwaited-for child processes of the specified kind exist) or zero if WNOHANG was used and no child was available  yet. In the latter two cases errno will be set appropriately.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Errors
</TITLE>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
ECHILD 
</TERM>
<LISTITEM>
<PARA>
No unwaited-for child process as specified does exist.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
ERESTARTSYS
</TERM>
<LISTITEM>
<PARA>
If WNOHANG was not set and an unblocked signal or a SIGCHLD was caught. This error is returned by the system call. The library interface is not allowed to return ERESTARTSYS, but will return EINTR.
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-warn-3"> <REFMETA>
<REFENTRYTITLE>warn</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warn
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void warn(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The warn() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The error message string affiliated with the current value of the global variable errno is output. The output is followed by a newline character.
</PARA>
</REFSECT1>

<!-- 4th Berkeley Distribution        June 9, 1993  -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-warnx-3"> <REFMETA>
<REFENTRYTITLE>warnx</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>warnx
</REFNAME>
<REFPURPOSE>
formatted error messages
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;err.h>

void warnx(const char *fmt, ...);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The warnx() function displays a formatted error message on the standard error output. The last component of the program name, a colon character, and a space are output. If the fmt argument is not NULL, the formatted error message, a colon character, and a space are output. The output is followed by a newline character.
</PARA>
</REFSECT1>
<!--        4th Berkeley Distribution        June 9, 1993    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

<REFENTRY ID="baselib-wcpcpy-3"> <REFMETA>
<REFENTRYTITLE>wcpcpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpcpy
</REFNAME>
<REFPURPOSE>
copy a wide character string, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcpcpy(wchar_t *dest, const wchar_t *src);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcpcpy function is the wide-character equivalent of the stpcpy function. It copies the wide character string pointed to by src, including the terminating L'\0' character, to the array pointed to by dest.
</PARA><PARA>
The strings may not overlap.
</PARA><PARA>
The programmer must ensure that there is room for at least wcslen(src)+1 wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
wcpcpy returns a pointer to the end of the wide-character string dest, that is, a pointer to the terminating L'\0' character.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcpncpy-3"> <REFMETA>
<REFENTRYTITLE>wcpncpy</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcpncpy
</REFNAME>
<REFPURPOSE>
copy a fixed-size string of wide characters, returning a pointer to its end
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcpncpy(wchar_t *dest, const wchar_t *src, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcpncpy function is the wide-character equivalent of the stpncpy function. It copies at most n wide characters from the wide-character string pointed to by src, including the terminating L'\0' character, to the array pointed to by dest. Exactly n wide characters are written at dest. If the length wcslen(src) is smaller than n, the remaining wide characters in the array pointed to by dest are filled with L'\0' characters. If the length wcslen(src) is greater or equal to n, the string pointed to by dest will not be L'\0' terminated.
</PARA><PARA>
The strings may not overlap.
</PARA><PARA>
The programmer must ensure that there is room for at least n wide characters at dest.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
wcpncpy returns a pointer to the last wide character written, i.e. dest + n - 1.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcscasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcscasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcscasecmp
</REFNAME>
<REFPURPOSE>
compare two wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

int wcscasecmp(const wchar_t *s1, const wchar_t *s2);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcscasecmp function is the wide-character equivalent of the strcasecmp function. It compares the wide-character string pointed to by s1 and the wide-character string pointed to by s2, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcscasecmp function returns zero if the wide-character strings at s1 and s2 are equal except for case distinctions. It returns a positive integer if s1 is greater than s2, ignoring case. It returns a negative integer if s1 is smaller than s2, ignoring case.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcscasecmp depends on the LC_CTYPE category of the current locale.
</PARA>
</REFSECT1>
<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsdup-3"> <REFMETA>
<REFENTRYTITLE>wcsdup</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsdup
</REFNAME>
<REFPURPOSE>
duplicate a wide-character string
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>13 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

wchar_t *wcsdup(const wchar_t *s);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>13 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsdup function is the wide-character equivalent of the strdup function. It allocates and returns a new wide-character string whose initial contents is a duplicate of the wide-character string pointed to by s.
</PARA><PARA>
Memory for the new wide-character string is obtained with malloc(3), and can be freed with free(3).
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsdup function returns a pointer to the new wide-character string, or NULL if sufficient memory was not available.
</PARA>
</REFSECT1>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->
</REFENTRY>

<REFENTRY ID="baselib-wcsncasecmp-3"> <REFMETA>
<REFENTRYTITLE>wcsncasecmp</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsncasecmp</REFNAME>
<REFPURPOSE>
compare two fixed-size wide-character strings, ignoring case
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

int wcsncasecmp(const wchar_t *s1, const wchar_t *s2, size_t n);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsncasecmp function is the wide-character equivalent of the strncasecmp function. It compares the wide-character string pointed to by s1 and the wide-character string pointed to by s2, but at most n wide characters from each string, ignoring case differences (towupper, towlower).
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsncasecmp function returns zero if the wide-character strings at s1 and s2, truncated to at most length n, are equal except for case distinctions. It returns a positive integer if truncated s1 is greater than truncated s2, ignoring case. It returns a negative integer if truncated s1 is smaller than truncated s2, ignoring case.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsncasecmp depends on the LC_CTYPE category of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcsnlen-3"> <REFMETA>
<REFENTRYTITLE>wcsnlen</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnlen</REFNAME>
<REFPURPOSE>
determine the length of a fixed-size wide-character string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnlen(const wchar_t *s, size_t maxlen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnlen function is the wide-character equivalent of the strnlen function. It returns the number of wide-characters in the string pointed to by s, not including the terminating  L'\0' character, but at most maxlen. In doing this, wcsnlen looks only at the first maxlen wide-characters at s and never beyond s+maxlen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsnlen function returns wcslen(s), if that is less than maxlen, or maxlen if there is no L'\0' character among the first maxlen wide characters pointed to by s.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsncasecmp depends on the LC_CTYPE category of the current locale.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcsnrtombs-3"> <REFMETA>
<REFENTRYTITLE>wcsnrtombs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnrtombs</REFNAME>
<REFPURPOSE>
convert a wide character string to a multi-byte string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnrtombs(char *dest, const wchar_t **src, size_t nwc,
                  size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnrtombs function is like the wcsrtombs function, except that the number of wide characters to be converted, starting at *src, is limited to nwc.
</PARA><PARA>
If dest is not a NULL pointer, the wcsnrtombs function converts at most nwc wide characters from the wide-character string *src to a multibyte string starting at dest. At most len bytes are written to dest. The  state *ps is updated. The conversion is effectively performed by repeatedly calling wcrtomb(dest,*src,ps), as long as this call succeeds, and then incrementing dest by the number of bytes written and *src by one. The conversion can stop for three reasons:
</PARA><PARA>
1. A wide character has been encountered that can not be represented as a multibyte sequence (according to the current locale). In this case *src is left pointing to the invalid wide character, (size_t)(-1) is returned, and errno is set to EILSEQ.
</PARA><PARA>
2. nwc wide characters have been converted without encountering a L'\0', or the length limit forces a stop. In this case *src is left pointing to the next wide character to be converted, and the number of bytes written to dest is returned.
</PARA><PARA>
3. The wide-character string has been completely converted, including the terminating L'\0' (which has the side effect of bringing back *ps to the initial state). In this case *src is set to NULL, and the number of bytes written to dest, excluding the terminating '\0' byte, is returned.
</PARA><PARA>
If dest is NULL, len is ignored, and the conversion proceeds as above, except that the converted bytes are not written out to memory, and that no destination length limit exists.
</PARA><PARA>
In both of the above cases, if ps is a NULL pointer, a static anonymous state only known to the wcsnrtombs function is used instead.
</PARA><PARA>
The programmer must ensure that there is room for at least len bytes at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Return Value
</TITLE>
<PARA>
The wcsnrtombs function returns the number of bytes that make up the converted part of multibyte sequence, not including the terminating null byte. If a wide character was encountered which could not be converted, (size_t)(-1) is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>Notes
</TITLE>
<PARA>
The behavior of wcsnrtombs depends on the LC_CTYPE category of the current locale.
</PARA><PARA>
Passing NULL as ps is not multi-thread safe.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstoq"> <REFMETA>
<REFENTRYTITLE>wcstoq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstoq</REFNAME>
<REFPURPOSE>
convert initial portion of wide string NPTR to long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

extern long long int wcstoq(const wchar_t *restrict nptr,
                            wchar_t **restrict endptr, int base);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Convert initial portion of wide string NPTR to long int representation.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib-wcstouq"> <REFMETA>
<REFENTRYTITLE>wcstouq</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA> 
<REFNAMEDIV>
<REFNAME>wcstouq</REFNAME>
<REFPURPOSE>
convert initial portion of wide string NPTR to unsigned long long int representation
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

extern unsigned long long int wcstouq(const wchar_t *restrict nptr,
                           wchar_t **restrict endptr,int base);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Convert initial portion of wide string NPTR to unsigned long long int representation.
</PARA>

</REFSECT1>
</REFENTRY>


<REFENTRY ID="baselib---xmknod-1"> <REFMETA>
<REFENTRYTITLE>__xmknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>__xmknod</REFNAME>
<REFPURPOSE>
make block or character special file
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>4 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int __xmknod(int ver,
            __const char *path,
            __mode_t mode,
            __dev_t *dev);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>16 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
ver must be 1 or the behavior is undefined.
</PARA>
<PARA>
__xmknod(1, path, mode, dev) has the same specification as mknod(path, mode, dev).
</PARA>
<PARA>
Note that the  of dev_t is not the same as the argument that the kernel syscall uses (TODO: need to document what dev_t is).
</PARA>
<PARA>
__xmknod is not in the source standard; it is only in the binary standard.
</PARA>
</REFSECT1>
</REFENTRY>

</SECT1>


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:13 2001 -->
<SECT1 ID=libm>
<TITLE></TITLE>
<PARA>
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
ISO/IEC 9899: 1999, Programming Languages --C<FOOTNOTE ID="std-13-25">
<PARA>
ISO/IEC 9899: 1999, Programming Languages --C</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-13-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Math</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libm - Math Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>acos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ceilf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remquof(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ceill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>exp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>remquol(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>expm1(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>rint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>acoshf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cexpf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabs(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>jnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>rintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acoshl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cexpl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabsf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexp(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>rintl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>acosl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cimag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fabsl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexpf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>round(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cimagf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdim(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ldexpl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>roundf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cimagl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdimf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgamma(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>roundl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>clog10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fdiml(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgamma_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>asinhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clog10f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feclearexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammaf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clog10l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammaf_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>asinl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>clogf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetexceptflag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbln(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>clogl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fegetround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lgammal_r(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalblnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>conj(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feholdexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrint(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalblnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>conjf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>feraiseexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrintf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbn(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atan2l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>conjl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llrintl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbnf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>copysign(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetexceptflag(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>scalbnl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanh(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>copysignf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fesetround(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llroundf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>significand(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>copysignl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fetestexcept(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>llroundl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>significandf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cos(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>feupdateenv(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>log(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>significandl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>atanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cosf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>finite(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>log10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sin(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cabs(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>cosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>finitef(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>log1p(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sincos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cabsf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>coshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>finitel(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>logb(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sincosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cabsl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>coshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floor(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>lrint(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sincosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floorf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lrintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpow(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>floorl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lrintl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cacosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpowf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lround(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacoshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cpowl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lroundf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacoshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cproj(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>lroundl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cacosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cprojf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmax(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>matherr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sqrt(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>carg(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>cprojl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaxf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>sqrtf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cargf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>creal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmaxl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modff(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>sqrtl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cargl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>creall(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>modfl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>casin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csin(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fminf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fminl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>casinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmod(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmodf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nearbyint(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>fmodl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nearbyintf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>casinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csinl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexp(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nearbyintl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tgamma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrt(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexpf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nextafter(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>tgammaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrtf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>frexpl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nextafterf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>tgammal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>csqrtl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gamma(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nextafterl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>trunc(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanhf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctan(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gammaf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nexttoward(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>truncf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanhl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>gammal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>nexttowardf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>truncl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>catanl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypot(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>nexttowardl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y0(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>cbrt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ctanhf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypotf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>y0f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cbrtf(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanhl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>hypotl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow10(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y0l(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>cbrtl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ctanl(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogb(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>pow10f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>ccos(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>dremf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogbf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>pow10l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1f(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>dreml(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ilogbl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>powf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>y1l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosh(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>j0(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>powl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>yn(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY></ROW>
<ROW><ENTRY>ccoshf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfc(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>j0f(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remainder(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>ynf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccoshl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfcf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j0l(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remainderf(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>ynl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY></ROW>
<ROW><ENTRY>ccosl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>erfcl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>remainderl(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>ceil(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY>erff(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>j1f(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>remquo(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libm - Math Data Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>clog<FOOTNOTEREF LINKEND="std-13-25"></ENTRY><ENTRY>signgam<FOOTNOTEREF LINKEND="std-13-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libm-ddefs>
<TITLE> Data Definitions for libm</TITLE>
<PARA>
</PARA>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:15 2001 -->
<SECT1 ID=libpthread>
<TITLE></TITLE>
<PARA>
</PARA>
<PARA>
LSB systems support POSIX threads with the following exceptions.
This list is intended to match the behavior of historical Linux
implementations.  Applications should be written to deal with either
POSIX threads or the thread behaviors described here.
</PARA>

<PARA>
POSIX specifies a concept of per-process rather than per-thread
signals.  The LSB does not require this behavior; traditional Linux
implementations have had per-thread signals only.  A related issue is
that applications cannot (using legacy Linux implementations, at
least) rely on getpid() returning the same value in different threads.
</PARA>

<PARA>
Note: one implication of per-thread signals is that a core dump (for
example) may not stop all threads in a given process.  This may be an
issue when designing ways to stop/start applications.
</PARA>

<PARA>
Applications which create child processes (using fork() and the like)
must then wait for them (using waitpid() family of functions) in the
same thread as they created them.  Note that coding applications this
way will work both with full POSIX threads and legacy Linux thread
implementations.
</PARA>

<PARA>
POSIX specifies that changing the user or group id instantly affects
the behavior of all threads.  This behavior is not specified;
applications must use their own lock if they need this behavior.
Rationale: it seems unnecessary and it is a performance hit (an SMP
kernel must lock the user id).  (FIXME: is this our current
understanding?  It was discussed on lsb-spec on January 2000 but I'm
not sure we reached a consensus).
</PARA>

<PARA>
Although this standard doesn't have a way to list processes (/proc or
"ps" command line isn't in, right?), it is our intention to not
specify one way or the other whether multiple threads appear as
separate processes or as a single process.
</PARA>

<PARA>
Applications cannot rely on resource limits (getrusage and setrusage)
being maintained per-process rather than per-thread.
</PARA>

<PARA>
Applications must disconnect from the controlling tty before
pthread_create (FIXME: have I summarized this correctly?).
</PARA>

<PARA>
times() doesn't account for all threads, just the caller.
</PARA>

<PARA>
Applications must not call pthread_cancel if they call any system
libraries (most notably X windows), as system libraries are not
guaranteed to be thread safe.  Likewise, for such libraries, only one
thread per process may call them.
</PARA>

<PARA>
Applications cannot rely on fcntl/lockf locks being visible
per-process rather than per-thread.  Likewise for mandatory file
locks.
</PARA>

<PARA>
Threaded applications cannot use SIGUSR1 or SIGUSR2.
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-132-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-132-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread - Posix Threads Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>pthread_attr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_once(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstackaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setspecific(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getspecific(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_sigmask(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_join(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_rdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_testcancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_broadcast(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_create(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_tryrdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_close(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_delete(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_trywrlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_kill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_unlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_getvalue(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstackaddr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_signal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_wrlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_timedwait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_open(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_wait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_lock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_getpshared(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_post(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_trylock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_timedwait<FOOTNOTEREF LINKEND="std-132-10"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_unlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_setpshared(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_trywait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_create<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_self(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_unlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_detach(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_gettype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcancelstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_wait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_equal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_settype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcanceltype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE> Data Definitions for libpthread</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct
{
  struct __sem_lock;
  long status;
  int __sem_value;
  int spinlock;
  Unknown Type:".." __sem_waiting;
}
sem_t;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:17 2001 -->
<SECT1 ID=libdl>
<TITLE></TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libdl Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libdl</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libdl.so.2</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-27-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-27-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Dynamic Loader</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libdl - Dynamic Loader Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>dladdr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-10"></ENTRY><ENTRY>dlclose(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlerror(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlopen(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY><ENTRY>dlsym(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-27-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libdl-ddefs>
<TITLE> Data Definitions for libdl</TITLE>
<PARA>
</PARA>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->

<SECT1 ID=libdlman>
<TITLE>Interface Definitions for libdl</TITLE>
<PARA>
</PARA>
<REFENTRY ID="baselib-dladdr-3"> <REFMETA>
<REFENTRYTITLE>dladdr</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>dladdr
</REFNAME>
<REFPURPOSE>
library routine for dynamic linking of object files
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>24 April  2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
cc ... -ldl ...

#include &lt;dlfcn.h>

typedef struct {
             const char      *dli_fname;
             void            *dli_fbase;
             const char      *dli_sname;
             void            *dli_saddr;
} Dl_info;

int dladdr(void *address, Dlinfo *dlip);
</SYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>24 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
This function implements the System V dynamic linking routines.
</PARA><PARA>
The dladdr() function is the inverse of the dlsym() function. If the given address is successfully located inside a module, dladdr() returns nonzero, otherwise 0. On a successful return, the fields of dlip are filled in as follows:
</PARA>

<VARIABLELIST>
<VARLISTENTRY>
<TERM>
dlifname
</TERM>
<LISTITEM>
<PARA>
the pathname of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dlifbase   
</TERM>
<LISTITEM>
<PARA>
the base address of the module
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dlisname   
</TERM>
<LISTITEM>
<PARA>
the name of the highest addressed symbol whose address precedes the given address 
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>
dlifaddr   
</TERM>
<LISTITEM>
<PARA>
the address of that symbol
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>

<PARA>
Shared objects must be linked using the -shared option to the linker ld(1). The linker flag -rpath may be used to add a directory to the default search path for shared objects and shared libraries. The linker flag -E or the C compiler flag -rdynamic should be used to cause the application to export its symbols to the shared objects.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>
Environment
</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM>
LD_LIBRARY_PATH
</TERM>
<LISTITEM>
<PARA>
directory search-path for object files
</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</REFSECT1>
<!--      BSDI BSD/OS                    February 9, 1998    -->
<!-- This data is part of a licensed program from BERKELEY SOFTWARE DESIGN, INC. -->
<!-- Portions are copyrighted by BSDI, The Regents of the University of California, -->
<!-- Massachusetts Institute of Technology, Free Software Foundation, and others.  -->
</REFENTRY>

</SECT1>


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:19 2001 -->
<SECT1 ID=libcrypt>
<TITLE></TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libcrypt Definition</TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libcrypt</ENTRY>
</ROW>
<ROW>
<ENTRY>SONAME:</ENTRY>
<ENTRY>libcrypt.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-29-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Encryption</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libcrypt - Encryption Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>crypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY>encrypt(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY>setkey(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-29-5"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libcrypt-ddefs>
<TITLE> Data Definitions for libcrypt</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>stdlib.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef struct
{
  long quot;
  long rem;
}
lldiv_t;

typedef struct
{
  int quot;
  int rem;
}
div_t;

typedef struct
{
  long quot;
  long rem;
}
ldiv_t;

typedef int (*__compar_fn_t) ();
</SCREEN>
</SECT2>
<SECT2>
<TITLE>unistd.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef __ssize_t ssize_t;

typedef __pid_t pid_t;

typedef __off_t off_t;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->
<!--    at Thu Jun  7 07:33:18 2001 -->
<SECT1 ID=librt>
<TITLE></TITLE>
<PARA>
</PARA>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Large File Support<FOOTNOTE ID="std-223-35">
<PARA>
Large File Support</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-223-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Asynchronous I/O</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>librt - Asynchronous I/O Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>aio_cancel(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_fsync64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_suspend(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>clock_getres<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>lio_listio64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY></ROW>
<ROW><ENTRY>aio_cancel64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_read(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_suspend64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_gettime(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>shm_open<FOOTNOTEREF LINKEND="std-223-5"></ENTRY></ROW>
<ROW><ENTRY>aio_error(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_read64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_write(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>clock_nanosleep<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>shm_unlink<FOOTNOTEREF LINKEND="std-223-5"></ENTRY></ROW>
<ROW><ENTRY>aio_error64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>aio_return(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_write64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_settime<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>aio_fsync(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>aio_return64(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-35"></ENTRY><ENTRY>clock_getcpuclockid<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY>lio_listio(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-223-5"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=librt-ddefs>
<TITLE> Data Definitions for librt</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>aio.h</TITLE>
<PARA>
</PARA>
<SCREEN>
struct aiocb
{
  int aio_fildes;
  int aio_lio_opcode;
  int aio_reqprio;
  void *aio_buf;
  size_t aio_nbytes;
  struct sigevent aio_sigevent;
  struct aiocb *__next_prio;
  int __abs_prio;
  int __policy;
  int __error_code;
  __ssize_t __return_value;
  __off_t aio_offset;
  char __pad[1];
  char __unused[1];
}
 ;

struct aiocb64
{
  int aio_fildes;
  int aio_lio_opcode;
  int aio_reqprio;
  void *aio_buf;
  size_t aio_nbytes;
  struct sigevent aio_sigevent;
  struct aiocb *__next_prio;
  int __abs_prio;
  int __policy;
  int __error_code;
  __ssize_t __return_value;
  __off64_t aio_offset;
  char __unused[1];
}
 ;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.26 2001/05/29 15:02:48 anderson Exp 0 -->


</CHAPTER>

</PART>
