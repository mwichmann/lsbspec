<REFENTRY ID="baselib-memmem-3"> <REFMETA>
<REFENTRYTITLE>memmem</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>memmem</REFNAME>
<REFPURPOSE>
locate a substring
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#define _GNU_SOURCE
#include &lt;string.h>

void *memmem(const void *haystack, size_t haystacklen,
       const void *needle, size_t needlelen);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The  memmem() function finds the start of the first occurrence 
of the substring needle of length needlelen  in  the
memory area haystack of length haystacklen.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  memmem()  function returns a pointer to the beginning
of the substring, or NULL if the substring is not found.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
This function was broken in  Linux  libraries  up  to  and
including  libc  5.0.9;  there the `needle' and `haystack'
arguments were interchanged, and a pointer to the  end  of
the  first  occurrence of needle was returned.  Since libc
5.0.9 is still widely used, this is a  dangerous  function
to use.
Both  old  and  new  libc's have the bug that if needle is
empty haystack-1 (instead of haystack) is  returned.   And
glibc  2.0  makes  it  worse, and returns a pointer to the
last byte of `haystack'. This is fixed in glibc 2.1.
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>








