<REFENTRY ID="baselib-wcsnrtombs-3"> <REFMETA>
<REFENTRYTITLE>wcsnrtombs</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>wcsnrtombs</REFNAME>
<REFPURPOSE>
convert a wide character string to a multi-byte string
</REFPURPOSE>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>2 April 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
#include &lt;wchar.h>

size_t wcsnrtombs (char *dest, const wchar_t **src, size_t nwc,
                   size_t len, mbstate_t *ps);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>2 April 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The wcsnrtombs function is like  the  wcsrtombs  function,
except that the number of wide characters to be converted,
starting at *src, is limited to nwc.

</PARA><PARA>
If dest is not a NULL  pointer,  the  wcsnrtombs  function
converts at most nwc wide characters from the wide-character string *src 
to a multibyte string starting at dest. At
most len bytes are written to dest. The shift state *ps is
updated.  The  conversion  is  effectively  performed   by
repeatedly  calling wcrtomb(dest,*src,ps), as long as this
call succeeds, and then incrementing dest by the number of
bytes written and *src by one. The conversion can stop for
three reasons:

</PARA><PARA>
1. A wide character has been encountered that can  not  be
represented as a multibyte sequence (according to the current locale). 
In this case *src is left  pointing  to  the
invalid  wide  character,  (size_t)(-1)  is  returned, and
errno is set to EILSEQ.

</PARA><PARA>
2. nwc wide characters have been converted without encountering a L'\0', 
or the length limit forces a stop. In this
case *src is left pointing to the next wide  character  to
be  converted,  and the number of bytes written to dest is
returned.

</PARA><PARA>
3. The wide-character  string  has  been  completely  converted,  
including  the  terminating  L'\0' (which has the
side effect of bringing back *ps to the initial state). In
this  case  *src  is  set to NULL, and the number of bytes
written to dest, excluding the terminating '\0'  byte,  is
returned.

</PARA><PARA>
If  dest  is NULL, len is ignored, and the conversion proceeds 
as above, except that the converted  bytes  are  not
written  out  to  memory,  and  that no destination length
limit exists.

</PARA><PARA>
In both of the above cases, if ps is  a  NULL  pointer,  a
static  anonymous state only known to the wcsnrtombs function 
is used instead.

</PARA><PARA>
The programmer must ensure that there is room for at least
len bytes at dest.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>RETURN VALUE
</TITLE>
<PARA>
The  wcsnrtombs  function returns the number of bytes that
make up the converted  part  of  multibyte  sequence,  not
including  the terminating null byte.  If a wide character
was encountered which could not be converted, (size_t)(-1)
is returned, and errno set to EILSEQ.
</PARA>
</REFSECT1>
<REFSECT1>
<TITLE>NOTES
</TITLE>
<PARA>
The  behaviour of wcsnrtombs depends on the LC_CTYPE category 
of the current locale.

Passing NULL as ps is not multi-thread safe
</PARA>

<!--	  LDP GENERAL PUBLIC LICENSE  -->
<!--        Version 1a, November 1998   -->

</REFSECT1>
</REFENTRY>








