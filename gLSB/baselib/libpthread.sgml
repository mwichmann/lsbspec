<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.31 2001/11/26 18:26:53 anderson Exp 0 -->
<!--    at Mon Dec 10 21:09:03 2001 -->
<SECT1 ID=libpthread>
<TITLE>Interfaces for libpthread</TITLE>
<PARA>
</PARA>
<PARA>
LSB systems support POSIX threads with the following exceptions.
This list is intended to match the behavior of historical Linux
implementations.  Applications should be written to deal with either
POSIX threads or the thread behaviors described here.

<ITEMIZEDLIST MARK=BULLET>

<LISTITEM>
<PARA>
POSIX specifies a concept of per-process rather than per-thread
signals.  The LSB does not require this behavior; traditional Linux
implementations have had per-thread signals only.  A related issue is
that applications cannot rely on getpid() returning the same value
in different threads.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Note: one implication of per-thread signals is that a core dump (for
example) may not stop all threads in a given process.  This may be an
issue when designing ways to stop/start applications.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications which create child processes (using fork() and the like)
must then wait for them (using waitpid() family of functions) in the
same thread as they created them.  Note that coding applications this
way will work both with full POSIX threads and legacy Linux thread
implementations.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
POSIX specifies that changing the user or group id instantly affects
the behavior of all threads.  This behavior is not specified;
applications must use their own lock if they need this behavior.
Rationale: it seems unnecessary and it is a performance hit (an SMP
kernel must lock the user id).
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Although this standard doesn't have a way to list processes (/proc or
"ps" command line isn't in, right?), it is our intention to not
specify one way or the other whether multiple threads appear as
separate processes or as a single process.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on resource limits (getrusage and setrusage)
being maintained per-process rather than per-thread.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must disconnect from the controlling tty before
calling pthread_create.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
times() doesn't account for all threads, just the caller.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications must not call pthread_cancel if they call any system
libraries (most notably X windows), as system libraries are not
guaranteed to be thread safe.  Likewise, for such libraries, only one
thread per process may call them.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Applications cannot rely on fcntl/lockf locks being visible
per-process rather than per-thread.  Likewise for mandatory file
locks.
</PARA>
</LISTITEM>

<LISTITEM>
<PARA>
Threaded applications cannot use SIGUSR1 or SIGUSR2.
</PARA>
</LISTITEM>

</ITEMIZEDLIST>
</PARA>

<PARA>
The behavior of the interfaces in this library is specified by the following standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-132-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
<MEMBER>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)<FOOTNOTE ID="std-132-5">
<PARA>
CAE Specification, January 1997, System Interfaces and Headers (XSH),
Issue 5 (ISBN: 1-85912-181-0, C606)</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Posix Threads</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE>libpthread - Posix Threads Function Interfaces</TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>pthread_attr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_exit(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_settype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcanceltype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstackaddr(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_once(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_attr_setstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_getspecific(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setspecific(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_join(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_sigmask(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_broadcast(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_create(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_rdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_testcancel(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_key_delete(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_tryrdlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_close(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getscope(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_kill(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_trywrlock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstackaddr(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_signal(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_unlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_getvalue(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_getstacksize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_timedwait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlock_wrlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_cond_wait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_lock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_destroy(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_open(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setdetachstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_trylock(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_getpshared(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_post(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setguardsize(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_condattr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutex_unlock(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_init(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_timedwait(GLIBC_2.1)<FOOTNOTEREF LINKEND="std-132-10"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setinheritsched(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_create(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_destroy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_rwlockattr_setpshared(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_trywait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedparam(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_detach(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_gettype(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_self(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_unlink(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
<ROW><ENTRY>pthread_attr_setschedpolicy(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_equal(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_mutexattr_init(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>pthread_setcancelstate(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY><ENTRY>sem_wait(GLIBC_2.0)<FOOTNOTEREF LINKEND="std-132-5"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libpthread-ddefs>
<TITLE>Data Definitions for libpthread</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>pthread.h</TITLE>
<PARA>
</PARA>
<SCREEN>

typedef unsigned int pthread_key_t;

typedef int pthread_once_t;

struct _pthread_fastlock
{
  int __spinlock;
}
 ;


typedef unsigned long pthread_t;


typedef struct _pthread_descr_struct *_pthread_descr;

struct _pthread_descr_struct;


typedef struct
{
  struct _pthread_fastlock lock;
  _pthread_descr owner;
  int kind;
  unsigned int count;
}
pthread_mutex_t;

typedef struct
{
  int __mutexkind;
}
pthread_mutexattr_t;


typedef struct
{
  int __detachstate;
  int __schedpolicy;
  struct sched_param __schedparam;
  int __inheritsched;
  int __scope;
  void *__stackaddr;
  unsigned long __stacksize;
}
pthread_attr_t;


typedef struct
{
  struct _pthread_fastlock lock;
  _pthread_descr wait_chain;
}
pthread_cond_t;

typedef void *pthread_condattr_t;



#define PTHREAD_ONCE_INIT	0
#define PTHREAD_CREATE_DETACHED	PTHREAD_CREATE_DETACHED
#define PTHREAD_CREATE_JOINABLE	PTHREAD_CREATE_JOINABLE
#define PTHREAD_EXPLICIT_SCHED	PTHREAD_EXPLICIT_SCHED
#define PTHREAD_INHERIT_SCHED	PTHREAD_INHERIT_SCHED
#define PTHREAD_PROCESS_PRIVATE	PTHREAD_PROCESS_PRIVATE
#define PTHREAD_PROCESS_SHARED	PTHREAD_PROCESS_SHARED
#define PTHREAD_SCOPE_PROCESS	PTHREAD_SCOPE_PROCESS
#define PTHREAD_SCOPE_SYSTEM	PTHREAD_SCOPE_SYSTEM

#define PTHREAD_CANCELED	((void*)-1)
#define PTHREAD_CANCEL_ASYNCHRONOUS	PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_DEFERRED	PTHREAD_CANCEL_DEFERRED
#define PTHREAD_CANCEL_DISABLE	PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCEL_ENABLE	PTHREAD_CANCEL_ENABLE
</SCREEN>
</SECT2>
<SECT2>
<TITLE>semaphore.h</TITLE>
<PARA>
</PARA>
<SCREEN>


typedef struct
{
  long status;
  int spinlock;
}
sem_t;


#define SEM_FAILED	((sem_t*)0)

#define SEM_VALUE_MAX	((int)((~0u)>>1))
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /cvsroot/lsb/spec/mklibspec,v 1.31 2001/11/26 18:26:53 anderson Exp 0 -->
