<PART ID="tocutillib">
<TITLE>Utility Libraries</TITLE>

<CHAPTER id=utillib>
<TITLE>Libraries</TITLE>

<PARA>
An LSB-conforming implementation may also support some utility libraries which
are built on top of the interfaces provided by the base libraries. These
libraries implement common functionality, and hide additional system dependent
information such as file formats and device names.
</PARA>

<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->
<!--    at Tue Apr 24 21:16:37 2001 -->
<SECT1 ID=libz>
<TITLE>libz</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libz</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libz.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
zlib 1.1.3 Manual<FOOTNOTE ID="std-127-24">
<PARA>
zlib 1.1.3 Manual</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Compression Library</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>adler32<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateInit_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzerror<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzread<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateInit2_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>compress<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateParams<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzflush<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzrewind<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateInit_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>compress2<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateReset<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzgetc<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzseek<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateReset<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>crc32<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>deflateSetDictionary<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzgets<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzsetparams<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSetDictionary<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflate<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>get_crc_table<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzopen<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gztell<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSync<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateCopy<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzclose<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzprintf<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzwrite<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateSyncPoint<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateEnd<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzdopen<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzputc<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflate<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>uncompress<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
<ROW><ENTRY>deflateInit2_<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzeof<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>gzputs<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>inflateEnd<FOOTNOTEREF LINKEND="std-127-24"></ENTRY><ENTRY>zError<FOOTNOTEREF LINKEND="std-127-24"></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->
<!--    at Tue Apr 24 21:16:59 2001 -->
<SECT1 ID=libncurses>
<TITLE>libncurses</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libncurses</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libncurses.so.5</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
 CAE Specification, May 1996, X/Open Curses, Issue 4, Version 2 (ISBN:
1-85912-171-3, C610), plus Corrigendum U018<FOOTNOTE ID="std-128-28">
<PARA>
 CAE Specification, May 1996, X/Open Curses, Issue 4, Version 2 (ISBN:
1-85912-171-3, C610), plus Corrigendum U018</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Curses</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>addch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>has_ic<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_dump<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>has_il<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_init<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>hline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_restore<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>idcok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_get<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>addstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>idlok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwaddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scrl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_off<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_get<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>immedok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scroll<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_on<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_off<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scrollok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_on<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>set_term<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>inchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>setscrreg<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>init_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attr_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wattrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>init_pair<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwhline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attroff<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wbkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>attrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>initscr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attron<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wbkgdset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>baudrate<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>innstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_attrset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wborder<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>beep<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_clear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>bkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insdelln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>bkgdset<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insertln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_init<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclrtobot<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>border<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_label<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wclrtoeol<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>box<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>insstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_noutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wcolor_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>can_change_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>instr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_refresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wcursyncup<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>cbreak<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>intrflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwinstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_restore<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>chgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>is_linetouched<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wdeleteln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clear<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>is_wintouched<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>slk_touch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wechochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clearok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>isendwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvwvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>standend<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>werase<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clrtobot<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>keyname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>napms<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>standout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>clrtoeol<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>keypad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newpad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>start_color<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>color_content<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>killchar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newterm<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>subpad<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>color_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>leaveok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>subwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>whline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>copywin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>longname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>syncok<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>curs_set<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>meta<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nocbreak<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>termattrs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>def_prog_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>move<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nodelay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>termname<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>def_shell_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noecho<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetent<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delay_output<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>nonl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetflag<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noqiflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetnum<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsdelln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>deleteln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>noraw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsertln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delscreen<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvaddstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>notimeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tgoto<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>delwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvchgat<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>overlay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetflag<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>derwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvcur<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>overwrite<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetnum<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>winstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>doupdate<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvdelch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pair_content<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tigetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wmove<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>dupwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvderwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pechochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>timeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wnoutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>echo<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>pnoutrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tparm<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>echochar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>prefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>tputs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wredrawln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>endwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvgetstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>printw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>typeahead<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wrefresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>erase<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvhline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>putp<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>ungetch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>erasechar<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>putwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>untouchwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wscrl<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>filter<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>qiflush<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>use_env<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsetscrreg<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>flash<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinchstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>raw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vidattr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wstandend<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>flushinp<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>redrawwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vidputs<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wstandout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getbkgd<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>refresh<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsyncdown<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>reset_prog_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vw_printw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wsyncup<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinsstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>reset_shell_mode<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vw_scanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wtimeout<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvinstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>resetty<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vwprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wtouchln<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>getwin<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvprintw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>ripoffline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>vwscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>wvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY></ROW>
<ROW><ENTRY>halfdelay<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvscanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>savetty<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddch<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>has_colors<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>mvvline<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>scanw<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>waddchnstr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
<SECT2>
<TITLE>Data Symbols</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>curscr<FOOTNOTEREF LINKEND="std-128-28"></ENTRY><ENTRY>newscr</ENTRY><ENTRY>stdscr</ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<SECT1 ID=libncurses-ddefs>
<TITLE> Data Definitions for libncurses</TITLE>
<PARA>
</PARA>
<SECT2>
<TITLE>curses.h</TITLE>
<PARA>
</PARA>
<SCREEN>
typedef unsigned long chtype;

typedef char bool;

typedef typedef unsigned long chtype;

attr_t;


int addch(chtype);
int addchnstr(chtype *, int);
int addchstr(chtype *);
int addnstr(char *, int);
int addstr(char *);
int attroff(int);
int attron(int);
int attrset(int);
int attr_get(attr_t *, short *, void *);
int attr_off(attr_t, void *);
int attr_on(attr_t, void *);
int attr_set(attr_t, short, void *);
int baudrate(void);
int beep(void);
int bkgd(chtype);
void bkgdset(chtype);
int border(chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);
int box(WINDOW *, chtype, chtype);
bool can_change_color(void);
int cbreak(void);
int chgat(int, attr_t, short, void *);
int clear(void);
int clearok(WINDOW *, bool);
int clrtobot(void);
int clrtoeol(void);
int color_content(short, short *, short *, short *);
int color_set(short, void *);
int copywin(WINDOW *, WINDOW *, int, int, int, int, int, int, int);
int curs_set(int);
int def_prog_mode(void);
int def_shell_mode(void);
int delay_output(int);
int delch(void);
void delscreen(SCREEN *);
int delwin(WINDOW *);
int deleteln(void);
WINDOW *derwin(WINDOW *, int, int, int, int);
int doupdate(void);
WINDOW *dupwin(WINDOW *);
int echo(void);
int echochar(chtype);
int erase(void);
int endwin(void);
char erasechar(void);
void filter(void);
int flash(void);
int flushinp(void);
chtype getbkgd(WINDOW *);
int getch(void);
int getnstr(char *, int);
int getstr(char *);
WINDOW *getwin(FILE *);
int halfdelay(int);
bool has_colors(void);
bool has_ic(void);
bool has_il(void);
int hline(chtype, int);
void idcok(WINDOW *, bool);
int idlok(WINDOW *, bool);
void immedok(WINDOW *, bool);
chtype inch(void);
int inchnstr(chtype *, int);
int inchstr(chtype *);
WINDOW *initscr(void);
int init_color(short, short, short, short);
int init_pair(short, short, short);
int innstr(char *, int);
int insch(chtype);
int insdelln(int);
int insertln(void);
int insnstr(char *, int);
int insstr(char *);
int instr(char *);
int intrflush(WINDOW *, bool);
bool isendwin(void);
bool is_linetouched(WINDOW *, int);
bool is_wintouched(WINDOW *);
char *keyname(int);
int keypad(WINDOW *, bool);
char killchar(void);
int leaveok(WINDOW *, bool);
char *longname(void);
int meta(WINDOW *, bool);
int move(int, int);
int mvaddch(int, int, chtype);
int mvaddchnstr(int, int, chtype *, int);
int mvaddchstr(int, int, chtype *);
int mvaddnstr(int, int, char *, int);
int mvaddstr(int, int, char *);
int mvchgat(int, int, int, attr_t, short, void *);
int mvcur(int, int, int, int);
int mvdelch(int, int);
int mvderwin(WINDOW *, int, int);
int mvgetch(int, int);
int mvgetnstr(int, int, char *, int);
int mvgetstr(int, int, char *);
int mvhline(int, int, chtype, int);
chtype mvinch(int, int);
int mvinchnstr(int, int, chtype *, int);
int mvinchstr(int, int, chtype *);
int mvinnstr(int, int, char *, int);
int mvinsch(int, int, chtype);
int mvinsnstr(int, int, char *, int);
int mvinsstr(int, int, char *);
int mvinstr(int, int, char *);
int mvprintw(int, int, char *, ...);
int mvscanw(int, int, char *, ...);
int mvvline(int, int, chtype, int);
int mvwaddch(WINDOW *, int, int, chtype);
int mvwaddchnstr(WINDOW *, int, int, chtype *, int);
int mvwaddchstr(WINDOW *, int, int, chtype *);
int mvwaddnstr(WINDOW *, int, int, char *, int);
int mvwaddstr(WINDOW *, int, int, char *);
int mvwchgat(WINDOW *, int, int, int, attr_t, short, void *);
int mvwdelch(WINDOW *, int, int);
int mvwgetch(WINDOW *, int, int);
int mvwgetnstr(WINDOW *, int, int, char *, int);
int mvwgetstr(WINDOW *, int, int, char *);
int mvwhline(WINDOW *, int, int, chtype, int);
int mvwin(WINDOW *, int, int);
chtype mvwinch(WINDOW *, int, int);
int mvwinchnstr(WINDOW *, int, int, chtype *, int);
int mvwinchstr(WINDOW *, int, int, chtype *);
int mvwinnstr(WINDOW *, int, int, char *, int);
int mvwinsch(WINDOW *, int, int, chtype);
int mvwinsnstr(WINDOW *, int, int, char *, int);
int mvwinsstr(WINDOW *, int, int, char *);
int mvwinstr(WINDOW *, int, int, char *);
int mvwprintw(WINDOW *, int, int, char *, ...);
int mvwscanw(WINDOW *, int, int, char *, ...);
int mvwvline(WINDOW *, int, int, chtype, int);
int napms(int);
WINDOW *newpad(int, int);
SCREEN *newterm(char *, FILE *, FILE *);
WINDOW *newwin(int, int, int, int);
int nl(void);
int nocbreak(void);
int nodelay(WINDOW *, bool);
int noecho(void);
int nonl(void);
void noqiflush(void);
int noraw(void);
int notimeout(WINDOW *, bool);
int overlay(WINDOW *, WINDOW *);
int overwrite(WINDOW *, WINDOW *);
int pair_content(short, short *, short *);
int pechochar(WINDOW *, chtype);
int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
int prefresh(WINDOW *, int, int, int, int, int, int);
int printw(char *, ...);
int putp(char *);
int putwin(WINDOW *, FILE *);
void qiflush(void);
int raw(void);
int redrawwin(WINDOW *);
int refresh(void);
int resetty(void);
int reset_prog_mode(void);
int reset_shell_mode(void);
int ripoffline(int, int);
int savetty(void);
int scanw(char *, ...);
int scr_dump(char *);
int scr_init(char *);
int scrl(int);
int scroll(WINDOW *);
int scrollok(WINDOW *, bool);
int scr_restore(char *);
int scr_set(char *);
int setscrreg(int, int);
SCREEN *set_term(SCREEN *);
int slk_attroff(chtype);
int slk_attron(chtype);
int slk_attrset(chtype);
int slk_attr_set(attr_t, short, void *);
int slk_clear(void);
int slk_color(short);
int slk_init(int);
char *slk_label(int);
int slk_noutrefresh(void);
int slk_refresh(void);
int slk_restore(void);
int slk_set(int, char *, int);
int slk_touch(void);
int standout(void);
int standend(void);
int start_color(void);
WINDOW *subpad(WINDOW *, int, int, int, int);
WINDOW *subwin(WINDOW *, int, int, int, int);
int syncok(WINDOW *, bool);
chtype termattrs(void);
char *termname(void);
int tigetflag(char *);
int tigetnum(char *);
char *tigetstr(char *);
void timeout(int);
char *tparm(char *, ...);
int typeahead(int);
int ungetch(int);
int untouchwin(WINDOW *);
void use_env(bool);
int vidattr(chtype);
int vidputs(chtype, int);
int vline(chtype, int);
int vwprintw(WINDOW *, char *, va_list);
int vw_printw(WINDOW *, char *, va_list);
int vwscanw(WINDOW *, char *, va_list);
int vw_scanw(WINDOW *, char *, va_list);
int waddch(WINDOW *, chtype);
int waddchnstr(WINDOW *, chtype *, int);
int waddchstr(WINDOW *, chtype *);
int waddnstr(WINDOW *, char *, int);
int waddstr(WINDOW *, char *);
int wattron(WINDOW *, int);
int wattroff(WINDOW *, int);
int wattrset(WINDOW *, int);
int wattr_get(WINDOW *, attr_t *, short *, void *);
int wattr_on(WINDOW *, attr_t, void *);
int wattr_off(WINDOW *, attr_t, void *);
int wattr_set(WINDOW *, attr_t, short, void *);
int wbkgd(WINDOW *, chtype);
void wbkgdset(WINDOW *, chtype);
int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype, chtype,
	    chtype, chtype);
int wchgat(WINDOW *, int, attr_t, short, void *);
int wclear(WINDOW *);
int wclrtobot(WINDOW *);
int wclrtoeol(WINDOW *);
int wcolor_set(WINDOW *, short, void *);
void wcursyncup(WINDOW *);
int wdelch(WINDOW *);
int wdeleteln(WINDOW *);
int wechochar(WINDOW *, chtype);
int werase(WINDOW *);
int wgetch(WINDOW *);
int wgetnstr(WINDOW *, char *, int);
int wgetstr(WINDOW *, char *);
int whline(WINDOW *, chtype, int);
chtype winch(WINDOW *);
int winchnstr(WINDOW *, chtype *, int);
int winchstr(WINDOW *, chtype *);
int winnstr(WINDOW *, char *, int);
int winsch(WINDOW *, chtype);
int winsdelln(WINDOW *, int);
int winsertln(WINDOW *);
int winsnstr(WINDOW *, char *, int);
int winsstr(WINDOW *, char *);
int winstr(WINDOW *, char *);
int wmove(WINDOW *, int, int);
int wnoutrefresh(WINDOW *);
int wprintw(WINDOW *, char *, ...);
int wredrawln(WINDOW *, int, int);
int wrefresh(WINDOW *);
int wscanw(WINDOW *, char *, ...);
int wscrl(WINDOW *, int);
int wsetscrreg(WINDOW *, int, int);
int wstandout(WINDOW *);
int wstandend(WINDOW *);
void wsyncdown(WINDOW *);
void wsyncup(WINDOW *);
void wtimeout(WINDOW *, int);
int wtouchln(WINDOW *, int, int, int);
int wvline(WINDOW *, chtype, int);
WINDOW *curscr;
WINDOW *newscr;
WINDOW *stdscr;
</SCREEN>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->


<!-- Start of text generated from database -->
<!-- generated from the LSB specification database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->
<!--    at Tue Apr 24 21:17:22 2001 -->
<SECT1 ID=libutil>
<TITLE>libutil</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=2>
<TBODY>
<ROW>
<ENTRY>Library:</ENTRY>
<ENTRY>libutil</ENTRY>
</ROW>
<ROW>
<ENTRY>Runtime Path:</ENTRY>
<ENTRY>libutil.so.1</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>
The behaviour of the interfaces in this library is specified by the following Standards.<SIMPLELIST COLUMNS=1>
<MEMBER>
Linux Standard Base<FOOTNOTE ID="std-130-10">
<PARA>
Linux Standard Base</PARA>
</FOOTNOTE>
</MEMBER>
</SIMPLELIST>
</PARA>
<SECT2>
<TITLE>Utility Functions</TITLE>
<PARA>
</PARA>
<TABLE>
<TITLE></TITLE>
<TGROUP COLS=5>
<TBODY>
<ROW><ENTRY>forkpty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>login_tty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>logwtmp<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
<ROW><ENTRY>login<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>logout<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY>openpty<FOOTNOTEREF LINKEND="std-130-10"></ENTRY><ENTRY></ENTRY><ENTRY></ENTRY></ROW>
</TBODY>
</TGROUP>
</TABLE>
</SECT2>
</SECT1>
<!-- End of text generated from database -->
<!--    by $Header: /home/mats.deb/cvsrepo/lsb/lsbspec.smaller/gLSB/utillib/Attic/utillib.sgml,v 1.14 2001-04-25 02:08:06 anderson Exp $ -->


<SECT1 ID=libutilman>
<TITLE>Interface Definitions for libutil</TITLE>
<PARA>
</PARA>
<REFENTRY ID="libutil-forkpty-3"> <REFMETA>
<REFENTRYTITLE>forkpty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>forkpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-forkpty-3"><PRIMARY>forkpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int forkpty (int *<replaceable class="parameter" >amaster</replaceable>, 
	char *<replaceable class="parameter" >name</replaceable>,
	struct termios *<replaceable class="parameter" >termp</replaceable>,
	struct winsize *<replaceable class="parameter" >winp</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The forkpty() function joins openpty(), fork(), and login_tty() to
create a new process operating on a pseudo-tty.  The file descriptor of
the master side of the pseudo-tty is returned in amaster, and null or the 
filename of the slave in name.  If non-null, the termp and winp 
parameters will determine the terminal attributes and window size
of the slave side of the pseudo-tty.
</PARA>
</REFSECT1>
<refsect1>
<title>
Return value
</title>
<para>
0         Success for the child process.
</para>
<para>
pid       Parent process receives the PID of its child process.
</para>
</refsect1>
<refsect1>
<title>
Errors
</title>
<para>
-1        Not successful, see errno.
</para>
</refsect1>
</REFENTRY>

<REFENTRY ID="libutil-getopt-3"> <REFMETA>
<REFENTRYTITLE>getopt</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getopt</REFNAME>
<REFPURPOSE>
parse command line options
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getopt-3"><PRIMARY>getopt</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
</SYNOPSIS>
<PARA>
GNU supports the following extensions of getopt:
</PARA>
<SYNOPSIS>
int getopt_long(int argc, char * const argv[],
               const char *optstring,
               const struct option *longopts, int *longindex);

int getopt_long_only(int argc, char * const argv[],
                    const char *optstring,
                    const struct option *longopts, int *longindex);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The getopt() function parses command line arguments.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Option Characteristics</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
an element of argv that starts with "-" (and is not exactly "-" or "--") is an option element.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
characters of an option element, aside from the initial "-", are option characters.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
applications using getopt() must obey the following syntax guidelines:
(1) option name is a single alphanumeric character from the portable character set
(2) option is preceded by the "-" delimiter character
(3) options without option-arguments should be accepted when grouped behind one "-" delimiter
(4) each option and option-argument is a separate argument
(5) option-arguments are not optional
(6) all options should precede operands on the command line
(7) the argument "--" is accepted as a delimiter indicating the end of options and the consideration of subsequent arguments, if any, as operands
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
historical implementations of getopt() support other characters as options as an allowed extension, but applications that use extensions are not maximally portable.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
support for multi-byte option characters is only possible when such characters can be represented as type int.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
applications that call any utility with a first operand starting with "-" should usually specify "--" to mark the end of the options.  Standard utilities that do not support this guideline indicate that fact in the OPTIONS section of the utility description.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Extensions</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if a character is followed by two colons, the option takes an optional arg; if there is text in the current argv-element, it is returned in optarg, otherwise optarg is set to zero.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if optstring contains W followed by a semi-colon, then -W foo is treated as the long option --foo.  (Not available with libraries before GNU libc 2.)
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long() works like getopt() except that it also accepts "long options", or, options that are preface with two dashes instead of one.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
long option names may be abbreviated if the abbreviation is unique or an exact match for some defined option.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
a long option may take a parameter, of the form  --arg=param or --arg param.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
getopt_long_only() works like getopt_long(), except that both "-" and "--" indicate long option.  If an option that starts with "-" (not "--") doesn't match a long option, but does match a short option, it is parsed instead as a short option.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the -W option is reserved for implementation extensions.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Return Values</TITLE>
<PARA>
GNU specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
GNU specifies the following getopt_long() and getopt_long_only() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
when short option is recognized, the option character is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
when long option is recognized, val is returned if flag is NULL, otherwise, 0 is returned.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
error and -1 returns are the same as for getopt().
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned for an ambiguous match or an extraneous parameter.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies the following getopt() return values:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the next option character is returned, if found successfully.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
colon character (":") is returned if a parameter is missing for one of the options and the first character of opstring is ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
question mark ("?") is returned if an unknown option character not in optstring is encountered, or if getopt() detects a missing argument and the first character of optstring is not ":".
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
"-1" is returned for the end of the option list.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
if the variable POSIXLY_CORRECT is set, option processing stops as soon as a non-option argument is encountered.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if POSIXLY_CORRECT is set, GNU getopt() conforms to POSIX.2.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
the variable _[PID]_GNU_nonoption_argv_flags_ was used by bash 2.0 to communicate to GNU libc which arguments resulted from wildcard expansion and so should not be considered as options.  This behavior was removed in bash version 2.01, but the support remains in GNU libc.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Environmental Variables</TITLE>
<PARA>
POSIX.2 Interpretation 150 reports a technical error in the function of getopt().  GNU implements the correct behavior of getopt().
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutent-r-3"> <REFMETA>
<REFENTRYTITLE>getutent_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutent_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutent-r-3"><PRIMARY>getutent_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutent_r (
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a
user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutid-r-3"> <REFMETA>
<REFENTRYTITLE>getutid_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutid_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutid-r-3"><PRIMARY>getutid_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutid_r (
const struct utmp *<replaceable class="parameter" >id</replaceable>,
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a
user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-getutline-r-3"> <REFMETA>
<REFENTRYTITLE>getutline_r</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>getutline_r
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-getutline-r-3"><PRIMARY>getutline_r</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int getutline_r (
const struct utmp *<replaceable class="parameter" >id</replaceable>,
struct utmp *<replaceable class="parameter" >buffer</replaceable>, 
struct utmp **<replaceable class="parameter" >result</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Same at described in getutent(3), but storing information in a
user provided buffer.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-login-tty-3"> <REFMETA>
<REFENTRYTITLE>login_tty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login_tty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-tty-3"><PRIMARY>login_tty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int login_tty(int <replaceable class="parameter" >fdr</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The login_tty() function sets up for a login on the tty referenced by the
file descriptor fd:  create a new session, make the tty for the current
process the controlling terminal, set the standard input, output, and error
streams of the current process, and closing fd.
</PARA>
</REFSECT1>
<refsect1>
<title>
Return value
</title>
<para>
0         Success.
</para>
</refsect1>
<refsect1>
<title>
Errors
</title>
<para>
-1        Not successful, see errno.
</para>
</refsect1>
</REFENTRY>

<REFENTRY ID="libutil-login-3"> <REFMETA>
<REFENTRYTITLE>login</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>login
</REFNAME>
<REFPURPOSE>login utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-login-3"><PRIMARY>login</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
void login(struct utmp *<replaceable class="parameter" >ut</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The login() function updates the /var/run/utmp and /var/log/wtmp files
with user information contained in ut.
</PARA>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-logout-3"> <REFMETA>
<REFENTRYTITLE>logout</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>logout
</REFNAME>
<REFPURPOSE>logout utility function
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-logout-3"><PRIMARY>logout</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int logout(const char *<replaceable class="parameter" >line</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
Given the device line, the logout() function removes the entry from the
corresponding /var/run/utmp system file.
</PARA>
</REFSECT1>
<refsect1>
<title>
Return Values
</title>
<para>
non-zero  Successful.
</para>
<para>
0 If there was not entry to remove.
</para>
</refsect1>
</REFENTRY>

<REFENTRY ID="libutil-mkfifo-3"> <REFMETA>
<REFENTRYTITLE>mkfifo</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mkfifo</REFNAME>
<REFPURPOSE>
make a FIFO special file
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-mkfifo-3"><PRIMARY>mkfifo</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int mkfifo(const char *path, mode_t mode);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mkfifo() function attempts to create a FIFO special file named by the pathname to which the argument path points.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Node Permissions</TITLE>
<PARA>
Permissions are specified in the mode argument.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
permissions are modified by the process umask in the usual way: the permissions of the created node are (mode & ~umask).
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
file permission bits of the new FIFO are initialized from mode.  The file permission bits of the mode argument are modified by the process file creation mask.  When bits in mode other than the file permission bits are set, the effect is implementation-dependent.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
upon successful completion, mkfifo() marks for update the st_atime, st_ctime and st_mtime fields of the file.  Also, the st_ctime and st_mtime fields of the directory that contains the new entry are marked for update.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Errors</TITLE>
<PARA>
POSIX specifies the following error conditions that are not reflected in GNU:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
ELOOP   too many symbolic links were encountered in resolving path
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-mknod-3"> <REFMETA>
<REFENTRYTITLE>mknod</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>mknod</REFNAME>
<REFPURPOSE>
make a directory, a special or regular file
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-mknod-3"><PRIMARY>mknod</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>20 March 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int mknod(const char *path, mode_t mode, dev_t dev);
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>20 March 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The mknod() function attempts to create a filesystem node named by the pathname to which the argument path points.  GNU and POSIX specifications for this function vary in the following areas.
</PARA>
<REFSECT2>
<TITLE>Node Type</TITLE>
<PARA>
Node type is specified in the mode argument (using the bitwise OR) from the symb
olic constants S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
a node type specified as zero behaves as S_IFREG.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
for the node types S_IFCHR and S_IFBLK, dev specifies the major and minor numbers of the newly created device special file.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
S_IFDIR may additionally be used to create a directory file.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
S_IFIFO is the only portable use of mknod().
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
if mode is not S_IFIFO or dev is not 0, the behavior of mknod() is unspecified.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Node Permissions</TITLE>
<PARA>
Permissions are specified in the mode argument.
</PARA>
<PARA>
GNU specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
permissions are modified by the process umask in the usual way: the permissions of the created node are (mode & ~umask).
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies that:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
the mode argument specifies node permissions (using the bitwise OR) from the following symbolic constants:
  S_ISUID  set user ID on execution
  S_ISGID  set group ID on execution
  S_IRWXU  read, write or execute (search) by owner
  S_IRUSR  read by owner
  S_IWUSR  write by owner
  S_IXUSR  execute (search) by owner
  S_IRWXG  read, write or execute (search) by group
  S_IRGRP  read by group
  S_IWGRP  write by group
  S_IXGRP  execute (search) by group
  S_IRWXO  read, write or execute (search) by others
  S_IROTH  read by others
  S_IWOTH  write by others
  S_IXOTH  execute (search) by others
  S_ISVTX  on directories, restricted deletion flag
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
owner, group, and other permission bits of mode are modified by the file mode creation mask of the process.  The mknod() function clears each bit whose corresponding bit in the file mode creation mask of the process is set.
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
upon successful completion, mknod() marks for update the st_atime, st_ctime and st_mtime fields of the file.  Also, the st_ctime and st_mtime fields of the directory that contains the new entry are marked for update.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Errors</TITLE>
<PARA>
GNU specifies the following error conditions that are not reflected in POSIX:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
EFAULT  pathname points outside your accessible address space
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>
ENOMEM  insufficient kernel memory was available
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
<PARA>
POSIX specifies the following error conditions that are not reflected in GNU:
<ITEMIZEDLIST MARK=BULLET>
<LISTITEM>
<PARA>
EIO     an I/O error occurred while accessing the file system
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARA>
</REFSECT2>
</REFSECT1>
</REFENTRY>

<REFENTRY ID="libutil-openpty-3"> <REFMETA>
<REFENTRYTITLE>openpty</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>openpty
</REFNAME>
<REFPURPOSE>find and open an available pseudo-tty
</REFPURPOSE>
<INDEXTERM ID="ix-libutil-openpty-3"><PRIMARY>openpty</PRIMARY></INDEXTERM>
</REFNAMEDIV>
<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>08 February 2001</DATE>
</REFSYNOPSISDIVINFO>
<SYNOPSIS>
int openpty (int *<replaceable class="parameter" >amaster</replaceable>, 
	int *<replaceable class="parameter" >aslave</replaceable>, 
	char *<replaceable class="parameter" >name</replaceable>,
	struct termios *<replaceable class="parameter" >termp</replaceable>,
	struct winsize *<replaceable class="parameter" >winp</replaceable>)
</SYNOPSIS>
</REFSYNOPSISDIV>
<REFSECT1>
<REFSECT1INFO>
<DATE>08 February 2001</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
The openpty() function finds an available pseudo-tty and returns file 
descriptors for the amaster and aslave.  The filename of the slave is 
returned in name, otherwise a null.  The terminal parameters of the slave 
will be set to the values in termp, otherwise a null.  The window size of 
the slave will be set to the values in winp, otherwise a null.
</PARA>
</REFSECT1>
<refsect1>
<title>
Return value
</title>
<para>
0         Success.
</para>
<para>
[ENOENT]  There are no available ttys.
</para>
</refsect1>
<refsect1>
<title>
Errors
</title>
<para>
-1        Not successful, see errno.
</para>
</refsect1>
</REFENTRY>

</SECT1>


</CHAPTER>

</PART>
