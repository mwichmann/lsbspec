<PART ID="tocsysinit">
<TITLE>System Initialization</TITLE>

<CHAPTER ID=sysinit>
<TITLE>System Initialization</TITLE>

<SECT1 ID=cronjobs>
<TITLE>Cron Jobs</TITLE>
<PARA>
Packages may not touch the configuration file <FILENAME>/etc/crontab</FILENAME>,
nor may they modify the files in <FILENAME>/var/spool/cron/crontabs</FILENAME>.
</PARA>
<PARA>
If a package wants to install a job that has to be executed via cron,
it shall place a file with the name if the package in one of the
following directories:
</PARA>
<PROGRAMLISTING>
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
</PROGRAMLISTING>
<PARA>
As these directory names say, the files within them are executed on a
daily, weekly, or monthly basis, respectively.
</PARA>
<PARA>

If a certain job has to be executed more frequently than daily, the
package shall install a file
<FILENAME>/etc/cron.d/<MARKUP><</MARKUP>package-name<MARKUP>></MARKUP></FILENAME>
tagged as configuration file. This file uses the same syntax as
<FILENAME>/etc/crontab</FILENAME> and is processed by cron automatically.
</PARA>
<PARA>
It is recommended that files installed in any of these directories be
scripts (shell scripts, Perl scripts, etc.) so that they may be
modified by the local system administrator. In addition, they must be
registered as configuration file.
</PARA>
<PARA>
The scripts in these directories have to check, if all necessary
programs are installed before they try to execute them. Otherwise,
problems will arise when a package was removed (but not purged), since
the configuration files are kept on the system in this situation.
</PARA>
</SECT1>


<SECT1 ID=runlevels>
<TITLE>Run Levels</TITLE>
<PARA>
</PARA>
<SIMPLELIST type=horiz columns=2>
<MEMBER>0</MEMBER><MEMBER>halt</MEMBER>
<MEMBER>1</MEMBER><MEMBER>single user mode</MEMBER>
<MEMBER>2</MEMBER><MEMBER>multiuser with no network services exported</MEMBER>
<MEMBER>3</MEMBER><MEMBER>normal/full multiuser</MEMBER>
<MEMBER>4</MEMBER><MEMBER>reserved for local use, default is normal/full multiuser</MEMBER>
<MEMBER>5</MEMBER><MEMBER>multiuser with xdm or equivalent</MEMBER>
<MEMBER>6</MEMBER><MEMBER>reboot</MEMBER>
</SIMPLELIST>
</SECT1>


<SECT1 ID=iniscrptact>
<TITLE>Init Script Actions</TITLE>
<PARA>
Init files should accept one argument, saying what to do:
</PARA>
<SIMPLELIST type=horiz columns=2>
<MEMBER>start</MEMBER><MEMBER>start the service</MEMBER>
<MEMBER>stop</MEMBER><MEMBER>stop the service</MEMBER>
<MEMBER>restart</MEMBER><MEMBER>stop and restart the service if the service
is already running, otherwise start the service</MEMBER>
<MEMBER>reload</MEMBER><MEMBER>cause the configuration of the service to be
reloaded without actually stopping and restarting the service</MEMBER>
<MEMBER>force-reload</MEMBER><MEMBER>cause the configuration to be reloaded
if the service supports this, otherwise restart the service</MEMBER>
<MEMBER>status</MEMBER><MEMBER>print the current status of the service</MEMBER>
</SIMPLELIST>
<PARA>
The start, stop, restart, force-reload, and status options must be
supported by all init files, the reload option is optional.
</PARA>
<PARA>
Init files should ensure that they will behave sensibly if invoked
with start when the service is already running, or with stop when it
isn't, and that they don't kill unfortunately-named user processes. The
best way to achieve this is usually to use start-stop-daemon
<FOOTNOTE>
<PARA>
assuming that start-stop-daemon or a similar program is included in the LSB
</PARA>
</FOOTNOTE>
.
</PARA>
<PARA>
If a service reloads its configuration automatically (as in the case
of cron, for example), the reload option of the init file should
behave as if the configuration has been reloaded successfully.
</PARA>
<PARA>
These executable files should not fail obscurely when the configuration
files remain but the package has been removed, as the default in [the
packaging system] is to leave configuration files on the system after
the package has been removed.  Only when it is executed with the
[purge] option will [the packaging system] remove configuration files.
Therefore, you should include a test statement at the top of the file,
like this:
<SCREEN>
<USERINPUT>test -f program-executed-later-in-file || exit 5</USERINPUT>
</SCREEN>
or take the equivalent action if the init file is not a shell script.
</PARA>
<PARA>
Init files should return an exit status of zero if the action
described by the argument has been successful.  Otherwise, the exit
status should be non-zero.  In addition to straightforward success,
the following situations are also to be considered successful:

<ITEMIZEDLIST MARK="bullet">
<LISTITEM><PARA>
restarting a service (instead of reloading it) with the "force-reload" argument
</PARA></LISTITEM>
<LISTITEM><PARA>
running "start" on a service already running
</PARA></LISTITEM>
<LISTITEM><PARA>
running "stop" on a service already stopped or not running
</PARA></LISTITEM>
<LISTITEM><PARA>
running "restart" on a service already stopped or not running
</PARA></LISTITEM>
</ITEMIZEDLIST>

</PARA>
<PARA>
Exit status for "status" command:
<SIMPLELIST type=horiz columns=2>
<MEMBER>0</MEMBER><MEMBER>program is running</MEMBER>
<MEMBER>1</MEMBER><MEMBER>program is dead and /var/run pid file exists</MEMBER>
<MEMBER>2</MEMBER><MEMBER>program is dead and /var/lock lock file exists</MEMBER>
<MEMBER>3</MEMBER><MEMBER>program is stopped</MEMBER>
<MEMBER>4-100</MEMBER><MEMBER>reserved for future LSB use</MEMBER>
<MEMBER>100-149</MEMBER><MEMBER>reserved for distribution use</MEMBER>
<MEMBER>150-199</MEMBER><MEMBER>reserved for application use</MEMBER>
<MEMBER>200-254</MEMBER><MEMBER>reserved</MEMBER>
</SIMPLELIST>
</PARA>
<PARA>
Exit status for "start", "stop", "restart", "reload", and "force-reload":
</PARA>
<PARA>
In error conditions, the init file should fail, print an error, and
return one of the following non-zero exit status codes.

<SIMPLELIST type=horiz columns=2>
<MEMBER>1</MEMBER><MEMBER>generic or unspecified error (current practice)</MEMBER>
<MEMBER>2</MEMBER><MEMBER>invalid or excess argument(s)</MEMBER>
<MEMBER>3</MEMBER><MEMBER>unimplemented feature (for example, "reload")</MEMBER>
<MEMBER>4</MEMBER><MEMBER>user had insufficient privilege</MEMBER>
<MEMBER>5</MEMBER><MEMBER>program is not installed</MEMBER>
<MEMBER>6</MEMBER><MEMBER>program is not configured</MEMBER>
<MEMBER>7</MEMBER><MEMBER>program is not running</MEMBER>
<MEMBER>8-100</MEMBER><MEMBER>reserved for future LSB use</MEMBER>
<MEMBER>100-149</MEMBER><MEMBER>reserved for distribution use</MEMBER>
<MEMBER>150-199</MEMBER><MEMBER>reserved for application use</MEMBER>
<MEMBER>200-254</MEMBER><MEMBER>reserved</MEMBER>
</SIMPLELIST>
</PARA>
<PARA>
All error messages should be printed on standard error.  All status
messages should be printed on standard output.
</PARA>
<PARA>

Since init files may be run manually by a system administrator with
non-standard environment variable values for PATH, USER, LOGNAME,
etc. init files should not depend on the values of these environment
variables.  They should set them to some known/default values if they
are needed.

</PARA>
</SECT1>


<SECT1 ID=initscrcomconv>
<TITLE>Comment conventions for init scripts</TITLE>

<PARA>
Packages that need to execute a script at bootup and/or shutdown will
provide an init.d file.  This file is installed by the install_initd
program described below, which copies it into a standard directory and
makes whatever other adjustments (creation of symlinks, creation of
entries in a database, etc.) are necessary so that the script can be run
at boot-time.
<FOOTNOTE><PARA>
This specification does not require, but is designed to allow, the
development of a system which runs boot scripts in parallel.  Hence,
enforced serialization of scripts are avoided unless they are explicitly
necessary. 
</PARA></FOOTNOTE>
</PARA>

<PARA>
In the init.d file, information about the shell script is delimited by
the strings "### BEGIN INIT INFO" and "### END INIT INFO".  Inside
this block declarations shall take the form of "# {keyword}: [arg1]
[arg2] ..."  The following keywords, with their arguments are defined
in this specification:
</PARA>

<SCREEN>
	# Provides: boot_facility_1 [ boot_facility_2 ...]
	# Required-Start: boot_facility_1 [ boot_facility_2 ...]
	# Required-Stop: boot_facility_1 [ boot_facility_2 ...]
	# Default-Start: run_level_1 [ run_level_2 ...]
	# Default-Stop: run_level_1 [ run_level_2 ...]
	# Description: multiline_description
</SCREEN>

<PARA>
Additional keywords may be defined in future LSB specifications.
Distributions may define local extensions by using the prefix
"X-[distribution name]" --- for example, "X-RedHat-foobardecl", or
"X-Debian-xyzzydecl".  
</PARA>

<PARA>
An init.d shell script may declare using the "Required-Start: " header
that it must not be run until certain boot facilities are provided.
This information is used by the installation tool or the boot-time
boot-script execution facility to assure that init scripts are run in
the correct order.
</PARA>

<PARA>
Similarly, the "Required-Stop:" header defines which facilities must
still be available during the shutdown of that service.  Hence, the
initscript system should avoid stopping shell scripts which provide
those facilities until this shell script is stopped.
</PARA>

<PARA>
In a multiline description, each continuation line must begin with a
'#' followed by tab character or a '#' followed by at least two space
characters.  The multiline description is terminated by the first line
that does not match this criteria.
</PARA>

</SECT1>




<SECT1 ID=initsrcinstrm>

<TITLE>Installation and removal of init.d files</TITLE>

<PARA>
An init.d file is installed by copying it into /etc/init.d (which may
be a symlink to another location).  This can be done by the package
installer.  During the package's postinstall script, the program
"/usr/lib/lsb/install_initd" to configure the distribution's boot
script system to call the package's init.d file at the appropriate
time.
</PARA>

<PARA>
The install_initd program takes a single argument, the pathanme to the
/etc/init.d file.  For example:
</PARA>

<SCREEN>
	/usr/lib/lsb/install_initd /etc/init.d/inet
</SCREEN>


<PARA> 
When a software package is removed, the package's preuninstall script
shall call /usr/lib/lsb/remove_initd and pass the pathname to the
/etc/init.d file.  The package manager is still responsible for removing 
the /etc/init.d file; the remove_initd program is provided in case the
distribution needs to clean up any other modifications the distribution's
boot script system which might have been made by the install_initd program.
For example:
</PARA>

<SCREEN>
	/usr/lib/lsb/remove_initd /etc/init.d/inet
</SCREEN>


<PARA>
There should be a tool available to the user (ala RedHat's chkconfig)
which can be used by the system administrator to easily manipulate at
which init levels a particular init.d script is started or stopped.
This specification currently does not specify such an interface,
however.  (XXX should it?)
</PARA>

</SECT1>


<SECT1 ID=facilname>

<TITLE>Facility names</TITLE>

<PARA>
Facility names that begin with a dollar sign ('$') are system facility
names, defined by the LSB, and MUST be provided by distributions.  LSB
applications should not provide system facilities.  This document
defines the following system facility names:
</PARA>

<SIMPLELIST type=horiz columns=2>
<MEMBER>$local_fs</MEMBER>	
<MEMBER>all remote filesystems are mounted</MEMBER>

<MEMBER>$network</MEMBER>  	
<MEMBER>low level networking (ethernet card; may
imply PCMCIA running)</MEMBER>

<MEMBER>$named</MEMBER>  	
<MEMBER>named is operational</MEMBER>

<MEMBER>$remote_fs</MEMBER>	
<MEMBER>all remote filesystems are mounted (note
in some cases /usr may be remote.  Most
applications that care will probably require
both $local_fs and $remote_fs)</MEMBER>

<MEMBER>$syslog</MEMBER>
<MEMBER>system logger is operational</MEMBER>

<MEMBER>$netdaemons</MEMBER>
<MEMBER>all network daemons are running</MEMBER>

</SIMPLELIST>

<PARA>
Other system facilities may be defined by other LSB applications.
</PARA>

<PARA>
Facility names may also be init.d script names, although LSB
applications SHOULD NOT use script names, especially script names which
are provided by distributions, as these may not necessarily be the same
across different distributions.
</PARA>

</SECT1>


<SECT1 ID=scrptnames>

<TITLE>Script names</TITLE>

<PARA>
Since the init.d scripts must live in a single directory, they must be
come from a single namespace.  Three means of assigning names from
this namespace are available:
</PARA>

<ITEMIZEDLIST MARK="bullet">
<LISTITEM><PARA>
	Assigned namespace.  This namespace consists of names which
		only use the character set [a-z0-9].  This space is
		desirable for scripts which system administrators may
		often wish to run manually: e.g., "/etc/init.d/named restart"
		In order to avoid conflicts these names must be reserved
		through the LANA (Linux Assigned Names/Numbers Authority).
	</PARA>

	<PARA>
		Commonly used names shall be reserved in advance; 
		developers for projects should be encouraged reserve names
		from LANA, so that each distribution can use the same
		name, and to avoid conflicts with other projects.
</PARA></LISTITEM>

<LISTITEM><PARA>
	Hierarchical namespace.  This namespace consists of scripts
		names which look like this: [hier1]-[hier2]-...-[name],
		where name is again taken the character set [a-z0-9], 
		and where there may be one or more [hier-n] components.  
		[hier1] may either be a [a-z0-9] name assigned by the LANA, or
		it may be owners' DNS name in lower case, with at
		least one '.'.  I.e., "debian.org", "staroffice.sun.com", etc.
</PARA></LISTITEM>

<LISTITEM><PARA>
	Reserved namespace.  This namespace consists of script names
		which begin with the character '_', and is reserved for
		distribution use only.  This namespace should be used
		for core packages only, and in general use of this
		namespace is highly discouraged.  

</PARA></LISTITEM>
</ITEMIZEDLIST>


<PARA>
In general, if a package or some system function is likely to be used
on multiple systems, the package developers or the distribution SHOULD
get a registered name through LANA, and distributions should strive to
use the same name whenever possible.  For applications which may not
be "core" or may not be commonly installed, the hierarchical namespace
may be more appropriate.  An advantage to the hierarchical namespace
is that there is no need to consult with the LANA before obtaining an
assigned name.
</PARA>

<PARA>
Obviously, short names are highly desirable, since many system
administrators like to use them to manually start and stop services.
Given this, they should be standardized on a per-package basis.  This
is the rationale behind having a LANA organization to assign these
names.  The LANA may be called upon to handle other namespace issues,
such as package/prerequisites naming (which I'm sure will be a hot
political topic, but essential to make prerequisites to work
correctly).
</PARA>

<PARA>
This specification shall pre-define the following script names as:

	apmd atd crond dhclient dhcpcd gpm halt identd inet
	httpd kudzu klogd lpd mcserv named nfs nfslock pcmcia
	portmap random routed rstatd rusersd rwhod sendmail smb
	snmpd sshd syslog xfs xntpd ypbind
</PARA>

<PARA>
XXX Note: we don't have to agree exactly how all of these scripts
work.  This is true especially of the low-level system names such as
syslog and klogd.  If some distributions put both in syslog, and some
separate them out, this isn't a big deal; we just need to reserve the
names.
</PARA>

<PARA>
XXX Some of these packages, such as sshd, aren't currently being
distributed by distributions, but may in the future.  For those we
need more definition, but it's still not much more than saying which
package they are associated with.
</PARA>


</SECT1>


<SECT1 ID=iniscrptfunc>

<TITLE>Init script Functions</TITLE>

<PARA>
Each LSB compliant init.d script must source the file
/lib/lsb/init-functions.  This file must cause the following shell
script commands to be defined.  This can be done either by adding a
directory to the PATH variable which defines these commands, or by
defining sh aliases.  While the distribution-provided aliases may
choose to use bash extensions (at the distribution's option), the LSB
init.d files themselves should only depend in /bin/sh features as
defined by POSIX.2.
</PARA>

<SIMPLELIST type=horiz columns=2>
<MEMBER>start_daemon [-f] [-n nicelevel] pathname [args]</MEMBER>

<MEMBER>	    This runs the specified program as a daemon.
		    start_daemon will check to see if there is a program
		    named "daemon" already running.  If so, it will not
		    start  another copy of the daemon unless the -f
		    option is given.  The -n option specifies a nice
		    level.  See nice(1).
</MEMBER>

<MEMBER>killproc basename [signal]</MEMBER>

<MEMBER>	    This stops the specified program.	The program is 
		    found using the algorithm given by pidofproc.  If  a
		    signal is specified, the program is sent that
		    signal.  Otherwise, a SIGTERM followed by a SIGKILL
		    after some number of seconds is sent.
		    [ Same as sysvinit package ]
</MEMBER>

<MEMBER>pidofproc basename</MEMBER>

<MEMBER>	  This finds the pid(s) for a particular daemon.  If an
		  entry is found in /var/run/basename.pid, then that
		  value is returned.  If not, first the "pidof" program
		  is used to try to find the daemon, and if that fails,
		  pidofproc will search the ps listing, looking for a
		  process name field of:

			  basename
			  (basename)
			  [basename]
			  basename: 

		    [ Same as sysvinit package ]
</MEMBER>

<MEMBER>log_success_msg "message"</MEMBER>

<MEMBER>	This requests the distribution to print a success
		message.  The message should be relatively short; no
		More than 60 characters is highly desirable.
</MEMBER>

<MEMBER>log_failure_msg "message"</MEMBER>

<MEMBER>	This requests the distribution to print a failure
		message.  The message should be relatively short; no
		more than 60 characters is highly desirable.
</MEMBER>

<MEMBER>log_warning_msg "message"</MEMBER>

<MEMBER>	This requests the distribution to print a warning
		message.  The message should be relatively short; no
		more than 60 characters is highly desirable.
</MEMBER>

</SIMPLELIST>

</SECT1>



</CHAPTER>

</PART>
