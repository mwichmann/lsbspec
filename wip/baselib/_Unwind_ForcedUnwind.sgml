<REFENTRY ID="baselib--Unwind-ForcedUnwind"> <REFMETA>
<REFENTRYTITLE>_Unwind_ForcedUnwind</REFENTRYTITLE>
<REFMISCINFO>Base Libraries</REFMISCINFO>
</REFMETA>
<REFNAMEDIV>
<REFNAME>_Unwind_ForcedUnwind
</REFNAME>
<REFPURPOSE>
private C++ error handling method
</REFPURPOSE>
</REFNAMEDIV>

<REFSYNOPSISDIV>
<REFSYNOPSISDIVINFO>
<DATE>8 October 2002</DATE>
</REFSYNOPSISDIVINFO>
<FUNCSYNOPSIS>
<FUNCPROTOTYPE>
 <FUNCDEF>_Unwind_Reason_Code
  <FUNCTION>_Unwind_ForcedUnwind</FUNCTION></FUNCDEF>
 <PARAMDEF>struct _Unwind_Exception
  <PARAMETER><REPLACEABLE>*object</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>_Unwind_Stop_Fn
  <PARAMETER><REPLACEABLE>stop</REPLACEABLE></PARAMETER></PARAMDEF>
 <PARAMDEF>void
  <PARAMETER><REPLACEABLE>*stop_parameter</REPLACEABLE></PARAMETER></PARAMDEF>
</FUNCPROTOTYPE>
</FUNCSYNOPSIS>
</REFSYNOPSISDIV>

<REFSECT1>
<REFSECT1INFO>
<DATE>8 October 2002</DATE>
</REFSECT1INFO>
<TITLE>Description
</TITLE>
<PARA>
<FUNCTION>_Unwind_ForcedUnwind</FUNCTION> 
raise and exception for forced unwinding, passing along the given exception
<emphasis>object</emphasis>, which should have its
<emphasis>exception_class</emphasis> and <emphasis>exceptoin_cleanup</emphasis>
fields set.  The exception object has been allocated by the language-specific
runtime, and has a language-specific format, except that it must contain an
<emphasis>_Unwind_Exceptoin struct</emphasis>.
</PARA>
<PARA>
Forced unwinding is a single-phase process.  The <emphasis>stop</emphasis>
and <emphasis>stop_parameter</emphasis> parameters control the termination
of the unwind process, instead of the usual personality routine query.
The <emphasis>stop</emphasis> function parameter is called for each unwind
frame, with the parameteres described for the usual personality routine below,
plus an additional <emphasis>stop_parameter</emphasis>.
</PARA>
</REFSECT1>

<REFSECT1>
<TITLE>Return</TITLE>
<PARA>
When the <emphasis>stop</emphasis> function identifies the destination frame,
it transfers control to the user code as appropriate without returning, 
normally after calling <emphasis>_Unwind_DeleteException</emphasis>.  If not,
then it should return an <emphasis>_Unwind_Reason_Code</emphasis> value.
</PARA>
<PARA>
If the <emphasis>stop</emphasis> function returns any reason code other than
<emphasis>_URC_NO_REASON</emphasis>, then the stack state is indeterminate
from the point of view of the caller of 
<emphasis>_Unwind_ForcedUnwind</emphasis>.  Rather than attempt to return,
therefore, the unwind library should use the 
<emphasis>exception_cleanup</emphasis> entry in the exception, and then 
call <emphasis>abort</emphasis>.
</PARA>
<VARIABLELIST>

<VARLISTENTRY>
<TERM>_URC_NO_REASON</TERM>
<LISTITEM>
<PARA>
This is not the destination from.  The unwind runtime will call frame's
personality routine with the <emphasis>_UA_FORCE_UNWIND</emphasis>
and <emphasis>_UA_CLEANUP_PHASE</emphasis> flag set in 
<emphasis>actions<emphasis>, and then unwind to the next frame
and callthe <emphasis>stop</emphasis> function again.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>_URC_END_OF_STACK</TERM>
<LISTITEM>
<PARA>
In order to allow <emphasis>_Unwind_ForcedUnwind</emphasis> to perform
special processing when it reaches the end of the stack, the unwind runtime
will call it after the last frame is rejected, with a NULL stack pointer
in the context, and the <emphasis>stop</emphasis> function must catch
this condition.  It may return this code if it cannot handle end-of-stack.
</PARA>
</LISTITEM>
</VARLISTENTRY>

<VARLISTENTRY>
<TERM>_URC_FATAL_PHASE2_ERROR</TERM>
<LISTITEM>
<PARA>
The <emphasis>stop</emphasis> function may return this code for other fatal 
conditions like stack corruption.
</PARA>
</LISTITEM>
</VARLISTENTRY>

</VARIABLELIST>

</REFSECT1>

</REFENTRY>
